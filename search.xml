<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Cloud 微服务权限系统搭建教程]]></title>
    <url>%2Fbook.html</url>
    <content type="text"><![CDATA[📖《 Spring Cloud 微服务权限系统搭建教程 》一本基于Spring Cloud Hoxton.RELEASE&amp;Spring Cloud Oauth2&amp;Spring Cloud Alibaba的微服务权限系统搭建教程书籍，手把手教你从零到K8S集群部署。第一章 基础框架搭建1.1 架构预览1.2 搭建微服务注册中心1.3 搭建认证服务器1.4 搭建微服务网关1.5 搭建微服务提供者（资源服务器）1.6 本章小结第二章 架构完善2.1 参数配置化2.2 异常处理2.3 Feign的使用2.4 微服务防护2.5 跨域处理2.6 本章小结第三章 完善登录流程3.1 表结构设计3.2 完善登录3.3 整合图形验证码3.4 Sentinel验证码限流3.5 本章小结第四章 整合Swagger4.1 完善febs-server-system4.2 接入Swagger4.3 Swagger OAuth2认证4.4 本章小结第五章 整合第三方服务5.1 整合Spring Boot Admin5.2 Sleuth Zipkin链路追踪5.3 logback日志打印5.4 ELK日志收集5.5 本章小结第六章 前端系统介绍6.1 封装Axios6.2 Vue导航守卫6.3 动态路由构建6.4 处理用户登录6.5 处理令牌刷新6.6 自定义Vue权限指令6.7 本章小结第七章 微服务部署7.1 微服务Dokcer化7.2 使用Docker Compose部署7.3 本章小结第八章 微服务进阶8.1 令牌存储策略8.2 使用Cloud Gateway搭建网关8.3 使用Alibaba Nacos注册中心8.4 使用Alibaba Nacos存储配置8.5 接入Prometheus + Grafana8.6 整合skywalking分布式追踪8.7 升级到Hoxton.RELEASE第九章 K8S集群部署9.1 集群环境准备9.2 安装第三方服务9.3 Kubeadm搭建K8S 1.16.2集群9.4 NFS服务器搭建9.5 搭建Docker镜像仓库Harbor9.6 K8S构建高可用Nacos9.7 K8S构建FEBS Cloud服务集群9.8 部署前端测试9.9 K8S实践总结第十章 分布式事务研究10.1 分布式架构事务挑战10.2 分布式事务解决方案10.3 基于消息中间件RocketMQ方案（一）10.4 基于消息中间件RocketMQ方案（二）10.5 基于TX-LCN方案10.6 基于阿里Seata方案10.7 本章总结$(function(){$("#comment-div").remove(),$(".post-copyright").remove(),$("#reward-div").remove(),$(".post-footer").remove()})]]></content>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 二叉树学习笔记]]></title>
    <url>%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[树（Tree）是一种很有趣的数据结构，它既能像链表那样快速的插入和删除，又能像有序数组那样快速查找。树的种类很多，本节将记录一种特殊的树————二叉树（Binary Tree）。二叉树的每个节点最多只能有两个子节点，通常称为左子节点和右子节点。如果一个二叉树的每个节点的左子节点的关键字值小于该节点，右子节点的关键字值大于等于该节点，那么这种二叉树也称为二叉搜索树（Binary Search Tree,BST），本节主要关注BST。相关术语查看一个BST例子：路径：从一个节点走到另一个节点，经过的节点顺序就称为路径；根：树的顶端节点称为根，一个数只能有一个根节点，并且从根节点到任意子节点只能有一条路径；父节点：每个节点（除了根）都有一条边向上连接到另一个节点，这个节点就是下面节点的父节点；子节点：每个节点（除了叶子节点）都有一条或两条边向下连接其他节点，下面这些节点就是当前节点的子节点。子节点分为左子节点和右子节点；叶节点：没有子节点的节点称为叶子节点，或叶节点；关键字：节点中的数据，比如上图中的数值。操作BST在操作BST前，我们先用代码定义一个BST的骨架：12345678910111213141516171819202122/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125;&#125;下面的这些操作都以这个BST为例：插入假如我们需要插入一个key为88的节点，需要经过如下步骤：从根节点出发，88比72大，所以走右子节点82路径；88比82大，所以走右子节点90路径；88比90小，所以走左子节点87路径；88比87大，并且87的右子节点为空，所以我们最终把88作为87的右子节点插入树中。当key重复时，可以选择覆盖或者忽略，这由业务决定。上述过程动态图如下所示：Java代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** 插入 */ public void insert(int key, String value) &#123; // 创建一个新节点 Node newNode = new Node(key, value); if (this.root == null) &#123; // 如果根为null，则这个新节点就是根 root = newNode; &#125; else &#123; // 如果跟不为null，则从根开始搜索插入位置 Node currentNode = root; // 用于暂存父节点 Node parentNode; while (true) &#123; // 父节点设置为当前节点 parentNode = currentNode; if (key &lt; currentNode.key) &#123; currentNode = currentNode.leftChild; if (currentNode == null) &#123; // 如果key小于当前节点key，并且当前节点的左子节点为空，则将新节点 // 设置为当前节点（父节点暂存对象）的左子节点，退出循环 parentNode.leftChild = newNode; return; &#125; &#125; else if (key &gt; currentNode.key) &#123; currentNode = currentNode.rightChild; if (currentNode == null) &#123; // 如果key大于当前节点key，并且当前节点的右子节点为空，则将新节点 // 设置为当前节点（父节点暂存对象）的又子节点，退出循环 parentNode.rightChild = newNode; return; &#125; &#125; else &#123; // 如果key等于当前节点key，则将value覆盖当前节点value currentNode.value = newNode.value; return; &#125; &#125; &#125; &#125;&#125;编写测试程序：1234567891011public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); &#125;&#125;以debug的方式运行程序，查看bst结构：bst结构和上图一致，有兴趣可以自己验证。查找假如我们需要查找key为67的节点，需要经过如下步骤：从根节点出发，67比72小，所以走左子节点57路径；67比57大，所以走右子节点63路径；67比63大，所以走右子节点67路径；67等于67，找到目标节点，退出；如果搜索直到叶子节点都没找到，则返回空。上述过程动态图如下所示：Java代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** 查找 */ public Node find(int key) &#123; // 从根节点开始查找 Node currentNode = root; // 当前节点的key不等于被查找的key时 while (currentNode.key != key) &#123; if (key &lt; currentNode.key) &#123; // 如果key值小于当前节点key，则查找左子节点 currentNode = currentNode.leftChild; &#125; else &#123; // 如果key值大于等于当前节点key，则查找右子节点 currentNode = currentNode.rightChild; &#125; // 如果当前节点为null，说明查到叶子节点了，仍没查到目标key，则直接返回null if (currentNode == null) &#123; return null; &#125; &#125; // 返回当前节点（退出while循环要么key相等，要么没找到，结果为null） return currentNode; &#125;&#125;编写测试程序：12345678910111213public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); System.out.println(bst.find(87).value); bst.insert(87, "hello world"); System.out.println(bst.find(87).value); &#125;&#125;输出如下：12我是key为87的valuehello world最大最小值在BST里查找最大值和最小值是非常容易的一件事，根据BST特性，小的值都分布在左节点，大的值都分布在右节点，所以最小值查找方法为：从根节点出发，一直往下查找左子节点，当该节点不再有左子节点时，该节点就是最小节点；最大值查找方法为：从根节点出发，一直往下查找右子节点，当该节点不再有右子节点时，该节点就是最大节点。查找最小值图示：查找最大值图示：Java代码实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** * 最小值 */ public Node min() &#123; Node currentNode = root; while (currentNode.leftChild != null) &#123; currentNode = currentNode.leftChild; &#125; return currentNode; &#125; /** * 最大值 */ public Node max() &#123; Node currentNode = root; while (currentNode.rightChild != null) &#123; currentNode = currentNode.rightChild; &#125; return currentNode; &#125;&#125;编写测试程序：123456789101112public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); System.out.println(bst.min().value); System.out.println(bst.max().value); &#125;&#125;输出如下所示：12我是key为27的value我是key为90的value删除删除是BST操作里最复杂的一个，因为需要考虑的因素比较多：被删除的节点是叶子节点；被删除的节点只有一个子节点；被删除的节点有两个子节点。下面我们逐个分析：被删除的节点是叶子节点这种情况最为简单，删除节点前需要先找到该节点，过程和上面的查找类似。找到需要删除的节点后，如果是叶子节点，则将该节点的父节点引用置为null，被删除的节点没了引用，后续由GC自动回收。假如我们需要删除key为48的节点，需要经过如下步骤：从根节点出发，48比72小，所以走左子节点57路径；48比57小，所以走左子节点30路径；48比30大，所以走右子节点40路径；48比40大，所以走右子节点48路径；48等于48，所以当前节点就是需要被删除节点；48没有子节点，为叶子节点，所以直接将40的右子节点引用设置为null即可。该过程如下图所示：Java代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** 删除 */ public boolean delete(int key) &#123; /* --------- 查找需要被删除的节点以及它的父节点 ------- */ // 从根节点开始查找 Node deleteNode = root; // 暂存需要被删除节点的父节点 Node parentNode = root; // 标识被删除的节点时父节点的左子节点还是右子节点 boolean isLeftChild = false; // 下面这个过程和查找一致，只不过加了isLeftChild标识 while (deleteNode.key != key) &#123; parentNode = deleteNode; if (key &lt; deleteNode.key) &#123; isLeftChild = true; deleteNode = deleteNode.leftChild; &#125; else &#123; isLeftChild = false; deleteNode = deleteNode.rightChild; &#125; // 如果目标key对应的节点为空，则不需要删除，直接返回false if (deleteNode == null) &#123; return false; &#125; &#125; /* --------- 情况1：被删除的节点是叶子节点 ------- */ if (deleteNode.leftChild == null &amp;&amp; deleteNode.rightChild == null) &#123; if (deleteNode == root) &#123; // 如果要删除的节点为root，则直接将root节点设置为null root = null; &#125; else if (isLeftChild) &#123; // 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null parentNode.leftChild = null; &#125; else &#123; // 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null parentNode.rightChild = null; &#125; &#125; return true; &#125;&#125;编写测试程序：123456789101112public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); System.out.println(bst.delete(49)); System.out.println(bst.delete(48)); &#125;&#125;12falsetrue可以看到40的右子节点已经被删除。被删除的节点只有一个子节点这种情况也比较简单，只需要将被删除节点的子节点和其父节点建立连接关系即可。假如我们需要删除key为79的节点，需要经过如下步骤：从根节点出发，79比72大，所以走右子节点82路径；79比82小，所以走左子节点79路径；79等于79，所以当前节点就是需要被删除节点；79只有一个右子节点，因为79是82的左子节点，所以直接将80设置为82的左子节点即可。该过程如下图所示：Java代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** * 删除 */ public boolean delete(int key) &#123; /* --------- 查找需要被删除的节点以及它的父节点 ------- */ // 从根节点开始查找 Node deleteNode = root; // 暂存需要被删除节点的父节点 Node parentNode = root; // 标识被删除的节点时父节点的左子节点还是右子节点 boolean isLeftChild = false; // 下面这个过程和查找一致，只不过加了isLeftChild标识 while (deleteNode.key != key) &#123; parentNode = deleteNode; if (key &lt; deleteNode.key) &#123; isLeftChild = true; deleteNode = deleteNode.leftChild; &#125; else &#123; isLeftChild = false; deleteNode = deleteNode.rightChild; &#125; // 如果目标key对应的节点为空，则不需要删除，直接返回false if (deleteNode == null) &#123; return false; &#125; &#125; /* --------- 情况1：被删除的节点是叶子节点 ------- */ if (deleteNode.leftChild == null &amp;&amp; deleteNode.rightChild == null) &#123; if (deleteNode == root) &#123; // 如果要删除的节点为root，则直接将root节点设置为null root = null; &#125; else if (isLeftChild) &#123; // 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null parentNode.leftChild = null; &#125; else &#123; // 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null parentNode.rightChild = null; &#125; &#125; else if (deleteNode.leftChild != null &amp;&amp; deleteNode.rightChild != null) &#123; /* --------- 情况3：被删除的节点有两个子节点 ------- */ &#125; else &#123; /* --------- 情况2：被删除的节点只有一个子节点 ------- */ // 获取被删除节点的唯一子节点 Node deleteNodeChild = deleteNode.leftChild == null ? deleteNode.rightChild : deleteNode.leftChild; if (deleteNode == root) &#123; // 如果被删除节点就是root，那么将其唯一子节点设置为root root = deleteNodeChild; &#125; else if (isLeftChild) &#123; // 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点 parentNode.leftChild = deleteNodeChild; &#125; else &#123; // 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点 parentNode.rightChild = deleteNodeChild; &#125; &#125; return true; &#125;&#125;编写测试程序：123456789101112public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); System.out.println(bst.delete(79)); System.out.println(bst.find(82).leftChild.value); &#125;&#125;程序输出：12true我是key为80的value被删除的节点有两个子节点这种情况比较复杂，删除的节点不能用删除节点的某个子节点来代替。比如现在需要删除上述BST的57节点，假如用57节点的右子节点63代替该节点，那么63的左子节点既不能是62，也不能是57的左子节点30。这种情况下需要找到被删除节点的中序后继节点（successor）来代替它。所谓的中序后继节点就是：整个树中关键字值比被删除节点大，并且比被删除节点右子节点小的那部分节点中的关键字值最小的节点。根据中序后继节点的定义来看，要找到它也很简单：从被删除节点的右子节点出发，一直往下找左子节点，当该节点不再有左子节点时，该节点就是中序后继节点；如果被删除节点的右子节点没有左子节点，那么它就是要找的中序后继节点。举个例子，比如现在需要删除上述BST的57节点，那么它的中序后继节点为62；假如要删除的节点为63，那么它的中序后继为67：当删除的节点为57时，过程如下所示：当删除的节点为63时，过程如下所示：编写查找中序后继节点的方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** * 查找中序后继节点 */ private Node getSuccessor(Node deleteNode) &#123; // 暂存中序后继节点的父节点 Node successorParent = deleteNode; // 暂存中序后继节点 Node successor = deleteNode; // 先从删除节点的右子节点开始查找 Node currentNode = deleteNode.rightChild; while (currentNode != null) &#123; successorParent = successor; successor = currentNode; // 一直往下查找当前节点的左子节点，直到为空 currentNode = currentNode.leftChild; &#125; // 如上面文章所说，中序后继节点和删除节点有两种可能性， // 当中序后继节点不是删除节点的右子节点时，需要做如下额外操作 if (successor != deleteNode.rightChild) &#123; // 如果中序后继节点的右子节点不为空的话，将其和中序后继节点父节点的左子节点挂钩 if (successor.rightChild != null) &#123; successorParent.leftChild = successor.rightChild; &#125; // 中序后继节点的右子节点和删除节点的右子节点挂钩 successor.rightChild = deleteNode.rightChild; &#125; // 中序后继节点的左子节点和删除节点的左子节点挂钩 successor.leftChild = deleteNode.leftChild; // 剩下的删除节点的父节点和中序后继节点的连接关系在删除方法里处理， // 因为这个方法内无法获取删除节点的父节点对象 return successor; &#125;&#125;完成删除方法的最后一个部分：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** * 删除 */ public boolean delete(int key) &#123; /* --------- 查找需要被删除的节点已经它的父节点 ------- */ // 从根节点开始查找 Node deleteNode = root; // 暂存需要被删除节点的父节点 Node parentNode = root; // 标识被删除的节点时父节点的左子节点还是右子节点 boolean isLeftChild = false; // 下面这个过程和查找一致，只不过加了isLeftChild标识 while (deleteNode.key != key) &#123; parentNode = deleteNode; if (key &lt; deleteNode.key) &#123; isLeftChild = true; deleteNode = deleteNode.leftChild; &#125; else &#123; isLeftChild = false; deleteNode = deleteNode.rightChild; &#125; // 如果目标key对应的节点为空，则不需要删除，直接返回false if (deleteNode == null) &#123; return false; &#125; &#125; /* --------- 情况1：被删除的节点是叶子节点 ------- */ if (deleteNode.leftChild == null &amp;&amp; deleteNode.rightChild == null) &#123; if (deleteNode == root) &#123; // 如果要删除的节点为root，则直接将root节点设置为null root = null; &#125; else if (isLeftChild) &#123; // 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null parentNode.leftChild = null; &#125; else &#123; // 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null parentNode.rightChild = null; &#125; &#125; else if (deleteNode.leftChild != null &amp;&amp; deleteNode.rightChild != null) &#123; /* --------- 情况3：被删除的节点有两个子节点 ------- */ // 获取删除节点的中序后继节点 Node successor = getSuccessor(deleteNode); // 如果伤处节点就是根节点的话，中序后继节点直接成为新的根 if (deleteNode == root) &#123; root = successor; &#125; else if (isLeftChild) &#123; // 如果删除节点是父节点的左子节点，则将父节点的左子节点和中序后继节点挂钩 parentNode.leftChild = successor; &#125; else &#123; // 如果删除节点是父节点的右子节点，则将父节点的右子节点和中序后继节点挂钩 parentNode.rightChild = successor; &#125; &#125; else &#123; /* --------- 情况2：被删除的节点只有一个子节点 ------- */ // 获取被删除节点的唯一子节点 Node deleteNodeChild = deleteNode.leftChild == null ? deleteNode.rightChild : deleteNode.leftChild; if (deleteNode == root) &#123; // 如果被删除节点就是root，那么将其唯一子节点设置为root root = deleteNodeChild; &#125; else if (isLeftChild) &#123; // 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点 parentNode.leftChild = deleteNodeChild; &#125; else &#123; // 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点 parentNode.rightChild = deleteNodeChild; &#125; &#125; return true; &#125;&#125;编写测试程序测试一下：当删除的节点为57时：123456789101112131415public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); System.out.println("删除57节点: " + bst.delete(57)); System.out.println("72节点的左子节点为: " + bst.find(72).leftChild.key); BinarySearchTree.Node node62 = bst.find(62); System.out.println("62节点的左子节点为: " + node62.leftChild.key); System.out.println("62节点的右子节点为: " + node62.rightChild.key); &#125;&#125;输出如下：1234删除57节点: true72节点的左子节点为: 6262节点的左子节点为: 3062节点的右子节点为: 63当删除的节点为63时：123456789101112131415public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); System.out.println("删除63节点: " + bst.delete(63)); System.out.println("57节点的右子节点为: " + bst.find(57).rightChild.key); BinarySearchTree.Node node67 = bst.find(67); System.out.println("67节点的左子节点为: " + node67.leftChild.key); System.out.println("67节点的右子节点为: " + (node67.rightChild == null ? null : node67.rightChild.key)); &#125;&#125;输出如下：1234删除63节点: true57节点的右子节点为: 6767节点的左子节点为: 6267节点的右子节点为: null遍历遍历树指的是以一种特定顺序访问树的每一个节点，这个顺序分为：中序、前序和后序。中序遍历中序遍历的步骤为：递归遍历目标节点的左子节点；访问目标节点本身；递归遍历目标节点的右子节点。Java实现如下：12345678910111213141516171819202122232425262728293031323334353637383940/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 遍历需要从根开始遍历，所以添加根的get方法 */ public Node getRoot() &#123; return root; &#125; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** 中序遍历 */ public void inOrder(Node targetNode) &#123; if (targetNode != null) &#123; // 递归遍历目标节点的左子节点 inOrder(targetNode.leftChild); // 访问目标节点本身 System.out.print(targetNode.key + " "); // 递归遍历目标节点的右子节点 inOrder(targetNode.rightChild); &#125; &#125;&#125;编写测试程序：1234567891011public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); bst.inOrder(bst.getRoot()); &#125;&#125;输出如下：127 30 40 48 57 62 63 67 72 79 80 82 87 90这个过程如下动图所示：前序遍历前序遍历的步骤为：访问目标节点本身；递归遍历目标节点的左子节点；递归遍历目标节点的右子节点。Java实现如下：12345678910111213141516171819202122232425262728293031323334353637383940/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 遍历需要从根开始遍历，所以添加根的get方法 */ public Node getRoot() &#123; return root; &#125; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** 前序遍历 */ public void preOrder(Node targetNode) &#123; if (targetNode != null) &#123; // 访问目标节点本身 System.out.print(targetNode.key + " "); // 递归遍历目标节点的左子节点 preOrder(targetNode.leftChild); // 递归遍历目标节点的右子节点 preOrder(targetNode.rightChild); &#125; &#125;&#125;编写测试程序：1234567891011public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); bst.preOrder(bst.getRoot()); &#125;&#125;输出如下：172 57 30 27 40 48 63 62 67 82 79 80 90 87这个过程如下动图所示：后序遍历前序遍历的步骤为：递归遍历目标节点的左子节点；递归遍历目标节点的右子节点；访问目标节点本身。Java实现如下：12345678910111213141516171819202122232425262728293031323334353637383940/** BST */public class BinarySearchTree &#123; /** 根节点 */ private Node root; /** 遍历需要从根开始遍历，所以添加根的get方法 */ public Node getRoot() &#123; return root; &#125; /** 节点 */ static class Node &#123; /** 关键字 */ int key; /** 额外携带的数据 */ String value; /** 左子节点 */ Node leftChild; /** 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125; /** 后续遍历 */ public void postOrder(Node targetNode) &#123; if (targetNode != null) &#123; // 递归遍历目标节点的左子节点 postOrder(targetNode.leftChild); // 递归遍历目标节点的右子节点 postOrder(targetNode.rightChild); // 访问目标节点本身 System.out.print(targetNode.key + " "); &#125; &#125;&#125;编写测试程序：1234567891011public class BinarySearchTreeTest &#123; public static void main(String[] args) &#123; BinarySearchTree bst = new BinarySearchTree(); Arrays.asList(72, 57, 82, 30, 63, 79, 90, 27, 40, 62, 67, 80, 87, 48).forEach(key -&gt; &#123; String value = "我是key为" + key + "的value"; bst.insert(key, value); &#125;); bst.postOrder(bst.getRoot()); &#125;&#125;输出如下：127 48 40 30 62 67 63 57 80 79 87 90 82 72这个过程如下动图所示：完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274/** * BST */public class BinarySearchTree &#123; /** * 根节点 */ private Node root; /** * 遍历需要从根开始遍历，所以添加根的get方法 */ public Node getRoot() &#123; return root; &#125; /** * 插入 */ public void insert(int key, String value) &#123; // 创建一个新节点 Node newNode = new Node(key, value); if (this.root == null) &#123; // 如果根为null，则这个新节点就是根 root = newNode; &#125; else &#123; // 如果跟不为null，则从根开始搜索插入位置 Node currentNode = root; // 用于暂存父节点 Node parentNode; while (true) &#123; // 父节点设置为当前节点 parentNode = currentNode; if (key &lt; currentNode.key) &#123; currentNode = currentNode.leftChild; if (currentNode == null) &#123; // 如果key小于当前节点key，并且当前节点的左子节点为空，则将新节点 // 设置为当前节点（父节点暂存对象）的左子节点，退出循环 parentNode.leftChild = newNode; return; &#125; &#125; else if (key &gt; currentNode.key) &#123; currentNode = currentNode.rightChild; if (currentNode == null) &#123; // 如果key大于当前节点key，并且当前节点的右子节点为空，则将新节点 // 设置为当前节点（父节点暂存对象）的又子节点，退出循环 parentNode.rightChild = newNode; return; &#125; &#125; else &#123; // 如果key等于当前节点key，则将value覆盖当前节点value currentNode.value = newNode.value; return; &#125; &#125; &#125; &#125; /** * 查找 */ public Node find(int key) &#123; // 从根节点开始查找 Node currentNode = root; // 当前节点的key不等于被查找的key时 while (currentNode.key != key) &#123; if (key &lt; currentNode.key) &#123; // 如果key值小于当前节点key，则查找左子节点 currentNode = currentNode.leftChild; &#125; else &#123; // 如果key值大于等于当前节点key，则查找右子节点 currentNode = currentNode.rightChild; &#125; // 如果当前节点为null，说明查到叶子节点了，仍没查到目标key，则直接返回null if (currentNode == null) &#123; return null; &#125; &#125; // 返回当前节点（退出while循环要么key相等，要么没找到，结果为null） return currentNode; &#125; /** * 最小值 */ public Node min() &#123; Node currentNode = root; while (currentNode.leftChild != null) &#123; currentNode = currentNode.leftChild; &#125; return currentNode; &#125; /** * 最大值 */ public Node max() &#123; Node currentNode = root; while (currentNode.rightChild != null) &#123; currentNode = currentNode.rightChild; &#125; return currentNode; &#125; /** * 删除 */ public boolean delete(int key) &#123; /* --------- 查找需要被删除的节点已经它的父节点 ------- */ // 从根节点开始查找 Node deleteNode = root; // 暂存需要被删除节点的父节点 Node parentNode = root; // 标识被删除的节点时父节点的左子节点还是右子节点 boolean isLeftChild = false; // 下面这个过程和查找一致，只不过加了isLeftChild标识 while (deleteNode.key != key) &#123; parentNode = deleteNode; if (key &lt; deleteNode.key) &#123; isLeftChild = true; deleteNode = deleteNode.leftChild; &#125; else &#123; isLeftChild = false; deleteNode = deleteNode.rightChild; &#125; // 如果目标key对应的节点为空，则不需要删除，直接返回false if (deleteNode == null) &#123; return false; &#125; &#125; /* --------- 情况1：被删除的节点是叶子节点 ------- */ if (deleteNode.leftChild == null &amp;&amp; deleteNode.rightChild == null) &#123; if (deleteNode == root) &#123; // 如果要删除的节点为root，则直接将root节点设置为null root = null; &#125; else if (isLeftChild) &#123; // 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为null parentNode.leftChild = null; &#125; else &#123; // 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为null parentNode.rightChild = null; &#125; &#125; else if (deleteNode.leftChild != null &amp;&amp; deleteNode.rightChild != null) &#123; /* --------- 情况3：被删除的节点有两个子节点 ------- */ // 获取删除节点的中序后继节点 Node successor = getSuccessor(deleteNode); // 如果伤处节点就是根节点的话，中序后继节点直接成为新的根 if (deleteNode == root) &#123; root = successor; &#125; else if (isLeftChild) &#123; // 如果删除节点是父节点的左子节点，则将父节点的左子节点和中序后继节点挂钩 parentNode.leftChild = successor; &#125; else &#123; // 如果删除节点是父节点的右子节点，则将父节点的右子节点和中序后继节点挂钩 parentNode.rightChild = successor; &#125; &#125; else &#123; /* --------- 情况2：被删除的节点只有一个子节点 ------- */ // 获取被删除节点的唯一子节点 Node deleteNodeChild = deleteNode.leftChild == null ? deleteNode.rightChild : deleteNode.leftChild; if (deleteNode == root) &#123; // 如果被删除节点就是root，那么将其唯一子节点设置为root root = deleteNodeChild; &#125; else if (isLeftChild) &#123; // 如果要删除的叶子节点为父节点的左子节点，则将父节点的左子节点关联置为被删除节点的唯一子节点 parentNode.leftChild = deleteNodeChild; &#125; else &#123; // 如果要删除的叶子节点为父节点的右子节点，则将父节点的右子节点关联置为被删除节点的唯一子节点 parentNode.rightChild = deleteNodeChild; &#125; &#125; return true; &#125; /** 中序遍历 */ public void inOrder(Node targetNode) &#123; if (targetNode != null) &#123; // 递归遍历目标节点的左子节点 inOrder(targetNode.leftChild); // 访问目标节点本身 System.out.print(targetNode.key + " "); // 递归遍历目标节点的右子节点 inOrder(targetNode.rightChild); &#125; &#125; /** 前序遍历 */ public void preOrder(Node targetNode) &#123; if (targetNode != null) &#123; // 访问目标节点本身 System.out.print(targetNode.key + " "); // 递归遍历目标节点的左子节点 preOrder(targetNode.leftChild); // 递归遍历目标节点的右子节点 preOrder(targetNode.rightChild); &#125; &#125; /** 后续遍历 */ public void postOrder(Node targetNode) &#123; if (targetNode != null) &#123; // 递归遍历目标节点的左子节点 postOrder(targetNode.leftChild); // 递归遍历目标节点的右子节点 postOrder(targetNode.rightChild); // 访问目标节点本身 System.out.print(targetNode.key + " "); &#125; &#125; /** * 查找中序后继节点 */ private Node getSuccessor(Node deleteNode) &#123; // 暂存中序后继节点的父节点 Node successorParent = deleteNode; // 暂存中序后继节点 Node successor = deleteNode; // 先从删除节点的右子节点开始查找 Node currentNode = deleteNode.rightChild; while (currentNode != null) &#123; successorParent = successor; successor = currentNode; // 一直往下查找当前节点的左子节点，直到为空 currentNode = currentNode.leftChild; &#125; // 如上面文章所说，中序后继节点和删除节点有两种可能性， // 当中序后继节点不是删除节点的右子节点时，需要做如下额外操作 if (successor != deleteNode.rightChild) &#123; // 如果中序后继节点的右子节点不为空的话，将其和中序后继节点父节点的左子节点挂钩 if (successor.rightChild != null) &#123; successorParent.leftChild = successor.rightChild; &#125; // 中序后继节点的右子节点和删除节点的右子节点挂钩 successor.rightChild = deleteNode.rightChild; &#125; // 中序后继节点的左子节点和删除节点的左子节点挂钩 successor.leftChild = deleteNode.leftChild; // 剩下的删除节点的父节点和中序后继节点的连接关系在删除方法里处理， // 因为这个方法内无法获取删除节点的父节点对象 return successor; &#125; /** * 节点 */ static class Node &#123; /** * 关键字 */ int key; /** * 额外携带的数据 */ String value; /** * 左子节点 */ Node leftChild; /** * 右子节点 */ Node rightChild; public Node(int key, String value) &#123; this.key = key; this.value = value; &#125; &#125;&#125;BST效率节点的查找需要从根节点开始一层一层往下找，树节点数和层数的关系如下表所示：节点数层数113273154315……102310……3276715……104857520……3355443225……107374182430假设节点数为N，层数为L，那么不难看出它们的关系为：N=2^(L-1)，所以L=log2(N+1)，大约为log2N，大O表示法为O(logN)。红黑树BST的缺陷虽然BST结合了数组和链表的优势，但它也不是完美的，当BST不平衡的时候，查找操作效率急剧下降。举个比较极端的例子：假如插入的数据是升序数据：2，4，6，8，10，12…，这时候BST如下所示：这时候BST实际上就是一个链表结构了，搜索效率为O(N)。一个BST完全平衡和完全不平衡的情况比较少见，就概率来说，BST的搜索效率介于O(N)与O(logN)之间。红黑树规则为了解决非平衡树搜索效率下降的问题，人们又提出了红黑树的概念。在红黑树中，每个节点要么是红色的要么是黑色的，红黑树在插入和删除的过程中，需要遵循某些特定的规则，遵循这些规则可以确保数始终是趋于平衡的。红黑树除了遵循基本的BST规则外，还需遵循以下4个规则：每一个节点不是红色就是黑色；根节点一定是黑色的；如果节点时红色的，那么它的子节点必须都是黑色的；从根节点到叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点。在数据插入和删除过程中，如果违背了上述4个规则，则树会执行以下操作进行修正，以重新满足上述4个规则：改变节点的颜色；执行旋转操作。红黑树演示下面通过一个动图演示红黑树如何处理升序数据：2，4，6，8，10，12的插入，使得树趋于平衡：参考自《Java数据结构与算法（第二版）》，上述BST图片均来自http://btv.melezinek.cz/binary-search-tree.html网站，红黑树示例来自https://www.wztlink1013.com/visualization/RedBlack.html。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Spring事件发布与监听]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E4%B8%8E%E7%9B%91%E5%90%AC.html</url>
    <content type="text"><![CDATA[在使用Spring构建的应用程序中，适当使用事件发布与监听的机制可以使我们的代码灵活度更高，降低耦合度。Spring提供了完整的事件发布与监听模型，在该模型中，事件发布方只需将事件发布出去，无需关心有多少个对应的事件监听器；监听器无需关心是谁发布了事件，并且可以同时监听来自多个事件发布方发布的事件，通过这种机制，事件发布与监听是解耦的。本节将举例事件发布与监听的使用，并介绍内部实现原理。事件发布监听例子新建springboot应用，boot版本2.4.0，引入如下依赖：123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;自定义事件Spring中使用ApplicationEvent接口来表示一个事件，所以我们自定义事件MyEvent需要实现该接口：123456public class MyEvent extends ApplicationEvent &#123; public MyEvent(Object source) &#123; super(source); &#125;&#125;构造器source参数表示当前事件的事件源，一般传入Spring的context上下文对象即可。事件发布器事件发布通过事件发布器ApplicationEventPublisher完成，我们自定义一个事件发布器MyEventPublisher：12345678910111213141516171819202122232425@Componentpublic class MyEventPublisher implements ApplicationEventPublisherAware, ApplicationContextAware &#123; private ApplicationContext applicationContext; private ApplicationEventPublisher applicationEventPublisher; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125; public void publishEvent() &#123; logger.info("开始发布自定义事件MyEvent"); MyEvent myEvent = new MyEvent(applicationContext); applicationEventPublisher.publishEvent(myEvent); logger.info("发布自定义事件MyEvent结束"); &#125;&#125;在自定义事件发布器MyEventPublisher中，我们需要通过ApplicationEventPublisher来发布事件，所以我们实现了ApplicationEventPublisherAware接口，通过回调方法setApplicationEventPublisher为MyEventPublisher的ApplicationEventPublisher属性赋值；同样的，我们自定义的事件MyEvent构造函数需要传入Spring上下文，所以MyEventPublisher还实现了ApplicationContextAware接口，注入了上下文对象ApplicationContext。publishEvent方法发布了一个自定义事件MyEvent。事件发布出去后，我们接着编写相应的事件监听器。注解监听我们可以方便地通过@EventListener注解实现事件监听，编写MyEventPublisher：12345678910@Componentpublic class MyAnnotationEventListener &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @EventListener public void onMyEventPublished(MyEvent myEvent) &#123; logger.info("收到自定义事件MyEvent -- MyAnnotationEventListener"); &#125;&#125;被@EventListener注解标注的方法入参为MyEvent类型，所以只要MyEvent事件被发布了，该监听器就会起作用，即该方法会被回调。编程实现监听除了使用@EventListener注解实现事件的监听外，我们也可以手动实现ApplicationListener接口来实现事件的监听（泛型为监听的事件类型）：12345678910@Componentpublic class MyEventListener implements ApplicationListener&lt;MyEvent&gt; &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void onApplicationEvent(MyEvent event) &#123; logger.info("收到自定义事件MyEvent"); &#125;&#125;测试在springboot的入口类中测试事件的发布：123456789@SpringBootApplicationpublic class MyApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(MyApplication.class, args); MyEventPublisher publisher = context.getBean(MyEventPublisher.class); publisher.publishEvent(); &#125;&#125;运行程序，输出如下：12342020-06-22 16:31:46.667 INFO 83600 --- [ main] c.m.demo.publisher.MyEventPublisher : 开始发布自定义事件MyEvent2020-06-22 16:31:46.668 INFO 83600 --- [ main] cc.mrbird.demo.listener.MyEventListener : 收到自定义事件MyEvent2020-06-22 16:31:46.668 INFO 83600 --- [ main] c.m.d.l.MyAnnotationEventListener : 收到自定义事件MyEvent -- MyAnnotationEventListener2020-06-22 16:31:46.668 INFO 83600 --- [ main] c.m.demo.publisher.MyEventPublisher : 发布自定义事件MyEvent结束可以看到，两个监听器都监听到了事件的发布。此外细心的读者会发现，事件发布和事件监听是同一个线程完成的，过程为同步操作，只有当所有对应事件监听器的逻辑执行完毕后，事件发布方法才能出栈。后面进阶使用会介绍如何使用异步的方式进行事件监听。事件发布监听原理事件发布监听过程在事件发布方法上打个断点：以debug的方式启动程序，程序执行到该断点后点击Step Into按钮，程序跳转到AbstractApplicationContext的publishEvent(ApplicationEvent event)方法：继续点击Step Into，程序跳转到AbstractApplicationContext的publishEvent(Object event, @Nullable ResolvableType eventType)方法：getApplicationEventMulticaster方法用于获取广播事件用的多播器，源码如下所示：那么AbstractApplicationContext的applicationEventMulticaster属性是何时赋值的呢，下面将会介绍到。获取到事件多播器后，调用其multicastEvent方法广播事件，点击Step Into进入该方法内部查看具体逻辑：查看invokeListener方法源码：继续查看doInvokeListener方法源码：上述过程就是整个事件发布与监听的过程。多播器创建过程为了弄清楚AbstractApplicationContext的applicationEventMulticaster属性是何时赋值的（即事件多播器是何时创建的），我们在AbstractApplicationContext的applicationEventMulticaster属性上打个断点：以debug的方式启动程序，程序跳转到了AbstractApplicationContext的initApplicationEventMulticaster方法中：通过跟踪方法调用栈，我们可以总结出程序执行到上述截图的过程：SpringBoot入口类的main方法执行SpringApplication.run(MyApplication.class, args)启动应用：run方法内部包含refreshContext方法（刷新上下文）：refresh方法内部包含initApplicationEventMulticaster方法：initApplicationEventMulticaster方法创建多播器。监听器获取过程在追踪事件发布与监听的过程中，我们知道事件对应的监听器是通过getApplicationListeners方法获取的：方法返回三个MyEvent事件对应的监听器，索引为0的监听器为DelegatingApplicationListener，它没有实质性的处理某事件，忽略；索引为1的监听器为通过实现ApplicationEventListener接口的监听器；索引为2的监听器为通过@EventListener实现的监听器。编程实现监听器注册过程查看getApplicationListeners源码：其中retrieverCache的定义为final Map&lt;ListenerCacheKey, CachedListenerRetriever&gt; retrieverCache = new ConcurrentHashMap&lt;&gt;(64)。接着查看retrieveApplicationListeners方法（方法见名知意，程序第一次获取事件对应的监听器时，缓存中是空的，所以继续检索获取事件对应的监听器）：从上面这段代码我们知道，用于遍历的监听器集合对象listeners和listenerBeans的值是从this.defaultRetriever的applicationListeners和applicationListenerBeans属性获取的，所以我们需要关注这些属性是何时被赋值的。defaultRetriever的类型为DefaultListenerRetriever：我们在applicationListeners属性上右键选择Find Usages查看赋值相关操作：可以看到，赋值操作发生在AbstractApplicationEventMulticaster的addApplicationListener方法中，继续在addApplicationListener方法上右键选择Find Usages查看调用源：我们在registerListeners方法上打个断点，重新启动程序，查看方法调用栈：从方法调用栈我们可以总结出this.defaultRetriever的applicationListeners和applicationListenerBeans属性值赋值的过程：SpringApplication.run(MyApplication.class, args)启动Boot程序；run方法内部调用refreshContext刷新容器方法：refresh方法内部调用了registerListener方法注册监听器：registerListeners方法内部从IOC容器获取所有ApplicationListener类型Bean，然后赋值给this.defaultRetriever的applicationListeners和applicationListenerBeans属性。注解监听器注册过程查看@EventListener注解源码：查看EventListenerMethodProcessor源码：其实现了SmartInitializingSingleton接口，该接口包含afterSingletonsInstantiated方法：通过注释可以看到这个方法的调用时机为：单实例Bean实例化后被调用，此时Bean已经被创建出来。我们查看EventListenerMethodProcessor是如何实现该方法的：继续查看processBean方法源码：至此，两种方式注册监听器的原理都搞清楚了。使用进阶与拓展事件监听异步化通过前面的分析，我们知道事件广播和监听是一个线程完成的同步操作，有时候为了让广播更有效率，我们可以考虑将事件监听过程异步化。单个异步先来看看如何实现单个监听器异步。首先需要在springboot入口类上通过@EnableAsync注解开启异步，然后在需要异步执行的监听器方法上使用@Async注解标注，以MyAnnotationEventListener为例：1234567891011@Componentpublic class MyAnnotationEventListener &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Async // 异步 @EventListener public void onMyEventPublished(MyEvent myEvent) &#123; logger.info("收到自定义事件MyEvent -- MyAnnotationEventListener"); &#125;&#125;启动程序，输出如下：通过日志可以看出来，该监听器方法已经异步化，执行线程为task-1。整体异步通过前面源码分析，我们知道多播器在广播事件时，会先判断是否有指定executor，有的话通过executor执行监听器逻辑。所以我们可以通过指定executor的方式来让所有的监听方法都异步执行：新建一个配置类：12345678910@Configurationpublic class AsyncEventConfigure &#123; @Bean(name = AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME) public ApplicationEventMulticaster simpleApplicationEventMulticaster() &#123; SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster(); eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor()); return eventMulticaster; &#125;&#125;在配置类中，我们注册了一个名称为AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME（即applicationEventMulticaster）的Bean，用于覆盖默认的事件多播器，然后指定了TaskExecutor，SimpleAsyncTaskExecutor为Spring提供的异步任务executor。在启动项目前，先把之前在springboot入口类添加的@EnableAsync注解去掉，然后启动项目，输出如下：可以看到，监听器事件都异步化了。多事件监听器事件监听器除了可以监听单个事件外，也可以监听多个事件（仅@EventListener支持），修改MyAnnotationEventListener：123456789101112131415161718@Componentpublic class MyAnnotationEventListener &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @EventListener(classes = &#123;MyEvent.class, ContextRefreshedEvent.class, ContextClosedEvent.class&#125;) public void onMyEventPublished(ApplicationEvent event) &#123; if (event instanceof MyEvent) &#123; logger.info("监听到MyEvent事件"); &#125; if (event instanceof ContextRefreshedEvent) &#123; logger.info("监听到ContextRefreshedEvent事件"); &#125; if (event instanceof ContextClosedEvent) &#123; logger.info("监听到ContextClosedEvent事件"); &#125; &#125;&#125;该监听器将同时监听MyEvent、ContextRefreshedEvent和ContextClosedEvent三种类型事件：监听器排序单个类型事件也可以有多个监听器同时监听，这时候可以通过实现Ordered接口实现排序（或者@Order注解标注）。修改MyEventListener：123456789101112131415@Componentpublic class MyEventListener implements ApplicationListener&lt;MyEvent&gt;, Ordered &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void onApplicationEvent(MyEvent event) &#123; logger.info("收到自定义事件MyEvent，我的优先级较高"); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125;修改MyAnnotationEventListener：1234567891011121314151617@Componentpublic class MyAnnotationEventListener implements Ordered &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @EventListener(classes = &#123;MyEvent.class&#125;) public void onMyEventPublished(ApplicationEvent event) &#123; if (event instanceof MyEvent) &#123; logger.info("监听到MyEvent事件，我的优先级较低"); &#125; &#125; @Override public int getOrder() &#123; return 1; &#125;&#125;启动程序输出如下：配合SpEL表达式@EventListener注解还包含一个condition属性，可以配合SpEL表达式来条件化触发监听方法。修改MyEvent，添加一个boolean类型属性：12345678910111213141516public class MyEvent extends ApplicationEvent &#123; private boolean flag; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; public MyEvent(Object source) &#123; super(source); &#125;&#125;在发布事件的时候，将该属性设置为false：1234567891011121314151617181920212223242526@Componentpublic class MyEventPublisher implements ApplicationEventPublisherAware, ApplicationContextAware &#123; private ApplicationContext applicationContext; private ApplicationEventPublisher applicationEventPublisher; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; this.applicationEventPublisher = applicationEventPublisher; &#125; public void publishEvent() &#123; logger.info("开始发布自定义事件MyEvent"); MyEvent myEvent = new MyEvent(applicationContext); myEvent.setFlag(false); // 设置为false applicationEventPublisher.publishEvent(myEvent); logger.info("发布自定义事件MyEvent结束"); &#125;&#125;在MyAnnotationEventListener的@EventListener注解上演示如何使用SpEL：1234567891011121314151617@Componentpublic class MyAnnotationEventListener implements Ordered &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @EventListener(classes = &#123;MyEvent.class&#125;, condition = "#event.flag") public void onMyEventPublished(ApplicationEvent event) &#123; if (event instanceof MyEvent) &#123; logger.info("监听到MyEvent事件，我的优先级较低"); &#125; &#125; @Override public int getOrder() &#123; return 1; &#125;&#125;condition = &quot;#event.flag&quot;的含义为，当前event事件（这里为MyEvent）的flag属性为true的时候执行。启动程序，输出如下：因为我们发布的MyEvent的flag属性值为false，所以上面这个监听器没有被触发。事务事件监听器Spring 4.2开始提供了一个@TransactionalEventListener注解用于监听数据库事务的各个阶段：AFTER_COMMIT - 事务成功提交；AFTER_ROLLBACK – 事务回滚后；AFTER_COMPLETION – 事务完成后（无论是提交还是回滚）；BEFORE_COMMIT - 事务提交前；例子：1234@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)public void onTransactionChange(ApplicationEvent event)&#123; logger.info("监听到事务提交事件");&#125;]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring声明式事务原理]]></title>
    <url>%2FSpring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[在Spring-事务管理一节中，我们了解了在Spring中如何方便的管理数据库事务，并了解了一些和事务相关的专业术语。本节将通过一个简单的例子回顾Spring声明式事务的使用，并通过源码解读内部实现原理，最后通过列举一些常见事务不生效的场景来加深对Spring事务原理的理解。事务例子回顾新建SpringBoot项目，Boot版本2.4.0，然后引入如下依赖：12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;引入了JDBC、MySQL驱动和mybatis等依赖。然后在Spring入口类上加上@EnableTransactionManagement注解，以开启事务：12345678@EnableTransactionManagement@SpringBootApplicationpublic class TransactionApplication &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(TransactionApplication.class, args); &#125;&#125;接着新建名称为test的MySQL数据库，并创建USER表：123456CREATE TABLE `USER` ( `USER_ID` varchar(10) NOT NULL COMMENT '用户ID', `USERNAME` varchar(10) DEFAULT NULL COMMENT '用户名', `AGE` varchar(3) DEFAULT NULL COMMENT '用户年龄', PRIMARY KEY (`USER_ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;其中USER_ID字段非空。在application.properties配置中添加数据库相关配置：1234spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2b8创建USER表对应实体类User：123456789101112131415161718192021222324252627282930313233343536373839public class User implements Serializable &#123; private String userId; private String username; private String age; public User(String userId, String username, String age) &#123; this.userId = userId; this.username = username; this.age = age; &#125; public User() &#123; &#125; public String getUserId() &#123; return userId; &#125; public void setUserId(String userId) &#123; this.userId = userId; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125;创建UserMapper：123456@Mapperpublic interface UserMapper &#123; @Insert("insert into user(user_id,username,age) values(#&#123;userId&#125;,#&#123;username&#125;,#&#123;age&#125;)") void save(User user);&#125;包含一个新增用户的方法save。创建Service接口UserService：12345public interface UserService &#123; void saveUser(User user);&#125;其实现类UserServiceImpl：12345678910111213141516171819@Servicepublic class UserServiceImpl implements UserService &#123; private final UserMapper userMapper; public UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Transactional @Override public void saveUser(User user) &#123; userMapper.save(user); // 测试事务回滚 if (!StringUtils.hasText(user.getUsername())) &#123; throw new RuntimeException("username不能为空"); &#125; &#125;&#125;在SpringBoot的入口类中测试一波：1234567891011@EnableTransactionManagement@SpringBootApplicationpublic class TransactionApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(TransactionApplication.class, args); UserService userService = context.getBean(UserService.class); User user = new User("1", null, "18"); userService.saveUser(user); &#125;&#125;如果事务生效的话，这条数据将不会被插入到数据库中，运行程序后，查看库表：可以看到数据并没有被插入，说明事务控制成功。我们注释掉UserServiceImpl的saveUser方法上的@Transactional注解，重新运行程序，查看库表：可以看到数据被插入到数据库中了，事务控制失效。事务原理@EnableTransactionManagement上面例子中，我们通过模块驱动注解@EnableTransactionManagement开启了事务管理功能，查看其源码：接着查看TransactionManagementConfigurationSelector的源码：对通过Selector往IOC容器中导入组件不熟悉的读者可以参考深入学习Spring组件注册。所以接下来我们重点关注AutoProxyRegistrar和ProxyTransactionManagementConfiguration的逻辑即可。AutoProxyRegistrar查看AutoProxyRegistrar的源码：查看AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)源码：查看InfrastructureAdvisorAutoProxyCreator的层级关系图：这和深入理解Spring-AOP原理一文中的AnnotationAwareAspectJAutoProxyCreator的层级关系图一致，所以我们可以推断出InfrastructureAdvisorAutoProxyCreator的作用为：为目标Service创建代理对象，增强目标Service方法，用于事务控制。ProxyTransactionManagementConfiguration查看ProxyTransactionManagementConfiguration源码：注册BeanFactoryTransactionAttributeSourceAdvisor增强器，该增强器需要如下两个Bean：TransactionAttributeSourceTransactionInterceptor注册TransactionAttributeSource：方法体内部创建了一个类型为AnnotationTransactionAttributeSource的Bean，查看其源码：查看SpringTransactionAnnotationParser源码：注册TransactionInterceptor事务拦截器：查看TransactionInterceptor源码，其实现了MethodInterceptor方法拦截器接口，在深入理解Spring-AOP原理一文中曾介绍过，MethodBeforeAdviceInterceptor、AspectJAfterAdvice、AfterReturningAdviceInterceptor和AspectJAfterThrowingAdvice等增强器都是MethodInterceptor的实现类，目标方法执行的时候，对应拦截器的invoke方法会被执行，所以重点关注TransactionInterceptor实现的invoke方法：查看invokeWithinTransaction方法源码：completeTransactionAfterThrowing源码如下：这里，假如没有在@Transactional注解上指定回滚的异常类型的话，默认只对RunTimeExcetion和Error类型异常进行回滚：commitTransactionAfterReturning源码如下：debug验证重新打开UserServiceImpl的saveUser方法上的@Transactional注解，然后在如下所示位置打个断点：以debug的方式启动程序：可以看到目标对象已经被JDK代理（目标对象实现了接口，默认走JDK动态代理。可以通过spring.aop.proxy-target-class=true配置来强制使用cglib代理，需要额外引入AOP自动装配依赖）。在断点处执行Step Into，程序跳转到JdkDynamicAopProxy的invoke方法：程序跳转到TransactionInterceptor的invoke方法：可以看到整个过程和深入理解Spring-AOP原理一文介绍的一致。事务不生效场景对Spring事务机制不熟悉的coder经常会遇到事务不生效的场景，这里列举两个最为常见的场景，并给出对应的解决方案。场景一Service方法抛出的异常不是RuntimeException或者Error类型，并且@Transactional注解上没有指定回滚异常类型。对应的代码例子为：12345678910111213141516171819@Servicepublic class UserServiceImpl implements UserService &#123; private final UserMapper userMapper; public UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Transactional @Override public void saveUser(User user) throws Exception &#123; userMapper.save(user); // 测试事务回滚 if (!StringUtils.hasText(user.getUsername())) &#123; throw new Exception("username不能为空"); &#125; &#125;&#125;这冲情况下，Spring并不会进行事务回滚操作。正如@Transactional注解源码注释所述的那样：默认情况下，Spring事务只对RuntimeException或者Error类型异常（错误）进行回滚，检查异常（通常为业务类异常）不会导致事务回滚。。所以要解决上面这个事务不生效的问题，我们主要有以下两种方式：手动在@Transactional注解上声明回滚的异常类型（方法抛出该异常及其所有子类型异常都能触发事务回滚）：12345678910111213141516171819@Servicepublic class UserServiceImpl implements UserService &#123; private final UserMapper userMapper; public UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Transactional(rollbackFor = Exception.class) @Override public void saveUser(User user) throws Exception &#123; userMapper.save(user); // 测试事务回滚 if (!StringUtils.hasText(user.getUsername())) &#123; throw new Exception("username不能为空"); &#125; &#125;&#125;方法内手动抛出的检查异常类型改为RuntimeException子类型：定义一个自定义异常类型ParamInvalidException：123456public class ParamInvalidException extends RuntimeException&#123; public ParamInvalidException(String message) &#123; super(message); &#125;&#125;修改UserServiceImpl的saveUser方法：12345678910111213141516171819@Servicepublic class UserServiceImpl implements UserService &#123; private final UserMapper userMapper; public UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Transactional @Override public void saveUser(User user) &#123; userMapper.save(user); // 测试事务回滚 if (!StringUtils.hasText(user.getUsername())) &#123; throw new ParamInvalidException("username不能为空"); &#125; &#125;&#125;这两种方式都能让事务按照我们的预期生效。场景二非事务方法直接通过this调用本类事务方法。这种情况也是比较常见的，举个例子，修改UserServiceImpl：123456789101112131415161718192021222324@Servicepublic class UserServiceImpl implements UserService &#123; private final UserMapper userMapper; public UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Override public void saveUserTest(User user) &#123; this.saveUser(user); &#125; @Transactional @Override public void saveUser(User user) &#123; userMapper.save(user); // 测试事务回滚 if (!StringUtils.hasText(user.getUsername())) &#123; throw new ParamInvalidException("username不能为空"); &#125; &#125;&#125;在UserServiceImpl中，我们新增了saveUserTest方法，该方法没有使用@Transactional注解标注，为非事务方法，内部直接调用了saveUser事务方法。在入口类里测试该方法的调用：1234567891011@EnableTransactionManagement@SpringBootApplicationpublic class TransactionApplication &#123; public static void main(String[] args) throws Exception &#123; ConfigurableApplicationContext context = SpringApplication.run(TransactionApplication.class, args); UserService userService = context.getBean(UserService.class); User user = new User("2", null, "28"); userService.saveUserTest(user); &#125;&#125;启动程序，观察数据库数据：可以看到，事务并没有回滚，数据已经被插入到了数据库中。这种情况下事务失效的原因为：Spring事务控制使用AOP代理实现，通过对目标对象的代理来增强目标方法。而上面例子直接通过this调用本类的方法的时候，this的指向并非代理类，而是该类本身。使用debug来验证this是否为代理对象：这种情况下要让事务生效主要有如下两种解决方式（原理都是使用代理对象来替代this）：从IOC容器中获取UserService Bean，然后调用它的saveUser方法：12345678910111213141516171819202122232425262728293031@Servicepublic class UserServiceImpl implements UserService, ApplicationContextAware &#123; private final UserMapper userMapper; private ApplicationContext context; public UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Override public void saveUserTest(User user) &#123; UserService userService = context.getBean(UserService.class); userService.saveUser(user); &#125; @Transactional @Override public void saveUser(User user) &#123; userMapper.save(user); // 测试事务回滚 if (!StringUtils.hasText(user.getUsername())) &#123; throw new ParamInvalidException("username不能为空"); &#125; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.context = applicationContext; &#125;&#125;上面代码我们通过实现ApplicationContextAware接口注入了应用上下文ApplicationContext，然后从中取出UserService Bean来代替this。从AOP上下文中取出当前代理对象：这种情况首先需要引入AOP Starter：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;然后在SpringBoot入口类中通过注解@EnableAspectJAutoProxy(exposeProxy = true)将当前代理对象暴露到AOP上下文中（通过AopContext的ThreadLocal实现）。最后在UserServcieImpl的saveUserTest方法中通过AopContext获取UserServce的代理对象：1234567891011121314151617181920212223242526@Servicepublic class UserServiceImpl implements UserService &#123; private final UserMapper userMapper; public UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Override public void saveUserTest(User user) &#123; UserService userService = (UserService) AopContext.currentProxy(); userService.saveUser(user); &#125; @Transactional @Override public void saveUser(User user) &#123; userMapper.save(user); // 测试事务回滚 if (!StringUtils.hasText(user.getUsername())) &#123; throw new ParamInvalidException("username不能为空"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Spring AOP原理]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-AOP%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[AOP底层为动态代理，AOP指的是：在程序运行期间动态地将某段代码切入到指定方法指定位置进行运行的编程方式，相关设计模式为代理模式。本节将通过一个简单的例子回顾Spring AOP的使用，并且通过debug源码深入理解内部原理。hints：本节图片较多，加载较慢。回顾Spring AOP的使用新建一个SpringBoot项目，SpringBoot版本为2.4.0，引入如下两个依赖：12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;然后创建一个目标类TatgetClass，包含待会需要被AOP代理增强的方法test：1234567891011@Componentpublic class TargetClass &#123; public String test(String value) &#123; System.out.println("目标方法test被执行"); if (!StringUtils.hasLength(value)) &#123; throw new RuntimeException("value不能为空"); &#125; return value; &#125;&#125;编写切面类MyAspect：12345678910111213141516171819202122232425262728293031323334@Aspect@Componentpublic class MyAspect &#123; @Pointcut("execution(public * cc.mrbird..*.TargetClass.test(..))") public void pointcut() &#123; &#125; @Before("pointcut()") public void onBefore(JoinPoint joinPoint) &#123; System.out.println("onBefore：" + joinPoint.getSignature().getName() + "方法开始执行，参数：" + Arrays.asList(joinPoint.getArgs())); &#125; @After("pointcut()") public void onAfter(JoinPoint joinPoint) &#123; System.out.println("onAfter：" + joinPoint.getSignature().getName() + "方法执行结束，参数：" + Arrays.asList(joinPoint.getArgs())); &#125; @AfterReturning(value = "pointcut()", returning = "result") public void afterReturning(JoinPoint joinPoint, Object result) &#123; System.out.println("afterReturning：" + joinPoint.getSignature().getName() + "方法执行结束返回，参数：" + Arrays.asList(joinPoint.getArgs()) + "，返回值：" + result); &#125; @AfterThrowing(value = "pointcut()", throwing = "exception") public void afterThrowing(JoinPoint joinPoint, Exception exception) &#123; System.out.println("afterThrowing：" + joinPoint.getSignature().getName() + "方法执行出错，参数：" + Arrays.asList(joinPoint.getArgs()) + "，异常：" + exception); &#125;&#125;该切面包含了4个通知方法：前置通知（@Before）：在目标方法被调用之前调用通知功能；后置通知（@After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；返回通知（@AfterReturning）：在目标方法成功执行之后调用通知；异常通知（@AfterThrowing）：在目标方法抛出异常后调用通知。这几个通知的顺序在不同的Spring版本中有所不同：Spring4.x正常情况：@Before —-&gt; 目标方法 —-&gt; @After —-&gt; @AfterReturning异常情况：@Before —-&gt; 目标方法 —-&gt; @After —-&gt; @AfterThrowingSpring5.x正常情况：@Before —-&gt; 目标方法 —-&gt; @AfterReturning —-&gt; @After异常情况：@Before —-&gt; 目标方法 —-&gt; @AfterThrowing —-&gt; @After具体可以参考这篇博客：https://www.cnblogs.com/orzjiangxiaoyu/p/13869747.html。通知顺序并不影响本文对SpringAOP源码的理解。在SpringBoot入口类测试AOP结果：12345678910@SpringBootApplicationpublic class AopApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(AopApplication.class, args); TargetClass targetClass = context.getBean(TargetClass.class); targetClass.test("aop"); &#125;&#125;主要逻辑为从IOC容器中获取TargetClass Bean，然后调用其test方法，程序运行结果如下：1234onBefore：test方法开始执行，参数：[aop]目标方法test被执行afterReturning：test方法执行结束返回，参数：[aop]，返回值：aoponAfter：test方法执行结束，参数：[aop]test方法参数为空时，程序运行结果如下：1234onBefore：test方法开始执行，参数：[]目标方法test被执行afterThrowing：test方法执行出错，参数：[]，异常：java.lang.RuntimeException: value不能为空onAfter：test方法执行结束，参数：[]可以看到，我们成功通过Spring AOP将各个通知方法织入到了目标方法的各个执行阶段，下面我们就来深入探究Spring AOP的实现原理。@EnableAspectJAutoProxy前面我们引入了Spring AOP开箱即用的starterspring-boot-starter-aop，@Enable模块驱动注解EnableAspectJAutoProxy用于开启AspectJ自动代理，源码如下所示：123456789@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)public @interface EnableAspectJAutoProxy &#123; boolean proxyTargetClass() default false; boolean exposeProxy() default false;&#125;该注解类上通过@Import导入了AspectJAutoProxyRegistrarAspectJ自动代理注册器（对@Import不了解的读者可以参考深入学习Spring组件注册），查看AspectJAutoProxyRegistrar的源码：通过注释我们大体可以知道，该注册器的作用是往IOC容器里注册了一个类型为AnnotationAwareAspectJAutoProxyCreator（注解驱动的AspectJ自动代理创建器）的Bean。该类的registerBeanDefinitions方法主要关注：1AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);查看其源码：可以看到，核心逻辑为通过RootBeanDefinition往IOC注册了名称为AUTO_PROXY_CREATOR_BEAN_NAME（常量，值为org.springframework.aop.config.internalAutoProxyCreator），类型为AnnotationAwareAspectJAutoProxyCreator的Bean（对这种通过ImportBeanDefinitionRegistrar往IOC注册Bean方式不了解的读者可以参考深入学习Spring组件注册）。总结：@EnableAspectJAutoProxy模块驱动注解往IOC容器中注册了类型为AnnotationAwareAspectJAutoProxyCreator的Bean，Bean名称为org.springframework.aop.config.internalAutoProxyCreator。AnnotationAwareAspectJAutoProxyCreator class hierarchy通过前面的分析，我们的目光聚焦在AnnotationAwareAspectJAutoProxyCreator类上，为了搞清楚这个类的作用，我们先捋清类的层级关系：可以看到AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor和BeanFactoryAware接口。实现BeanFactoryAware用于在Bean初始化时注入BeanFactory，而SmartInstantiationAwareBeanPostProcessor接口的父类为InstantiationAwareBeanPostProcessor接口，该接口继承自BeanPostProcessor接口。通过深入理解Spring BeanPostProcessor &amp; InstantiationAwareBeanPostProcessor一节的学习，我们知道BeanPostProcessor接口和InstantiationAwareBeanPostProcessor接口包含一些用于Bean实例化初始化前后进行自定义操作的方法，所以我们大体可以猜测出目标Bean的代理是在这些接口方法里实现的。通过查看AnnotationAwareAspectJAutoProxyCreator及其各个层级父类源码可以发现，AbstractAutoProxyCreator类实现了InstantiationAwareBeanPostProcessor接口的postProcessBeforeInstantiation方法（自定义Bean实例化前操作逻辑），实现了BeanPostProcessor的postProcessAfterInitialization方法（自定义Bean初始化后操作逻辑），所以我们在这两个方法上打个端点，用于后续debug：AOP代理创建过程我们以debug的方式启动前面的AOP例子，因为后置处理器对所有Bean都生效，所以每个Bean创建时都会进入我们刚刚打断点的那两个方法中。但我们只关心Spring AOP是怎样增强我们定义的目标类TargetClass的，所以如果Bean类型不是TargetClass，我们都直接点击Resume Program按钮跳过，直到Bean类型是TargetClass：postProcessBeforeInstantiation方法主要包含以下几个核心步骤：通过Bean名称和Bean类型获取该Bean的唯一缓存键名，getCacheKey方法源码如下所示：在这里，cacheKey的值为targetClass。判断当前Bean（TargetClass）是否包含在advisedBeans集合中（AbstractAutoProxyCreator的成员变量private final Map&lt;Object, Boolean&gt; advisedBeans = new ConcurrentHashMap&lt;&gt;(256)，用于存放所有Bean是否需要增强标识，键为每个Bean的cacheKey，值为布尔类型，true表示需要增强，false表示不需要增强），此时TargetClass还未实例化，所以自然不在该集合中。判断当前Bean（TargetClass）是否是基础类，查看isInfrastructureClass方法源码：方法调用了父类的isInfrastructureClass方法：this.aspectJAdvisorFactory.isAspect方法源码如下所示：所以这一步逻辑为：判断当前Bean（TargetClass）是否是Advice，Pointcut，Advisor，AopInfrastructureBean的子类或者是否为切面类（@Aspect注解标注）。判断是否需要跳过：shouldSkip源码如下所示：通过Bean名称判断是否以AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX（.ORIGINAL）结尾，是的话返回true表示跳过代理。很明显我们的TargetClass不符合3和4，所以继续走第5步。如果我们自定义了TargetSource，则在此处创建Bean代理，以取代目标Bean的后续默认实例化方式。我们并没有自定义TargetSource，所以直接跳过。经过以上这些步骤，就TargetClass这个Bean而言，postProcessBeforeInstantiation方法最终返回null。Bean实例化前置处理到此完毕，点击Resume Program，继续Bean的后续生命周期处理逻辑，程序跳转到Bean初始化后置处理方法postProcessAfterInitialization：该方法重点关注wrapIfNecessary方法，查看wrapIfNecessary方法源码：getAdvicesAndAdvisorsForBean方法内部主要包含以下这些逻辑（有兴趣自己debug查看具体判断逻辑实现，这里不再贴图，只做总结）：获取所有的通知方法（切面里定义的各个方法）；通过切点表达式判断这些通知方法是否可为当前Bean所用；如果有符合的通知方法，则对它们进行排序（排序规则不同版本Spring有所不同，上面已经提及过）。在前面的AOP例子中，切面MyAspect里的通知方法就是为了增强TargetClass所设的（根据切点表达式），所以getAdvicesAndAdvisorsForBean方法返回值如下所示：这些通知方法就是我们在MyAspect切面里定义的通知方法：如果该Bean的通知方法集合不为空的话，则创建该Bean的代理对象，具体查看createProxy方法源码：继续跟踪proxyFactory.getProxy(getProxyClassLoader())源码：Spring会判断当前使用哪种代理对象（一般来说当Bean有实现接口时，使用JDK动态代理，当Bean没有实现接口时，使用cglib代理，在Boot中，我们可以通过spring.aop.proxy-target-class=true配置来强制使用cglib代理）。通过Bean初始化后置代理方法postProcessBeforeInstantiation处理后，TargetClass被包装为了cglib代理的增强Bean，注册到IOC容器中：后续从IOC容器中获得的TargetClass就是被代理后的对象，执行代理对象的目标方法的时候，代理对象会执行相应的通知方法链，下面接着分析。生成拦截器链MethodInterceptorAOP代理对象生成后，我们接着关注代理对象的目标方法执行时，通知方法是怎么被执行的。先将前面打的断点都去掉，然后在SpringBoot的入口类AopApplication的如下位置打个断点：以debug方式启动程序：可以看到获取到的TargetClass Bean就是前面cglib代理后的Bean（TargetClass$$EnhanceBySpringCGLIB）：点击Step Into进入test方法内部调用逻辑，会发现程序跳转到了CglibAopProxy的intercept方法中，也就是说我们的目标对象的目标方法被CglibAopProxy的intercept方法拦截了，该拦截方法主要逻辑如下：这里先重点关注下getInterceptorsAndDynamicInterceptionAdvice方法，其源码如下所示：图中错别字纠正：提供-&gt;提高，懒得再次截图注释了😢所谓的拦截器链，就是在代理对象的某个方法被执行时，从通知方法集合（创建代理对象的时候就已经将可用通知集合保存在代理对象中了）中筛选出适用于该方法的通知，然后封装为拦截器对象集合（类型为MethodInteceptor，下面会介绍到）。继续查看this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice源码：通过debug我们可以看到，当前代理对象的test方法的拦截器链不为空，并且元素个数为5：拦截器链第一个元素类型为ExposeInvocationInterceptor，是默认的拦截器，后面会介绍到它的作用。剩下四个依次为：MethodBeforeAdviceInterceptor、AspectJAfterAdvice、AfterReturningAdviceInterceptor和AspectJAfterThrowingAdvice，它们都是MethodInterceptor的实现类：链式调用通知方法获取到了代理对象目标方法的拦截器链后，我们最后来关注这些拦截器是如何链式调用通知方法的。获取拦截器链并且拦截器链不为空时，CglibAopProxy的intercept方法创建CglibMethodInvocation对象，并调用它的proceed方法：查看CglibMethodInvocation源码：查看CglibMethodInvocation父类ReflectiveMethodInvocation proceed方法源码：清除掉之前打的断点，在该方法上第一行打个端点，重新以debug方式启动Boot应用：程序第一次进该方法时currentInterceptorIndex值为-1，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第一个拦截器ExposeInvocationInterceptor，方法最后调用该拦截器的invoke方法，Step Into进入该方法：mi就是我们传入的ReflectiveMethodInvocation对象，程序执行到mi.proceed方法时，Step Into进入该方法：可以看到，此时程序第二次执行ReflectiveMethodInvocation的poceed方法，currentInterceptorIndex值为0，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第二个拦截器MethodBeforeAdviceInterceptor，方法最后调用该拦截器的invoke方法，Step Into进入该方法：可以看到MethodBeforeAdviceInterceptor的invoke方法第一行调用了通知方法before，此时控制台打印内容为：1onBefore：test方法开始执行，参数：[hello]接着又通过mi.proceed再次调用ReflectiveMethodInvocation的poceed方法，Step Into进入该方法：此时程序第三次执行ReflectiveMethodInvocation的poceed方法，currentInterceptorIndex值为1，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第三个拦截器AspectJAfterAdvice，方法最后调用该拦截器的invoke方法，Step Into进入该方法：可以看到AspectJAfterAdvice的invoke方法内通过mi.proceed再次调用ReflectiveMethodInvocation的poceed方法，Step Into进入该方法：此时程序第四次执行ReflectiveMethodInvocation的poceed方法，currentInterceptorIndex值为2，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第四个拦截器AfterReturningAdviceInterceptor，方法最后调用该拦截器的invoke方法，Step Into进入该方法：可以看到AfterReturningAdviceInterceptor的invoke方法内通过mi.proceed再次调用ReflectiveMethodInvocation的poceed方法，Step Into进入该方法：此时程序第五次执行ReflectiveMethodInvocation的poceed方法，currentInterceptorIndex值为3，this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)取出拦截器链第五个拦截器AspectJAfterThrowingAdvice，方法最后调用该拦截器的invoke方法，Step Into进入该方法：可以看到AspectJAfterThrowingAdvice的invoke方法内通过mi.proceed再次调用ReflectiveMethodInvocation的poceed方法，Step Into进入该方法：此时程序第六次执行ReflectiveMethodInvocation的poceed方法，currentInterceptorIndex值为4，而拦截器链的长度为5，4==5-1成立，所以执行invokeJoinpoint()方法，该方法内部通过反射调用了目标方法（这里为TargetClass的test方法），执行后，控制台打印内容如下：12onBefore：test方法开始执行，参数：[hello]目标方法test被执行随着invokeJoinpoint()方法执行结束返回出栈，程序回到AspectJAfterThrowingAdvice的invoke方法：就这个例子来说，目标方法test并没有抛出异常，所以AspectJAfterThrowingAdvice的invoke方法执行结束出栈，程序回到AfterReturningAdviceInteceptor的invoke方法：this.advice.afterReturning执行afterReturning通知方法，控制台打印内容如下：123onBefore：test方法开始执行，参数：[hello]目标方法test被执行afterReturning：test方法执行结束返回，参数：[hello]，返回值：helloAfterReturningAdviceInteceptor的invoke方法执行结束出栈，程序回到AspectJAfterAdvice的invoke方法：AspectJAfterAdvice的invoke方法最终执行finally after逻辑，控制台打印内容如下：1234onBefore：test方法开始执行，参数：[hello]目标方法test被执行afterReturning：test方法执行结束返回，参数：[hello]，返回值：helloonAfter：test方法执行结束，参数：[hello]AspectJAfterAdvice的invoke方法执行结束出栈，程序回到MethodBeforeAdviceInterceptor的invoke方法：MethodBeforeAdviceInterceptor的invoke方法正常执行结束，出栈，程序回到ExposeInvocationInterceptor的invoke方法：ExposeInvocationInterceptor的invoke方法执行结束出栈，程序回到CglibAopProxy的intercept方法：CglibAopProxy的intercept方法执行结束出栈后，整个AOP的拦截器链调用也随之结束了：我们已经成功在目标方法的各个执行时期织入了通知方法。上述过程伴随着不断的入栈出栈操作，不懂您看懂没🤨。下面用一张图总结拦截器链调用过程：尚硅谷AOP源码解析学习笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解BeanFactoryPostProcessor & BeanDefinitionRegistryPostProcessor]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BeanFactoryPostProcessor-BeanDefinitionRegistryPostProcessor.html</url>
    <content type="text"><![CDATA[本节主要记录BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor的方法执行时机以及简单原理分析。BeanFactoryPostProcessor查看BeanFactoryPostProcessor源码：根据注释我们了解到postProcessBeanFactory方法的执行时机为：BeanFactory标准初始化之后，所有的Bean定义已经被加载，但Bean的实例还没被创建（不包括BeanFactoryPostProcessor类型）。该方法通常用于修改bean的定义，Bean的属性值等，甚至可以在此快速初始化Bean。下面测试一波。新建SpringBoot项目，Boot版本2.4.0，依赖如下：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;然后新建MyBeanFactoryPostProcessor，实现BeanFactoryPostProcessor接口：12345678910111213141516171819202122@Componentpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; private static final Logger logger = LoggerFactory.getLogger(MyBeanFactoryPostProcessor.class); public MyBeanFactoryPostProcessor() &#123; logger.info("实例化MyBeanFactoryPostProcessor Bean"); &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; int beanDefinitionCount = beanFactory.getBeanDefinitionCount(); logger.info("Bean定义个数: " + beanDefinitionCount); &#125; @Component static class TestBean &#123; public TestBean() &#123; logger.info("实例化TestBean"); &#125; &#125;&#125;在postProcessBeanFactory方法内，我们打印了当前已加载Bean定义的个数，并且在MyBeanFactoryPostProcessor类中，注册了TestBean。MyBeanFactoryPostProcessor和TestBean的构造函数输出的日志用于观察Bean实例化时机。启动程序，输出如下：上面的日志证实了方法的执行时机的确是在BeanFactory标准初始化之后，所有的Bean定义已经被加载，但Bean的实例还没被创建（此时TestBean还未被实例化，日志还没有输出”实例化TestBean”，但这不包括BeanFactoryPostProcessor类型Bean，该方法执行之前，日志就已经输出了”实例化MyBeanFactoryPostProcessor Bean”）。我们在postProcessBeanFactory方法上打个断点：以debug方式启动程序：通过追踪方法调用栈，我们可以总结出BeanFactoryPostProcessor的postProcessBeanFactory方法执行时机和原理：SpringApplication.run(MyApplication.class, args)启动Boot程序：run方法内部调用refreshContext方法刷新上下文：refresh方法内部调用invokeBeanFactoryPostProcessors方法：PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法内部：BeanDefinitionRegistryPostProcessorBeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，新增了一个postProcessBeanDefinitionRegistry方法：通过注释我们了解到postProcessBeanDefinitionRegistry方法的执行时机为：所有的Bean定义即将被加载，但Bean的实例还没被创建时。也就是说，BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法执行时机先于BeanFactoryPostProcessor的postProcessBeanFactory方法。这个方法通常用于给IOC容器添加额外的组件。举个例子测试一波。新建BeanDefinitionRegistryPostProcessor的实现类MyBeanDefinitionRegistryPostProcessor：12345678910111213141516171819@Componentpublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123; private final Logger logger = LoggerFactory.getLogger(MyBeanDefinitionRegistryPostProcessor.class); @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; int beanDefinitionCount = registry.getBeanDefinitionCount(); logger.info("Bean定义个数: " + beanDefinitionCount); // 添加一个新的Bean定义 RootBeanDefinition definition = new RootBeanDefinition(Object.class); registry.registerBeanDefinition("hello", definition); &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; &#125;&#125;启动程序，输出如下：可以看到，BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法执行时机的确先于BeanFactoryPostProcessor的postProcessBeanFactory方法。通过查看PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法源码也可以证实这一点：]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Spring BeanPostProcessor & InstantiationAwareBeanPostProcessor]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring-BeanPostProcessor-InstantiationAwareBeanPostProcessor.html</url>
    <content type="text"><![CDATA[在深入学习Spring Bean生命周期一节中，我们学习了Bean后置处理器BeanPostProcessor，用于在Bean初始化前后插入我们自己的逻辑（Bean增强，Bean代理等）。今天偶然接触到BeanPostProcessor的子类InstantiationAwareBeanPostProcessor，用于Bean实例化前后处理。本节记录两者的区别以及简单原理分析。两者比较Initialization为初始化的意思，Instantiation为实例化的意思。在Spring Bean生命周期中，实例化指的是创建Bean的过程，初始化指的是Bean创建后，对其属性进行赋值（populate bean）、后置处理等操作的过程，所以Instantiation执行时机先于Initialization。类关系先来看看BeanPostProcessor的类结构：InstantiationAwareBeanPostProcessor为BeanPostProcessor的子类，新增了三个额外的方法：方法解析BeanPostProcessorpostProcessBeforeInitialization(Object bean, String beanName)：bean：Bean实例；beanName：Bean名称。方法将在Bean实例的afterPropertiesSet方法或者自定义的init方法被调用前调用，此时Bean属性已经被赋值。方法返回原始Bean实例或者包装后的Bean实例，如果返回null，则后续的后置处理方法不再被调用。postProcessAfterInitialization(Object bean, String beanName)：bean：Bean实例；beanName：Bean名称。方法将在Bean实例的afterPropertiesSet方法或者自定义的init方法被调用后调用，此时Bean属性已经被赋值。方法返回原始Bean实例或者包装后的Bean实例，如果返回null，则后续的后置处理方法不再被调用。InstantiationAwareBeanPostProcessorpostProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)：beanClass：待实例化的Bean类型；beanName：待实例化的Bean名称。方法作用为：在Bean实例化前调用该方法，返回值可以为代理后的Bean，以此代替Bean默认的实例化过程。返回值不为null时，后续只会调用BeanPostProcessor的 postProcessAfterInitialization方法，而不会调用别的后续后置处理方法（如postProcessAfterInitialization、postProcessBeforeInstantiation等方法）；返回值也可以为null，这时候Bean将按默认方式初始化。postProcessAfterInstantiation(Object bean, String beanName)：bean：实例化后的Bean，此时属性还没有被赋值；beanName：Bean名称。方法作用为：当Bean通过构造器或者工厂方法被实例化后，当属性还未被赋值前，该方法会被调用，一般用于自定义属性赋值。方法返回值为布尔类型，返回true时，表示Bean属性需要被赋值；返回false表示跳过Bean属性赋值，并且InstantiationAwareBeanPostProcessor的postProcessProperties方法不会被调用。执行时机对比为了验证实例化和初始化的先后顺序，我们新建一个SpringBoot项目，版本2.4.0，依赖如下所示：123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;Spring入口类名称为DemoApplication。新建MyBeanPostProcessor实现BeanPostProcessor接口：1234567891011121314151617181920@Componentpublic class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if ("demoApplication".equals(beanName)) &#123; System.out.println("post processor before " + beanName + " initialization"); &#125; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if ("demoApplication".equals(beanName)) &#123; System.out.println("post processor after " + beanName + " initialization"); &#125; return bean; &#125;&#125;因为对所有的Bean生效，所以为了方便观察输出，这里仅当Bean名称为demoApplication时才打印输出。接着新建MyBeanInstantiationPostProcessor实现InstantiationAwareBeanPostProcessor接口：123456789101112131415161718192021222324252627@Componentpublic class MyBeanInstantiationPostProcessor implements InstantiationAwareBeanPostProcessor &#123; @Override public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; if ("demoApplication".equals(beanName)) &#123; System.out.println("post process before " + beanName + " instantiation"); &#125; return null; &#125; @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; if ("demoApplication".equals(beanName)) &#123; System.out.println("post process after " + beanName + " instantiation"); &#125; return true; &#125; @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException &#123; if ("demoApplication".equals(beanName)) &#123; System.out.println("post process " + beanName + " properties"); &#125; return pvs; &#125;&#125;启动程序，输出如下所示：12345post process before demoApplication instantiationpost process after demoApplication instantiationpost process demoApplication propertiespost processor before demoApplication initializationpost processor after demoApplication initialization如果将MyBeanInstantiationPostProcessor的postProcessAfterInstantiation方法返回值改为false，程序输出如下：1234post process before demoApplication instantiationpost process after demoApplication instantiationpost processor before demoApplication initializationpost processor after demoApplication initialization原理解析postProcessAfterInitialization和InstantiationAwareBeanPostProcessor的方法都和Bean生命周期有关，要分析它们的实现原理自然要从Bean的创建过程入手。Bean创建的入口为AbstractAutowireCapableBeanFactory的createBean方法，查看其源码：resolveBeforeInstantiation方法源码如下所示：上面方法返回的bean如果为空的话，AbstractAutowireCapableBeanFactory的createBean方法将继续往下执行doCreateBean方法：查看doCreateBean方法源码：其他部分和本节讨论内容关系不大（Bean生命周期其他部分），重点关注populateBean和initializeBean方法。查看populateBean方法源码：接着查看initializeBean方法源码：至此我们通过查看Bean生命周期相关源码弄清楚了BeanPostProcessor和InstantiationAwareBeanPostProcessor相关方法的执行时机以及原理。上面源码的追踪其实不仅涉及到了BeanPostProcessor和InstantiationAwareBeanPostProcessor相关方法的执行时机以及原理，更是整个Bean生命周期创建过程，结合Spring-Bean生命周期这篇文章的流程再走一遍源码，你会对Bean的生命周期有更深的理解。总结下面通过一张流程图总结本文：]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring自带工具类使用学习]]></title>
    <url>%2FSpring%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[我们项目大多数都是基于Spring架构，Spring自身包含了许多实用的工具类，学习这些工具类的使用不仅能让我们达到事半功倍的效果，而且还能减少不必要的额外的工具类的引入。查看这些工具类的源码时发现它们都是abstract类型的，这是因为工具类的方法一般都是static静态方法，静态方法和类绑定，类加载后就能使用了，无需实例化（刚好abstract类不能直接实例化，并且可以定义非抽象方法），所以工具类定义为abstract类型再合适不过。本文print方法为System.out.println的封装：123private static void print(Object value) &#123; System.out.println(value);&#125;ClassUtilsorg.springframework.util.classUtils包含一些和java.lang.Class相关的实用方法。getDefaultClassLoaderClassLoader getDefaultClassLoader()获取当前线程上下文的类加载器：1print(ClassUtils.getDefaultClassLoader());1sun.misc.Launcher$AppClassLoader@18b4aac2overrideThreadContextClassLoaderClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse)用特定的类加载器覆盖当前线程上下文的类加载器：123print(ClassUtils.getDefaultClassLoader());ClassUtils.overrideThreadContextClassLoader(ClassLoader.getSystemClassLoader().getParent());print(ClassUtils.getDefaultClassLoader());12sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@3feba861forNameforName(String name, @Nullable ClassLoader classLoader)通过类名返回类实例，类似于Class.forName()，但功能更强，可以用于原始类型，内部类等：1234ClassLoader classLoader = ClassUtils.getDefaultClassLoader();print(ClassUtils.forName("int", classLoader));print(ClassUtils.forName("java.lang.String[]", classLoader));print(ClassUtils.forName("java.lang.Thread$State", classLoader));123intclass [Ljava.lang.String;class java.lang.Thread$StateisPresentboolean isPresent(String className, @Nullable ClassLoader classLoader)判断当前classLoader是否包含目标类型（包括它的所有父类和接口）：123ClassLoader classLoader = ClassUtils.getDefaultClassLoader();print(ClassUtils.isPresent("int", classLoader));print(ClassUtils.isPresent("intt", classLoader));12truefalseresolvePrimitiveClassNameClass&lt;?&gt; resolvePrimitiveClassName(@Nullable String name)通过给定类名获取原始类：12print(ClassUtils.resolvePrimitiveClassName("int"));print(ClassUtils.resolvePrimitiveClassName("java.lang.Integer"));12intnullisPrimitiveWrapperboolean isPrimitiveWrapper(Class&lt;?&gt; clazz)判断给定类是否为包装类，如Boolean, Byte, Character, Short, Integer, Long, Float, Double 或者 Void：1234print(ClassUtils.isPrimitiveWrapper(Integer.class));print(ClassUtils.isPrimitiveWrapper(Character.class));print(ClassUtils.isPrimitiveWrapper(Void.class));print(ClassUtils.isPrimitiveWrapper(String.class));1234truetruetruefalse类似的方法还有isPrimitiveOrWrapper判断是否为原始类或者包装类、isPrimitiveWrapperArray判断是否为包装类数组、isPrimitiveArray判断是否为原始类数组。resolvePrimitiveIfNecessaryClass&lt;?&gt; resolvePrimitiveIfNecessary(Class&lt;?&gt; clazz)如果给定类是原始类，则返回对应包装类，否则直接返回给定类：12print(ClassUtils.resolvePrimitiveIfNecessary(int.class));print(ClassUtils.resolvePrimitiveIfNecessary(Object.class));12class java.lang.Integerclass java.lang.ObjectisAssignableboolean isAssignable(Class&lt;?&gt; lhsType, Class&lt;?&gt; rhsType)通过反射检查，是否可以将rhsType赋值给lhsType（注意，包装类型可以赋值给相应的原始类型，自动拆装箱机制）：12345print(ClassUtils.isAssignable(Integer.class, int.class));print(ClassUtils.isAssignable(Object.class, String.class));print(ClassUtils.isAssignable(BeanPostProcessor.class, InstantiationAwareBeanPostProcessor.class));print(ClassUtils.isAssignable(double.class, Double.class)); // consider thisprint(ClassUtils.isAssignable(Integer.class, Long.class));12345truetruetruetruefalseisAssignableValueboolean isAssignableValue(Class&lt;?&gt; type, @Nullable Object value)判断给定的值是否符合给定的类型：12345print(ClassUtils.isAssignableValue(Integer.class, 1));print(ClassUtils.isAssignableValue(Integer.class, 1L));print(ClassUtils.isAssignableValue(int.class, Integer.valueOf(1)));print(ClassUtils.isAssignableValue(Object.class,1));print(ClassUtils.isAssignableValue(String.class,1));12345truefalsetruetruefalseconvertResourcePathToClassNameString convertResourcePathToClassName(String resourcePath)将类路径转换为全限定类名：1print(ClassUtils.convertResourcePathToClassName("java/lang/String"));1java.lang.String实际上就是将/替换为.。convertClassNameToResourcePath方法功能相反。classNamesToStringString classNamesToString(Class&lt;?&gt;... classes)直接看演示不解释：1print(ClassUtils.classNamesToString(String.class, Integer.class, BeanPostProcessor.class));1[java.lang.String, java.lang.Integer, org.springframework.beans.factory.config.BeanPostProcessor]getAllInterfacesClass&lt;?&gt;[] getAllInterfaces(Object instance)返回给定实例对象所实现接口类型集合：123AutowiredAnnotationBeanPostProcessor processor = new AutowiredAnnotationBeanPostProcessor();Class&lt;?&gt;[] allInterfaces = ClassUtils.getAllInterfaces(processor);Arrays.stream(allInterfaces).forEach(System.out::println);1234interface org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessorinterface org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessorinterface org.springframework.core.PriorityOrderedinterface org.springframework.beans.factory.BeanFactoryAware类似的方法还有getAllInterfacesForClass、getAllInterfacesAsSet、getAllInterfacesForClassAsSetdetermineCommonAncestorClass&lt;?&gt; determineCommonAncestor(@Nullable Class&lt;?&gt; clazz1, @Nullable Class&lt;?&gt; clazz2)寻找给定类型的共同祖先（所谓共同祖先指的是给定类型调用class.getSuperclass获得的共同类型，如果给定类型是Object.class，接口，原始类型或者Void，直接返回null）：1234// 它两都是接口print(ClassUtils.determineCommonAncestor(AutowireCapableBeanFactory.class, ListableBeanFactory.class));print(ClassUtils.determineCommonAncestor(Long.class, Integer.class));print(ClassUtils.determineCommonAncestor(String.class, Integer.class));123nullclass java.lang.NumbernullisInnerClassboolean isInnerClass(Class&lt;?&gt; clazz)判断给定类型是否为内部类（非静态）：123456class A &#123; class B &#123; &#125;&#125;print(ClassUtils.isInnerClass(A.B.class)); // true123456static class A &#123; class B &#123; &#125;&#125;print(ClassUtils.isInnerClass(A.B.class)); // true123456static class A &#123; static class B &#123; &#125;&#125;print(ClassUtils.isInnerClass(A.B.class)); // falseisCglibProxyboolean isCglibProxy(Object object)是否为Cglib代理对象：1234567891011121314@SpringBootApplicationpublic class AopApplication &#123; @Configuration static class MyConfigure &#123; &#125; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(AopApplication.class, args); MyConfigure myConfigure = context.getBean(MyConfigure.class); System.out.println(ClassUtils.isCglibProxy(myConfigure)); &#125;&#125;1true配置类不由Cglib代理的话，返回为false：1234567891011121314@SpringBootApplicationpublic class AopApplication &#123; @Configuration(proxyBeanMethods = false) // 注意这里 static class MyConfigure &#123; &#125; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(AopApplication.class, args); MyConfigure myConfigure = context.getBean(MyConfigure.class); System.out.println(ClassUtils.isCglibProxy(myConfigure)); &#125;&#125;1false不过这个方法废弃了，建议使用org.springframework.aop.support.AopUtils.isCglibProxy(Object)方法。getUserClassClass&lt;?&gt; getUserClass(Object instance)返回给定实例对应的类型，如果实例是Cglib代理后的对象，则返回代理的目标对象类型：1print(ClassUtils.getUserClass("Hello")); // class java.lang.StringCglib代理例子：12345678910111213141516@SpringBootApplicationpublic class AopApplication &#123; @Configuration static class MyConfigure &#123; &#125; public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(AopApplication.class, args); MyConfigure myConfigure = context.getBean(MyConfigure.class); // 注意它们的区别 System.out.println(myConfigure.getClass()); System.out.println(ClassUtils.getUserClass(myConfigure)); &#125;&#125;12class cc.mrbird.aop.AopApplication$MyConfigure$$EnhancerBySpringCGLIB$$e51ce45class cc.mrbird.aop.AopApplication$MyConfigurematchesTypeNameboolean matchesTypeName(Class&lt;?&gt; clazz, @Nullable String typeName)判断给定class和类型名称是否匹配：1print(ClassUtils.matchesTypeName(String.class, "java.lang.String")); // truegetShortNameString getShortName(Class&lt;?&gt; clazz)返回类名：1print(ClassUtils.getShortName(String.class)); // StringgetShortNameAsPropertyString getShortNameAsProperty(Class&lt;?&gt; clazz)返回首字母小写的类名，如果是内部类的话，则去掉外部类名：1print(ClassUtils.getShortNameAsProperty(String.class)); // string12345class A &#123; class B &#123; &#125;&#125;print(ClassUtils.getShortNameAsProperty(String.class)); // bgetClassFileNameString getClassFileName(Class&lt;?&gt; clazz)返回类名+.class：1print(ClassUtils.getShortNameAsProperty(String.class)); // String.classgetPackageNameString getPackageName(Class&lt;?&gt; clazz)返回包名：1print(ClassUtils.getShortNameAsProperty(String.class)); // java.langgetQualifiedNameString getQualifiedName(Class&lt;?&gt; clazz)返回全限定类名，如果是数组类型则末尾加[]：12print(ClassUtils.getQualifiedName(String.class));print(ClassUtils.getQualifiedName(String[].class));12java.lang.Stringjava.lang.String[]getQualifiedMethodNameString getQualifiedMethodName(Method method)获取方法的全限定名：123print(ClassUtils.getQualifiedMethodName( ClassUtils.class.getDeclaredMethod("getQualifiedMethodName", Method.class )));1org.springframework.util.ClassUtils.getQualifiedMethodNamehasConstructorboolean hasConstructor(Class&lt;?&gt; clazz, Class&lt;?&gt;... paramTypes)判断给定类型是否有给定类型参数构造器：12print(ClassUtils.hasConstructor(String.class, String.class));print(ClassUtils.hasConstructor(String.class, Object.class));12truefalsegetConstructorIfAvailable&lt;T&gt; Constructor&lt;T&gt; getConstructorIfAvailable(Class&lt;T&gt; clazz, Class&lt;?&gt;... paramTypes)返回给定类型的给定参数类型构造器，没有的话返回null：123Constructor&lt;String&gt; constructorIfAvailable = ClassUtils.getConstructorIfAvailable(String.class, String.class);print(constructorIfAvailable != null);print(constructorIfAvailable.toString());12truepublic java.lang.String(java.lang.String)hasMethodboolean hasMethod(Class&lt;?&gt; clazz, Method method)判断给定类型是否有指定的方法：12Method hasMethod = ClassUtils.class.getDeclaredMethod("hasMethod", Class.class, Method.class);print(ClassUtils.hasMethod(ClassUtils.class, hasMethod)); // true重载方法boolean hasMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes)。getMethodMethod getMethod(Class&lt;?&gt; clazz, String methodName, @Nullable Class&lt;?&gt;... paramTypes)从指定类型中找指定方法，没找到抛IllegalStateException异常：1ClassUtils.getMethod(ClassUtils.class,"hello", String.class);1java.lang.IllegalStateException: Expected method not found: java.lang.NoSuchMethodException: org.springframework.util.ClassUtils.hello(java.lang.String)如果希望没找到返回null，而非抛异常，可以用getMethodIfAvailable方法。getMethodCountForNameint getMethodCountForName(Class&lt;?&gt; clazz, String methodName)从指定类型中通过方法名称查找该方法个数（重写、重载、非public的都算）：1print(ClassUtils.getMethodCountForName(ClassUtils.class,"hasMethod")); // 2类似的方法还有hasAtLeastOneMethodWithName，至少得有一个。getStaticMethodMethod getStaticMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... args)获取给定类型的静态方法，如果该方法不是静态的或者没有这个方法，则返回null：123Method method = ClassUtils.getStaticMethod(ClassUtils.class, "getDefaultClassLoader");print(method != null);print(method.getReturnType());12trueclass java.lang.ClassLoaderFileSystemUtils文件系统实用工具类deleteRecursivelyboolean deleteRecursively(@Nullable File root)递归删除指定文件或目录，删除成功返回true，失败返回false，不会抛出异常。新建一个多层级目录：实用File的delete目录尝试删除a目录：12File file = new File("a");print(file.delete()); // false因为a目录包含子目录（文件），所以应该使用递归删除：12File file = new File("a");print(FileSystemUtils.deleteRecursively(file)); // true重载方法boolean deleteRecursively(@Nullable Path root)和该方法功能相似，但该方法可能会抛出IO异常。copyRecursivelyvoid copyRecursively(File src, File dest)递归复制src文件到dest（目标路径不存在则自动创建）：新建一个多层级目录：123File src = new File("a");File dest = new File("aa");FileSystemUtils.copyRecursively(src, dest);重载方法void copyRecursively(Path src, Path dest)。StreamUtils包含一些文件流的实用方法默认的缓冲区大小为4096bytes。注意：该工具类的所有方法都不会对流进行关闭处理！未完待续，慢慢记录😴]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 数字签名算法]]></title>
    <url>%2FJava-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[数字签名算法可以看成是带秘钥的消息摘要算法，用于验证数据完整性、认证数据来源，并起到抗否认的作用。遵循私钥加签，公钥验签的规则，数字签名算法是非对称加密算法和消息摘要算法的结合体。数字签名算法主要包括RSA和DSA。这节记录下这两种算法在JDK8下的实现。数字签名加签验签流程分为以下几步：A在本地构建秘钥对，并将公钥发布给B；A使用私钥对数据进行签名；A发送签名和数据给B；B使用公钥对签名和数据进行验签。RSARSA数字签名算法主要分为MD系列和SHA系列两大类。MD系列主要包括MD2withRSA和MD5withRSA共2种数字签名算法；SHA系列主要包括SHA1withRSA、SHA224withRSA、SHA256withRSA、SHA384withRSA和SHA512withRSA共5种数字签名算法。代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.junit.Test;import java.security.*;import java.util.Base64;public class RsaSignatureDemo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; // 非对称加密算法 String algorithm = "RSA"; // 签名算法，RSA+SHA String signAlgorithm = "SHA256withRSA"; // ----- 公私钥生成 -------- // 实例化秘钥对生成器 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm); // 初始化，秘钥长度512~16384位，64倍数 keyPairGenerator.initialize(512); // 生成秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); // 公钥 PublicKey publicKey = keyPair.getPublic(); System.out.println("RSA公钥: " + Base64.getEncoder().encodeToString(publicKey.getEncoded())); // 私钥 PrivateKey privateKey = keyPair.getPrivate(); System.out.println("RSA私钥: " + Base64.getEncoder().encodeToString(privateKey.getEncoded())); // ----- 私钥加签 --------- // 获取签名对象 Signature signature = Signature.getInstance(signAlgorithm); signature.initSign(privateKey); signature.update(value.getBytes()); byte[] sign = signature.sign(); System.out.println("签名值: " + Base64.getEncoder().encodeToString(sign)); // ----- 公钥验签 --------- signature.initVerify(publicKey); signature.update(value.getBytes()); System.out.println("验签结果: " + signature.verify(sign)); &#125;&#125;秘钥对生成过程和上篇RSA介绍的无异，主要关注加签和验签操作即可，程序输出如下：1234RSA公钥: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKTTlw+zyhGzmTmhT5w9vEP1ejOcVfM2rHbz8jUae7InAh42R9ZaYUk1c3q0uqmTv8xKOnszU/vrdV52zoFM+OMCAwEAAQ==RSA私钥: MIIBUwIBADANBgkqhkiG9w0BAQEFAASCAT0wggE5AgEAAkEApNOXD7PKEbOZOaFPnD28Q/V6M5xV8zasdvPyNRp7sicCHjZH1lphSTVzerS6qZO/zEo6ezNT++t1XnbOgUz44wIDAQABAkBsZQXz+p2J1J2Qq8fqDSNxYc8Sf956SttSgw0m5Rqxxiw10cgHt67uocu3qK6UeMuJuaOiN3YT48kvFp6Joc75AiEA4L7R1zDWcOdWf2BE/k3yxJ4Uv0vbIZ9vWLuJGBR3xK0CIQC7v5f2fcedBWbJ/kR7CvbFE91ivM55dvWZMe/JrjXVzwIgFUn+FqRJq+g+CVLVNkGr/XP8AyLsXwL7SSx6kA1gSwECIHysAn4VEftr/dC+Pr0yD6HYyhbp53XzD6214lQbkfYzAiB1b2wNi0Y3N+D/OIrGUHlwgA0vkX82NP3V8qMDmRbCTQ==签名值: HVN5WkhND0hy/xY43h8r3+AVt6oxMSv1Ug/Y+bv1tGxw4ePQtIgzFwK0lQQbhIlwts2d2STwQBews4dXCfEMmA==验签结果: true需要注意的是不同签名算法需要的秘钥长度最小值不同，大伙可以自己试试。DSADSA算法与RSA算法都是数字证书中不可或缺的两种算法。两者不同的是，DSA算法仅包含数字签名算法，使用DSA算法的数字证书无法进行加密通信，而RSA算法既包含加密/解密算法，同时兼有数字签名算法。JDK8支持SHA1withDSA、SHA224withDSA、SHA256withDSA、SHA384withDSA和SHA512withDSA这五种DSA数字签名算法。代码示例（只需将上面的例子算法替换下就好，并且注意秘钥的长度范围）：1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.junit.Test;import java.security.*;import java.util.Base64;public class RsaSignatureDemo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; // 非对称加密算法 String algorithm = "DSA"; // 签名算法，DSA+SHA String signAlgorithm = "SHA224withDSA"; // ----- 公私钥生成 -------- // 实例化秘钥对生成器 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm); // 初始化，秘钥长度512~1024位，64倍数 keyPairGenerator.initialize(1024); // 生成秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); // 公钥 PublicKey publicKey = keyPair.getPublic(); System.out.println("DSA公钥: " + Base64.getEncoder().encodeToString(publicKey.getEncoded())); // 私钥 PrivateKey privateKey = keyPair.getPrivate(); System.out.println("DSA私钥: " + Base64.getEncoder().encodeToString(privateKey.getEncoded())); // ----- 私钥加签 --------- // 获取签名对象 Signature signature = Signature.getInstance(signAlgorithm); signature.initSign(privateKey); signature.update(value.getBytes()); byte[] sign = signature.sign(); System.out.println("签名值: " + Base64.getEncoder().encodeToString(sign)); // ----- 公钥验签 --------- signature.initVerify(publicKey); signature.update(value.getBytes()); System.out.println("验签结果: " + signature.verify(sign)); &#125;&#125;运行结果如下：1234DSA公钥: MIIBtzCCASwGByqGSM44BAEwggEfAoGBAP1/U4EddRIpUt9KnC7s5Of2EbdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq/xfW6MPbLm1Vs14E7gB00b/JmYLdrmVClpJ+f6AR7ECLCT7up1/63xhv4O1fnxqimFQ8E+4P208UewwI1VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC/BYHPUCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN/C/ohNWLx+2J6ASQ7zKTxvqhRkImog9/hWuWfBpKLZl6Ae1UlZAFMO/7PSSoDgYQAAoGAcW0aiebAWi5M18Lu6QS/1OoHbtw2I7kyivwExbNAZpWR9I9sNIwE1T0a491t1oqRV1cdBHyd9jiJqFwfLG6k5QidasXTgGYSsSZqFBebP5nrF5q3RtkosoHeHVKDnShQf5b36NK53CpCRfLayk2e5inu7CCCo+a58piAMiF3c+k=DSA私钥: MIIBTAIBADCCASwGByqGSM44BAEwggEfAoGBAP1/U4EddRIpUt9KnC7s5Of2EbdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq/xfW6MPbLm1Vs14E7gB00b/JmYLdrmVClpJ+f6AR7ECLCT7up1/63xhv4O1fnxqimFQ8E+4P208UewwI1VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC/BYHPUCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN/C/ohNWLx+2J6ASQ7zKTxvqhRkImog9/hWuWfBpKLZl6Ae1UlZAFMO/7PSSoEFwIVAIv03r5wR+DolDC5bGFOqQ2vuHlo签名值: MCwCFBRba/HI5/tLt+exzpgvLoq5mAwaAhQvaVv4dbGFNtMpcI4ZeqjgAGeGyg==验签结果: true]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 非对称加密算法RSA]]></title>
    <url>%2FJava-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[非对称加密和对称加密算法相比，多了一把秘钥，为双秘钥模式，一个公开称为公钥，一个保密称为私钥。遵循公钥加密私钥解密，或者私钥加密公钥解密。非对称加密算法源于DH算法，后又有基于椭圆曲线加密算法的密钥交换算法ECDH，不过目前最为流行的非对称加密算法是RSA，本文简单记录下RSA的使用。RSA算法RSA算法是最为典型的非对称加密算法，该算法由美国麻省理工学院（MIT）的Ron Rivest、Adi Shamir和Leonard Adleman三位学者提出，并以这三位学者的姓氏开头字母命名，称为RSA算法。RSA算法的数据交换过程分为如下几步：A构建RSA秘钥对；A向B发布公钥；A用私钥加密数据发给B；B用公钥解密数据；B用公钥加密数据发给A；A用私钥解密数据。JDK8支持RSA算法：算法秘钥长度加密模式填充模式RSA512~16384位，64倍数ECBNoPaddingPKCS1PaddingOAEPWithMD5AndMGF1PaddingOAEPWithSHA1AndMGF1PaddingOAEPWithSHA-1AndMGF1PaddingOAEPWithSHA-224AndMGF1PaddingOAEPWithSHA-256AndMGF1PaddingOAEPWithSHA-384AndMGF1PaddingOAEPWithSHA-512AndMGF1Padding OAEPWithSHA-512/224AndMGF1PaddingOAEPWithSHA-512/2256ndMGF1Padding代码例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.junit.Test;import javax.crypto.Cipher;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; // 加密算法 String algorithm = "RSA"; // 转换模式 String transform = "RSA/ECB/PKCS1Padding"; // 实例化秘钥对生成器 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm); // 初始化，秘钥长度512~16384位，64倍数 keyPairGenerator.initialize(512); // 生成秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); // 公钥 PublicKey publicKey = keyPair.getPublic(); System.out.println("RSA公钥: " + Base64.getEncoder().encodeToString(publicKey.getEncoded())); // 私钥 PrivateKey privateKey = keyPair.getPrivate(); System.out.println("RSA私钥: " + Base64.getEncoder().encodeToString(privateKey.getEncoded())); // ------ 测试公钥加密，私钥解密 ------ Cipher cipher = Cipher.getInstance(transform); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] pubEncryptBytes = cipher.doFinal(value.getBytes()); System.out.println("RSA公钥加密后数据: " + Base64.getEncoder().encodeToString(pubEncryptBytes)); cipher.init(Cipher.DECRYPT_MODE, privateKey); byte[] priDecryptBytes = cipher.doFinal(pubEncryptBytes); System.out.println("RSA私钥解密后数据: " + new String(priDecryptBytes)); // ------ 测试私钥加密，公钥解密 ------ cipher.init(Cipher.ENCRYPT_MODE, privateKey); byte[] priEncryptBytes = cipher.doFinal(value.getBytes()); System.out.println("RSA私钥加密后数据: " + Base64.getEncoder().encodeToString(priEncryptBytes)); cipher.init(Cipher.DECRYPT_MODE, publicKey); byte[] pubDecryptBytes = cipher.doFinal(priEncryptBytes); System.out.println("RSA公钥解密后数据: " + new String(pubDecryptBytes)); &#125;&#125;程序输出如下：123456RSA公钥: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKBvz9cma+hXNiv2yXg6e1PyZhHVZm3bJXDvTJP2LyXo4vs9grH36Q9kNgr6quHtuU6fEoUxUu2zbEB8dkEWB9UCAwEAAQ==RSA私钥: MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAoG/P1yZr6Fc2K/bJeDp7U/JmEdVmbdslcO9Mk/YvJeji+z2CsffpD2Q2Cvqq4e25Tp8ShTFS7bNsQHx2QRYH1QIDAQABAkEAjemZXORdesz52/WVzEVepai6ZHfw/Kdl/PmPMSoIFmz7mk55rprl2Akn2V0odSiHSnMWvDmOUIAvHaHF4Re4wQIhAN5GxVeF7ndyoWasxqIOVb6baNkUrapBM0nacPS4WA8JAiEAuMcvNM2Z1rW74JagoGlSIfRkNUqa+3LTCN/fK7VR2W0CICs/+gYduVjkpSMlW0ENKQH9m1kh/Oiz5xbnujLj676BAiBVGif7wdXgtcLaJYXFW7ygNtcQVFQdCz13EOTQVKpl4QIgY2YyH3vUYI2J68qCGtYjj5iNHUEwwze+Za1R7y0V43k=RSA公钥加密后数据: O55w+9ve4QPcNDXNXF3W6O3J9UHxGBWlOM8W5RkKIslMR5xoUkBqIufWO2mz5MWezfxHB9yH1mPQgrv3H1hMKQ==RSA私钥解密后数据: mrbird&apos;s blogRSA私钥加密后数据: UtwtFxWstrg+fQV6WSw8PYY1YP5K9bjYH7uY20SQIJ5iWQ9FEERi8+ttk2MougQro66aiJRpdCeSpIVi09J+Ew==RSA公钥解密后数据: mrbird&apos;s blog可以看到，公钥加密私钥解密和私钥加密公钥解密的模式都可行。公私钥获取假如现在有RSA公钥：1MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKBvz9cma+hXNiv2yXg6e1PyZhHVZm3bJXDvTJP2LyXo4vs9grH36Q9kNgr6quHtuU6fEoUxUu2zbEB8dkEWB9UCAwEAAQ==RSA私钥：1MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAoG/P1yZr6Fc2K/bJeDp7U/JmEdVmbdslcO9Mk/YvJeji+z2CsffpD2Q2Cvqq4e25Tp8ShTFS7bNsQHx2QRYH1QIDAQABAkEAjemZXORdesz52/WVzEVepai6ZHfw/Kdl/PmPMSoIFmz7mk55rprl2Akn2V0odSiHSnMWvDmOUIAvHaHF4Re4wQIhAN5GxVeF7ndyoWasxqIOVb6baNkUrapBM0nacPS4WA8JAiEAuMcvNM2Z1rW74JagoGlSIfRkNUqa+3LTCN/fK7VR2W0CICs/+gYduVjkpSMlW0ENKQH9m1kh/Oiz5xbnujLj676BAiBVGif7wdXgtcLaJYXFW7ygNtcQVFQdCz13EOTQVKpl4QIgY2YyH3vUYI2J68qCGtYjj5iNHUEwwze+Za1R7y0V43k=需要将它们还原为PublicKey和PrivateKey对象，可以参考如下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.junit.Test;import javax.crypto.Cipher;import java.security.KeyFactory;import java.security.PrivateKey;import java.security.PublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; // 加密算法 String algorithm = "RSA"; // 转换模式 String transform = "RSA/ECB/PKCS1Padding"; // RSA公钥BASE64字符串 String rsaPublicKey = "MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKBvz9cma+hXNiv2yXg6e1PyZhHVZm3bJXDvTJP2LyXo4vs9grH36Q9kNgr6quHtuU6fEoUxUu2zbEB8dkEWB9UCAwEAAQ=="; // RSA私钥BASE64字符串 String rsaPrivateKey = "MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAoG/P1yZr6Fc2K/bJeDp7U/JmEdVmbdslcO9Mk/YvJeji+z2CsffpD2Q2Cvqq4e25Tp8ShTFS7bNsQHx2QRYH1QIDAQABAkEAjemZXORdesz52/WVzEVepai6ZHfw/Kdl/PmPMSoIFmz7mk55rprl2Akn2V0odSiHSnMWvDmOUIAvHaHF4Re4wQIhAN5GxVeF7ndyoWasxqIOVb6baNkUrapBM0nacPS4WA8JAiEAuMcvNM2Z1rW74JagoGlSIfRkNUqa+3LTCN/fK7VR2W0CICs/+gYduVjkpSMlW0ENKQH9m1kh/Oiz5xbnujLj676BAiBVGif7wdXgtcLaJYXFW7ygNtcQVFQdCz13EOTQVKpl4QIgY2YyH3vUYI2J68qCGtYjj5iNHUEwwze+Za1R7y0V43k="; // ------- 还原公钥 -------- byte[] publicKeyBytes = Base64.getDecoder().decode(rsaPublicKey); X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKeyBytes); KeyFactory keyFactory = KeyFactory.getInstance(algorithm); PublicKey publicKey = keyFactory.generatePublic(x509EncodedKeySpec); // ------- 还原私钥 -------- byte[] privateKeyBytes = Base64.getDecoder().decode(rsaPrivateKey); PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKeyBytes); PrivateKey privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec); // ------- 测试加解密 -------- Cipher cipher = Cipher.getInstance(transform); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] pubEncryptBytes = cipher.doFinal(value.getBytes()); System.out.println("RSA公钥加密数据: " + Base64.getEncoder().encodeToString(pubEncryptBytes)); cipher.init(Cipher.DECRYPT_MODE, privateKey); byte[] priDecryptBytes = cipher.doFinal(pubEncryptBytes); System.out.println("RSA私钥解密数据: " + new String(priDecryptBytes)); &#125;&#125;程序输出如下：12RSA公钥加密数据: PdSr+WRUWIxbA7stmZ03GCwDBnE3CyFL43bTskJmBilY+9lL63Jt0KxN0S2A4ombxvngbiB8PVZiqj1oSkgWpA==RSA私钥解密数据: mrbird&apos;s blog分段加解密RSA加解密中必须考虑到的密钥长度、明文长度和密文长度问题。明文长度需要小于密钥长度，而密文长度则等于密钥长度。因此当加密内容长度大于密钥长度时，有效的RSA加解密就需要对内容进行分段。这是因为，RSA算法本身要求加密内容也就是明文长度m必须满足0&lt;m&lt;密钥长度n。如果小于这个长度就需要进行padding，因为如果没有padding，就无法确定解密后内容的真实长度，字符串之类的内容问题还不大，以0作为结束符，但对二进制数据就很难，因为不确定后面的0是内容还是内容结束符。而只要用到padding，那么就要占用实际的明文长度，于是实际明文长度需要减去padding字节长度。我们一般使用的padding标准有NoPPadding、OAEPPadding、PKCS1Padding等，其中PKCS#1建议的padding就占用了11个字节。以秘钥长度为1024bits为例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.junit.Test;import javax.crypto.Cipher;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; StringBuilder value = new StringBuilder(); for (int i = 0; i &lt;= 29; i++) &#123; value.append("18cm"); &#125; System.out.println("待加密内容长度: " + value.toString().length()); // 加密算法 String algorithm = "RSA"; // 转换模式 String transform = "RSA/ECB/PKCS1Padding"; // 实例化秘钥对生成器 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm); // 初始化，秘钥长度512~16384位，64倍数 keyPairGenerator.initialize(1024); // 生成秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); // 公钥 PublicKey publicKey = keyPair.getPublic(); System.out.println("RSA公钥: " + Base64.getEncoder().encodeToString(publicKey.getEncoded())); // 私钥 PrivateKey privateKey = keyPair.getPrivate(); System.out.println("RSA私钥: " + Base64.getEncoder().encodeToString(privateKey.getEncoded())); // ------ 测试公钥加密，私钥解密 ------ Cipher cipher = Cipher.getInstance(transform); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] pubEncryptBytes = cipher.doFinal(value.toString().getBytes()); System.out.println("RSA公钥加密后数据: " + Base64.getEncoder().encodeToString(pubEncryptBytes)); cipher.init(Cipher.DECRYPT_MODE, privateKey); byte[] priDecryptBytes = cipher.doFinal(pubEncryptBytes); System.out.println("RSA私钥解密后数据: " + new String(priDecryptBytes)); // ------ 测试私钥加密，公钥解密 ------ cipher.init(Cipher.ENCRYPT_MODE, privateKey); byte[] priEncryptBytes = cipher.doFinal(value.toString().getBytes()); System.out.println("RSA私钥加密后数据: " + Base64.getEncoder().encodeToString(priEncryptBytes)); cipher.init(Cipher.DECRYPT_MODE, publicKey); byte[] pubDecryptBytes = cipher.doFinal(priEncryptBytes); System.out.println("RSA公钥解密后数据: " + new String(pubDecryptBytes)); &#125;&#125;程序会抛出如下异常：1234567891011121314151617181920212223242526272829303132待加密内容长度: 120RSA公钥: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC79DkQcppMMl11r21OMYcTlLWMJP9ZZw9BdszZPu+D1kHijbETrae84AwOrNPqrl8/vpPh2q9BLkrkfQuvSLQHk6tuefVEyWRnnnEwYJzIbjuQPhEwKU7khqjhNXdoW/27AN7kyQwFFnbLHfkc/lh6V6N6S2g5J2NmQL4hfqVgGwIDAQABRSA私钥: MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALv0ORBymkwyXXWvbU4xhxOUtYwk/1lnD0F2zNk+74PWQeKNsROtp7zgDA6s0+quXz++k+Har0EuSuR9C69ItAeTq2559UTJZGeecTBgnMhuO5A+ETApTuSGqOE1d2hb/bsA3uTJDAUWdssd+Rz+WHpXo3pLaDknY2ZAviF+pWAbAgMBAAECgYA2ksoC6ZO9rh4O7rnpK15SJCq2n4N5HQCD/I+sQKbg+9QziPqygQikQdWeaTY6/Rhw9NARkyKx5VQfleNPqOeEj1KwNK8pctD7nkb/PL/LZofH1uk1J0sgaSPpox2LUrIabWFs/dztbHpR/aiaQLbLfrdOgkGoQWM3FB8hMEsbSQJBAPhD/US0C6VQuMqLytuOsB7imqNttD8F6gGQAXAGz2YcgDHSHdayzhT1q12J0nrzfJGfZLZpc+4t9szS9Oh3VvcCQQDBzznlqTbaq7KaxAacdo6BRQszVMuy9kJXupINUUyw+wEaCiz4sxCJsa8ASfJBnxRGFEPyi9Hea6ijOwckDYL9AkEAkAPYqn8K9mYCHDTFg2GdVv06mS0tTxXeLfPccaDxtJk54Cyz9HSayVvNgaBOgdY2376nzI0VnAf7z8tcGHIJ9wJAcPwb5pU1U1mRL8RjjkdXYGkd1Hj0n4oMtxQfHQBuUyahR8ry2LGbTIp3WRXC0xqoOQqLahS07pOYpkA9M3llCQJBAN4oaSLXsSpZtnwekocGapsBaY62Kn9QIZGaGHJkmAwXBXEdXZfr/16BhUd4JSlfGgL3CvdP57OaWjl0CPZ0wxs=javax.crypto.IllegalBlockSizeException: Data must not be longer than 117 bytes at com.sun.crypto.provider.RSACipher.doFinal(RSACipher.java:344) at com.sun.crypto.provider.RSACipher.engineDoFinal(RSACipher.java:389) at javax.crypto.Cipher.doFinal(Cipher.java:2164) at cc.mrbird.security.temp.rsa.Demo.test(Demo.java:42) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)对于1024长度的密钥。128字节（1024bits/8）减去PKCS#1建议的padding就占用了11个字节正好是117字节。所以加密的明文长度120字节大于117字节，程序抛出了异常。要解决这个问题，可以采用分段加密的手段。编写一个分段加解密的工具类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import javax.crypto.Cipher;import java.io.ByteArrayOutputStream;import java.security.PrivateKey;import java.security.PublicKey;import java.util.Base64;/** * RSA分段加解密 * 针对秘钥长度为1024bits */public class RsaUtil &#123; // 最大加密块长度 1024/8 - 11 private static final int MAX_ENCRYPT_BLOCK = 117; // 最大解密块长度 1024/8 private static final int MAX_DECRYPT_BLOCK = 128; private static final String TRANSFORM = "RSA/ECB/PKCS1Padding"; /** * 公钥加密 * * @param publicKey 公钥 * @param value 待加密值 * @return 加密值 */ public static String encrypt(PublicKey publicKey, String value) &#123; try (ByteArrayOutputStream out = new ByteArrayOutputStream()) &#123; Cipher cipher = Cipher.getInstance(TRANSFORM); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] bytes = value.getBytes(); int length = bytes.length; int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (length - offSet &gt; 0) &#123; if (length - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(bytes, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(bytes, offSet, length - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); return Base64.getEncoder().encodeToString(encryptedData); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 私钥解密 * * @param privateKey 私钥 * @param encrypt 带解密值 * @return 解密值 */ public static String decrypt(PrivateKey privateKey, String encrypt) &#123; try (ByteArrayOutputStream out = new ByteArrayOutputStream()) &#123; Cipher cipher = Cipher.getInstance(TRANSFORM); cipher.init(Cipher.DECRYPT_MODE, privateKey); byte[] bytes = Base64.getDecoder().decode(encrypt); int length = bytes.length; int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (length - offSet &gt; 0) &#123; if (length - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(bytes, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(bytes, offSet, length - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); return new String(decryptedData); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;测试：123456789101112131415161718192021222324252627282930313233343536373839404142import org.junit.Test;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; StringBuilder value = new StringBuilder(); for (int i = 0; i &lt;= 29; i++) &#123; value.append("18cm"); &#125; System.out.println("待加密内容长度: " + value.toString().length()); // 加密算法 String algorithm = "RSA"; // 实例化秘钥对生成器 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm); // 初始化，秘钥长度512~16384位，64倍数 keyPairGenerator.initialize(1024); // 生成秘钥对 KeyPair keyPair = keyPairGenerator.generateKeyPair(); // 公钥 PublicKey publicKey = keyPair.getPublic(); System.out.println("RSA公钥: " + Base64.getEncoder().encodeToString(publicKey.getEncoded())); // 私钥 PrivateKey privateKey = keyPair.getPrivate(); System.out.println("RSA私钥: " + Base64.getEncoder().encodeToString(privateKey.getEncoded())); // ------ 测试公钥加密，私钥解密 ------ String pubEncrypt= RsaUtil.encrypt(publicKey, value.toString()); System.out.println("RSA公钥加密后数据: " + pubEncrypt); String priDecrypt = RsaUtil.decrypt(privateKey, pubEncrypt); System.out.println("RSA私钥解密后数据: " + priDecrypt); &#125;&#125;程序输出如下：12345待加密内容长度: 120RSA公钥: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCJcyiFAbUHBYXe5BTY/TF5Bn4/fW4L0dK2eaDSPJr4uqTFxIj+sRDqRq71yZw3KJk0qxmmGbtMRQGuR+GVAyJ/0E2R3q2RM+aWCZmkzyDnq6xHIvV0d3mU3N8EDtPS6iO+ANOEPNKfdzr+BJN8NKnpXC2ii7phvMk/QlYqjVAbIwIDAQABRSA私钥: MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIlzKIUBtQcFhd7kFNj9MXkGfj99bgvR0rZ5oNI8mvi6pMXEiP6xEOpGrvXJnDcomTSrGaYZu0xFAa5H4ZUDIn/QTZHerZEz5pYJmaTPIOerrEci9XR3eZTc3wQO09LqI74A04Q80p93Ov4Ek3w0qelcLaKLumG8yT9CViqNUBsjAgMBAAECgYEAhaU2UdVuGoyxNR9acf4GW6IHoV4pYU68bnbm+2S4Xn7EdhN6DQNH6jOeLRjCTxOnnAF95/Z/GlLCpp335nbs1B1wlb6MP5l3keO2KhYuvPhnZdPInNV0aKWzOoX7gcmy12g5IAQgoYoc/IohPIpMmkgrbuGQGk2+jxnGPETgNdECQQDhDyP3VIH5AucbHHeL6fSU9kswO1eejLzRmvlKIwk15wE1xteFvIqpLOLlR8wJm+Eb5uB0HEr4X7rlWDQLq/OZAkEAnFilYybZfp4rRctsnYjFZf0QGUCCBV9hFa7xoGztV2rAkLLmsnayXzSJpOYYAOI7ekrqfLL3xALQKn8DZtr6GwJAecd9iKl7oshFUVA4B8dShwA2cyTJJou06B5ZYhpPM5GKABVWLZF13lDhfXs6FsD4L+bf8TQWBQuXz93IW8BxkQJAZqfR2BuPHRMPiKE77Of77K5PnrT7ajmpDkqy/knnQMmoLJo63Z0QG3Dsm6g0xIfG09JSypPcGQhb1DtXaXaIVwJAVVSPa1caRWLKYlEKAi1gBbrC5Zt7aTQ/ska2E3ksAhaVhScPBOEIoQf9EdbGajmpuueWeH9IlVrqQv0vFNY4gA==RSA公钥加密后数据: cy7Var2L72bgne9F8iGro+SCQxs2ejIMPwQDJ5hQFTLvyqtT4ZJYM5i2ClgOD9viAP2Tp/X5cCX0+K1xz88hf5w/xNPWonzdaJNa2J5gQv7KGxNe/pW4mtpf878u4sIvO9sT8AktWtJC3jFtvxL9u9vJdzWl99RSRf/3sNqWj3gLRM/YpCcGM0HPuDsyUdOA4q+Tn+d2nOf36XrBtjIl2QyOTwnMoMCbC9Hlt6jN8fMsSFW8oiFNqV/+HPlhs5ZtFixhUE6SryketJfzXGmUSXH5cM/+11pB2bBxrCvtqRUE5/MZKjL2kKmrZan3kDHi4aiwLSDdpYdZn0urrJObAA==RSA私钥解密后数据: 18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm18cm建议公钥是通过A发送给B的，其在传递过程中很有可能被截获，也就是说窃听者很有可能获得公钥。如果窃听者获得了公钥，向A发送数据，A是无法辨别消息的真伪的。因此，虽然可以使用公钥对数据加密，但这种方式还是会有存在一定的安全隐患。如果要建立更安全的加密消息传递模型，就需要AB双方构建两套非对称加密算法密钥，仅遵循“私钥加密，公钥解密”的方式进行加密消息传递；RSA不适合加密过长的数据，虽然可以通过分段加密手段解决，但过长的数据加解密耗时较长，在响应速度要求较高的情况下慎用。一般推荐使用非对称加密算法传输对称加密秘钥，双方数据加密用对称加密算法加解密。]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 对称加密算法]]></title>
    <url>%2FJava-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[对称加密算法加密和解密使用的是同一份秘钥，解密是加密的逆运算。对称加密算法加密速度快，密文可逆，一旦秘钥文件泄露，就会导致原始数据暴露。对称加密的结果一般使用Base64算法编码，便于阅读和传输。JDK8支持的对称加密算法主要有DES、DESede、AES、Blowfish，以及RC2和RC4等。不同的算法秘钥长度不同，秘钥长度越长，加密安全性越高。DESDES（Data Encryption Standard，数据加密标准）算法是对称加密算法领域中的典型算法，DES算法秘钥较短，以现在计算机的计算能力，DES算法加密的数据在24小时内可能被破解。所以DES算法已经被淘汰，建议使用AES算法，不过这里还是简单了解下。JDK8仅支持56位长度的DES秘钥，下面举个JDK8实现DES加密的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "DES"; // 转换模式 String transformation = "DES"; // --- 生成秘钥 --- // 实例化秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 初始化秘钥长度 keyGenerator.init(56); // 生成秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 实例化DES秘钥材料 DESKeySpec desKeySpec = new DESKeySpec(secretKey.getEncoded()); // 实例化秘钥工厂 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm); // 生成DES秘钥 SecretKey desSecretKey = secretKeyFactory.generateSecret(desKeySpec); System.out.println("DES秘钥：" + Base64.getEncoder().encodeToString(desSecretKey.getEncoded())); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥 cipher.init(Cipher.ENCRYPT_MODE, desSecretKey); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("DES加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, desSecretKey); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("DES解密结果：" + new String(decrypt)); &#125;&#125;转换模式transformation这里先设置为和加密算法一样，下面介绍了加密模式和填充模式后再作说明。上面步骤看着挺多，其实可以总结为如下几步：生成加密秘钥；1.1. 通过KeyGenerator生成一个指定位数的秘钥；1.2. 通过上面生成的秘钥实例化算法对应的秘钥材料KeySpec；1.3. 使用秘钥材料通过秘钥工厂SecretKeyFactory生成算法秘钥SecretKey。通过转换模式实例化Cipher；指定Cipher模式和秘钥，进行加解密操作。运行结果如下：1234待加密值：mrbird&apos;s blogDES秘钥：LO/CCEC8y8E=DES加密结果：hRZdN6f+6yj/lhPWUPsayA==DES解密结果：mrbird&apos;s blog如果在生成秘钥的时候，不指定为56位，则会抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 56异常。DESede作为DES算法的一种改良，DESede算法（也成为3DES，三重DES）针对其秘钥长度偏短和迭代次数偏少等问题做了相应改进，提高了安全强度，但同时也造成处理速度较慢、秘钥计算时间加长、加密效率不高的问题。所以这里还是简单了解下，实际还是推荐用AES。JDK8支持112位或168位长度的DESede秘钥，下面举个JDK8实现DESede加密的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESedeKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "DESede"; // 转换模式 String transformation = "DESede"; // --- 生成秘钥 --- // 实例化秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 初始化秘钥长度 keyGenerator.init(112); // 生成秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 实例化DESede秘钥材料 DESedeKeySpec desKeySpec = new DESedeKeySpec(secretKey.getEncoded()); // 实例化秘钥工厂 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm); // 生成DES秘钥 SecretKey desSecretKey = secretKeyFactory.generateSecret(desKeySpec); System.out.println("DESede秘钥：" + Base64.getEncoder().encodeToString(desSecretKey.getEncoded())); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥 cipher.init(Cipher.ENCRYPT_MODE, desSecretKey); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("DESede加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, desSecretKey); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("DESede解密结果：" + new String(decrypt)); &#125;&#125;过程和DES一致，区别仅在于使用的加密算法为DESede，秘钥长度指定为112，秘钥材料对象为DESedeKeySpec类。上面程序输出如下：1234待加密值：mrbird&apos;s blogDESede秘钥：1fFb+F1wboVGGTSPNIBJ+9XxW/hdcG6FDESede加密结果：WVg9w6exyRREqY1vNyRI+Q==DESede解密结果：mrbird&apos;s blog如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 112 or 168异常。AESAES（AdvancedEncryption Standard，高级数据加密标准）算法支持128位、192位和256位的秘钥长度，加密速度比DES和DESede都快，至今还没有被破解的报道。经过验证，目前采用的AES算法能够有效抵御已知的针对DES算法的所有攻击方法，如部分差分攻击、相关秘钥攻击等。AES算法因秘钥建立时间短、灵敏性好、内存需求低等优点，在各个领域得到广泛的研究与应用。JDK8支持128位、192位和256位长度的AES秘钥，下面举个JDK8实现AES加密的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "AES"; // 转换模式 String transformation = "AES"; // --- 生成秘钥 --- // 实例化秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 初始化秘钥长度 keyGenerator.init(256); // 生成秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 生成秘钥材料 SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); System.out.println("AES秘钥：" + Base64.getEncoder().encodeToString(secretKey.getEncoded())); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥 cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("AES加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, secretKeySpec); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("AES解密结果：" + new String(decrypt)); &#125;&#125;过程和上面例子大体一致，唯一区别是使用AES算法无需指定特定类型的秘钥材料，直接用SecretKeySpec对象即可。程序输出如下：1234待加密值：mrbird&apos;s blogAES秘钥：vMj1fnhYdIGpTfxpEeKaynG879ARZ5r2AcfBpf+yoRs=AES加密结果：GCmIlqEJIBlBRw/474OanQ==AES解密结果：mrbird&apos;s blog如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Wrong keysize: must be equal to 128, 192 or 256异常。RC2、RC4RC2和RC4算法也可以用于替换DES算法，特点是秘钥长度较为灵活，RC2和RC4的秘钥长度范围为40到1024位。JDK8支持RC2和RC4算法：12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "RC2"; // 转换模式 String transformation = "RC2"; // --- 生成秘钥 --- // 实例化秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 初始化秘钥长度 keyGenerator.init(666); // 生成秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 生成秘钥材料 SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); System.out.println("RC2秘钥：" + Base64.getEncoder().encodeToString(secretKey.getEncoded())); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥 cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("RC2加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, secretKeySpec); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("RC2解密结果：" + new String(decrypt)); &#125;&#125;程序输出如下：1234待加密值：mrbird&apos;s blogRC2秘钥：//wHmkfa/TpQqeard5RD8h6Gdd1YJQZbFT4pUsssRfitpz1YkhJfCN/J/hjR0Q1HmVReJaSPCNDqP+GUBlvnWi7zsoKW35O6R5W/R0Bgnjh/qVsuRC2加密结果：+XL70sqXz/myi1JRiLVbCw==RC2解密结果：mrbird&apos;s blog如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Key length for RC2 must be between 40 and 1024 bits异常。RC4读者可以自己玩一玩。BlowfishBlowfish算法也可以用于替换DES，Blowfish算法的秘钥长度范围为32到448位，并且必须为8的倍数。JDK8支持Blowfish算法：12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "Blowfish"; // 转换模式 String transformation = "Blowfish"; // --- 生成秘钥 --- // 实例化秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 初始化秘钥长度 keyGenerator.init(128); // 生成秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 生成秘钥材料 SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); System.out.println("Blowfish秘钥：" + Base64.getEncoder().encodeToString(secretKey.getEncoded())); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥 cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("Blowfish加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, secretKeySpec); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("Blowfish解密结果：" + new String(decrypt)); &#125;&#125;程序运行结果：1234待加密值：mrbird&apos;s blogBlowfish秘钥：d3ReFylxI2OI7n3qgPFViQ==Blowfish加密结果：nnH2mqVZhhhegBwAuqecLw==Blowfish解密结果：mrbird&apos;s blog如果指定不合法的秘钥长度，程序将抛出java.security.InvalidParameterException: Keysize must be multiple of 8, and can only range from 32 to 448 (inclusive)异常。PBEPBE（Password Based Encryption，基于口令加密）算法是一种基于口令的加密算法，特点是没有秘钥的概念，信息交互双方事先拟定好口令即可。单纯的口令很容易通过穷举攻击方式破译，所以PBE也加入了“盐”的概念。PBE算法是对称加密算法的综合性算法，常见算法如PBEWithMD5AndDES，该算法使用了MD5和DES算法构建PBE算法。JDK8支持PBEWithMD5AndDES、PBEWithMD5AndTripleDES、PBEWithSHA1AndDESede、PBEWithSHA1AndRC2_40、PBEWithSHA1AndRC2_128、PBEWithSHA1AndRC4_40、PBEWithSHA1AndRC4_128、PBEWithHmacSHA1AndAES_128、PBEWithHmacSHA224AndAES_128、PBEWithHmacSHA256AndAES_128、PBEWithHmacSHA384AndAES_128、PBEWithHmacSHA512AndAES_128、PBEWithHmacSHA1AndAES_256、PBEWithHmacSHA224AndAES_256、PBEWithHmacSHA256AndAES_256、PBEWithHmacSHA384AndAES_256和PBEWithHmacSHA512AndAES_256，其中算法名称中包含Hmac的需要配和初始化向量使用。不需要指定初始化向量的PBE算法族（PBEWithMD5AndDES、PBEWithMD5AndTripleDES、PBEWithSHA1AndDESede、PBEWithSHA1AndRC2_40、PBEWithSHA1AndRC2_128、PBEWithSHA1AndRC4_40、PBEWithSHA1AndRC4_128）例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.security.SecureRandom;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "PBEWithSHA1AndDESede"; // 转换模式 String transformation = "PBEWithSHA1AndDESede"; // 密码（口令） String password = "mrbird@qq.com"; System.out.println("PBE口令：" + password); // 迭代次数 int count = 99; // 实例化安全随机数 SecureRandom secureRandom = new SecureRandom(); // 生成盐 byte[] salt = secureRandom.generateSeed(8); System.out.println("盐值：" + Base64.getEncoder().encodeToString(salt)); // 通过密码生成秘钥材料 PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray()); // 实例化秘钥工厂 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm); // 生成秘钥 SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec); // 实例化PBE参数材料 PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, count); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 初始化 cipher.init(Cipher.ENCRYPT_MODE, secretKey, pbeParameterSpec); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("PBE加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, secretKey, pbeParameterSpec); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("PBE解密结果：" + new String(decrypt)); &#125;&#125;程序输出如下：12345待加密值：mrbird&apos;s blogPBE口令：mrbird@qq.com盐值：e2vd/Or8i3U=PBE加密结果：TZx40AyeTP9PZyF6iP3C8A==PBE解密结果：mrbird&apos;s blog算法名称包含Hmac的PBE算法需要指定初始化向量，比如PBEWithHmacSHA1AndAES_128：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.security.SecureRandom;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "PBEWithHmacSHA1AndAES_128"; // 转换模式 String transformation = "PBEWithHmacSHA1AndAES_128"; // 密码（口令） String password = "mrbird@qq.com"; System.out.println("PBE口令：" + password); // 迭代次数 int count = 99; // 实例化安全随机数 SecureRandom secureRandom = new SecureRandom(); // 生成盐 byte[] salt = secureRandom.generateSeed(8); System.out.println("盐值：" + Base64.getEncoder().encodeToString(salt)); // 通过密码生成秘钥材料 PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray()); // 实例化秘钥工厂 SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm); // 生成秘钥 SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec); // 创建初始化向量 IvParameterSpec iv = new IvParameterSpec("123456789abcdefg".getBytes()); // 实例化PBE参数材料 PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, count, iv); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 初始化 cipher.init(Cipher.ENCRYPT_MODE, secretKey, pbeParameterSpec); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("PBE加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, secretKey, pbeParameterSpec); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("PBE解密结果：" + new String(decrypt)); &#125;&#125;通过IvParameterSpec类创建初始化向量，创建初始化向量的秘钥必须为16字节，这里为123456789abcdefg，实例化PBE参数材料的时候通过构造参数传入初始化向量。程序输出如下：12345待加密值：mrbird&apos;s blogPBE口令：mrbird@qq.com盐值：UJwEggkfM88=PBE加密结果：l+HGXLUHEQN+uKmNuIzqzA==PBE解密结果：mrbird&apos;s blog加密模式对称加密算法分为：序列密码(流密码)加密，分组密码(块密码)加密两种。流密码是对信息流中的每一个元素（一个字母或一个比特）作为基本的处理单元进行加密，块密码是先对信息流分块，再对每一块分别加密。上面介绍的这些都属于块密码加密。不同的算法侧重点不同，有的强调效率，有的强调安全，有的强调容错性。根据数据加密时每个加密区块间的关联方式来区分，可以分为4种加密模式：电子密码本模式（Electronic Code Book，ECB）、密文链接模式（Cipher Book Chaining，CBC）、密文反馈模式（Cipher Feed Back，CFB）、输出反馈模式（Output Feed Back，OFB）。AES标准除了推荐上述4种工作模式外，还推荐了一种新的工作模式—计数器模式（Counter，CTR）。这些工作模式可适用于各种分组密码算法。ECBECB模式加解密过程如下图所示：明文分为若干块，每次加密均产生独立的密文分组，每组的加密结果不会对其他分组产生影响，相同的明文加密后对应产生相同的密文。优点：可并行操作，没有误差传递（因为每个密文都是独立加密来的）；缺点：如果明文重复，则对应的密文也会重复，对明文进行主动攻击的可能性较高；用途：适合加密秘钥、随机数等短数据。例如，安全地传递DES秘钥，ECB是最合适的模式。CBCCBC模式加解密过程如下图所示：明文分为若干块，每次加密前，明文块都和前一个明文块加密后的内容进行异或处理，然后再用秘钥加密。因为第一个明文块没有可以用来异或处理的密文块，所以我们需要提供一个初始化向量来替代。优点：密文链接模式加密后的密文上下文关联，对明文的主动攻击的可能性较低；缺点：不能并行加密，如果在加密过程中发生错误，则错误将被无限放大，导致加密失败。并且需要提供初始化向量；用途：可加密任意长度的数据；适用于计算产生检测数据完整性的消息认证码Mac。CFBCFB模式加解密过程如下图所示：明文分为若干块，每次加密前，先将前一个密文块使用秘钥加密，加密结果和当前明文块异或处理得到密文块。同样的，需要为第一个明文块加密提供初始化向量。优点：和CBC类似；缺点：和CBC类似；用途：因错误传播无界，可用于检查发现明文密文的篡改。OFBOFB模式加解密过程如下图所示：过程和CFB类似，区别在于OFB第一次使用秘钥对初始化向量进行加密（结果为A），加密结果和明文块异或处理得到密文块，下一次操作时候，不是使用秘钥加密前一个密文块，而是使用秘钥加密A的结果再和明文块异或处理，得到当前密文块。优点：和CFB类似；缺点：不利于并行计算；对明文的主动攻击是可能的，安全性较CFB差；用途：适用于加密冗余性较大的数据，比如语音和图像数据。CTRCTR模式加解密过程如下图所示：CTR含义是计数器模式，所以它维护了一个递增的计数器。秘钥加密计数器，结果和明文块异或得到密文块，依次类推。优点：可以并行操作，安全性和CBC一样好；缺点：没有错误传播，因此不易确保数据完整性；用途：适用于各种加密应用。填充模式当需要按块处理的数据, 数据长度不符合块处理需求时, 按照一定的方法填充满块长的规则。如果不填充，待加密的数据块长度不符合要求时程序会抛出异常。JDK8中主要支持NoPadding和PKCS5Padding填充模式。NoPadding：不填充；PKCS5Padding：数据块的大小为8位, 不够就补足。加密、填充模式实战在了解了加密模式和填充模式后，我们回头看前面代码中的transformation参数，实例化Cipher对象的时候需要指定transformation转换模式，转换模式主要有两种格式：算法；算法/加密模式/填充模式。下面就AES算法来实践不同的加密、填充模式。当转换模式为AES/ECB/PKCS5Padding时：12345678910111213141516171819202122232425262728293031323334353637383940414243import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "AES"; // 转换模式 String transformation = "AES/ECB/PKCS5Padding"; // --- 生成秘钥 --- // 实例化秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 初始化秘钥长度 keyGenerator.init(256); // 生成秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 生成秘钥材料 SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); System.out.println("AES秘钥：" + Base64.getEncoder().encodeToString(secretKey.getEncoded())); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥 cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("AES加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, secretKeySpec); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("AES解密结果：" + new String(decrypt)); &#125;&#125;程序运行解果：1234待加密值：mrbird&apos;s blogAES秘钥：xCwGw2d/cflibDRY4oQtjNEgBN5tIrxOBtt/31jAeN8=AES加密结果：kjFz9IMO2HAOFgExXMsBjg==AES解密结果：mrbird&apos;s blog将转换模式改为AES/CBC/PKCS5Padding时，程序输出抛出java.security.InvalidKeyException: Parameters missing异常。因为该模式需要指定初始化向量，将代码修改为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "mrbird's blog"; System.out.println("待加密值：" + value); // 加密算法 String algorithm = "AES"; // 转换模式 String transformation = "AES/CBC/PKCS5Padding"; // --- 生成秘钥 --- // 实例化秘钥生成器 KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 初始化秘钥长度 keyGenerator.init(256); // 生成秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 生成秘钥材料 SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), algorithm); System.out.println("AES秘钥：" + Base64.getEncoder().encodeToString(secretKey.getEncoded())); // 初始化向量，123456789abcdefg初始化向量秘钥，16字节 IvParameterSpec iv = new IvParameterSpec("123456789abcdefg".getBytes()); // 实例化密码对象 Cipher cipher = Cipher.getInstance(transformation); // 设置模式（ENCRYPT_MODE：加密模式；DECRYPT_MODE：解密模式）和指定秘钥 cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv); // 加密 byte[] encrypt = cipher.doFinal(value.getBytes()); System.out.println("AES加密结果：" + Base64.getEncoder().encodeToString(encrypt)); // 解密 // 设置为解密模式 cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, iv); byte[] decrypt = cipher.doFinal(encrypt); System.out.println("AES解密结果：" + new String(decrypt)); &#125;&#125;程序输出如下：1234待加密值：mrbird&apos;s blogAES秘钥：xbqvwRKSrAtMsKOxzkbJqG0aMgMQwTC7TF5jkch1M5I=AES加密结果：jksbHzoAA/K0sNVW1+RUOw==AES解密结果：mrbird&apos;s blog将转换模式改为AES/CBC/NoPadding时，程序抛出javax.crypto.IllegalBlockSizeException: Input length not multiple of 16 bytes异常。因为mrbird’s blog不是16字节的倍数。更多对称加密算法和加密模式填充模式的组合可以自己尝试下，或者参考下面的算法总结。手动指定秘钥在使用对称加密算法加解密的时候，秘钥一般是双方事先约定好的，假如现在有AES秘钥/a3nqjFFtkWNmeX5HzmMtzCziOThbAnEHoiTA4JquAI=，AES密文y9YMlnX7TE4qF0dDIQ==，转换模式为AES/CTR/PKCS5Padding，初始化向量秘钥为123456789abcdefg，如何通过秘钥和密文进行解密呢，可以参考下面的代码（即演示如何手动指定秘钥并解密）：1234567891011121314151617181920212223import org.junit.Test;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;public class Demo &#123; @Test public void test() throws Exception &#123; String algorithm = "AES"; String transformation = "AES/CTR/PKCS5Padding"; String key = "/a3nqjFFtkWNmeX5HzmMtzCziOThbAnEHoiTA4JquAI="; String encrypt = "y9YMlnX7TE4qF0dDIQ=="; String ivKey = "123456789abcdefg"; Cipher cipher = Cipher.getInstance(transformation); SecretKeySpec secretKeySpec = new SecretKeySpec(Base64.getDecoder().decode(key), algorithm); IvParameterSpec iv = new IvParameterSpec(ivKey.getBytes()); cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, iv); byte[] decrypt = cipher.doFinal(Base64.getDecoder().decode(encrypt)); System.out.println("AES解密结果：" + new String(decrypt));输出如下：1AES解密结果：mrbird&apos;s blog算法总结对上面这些算法进行总结：算法秘钥长度（位）工作模式填充模式初始化向量秘钥长度（字节）DES56ECB、CBC、CFB、OFB、CTR等NoPadding、PKCS5Padding、ISO10126Padding8DESede112、168ECB、CBC、CFB、OFB、CTR等NoPadding、PKCS5Padding、ISO10126Padding8AES128、192、256ECB、CBC、CFB、OFB、CTR等NoPadding、PKCS5Padding、ISO10126Padding16RC240~1024ECB、CBC、CFB、OFB、CTR等NoPadding、PKCS5Padding、ISO10126Padding8RC440~1024ECBNoPadding无Blowfish32~448，8的倍数ECB、CBC、CFB、OFB、CTR等NoPadding、PKCS5Padding、ISO10126Padding8PBE无CBCPKCS5Padding16（带Hmac）《Java加密与解密的艺术》读书笔记]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 消息摘要算法]]></title>
    <url>%2FJava-%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[消息摘要算法是单向不可逆的，无法通过加密后的散列值反推原始值，相同的内容用同样的摘要算法获得的散列值是一样的，所以常用于验证数据的完整性。该算法主要分为三大类：MD（Message Digest，消息摘要算法）、SHA（Secure HashAlgorithm，安全散列算法）和MAC（Message Authentication Code，消息认证码算法）。MD系列算法包括MD2、MD4和MD5共3种算法；SHA算法主要包括其代表算法SHA-1和SHA-1算法的变种SHA-2系列算法（包含SHA-224、SHA-256、SHA-384和SHA-512）；MAC算法综合了上述两种算法，主要包括HmacMD5、HmacSHA1、HmacSHA256、HmacSHA384和HmacSHA512算法。这节主要记录下JDK8对这些算法的支持情况。消息摘要算法的结果我们一般将其转换为16进制字符串，方便阅读传输。MD系列算法MD5算法是MD系列算法的代表，由MD2、MD4等算法演变而来。无论采用哪种MD算法，结果都是32字节的16进制字符串。JDK8只支持MD2和MD5两种MD算法。新建一个maven项目，引入common-codec依赖（包含一些加解密工具类，用于增强JDK或者简化JDK相关加解密API）：12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.14&lt;/version&gt;&lt;/dependency&gt;JDK8中，MD系列算法的实现是通过MessageDigest类来完成的，下面演示下使用JDK8原生API实现MD2和MD5加密（算法名称不区分大小写）。MD2：123456789101112131415161718192021import org.apache.commons.codec.binary.Hex;import org.junit.Test;import java.security.MessageDigest;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "hello"; String algorithm = "md2"; // 获取MessageDigest实例 MessageDigest messageDigest = MessageDigest.getInstance(algorithm); // 调用digest方法生成数字摘要 byte[] digest = messageDigest.digest(value.getBytes()); // 结果转换为16进制字符串（借助common-codec Hex类） String md2Hex = Hex.encodeHexString(digest); System.out.println(md2Hex); System.out.println(md2Hex.length()); &#125;&#125;运行结果：12a9046c73e00331af68917d3804f7065532MD5（只需要将算法改为md5即可）：123456789101112131415161718192021import org.apache.commons.codec.binary.Hex;import org.junit.Test;import java.security.MessageDigest;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "hello"; String algorithm = "md5"; // 获取MessageDigest实例 MessageDigest messageDigest = MessageDigest.getInstance(algorithm); // 调用digest方法生成数字摘要 byte[] digest = messageDigest.digest(value.getBytes()); // 结果转换为16进制字符串（借助common-codec Hex类） String md5Hex = Hex.encodeHexString(digest); System.out.println(md5Hex); System.out.println(md5Hex.length()); &#125;&#125;运行结果：125d41402abc4b2a76b9719d911017c59232common-codec的DigestUtils也提供了MD2和MD5算法相关方法：123456789101112131415import org.apache.commons.codec.digest.DigestUtils;import org.junit.Test;public class Demo &#123; @Test public void test() &#123; String value = "hello"; String md5Hex = DigestUtils.md5Hex(value.getBytes()); System.out.println(md5Hex); String md2Hex = DigestUtils.md2Hex(value.getBytes()); System.out.println(md2Hex); &#125;&#125;common-codec并没有自己实现相关算法，而是对JDK原生API进行封装，使用起来更方便。SHA系列算法SHA算法是基于MD4算法实现的，作为MD算法的继任者，成为了新一代的消息摘要算法的代表。SHA与MD算法不同之处主要在于摘要长度，SHA算法的摘要更长，安全性更高。SHA算法家族目前共有SHA-1、SHA-224、SHA-256、SHA-384和SHA-512五种算法，通常将后四种算法并称为SHA-2算法。JDK8支持SHA-1、SHA-256、SHA-384、SHA-224和SHA-512五种算法，其中SHA的写法等价于SHA-1。JDK8中，SHA系列算法的实现也是通过MessageDigest类来完成的：1234567891011121314151617import org.apache.commons.codec.binary.Hex;import org.junit.Test;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class Demo &#123; @Test public void test() throws NoSuchAlgorithmException &#123; String value = "hello"; String algorithm = "SHA-1"; MessageDigest messageDigest = MessageDigest.getInstance(algorithm); byte[] digest = messageDigest.digest(value.getBytes()); System.out.println(Hex.encodeHexString(digest)); &#125;&#125;运行结果：1aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d剩下的几种算法可以自己尝试。common-codec同样也提供了SHA相关算法的API：12345678910111213141516171819202122import org.apache.commons.codec.digest.DigestUtils;import org.junit.Test;public class Demo &#123; @Test public void test() &#123; String value = "hello"; String sha1Hex = DigestUtils.sha1Hex(value); System.out.println(sha1Hex); String sha256Hex = DigestUtils.sha256Hex(value); System.out.println(sha256Hex); String sha384Hex = DigestUtils.sha384Hex(value); System.out.println(sha384Hex); String sha512Hex = DigestUtils.sha512Hex(value); System.out.println(sha512Hex); &#125;&#125;MAC系列算法MAC算法结合了MD和SHA算法的优势，并加入秘钥的支持，是一种更为安全的消息摘要算法。因为MAC算法融合了秘钥散列函数（keyed-Hash），通常我们也把MAC称为HMAC（keyed-Hash Message Authentication Code）。MAC算法主要集合了MD和SHA两大系列消息摘要算法。MD系列算法有HmacMD2、HmacMD4和HmacMD5三种算法；SHA系列算法有HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384和HmacSHA512五种算法。JDK8支持了HmacMD5、HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384和HmacSHA512这六种MAC算法，通过Mac类实现。123456789101112131415161718192021222324252627282930313233343536import org.apache.commons.codec.binary.Base64;import org.apache.commons.codec.binary.Hex;import org.junit.Test;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;public class Demo &#123; @Test public void test() throws Exception &#123; String value = "hello"; // JDK支持 HmacMD5、HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384和HmacSHA512六种算法 String algorithm = "HmacMD5"; // 初始化KeyGenerator KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // 构建秘钥 SecretKey secretKey = keyGenerator.generateKey(); // 获得秘钥 byte[] key = secretKey.getEncoded(); // 还原秘钥 SecretKeySpec secretKeySpec = new SecretKeySpec(key, algorithm); // 打印下秘钥 System.out.println(Base64.encodeBase64String(secretKeySpec.getEncoded())); // 实例化Mac Mac mac = Mac.getInstance(algorithm); // 初始化Mac mac.init(secretKeySpec); // 获取消息摘要 byte[] bytes = mac.doFinal(value.getBytes()); // 转换为16进制 System.out.println(Hex.encodeHexString(bytes)); &#125;&#125;输出结果：12PCg3+Q7i/C0ahZ74Vo3Nl/2wBvHnsdycoSmoAXzuxSwc5DVc1rWyHKHdt1XzlanT5GdJiKkcKhCwXGm7iN+udA==6c40b8d59b9d0f818e94b9028b789892实际应用在Tomcat下载页面：https://tomcat.apache.org/download-70.cgi中，我们可以查看相关文件的摘要：我们将32-bit Windows zip这个文件下载下来，计算出这个文件的sha512值：123456789101112131415161718192021222324252627import org.apache.commons.codec.binary.Hex;import org.junit.Test;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.security.MessageDigest;public class Demo &#123; @Test public void test() throws Exception &#123; String algorithm = "SHA-512"; MessageDigest messageDigest = MessageDigest.getInstance(algorithm); String filePath = "files/apache-tomcat-7.0.105-windows-x86.zip"; FileInputStream fis = new FileInputStream(filePath); int len; byte[] buffer = new byte[1024]; ByteArrayOutputStream stream = new ByteArrayOutputStream(); while ((len = fis.read(buffer)) != -1) &#123; stream.write(buffer, 0, len); &#125; byte[] digest = messageDigest.digest(stream.toByteArray()); System.out.println(Hex.encodeHexString(digest)); &#125;&#125;结果：1b7a3b0629dad0d9684bc57a5d18251e38bafa172fcffeac06f7e3c40884f2afc099e7c0143a0471639887b8294c8135c35d1f1ac24f1637dee3c2b3a06aa3aa5这和页面https://downloads.apache.org/tomcat/tomcat-7/v7.0.105/bin/apache-tomcat-7.0.105-windows-x86.zip.sha512上显示的一致，说明我们下载的文件在传输过程中没有被篡改。《Java加密与解密的艺术》读书笔记]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Base64算法]]></title>
    <url>%2FJava-Base64%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[Base64算法并不是加密算法，它的出现是为了解决ASCII码在传输过程中可能出现乱码的问题。Base64是网络上最常见的用于传输8bit字节码的可读性编码算法之一。可读性编码算法不是为了保护数据的安全性，而是为了可读性。可读性编码不改变信息内容，只改变信息内容的表现形式。Base64使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”，故得此名。储备知识Byte和bitByte：字节，数据存储的基本单位；bit：比特，也叫位，一个位只能存储0或者1。关系：1Byte = 8bit。一个英文字符占1个字节，8位：123456789@Testpublic void demo1() &#123; String a = "a"; byte[] bytes = a.getBytes(); for (byte b : bytes) &#123; System.out.println(b); System.out.println(Integer.toBinaryString(b)); &#125;&#125;程序输出：12971100001一个中文字符在不同编码下所占的字节数不同：1234567891011121314151617@Testpublic void demo2() throws UnsupportedEncodingException &#123; String a = "鸟"; byte[] utf8Bytes = a.getBytes("utf-8"); for (byte b : utf8Bytes) &#123; System.out.print(b); System.out.print(" "); System.out.println(Integer.toBinaryString(b)); &#125; System.out.println(); byte[] gbkBytes = a.getBytes("gbk"); for (byte b : gbkBytes) &#123; System.out.print(b); System.out.print(" "); System.out.println(Integer.toBinaryString(b)); &#125;&#125;程序输出：123456-23 11111111111111111111111111101001-72 11111111111111111111111110111000-97 11111111111111111111111110011111-60 11111111111111111111111111000100-15 11111111111111111111111111110001所以在UTF-8编码下，一个中文占3个字节；在GBK编码下，一个中文占2个字节。Base64编码原理Base64编码表：索引对应字符索引对应字符索引对应字符索引对应字符0A17R34i51z1B18S35j5202C19T36k5313D20U37l5424E21V38m5535F22W39n5646G23X40o5757H24Y41p5868I25Z42q5979J26a43r60810K27b44s61911L28c45t62+12M29d46u63/13N30e47v14O31f48w15P32g49x16Q33h50yBase64编码的过程：将字符串转换为字符数组；将每个字符转换为ASCII码；将ASCII码转换为8bit二进制码；然后每3个字节为一组（一个字节为8个bit，所以每组24个bit）；将每组的24个bit分为4份，每份6个bit；在每6个bit前补0，补齐8bit（前面补0不影响数值大小）；然后将每8bit转换为10进制数，根据上面的Base64编码表进行转换。上面步骤中，为什么要将每组24个bit分为4份，每份6个bit呢？因为6bit的最大值为111111，转换为十进制为63，所以6bit的取值范围为0~63，这和base64编码表长度一致。根据上面的过程，我们来举个例子：现要对hello这个字符串进行Base64编码，过程如下：hello转换为字符数组：h e l l o；对应的ASCII码为：104 101 108 108 111；转换为8bit二进制数：01101000 01100101 01101100 01101100 01101111分组，每组24个bit（不足24个bit的用00000000补齐）： 011010000110010101101100 011011000110111100000000；每组24bit分为4份，每份6bit：011010 000110 010101 101100 011011 000110 111100 000000；在每6个bit前补0，补齐8bit：00011010 00000110 00010101 00101100 00011011 00000110 00111100 00000000；将每8bit转换为10进制数：26 6 21 44 27 6 60 0从上面Base64编码表中找到十进制数对应的字符（末尾的0并不是A，而是用=等号补位）：a G V s b G 8 =所以hello经过Base64编码的结果为aGVsbG8=我们可以用代码验证下（JDK8开始已经提供了Base64的实现）：12345678910import org.junit.Test;import java.util.Base64;public class Base64Test &#123; @Test public void demo1() &#123; System.out.println(Base64.getEncoder().encodeToString("hello".getBytes())); &#125;&#125;程序输出也是aGVsbG8=URL Base64算法Base64编码值通过URL传输会出现问题，因为Base64编码中的“+”和“/”符号是不允许出现在URL中的。同样，符号“=”用做参数分隔符，也不允许出现在URL中，根据RFC 4648中的建议，“~”和“.”符都有可能替代“=”符号。但“~”符号与文件系统相冲突，不能使用；如果使用“.”符号，某些文件系统认为该符号连续出现两次则为错误。所以common codec包下的URL Base64算法舍弃了填充符，使用了不定长URL Base64编码。引入common codec依赖包：12345&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.14&lt;/version&gt;&lt;/dependency&gt;举个例子：12345678910111213import org.apache.commons.codec.binary.Base64;import org.junit.Test;public class Base64Test &#123; @Test public void demo1() &#123; String value = "hello"; System.out.println(Base64.encodeBase64String(value.getBytes())); System.out.println(Base64.encodeBase64URLSafeString(value.getBytes())); &#125;&#125;输出如下：12aGVsbG8=aGVsbG8]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式学习]]></title>
    <url>%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[简单记录Java中23种设计模式的应用，方便后期查看。创建型模式简单工厂模式简单工厂模式严格意义上来说，并不属于设计模式中的一种，不过这里还是简单记录下。定义：由一个工厂对象决定创建出哪一种类型实例。客户端只需传入工厂类的参数，无心关心创建过程。优点：具体产品从客户端代码中抽离出来，解耦。缺点：工厂类职责过重，增加新的类型时，得修改工程类得代码，违背开闭原则。举例：新建Fruit水果抽象类，包含eat抽象方法：1234public abstract class Fruit &#123; public abstract void eat();&#125;其实现类Apple：123456public class Apple extends Fruit&#123; @Override public void eat() &#123; System.out.println("吃🍎"); &#125;&#125;新建创建Fruit的工厂类：12345678910public class FruitFactory &#123; public Fruit produce(String name) &#123; if ("apple".equals(name)) &#123; return new Apple(); &#125; else &#123; return null; &#125; &#125;&#125;新建个客户端测试一下：12345678public class Application &#123; public static void main(String[] args) &#123; FruitFactory factory = new FruitFactory(); Fruit fruit = factory.produce("apple"); fruit.eat(); &#125;&#125;运行main方法，输出：1吃🍎可以看到，客户端Application并未依赖具体的水果类型，只关心FruitFactory的入参，这就是客户端和具体产品解耦的体现，UML图如下：工厂方法模式为了解决简单工厂模式的缺点，诞生了工厂方法模式（Factory method pattern）。定义：定义创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类进行。优点：具体产品从客户端代码中抽离出来，解耦。加入新的类型时，只需添加新的工厂方法（无需修改旧的工厂方法代码），符合开闭原则。缺点：类的个数容易过多，增加复杂度。举例：新建Fruit抽象类，包含eat抽象方法：1234public abstract class Fruit &#123; public abstract void eat();&#125;新建FruitFactory抽象工厂，定义produceFruit抽象方法：1234public abstract class FruitFactory &#123; public abstract Fruit produceFruit();&#125;新建Fruit的实现类，Apple：123456public class Apple extends Fruit &#123; @Override public void eat() &#123; System.out.println("吃🍎"); &#125;&#125;新建FruitFactory的实现类AppleFruitFactory，用于生产具体类型的水果 —— 苹果：123456public class AppleFruitFactory extends FruitFactory&#123; @Override public Fruit produceFruit() &#123; return new Apple(); &#125;&#125;新建客户端Application测试一波：12345678public class Application &#123; public static void main(String[] args) &#123; FruitFactory factory = new AppleFruitFactory(); Fruit fruit = factory.produceFruit(); fruit.eat(); &#125;&#125;运行main方法，输出如下：1吃🍎现在要新增Banana类型的水果，只需要新增Banana类型的工厂类即可，无需修改现有的AppleFruitFactory代码，符合开闭原则。但是这种模式的缺点也显而易见，就是类的个数容易过多，增加复杂度。上面例子UML图如下所示：抽象工厂模式抽象工厂模式（Abstract factory pattern）提供了一系列相关或者相互依赖的对象的接口，关键字是“一系列”。优点：具体产品从客户端代码中抽离出来，解耦。将一个系列的产品族统一到一起创建。缺点：拓展新的功能困难，需要修改抽象工厂的接口；综上所述，抽象工厂模式适合那些功能相对固定的产品族的创建。举例：新建水果抽象类Fruit，包含buy抽象方法：1234public abstract class Fruit &#123; public abstract void buy();&#125;新建价格抽象类Price，包含pay抽象方法：1234public abstract class Price &#123; public abstract void pay();&#125;新建水果创建工厂接口FruitFactory，包含获取水果和价格抽象方法（产品族的体现是，一组产品包含水果和对应的价格）：12345public interface FruitFactory &#123; Fruit getFruit(); Price getPrice();&#125;接下来开始创建🍎这个“产品族”。新建Fruit实现类AppleFruit：123456public class AppleFruit extends Fruit&#123; @Override public void buy() &#123; System.out.println("购买🍎"); &#125;&#125;新建对应的苹果价格实现ApplePrice：123456public class ApplePrice extends Price&#123; @Override public void pay() &#123; System.out.println("🍎单价2元"); &#125;&#125;创建客户端Application，测试一波：1234567public class Application &#123; public static void main(String[] args) &#123; FruitFactory factory = new AppleFruitFactory(); factory.getFruit().buy(); factory.getPrice().pay(); &#125;&#125;输出如下：12购买🍎🍎单价2元客户端只需要通过创建AppleFruitFactory就可以获得苹果这个产品族的所有内容，包括苹果对象，苹果价格。要新建🍌的产品族，只需要实现FruitFactory、Price和Fruit接口即可。这种模式的缺点和工厂方法差不多，就是类的个数容易过多，增加复杂度。上面例子UML图如下所示：建造者模式建造者模式也称为生成器模式（Builder Pattern），将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。适用于：一个对象有非常复杂的内部结构（很多属性）想将复杂对象的创建和使用分离。优点：封装性好，创建和使用分离拓展性好，建造类之间独立，一定程度上解耦。缺点：产生多余的Builder对象；产品内部发生变化，建造者需要更改，成本较大。举个例子：新增商铺类Shop，包含名称，地点和类型属性：123456789101112131415161718192021222324252627282930313233343536373839public class Shop &#123; private String name; private String location; private String type; @Override public String toString() &#123; return "Shop&#123;" + "name='" + name + '\'' + ", location='" + location + '\'' + ", type='" + type + '\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getLocation() &#123; return location; &#125; public void setLocation(String location) &#123; this.location = location; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125;&#125;接着创建Shop抽象生成器ShopBuilder：123456789101112public abstract class ShopBuilder &#123; private String name; private String location; private String type; public abstract void name(String name); public abstract void location(String location); public abstract void type(String type); public abstract Shop build();&#125;包含和Shop相同的属性及对应的抽象构建方法。继续创建ShopBuilder的实现，水果店构造器FruitShopBuilder：123456789101112131415161718192021222324public class FruitShopBuilder extends ShopBuilder&#123; private Shop shop = new Shop(); @Override public void name(String name) &#123; this.shop.setName(name); &#125; @Override public void location(String location) &#123; this.shop.setLocation(location); &#125; @Override public void type(String type) &#123; this.shop.setType(type); &#125; @Override public Shop build() &#123; return shop; &#125;&#125;创建个经销商类Dealer，用于通过ShopBuilder构建具体的商店：123456789101112131415public class Dealer &#123; private ShopBuilder builder; public void setBuilder(ShopBuilder builder) &#123; this.builder = builder; &#125; public Shop build(String name, String location, String type) &#123; this.builder.name(name); this.builder.location(location); this.builder.type(type); return builder.build(); &#125;&#125;创建个客户端Application测试一波：1234567891011public class Application &#123; public static void main(String[] args) &#123; ShopBuilder builder = new FruitShopBuilder(); Dealer dealer = new Dealer(); dealer.setBuilder(builder); Shop shop = dealer.build("XX水果店", "福州市XX区XX街XX号", "水果经营"); System.out.println(shop); &#125;&#125;输出如下：1Shop&#123;name=&apos;XX水果店&apos;, location=&apos;福州市XX区XX街XX号&apos;, type=&apos;水果经营&apos;&#125;这个例子是典型的建造者模式，UML图如下所示：其实建造者模式更为常用的例子是下面这个：创建一个店铺类Shop，Shop里包含构造该Shop的内部类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Shop &#123; private String name; private String location; private String type; public Shop(ShopBuilder builder) &#123; this.name = builder.name; this.location = builder.location; this.type = builder.type; &#125; @Override public String toString() &#123; return "Shop&#123;" + "name='" + name + '\'' + ", location='" + location + '\'' + ", type='" + type + '\'' + '&#125;'; &#125; public static class ShopBuilder &#123; private String name; private String location; private String type; public ShopBuilder name(String name) &#123; this.name = name; return this; &#125; public ShopBuilder location(String location) &#123; this.location = location; return this; &#125; public ShopBuilder type(String type) &#123; this.type = type; return this; &#125; public Shop build() &#123; return new Shop(this); &#125; &#125;&#125;在客户端构建Shop只需：1234567891011public class Application &#123; public static void main(String[] args) &#123; Shop shop = new Shop.ShopBuilder() .name("XX水果店") .location("福州市XX区XX街XX号") .type("水果经营") .build(); System.out.println(shop); &#125;&#125;这种用法和Lombok的@Builder注解效果是一样的。这个例子的UML图：单例模式单例模式目的是为了一个类只有一个实例。优点：内存中只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问。缺点：没有接口，拓展困难。懒汉模式懒汉模式下的单例写法是最简单的，但它是线程不安全的：123456789101112131415public class LazySingleton &#123; private static LazySingleton lazySingleton = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; if (lazySingleton == null) &#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125;可加同步锁解决线程安全问题：1234567891011121314151617public class LazySingleton &#123; private static LazySingleton lazySingleton = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; synchronized (LazySingleton.class) &#123; if (lazySingleton == null) &#123; lazySingleton = new LazySingleton(); &#125; &#125; return lazySingleton; &#125;&#125;但是同步锁锁的是整个类，比较消耗资源，并且即使运行内存中已经存在LazySingleton，调用其getInstance还是会上锁，所以这种写法也不是很好。双重同步锁单例模式12345678910111213141516171819public class LazyDoubleCheckSingleton &#123; private static LazyDoubleCheckSingleton instance = null; private LazyDoubleCheckSingleton() &#123; &#125; public static LazyDoubleCheckSingleton getInstance() &#123; if (instance == null) &#123; synchronized (LazyDoubleCheckSingleton.class) &#123; if (instance == null) &#123; instance = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125;&#125;上面例子虽然加了同步锁，但它还是线程不安全的。虽然上面的例子不会出现多次初始化LazyDoubleCheckSingleton实例的情况，但是由于指令重排的原因，某些线程可能会获取到空对象，后续对该对象的操作将触发空指针异常。要修复这个问题，只需要阻止指令重排即可，所以可以给instance属性加上volatile关键字：12345678910111213141516171819public class LazyDoubleCheckSingleton &#123; private volatile static LazyDoubleCheckSingleton instance = null; private LazyDoubleCheckSingleton() &#123; &#125; public static LazyDoubleCheckSingleton getInstance() &#123; if (instance == null) &#123; synchronized (LazyDoubleCheckSingleton.class) &#123; if (instance == null) &#123; instance = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125;&#125;相关博文：深入理解volatile关键字。上面这种写法是不但确保了线程安全，并且当LazyDoubleCheckSingleton实例创建好后，后续再调用其getInstance方法不会上锁。静态内部类单例模式看例子：1234567891011121314public class StaticInnerClassSingleton &#123; private StaticInnerClassSingleton() &#123; &#125; private static class InnerClass &#123; private static StaticInnerClassSingleton instance = new StaticInnerClassSingleton(); &#125; public static StaticInnerClassSingleton getInstance() &#123; return InnerClass.instance; &#125;&#125;为什么这个例子是可行的呢？主要有两个原因：JVM在类的初始化阶段会加Class对象初始化同步锁，同步多个线程对该类的初始化操作；静态内部类InnerClass的静态成员变量instance在方法区中只会有一个实例。在Java规范中，当以下这些情况首次发生时，A类将会立刻被初始化：A类型实例被创建；A类中声明的静态方法被调用；A类中的静态成员变量被赋值；A类中的静态成员被使用（非常量）；饿汉单例模式“饿汉”意指在类加载的时候就初始化：123456789101112public class HungrySingleton &#123; private final static HungrySingleton instance = new HungrySingleton(); private HungrySingleton() &#123; &#125; public static HungrySingleton getInstance() &#123; return instance; &#125;&#125;这种模式在类加载的时候就完成了初始化，所以并不存在线程安全性问题；但由于不是懒加载，饿汉模式不管需不需要用到实例都要去创建实例，如果创建了不使用，则会造成内存浪费。序列化破坏单例模式前面的单例例子在实现序列化接口后都能被序列化的方式破坏，比如HungrySingleton，让其实现序列化接口：1234567891011121314public class HungrySingleton implements Serializable &#123; private static final long serialVersionUID = -8073288969651806838L; private final static HungrySingleton instance = new HungrySingleton(); private HungrySingleton() &#123; &#125; public static HungrySingleton getInstance() &#123; return instance; &#125;&#125;然后创建Application测试一下如何破坏：12345678910111213141516public class Application &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; // 演示序列化破坏单例 HungrySingleton instance = HungrySingleton.getInstance(); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("file")); outputStream.writeObject(instance); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("file")); HungrySingleton newInstance = (HungrySingleton) inputStream.readObject(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance == newInstance); &#125;&#125;输出如下所示：123cc.mrbird.design.pattern.creational.singleton.HungrySingleton@7f31245acc.mrbird.design.pattern.creational.singleton.HungrySingleton@6d03e736false可以看到，虽然是单例模式，但却成功创建出了两个不一样的实例，单例遭到了破坏。要让反序列化后的对象和序列化前的对象是同一个对象的话，可以在HungrySingleton里加上readResolve方法：123456789101112131415161718public class HungrySingleton implements Serializable &#123; private static final long serialVersionUID = -8073288969651806838L; private final static HungrySingleton instance = new HungrySingleton(); private HungrySingleton() &#123; &#125; public static HungrySingleton getInstance() &#123; return instance; &#125; // 新增 private Object readResolve() &#123; return instance; &#125;&#125;再次运行Application的main方法后：123cc.mrbird.design.pattern.creational.singleton.HungrySingleton@7f31245acc.mrbird.design.pattern.creational.singleton.HungrySingleton@7f31245atrue可以看到，这种方式最终反序列化出来的对象和序列化对象是同一个对象。但这种方式反序列化过程内部还是会重新创建HungrySingleton实例，只不过因为HungrySingleton类定义了readResolve方法（方法内部返回instance引用），反序列化过程会判断目标类是否定义了readResolve该方法，是的话则通过反射调用该方法。反射破坏单例模式除了序列化能破坏单例外，反射也可以，举个反射破坏HungrySingleton的例子：1234567891011121314151617public class Application &#123; public static void main(String[] args) throws Exception &#123; HungrySingleton instance = HungrySingleton.getInstance(); // 反射创建实例 Class&lt;HungrySingleton&gt; c = HungrySingleton.class; // 获取构造器 Constructor&lt;HungrySingleton&gt; constructor = c.getDeclaredConstructor(); // 打开构造器权限 constructor.setAccessible(true); HungrySingleton newInstance = constructor.newInstance(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance == newInstance); &#125;&#125;输出如下所示：123cc.mrbird.design.pattern.creational.singleton.HungrySingleton@1b6d3586cc.mrbird.design.pattern.creational.singleton.HungrySingleton@4554617cfalse可以看到，我们通过反射破坏了私有构造器权限，成功创建了新的实例。对于这种情况，饿汉模式下的例子可以在构造器中添加判断逻辑来防御（懒汉模式的就没有办法了），比如修改HungrySingleton的代码如下所示：1234567891011121314public class HungrySingleton &#123; private final static HungrySingleton instance = new HungrySingleton(); private HungrySingleton() &#123; if (instance != null) &#123; throw new RuntimeException("forbidden"); &#125; &#125; public static HungrySingleton getInstance() &#123; return instance; &#125;&#125;再次运行Application的main方法：123456789Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at cc.mrbird.design.pattern.creational.singleton.Application.main(Application.java:33)Caused by: java.lang.RuntimeException: forbidden at cc.mrbird.design.pattern.creational.singleton.HungrySingleton.&lt;init&gt;(HungrySingleton.java:16) ... 5 more枚举单例模式枚举单例模式是推荐的单例模式，它不仅可以防御序列化攻击，也可以防御反射攻击。举个枚举单例模式的代码：123456789101112131415161718public enum EnumSingleton &#123; INSTANCE; private Object data; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public static EnumSingleton getInstance()&#123; return INSTANCE; &#125;&#125;验证下是否是单例的：1234567891011121314public class Application &#123; public static void main(String[] args) throws Exception &#123; EnumSingleton instance = EnumSingleton.getInstance(); instance.setData(new Object()); EnumSingleton newInstance = EnumSingleton.getInstance(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance.getData()); System.out.println(newInstance.getData()); &#125;&#125;输出如下所示：1234INSTANCEINSTANCEjava.lang.Object@1b6d3586java.lang.Object@1b6d3586测试下序列化攻击：1234567891011121314151617181920public class Application &#123; public static void main(String[] args) throws Exception &#123; EnumSingleton instance = EnumSingleton.getInstance(); instance.setData(new Object()); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("file")); outputStream.writeObject(instance); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("file")); EnumSingleton newInstance = (EnumSingleton) inputStream.readObject(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance == newInstance); System.out.println(instance.getData()); System.out.println(newInstance.getData()); System.out.println(instance.getData() == newInstance.getData()); &#125;&#125;输出如下所示：123456INSTANCEINSTANCEtruejava.lang.Object@568db2f2java.lang.Object@568db2f2true可以看到序列化和反序列化后的对象是同一个。原理：跟踪ObjectInputStream#readObject源码，其中当反编译对象为枚举类型时，将调用readEnum方法：name为枚举类里的枚举常量，对于线程来说它是唯一的，存在方法区，所以通过Enum.valueOf((Class)cl, name)方法得到的枚举对象都是同一个。再测试一下反射攻击：1234567891011121314public class Application &#123; public static void main(String[] args) throws Exception &#123; EnumSingleton instance = EnumSingleton.getInstance(); Class&lt;EnumSingleton&gt; c = EnumSingleton.class; // 枚举类只包含一个(String,int)类型构造器 Constructor&lt;EnumSingleton&gt; constructor = c.getDeclaredConstructor(String.class, int.class); constructor.setAccessible(true); EnumSingleton newInstance = constructor.newInstance("hello", 1); System.out.println(instance == newInstance); &#125;&#125;运行输出如下：123Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects at java.lang.reflect.Constructor.newInstance(Constructor.java:417) at cc.mrbird.design.pattern.creational.singleton.Application.main(Application.java:71)可以看到抛异常了，查看Constructor类的417行代码可以发现原因： Java禁止通过反射创建枚举对象。正是因为枚举类型拥有这些天然的优势，所以用它创建单例是不错的选择，这也是Effective Java推荐的方式。原型模式原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象。适用于：类初始化消耗较多资源；循环体中生产大量对象的时候。优点：原型模式性能比直接new一个对象性能好；简化创建对象过程。缺点：对象必须重写Object克隆方法；复杂对象的克隆方法写起来较麻烦（深克隆、浅克隆）举例：新建一个学生类Student，实现克隆接口，并重写Object的克隆方法（因为都是简单属性，所以浅克隆即可）：12345678910111213141516171819202122232425262728293031323334public class Student implements Cloneable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;在Application中测试一波：1234567891011121314public class Application &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Student student = new Student(); ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; Student s = (Student) student.clone(); s.setName("学生" + i); s.setAge(20 + i); list.add(s); &#125; System.out.println(list); &#125;&#125;输出如下所示：1[Student&#123;name='学生0', age=20&#125;, Student&#123;name='学生1', age=21&#125;, Student&#123;name='学生2', age=22&#125;]这种方式会比直接在循环中创建Student性能好。当对象包含引用类型属性时，需要使用深克隆，比如Student包含Date属性时：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Student implements Cloneable &#123; private String name; private int age; private Date birthday; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + ", birthday=" + birthday + '&#125;'; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Student student = (Student) super.clone(); // 引用类型深克隆 Date birthday = (Date) student.getBirthday().clone(); student.setBirthday(birthday); return student; &#125;&#125;值得注意的是，克隆会破坏实现了Cloneable接口的单例对象。结构型模式外观模式外观模式又叫门面模式，提供了统一得接口，用来访问子系统中的一群接口。适用于：子系统越来越复杂，增加外观模式提供简单接口调用；构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。优点：简化了调用过程，无需了解深入子系统；减低耦合度；更好的层次划分；符合迪米特法则。缺点：增加子系统，拓展子系统行为容易引入风险；不符合开闭原则。举个订外卖的例子。创建一个外卖实体类Takeaway：123456789101112public class Takeaway &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;订外卖过程一般分为三个步骤：下单、支付和配送，所以我们创建三个Service对应这三个过程。新建下单服务OrderService：1234567public class OrderService &#123; public boolean placeAnOrder(Takeaway takeaway) &#123; System.out.println(takeaway.getName() + "下单成功"); return true; &#125;&#125;新建支付服务PayService：1234567public class PayService &#123; public boolean pay(Takeaway takeaway) &#123; System.out.println("商品" + takeaway.getName() + "支付成功"); return true; &#125;&#125;新建配送服务DeliveryService：123456public class DeliveryService &#123; public void delivery(Takeaway takeaway) &#123; System.out.println(takeaway.getName() + "已由骑手XX接单，订单派送中"); &#125;&#125;基于外观模式法则，我们需要创建一个Service来聚合这三个服务，客户端只需要和这个Service交互即可。新建外卖服务TakeawayService：1234567891011121314public class TakeawayService &#123; private OrderService orderService = new OrderService(); private PayService payService = new PayService(); private DeliveryService deliveryService = new DeliveryService(); public void takeOrder(Takeaway takeaway) &#123; if (orderService.placeAnOrder(takeaway)) &#123; if (payService.pay(takeaway)) &#123; deliveryService.delivery(takeaway); &#125; &#125; &#125;&#125;新建个客户端测试一波：12345678910public class Application &#123; public static void main(String[] args) &#123; Takeaway takeaway = new Takeaway(); takeaway.setName("泡椒🐸"); TakeawayService takeawayService = new TakeawayService(); takeawayService.takeOrder(takeaway); &#125;&#125;可以看到，客户端只需要调用TakeawayService即可，无需关系内部具体经历了多少个步骤，运行main方法输出如下：123泡椒🐸下单成功商品泡椒🐸支付成功泡椒🐸已由骑手XX接单，订单派送中该例子的UML图如下所示：装饰者模式在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案。适用于：拓展一个类的功能；动态给对象添加功能，并且动态撤销。优点：继承的有力补充，不改变原有对象的情况下给对象拓展功能；通过使用不同的装饰类、不同的组合方式，实现不同的效果。符合开闭原则。缺点：增加程序复杂性；举个水果沙拉的例子。比如在点水果沙拉外卖时，可以往水果沙拉里加各种水果，价格也会相应的调整，要让程序支持不同水果自由组合，并计算相应的价格，则可以使用装饰者模式来完成。定义一个抽象的水果沙拉类AbstractFruitSalad：1234public abstract class AbstractFruitSalad &#123; public abstract String remark(); public abstract int price();&#125;包含备注和价格抽象方法。接着创建一个抽象的装饰器AbstractDecorator（关键点，继承抽象水果沙拉类）：123456789101112131415161718public class AbstractDecorator extends AbstractFruitSalad&#123; private AbstractFruitSalad fruitSalad; public AbstractDecorator(AbstractFruitSalad fruitSalad)&#123; this.fruitSalad = fruitSalad; &#125; @Override public String remark() &#123; return fruitSalad.remark(); &#125; @Override public int price() &#123; return fruitSalad.price(); &#125;&#125;创建具体的水果沙拉类FruitSalad：1234567891011public class FruitSalad extends AbstractFruitSalad&#123; @Override public String remark() &#123; return "水果🥗（标准）\n"; &#125; @Override public int price() &#123; return 9; &#125;&#125;该沙拉是标准的水果沙拉，价格是9元。如果我们的水果沙拉还允许客户添加猕猴桃和西瓜，那么我们可以添加两个新的装饰器。添加猕猴桃装饰器KiwiDecorator：12345678910111213141516public class KiwiDecorator extends AbstractDecorator &#123; public KiwiDecorator(AbstractFruitSalad fruitSalad) &#123; super(fruitSalad); &#125; @Override public String remark() &#123; return super.remark() + "加份🥝切\n"; &#125; @Override public int price() &#123; return super.price() + 2; &#125;&#125;可以看到，加一份猕猴桃需要在原有基础上加2元。接着继续创建西瓜装饰器WaterMelonDecorator：12345678910111213141516public class WaterMelonDecorator extends AbstractDecorator &#123; public WaterMelonDecorator(AbstractFruitSalad fruitSalad) &#123; super(fruitSalad); &#125; @Override public String remark() &#123; return super.remark() + "加份🍉切\n"; &#125; @Override public int price() &#123; return super.price() + 3; &#125;&#125;最后创建客户端Application测试一下：123456789101112public class Application &#123; public static void main(String[] args) &#123; // 点了份水果沙拉，并加了两份🥝和一份🍉，看看最终价格是多少？ AbstractFruitSalad fruitSalad = new FruitSalad(); fruitSalad = new KiwiDecorator(fruitSalad); fruitSalad = new KiwiDecorator(fruitSalad); fruitSalad = new WaterMelonDecorator(fruitSalad); System.out.println(fruitSalad.remark() + "价格是：" + fruitSalad.price()); &#125;&#125;上面的写法也可以改为：12345678910public class Application &#123; public static void main(String[] args) &#123; // 点了份水果沙拉，并加了两份🥝和一份🍉，看看最终价格是多少？ AbstractFruitSalad fruitSalad = new FruitSalad(); fruitSalad = new WaterMelonDecorator(new KiwiDecorator(new KiwiDecorator(fruitSalad))); System.out.println(fruitSalad.remark() + "价格是：" + fruitSalad.price()); &#125;&#125;程序输出如下：12345水果🥗（标准）加份🥝切加份🥝切加份🍉切价格是：16通过不同的装饰器自由组合，我们可以灵活的组装出各式各样的水果沙拉，这正是装饰者模式的优点，但明显可以看出代码变复杂了。这个例子的UML图如下所示:适配器模式将一个类的接口转换为期望的另一个接口，使原本不兼容的类可以一起工作。适用于：已存在的类，它的方法和需求不匹配时（方法结果相同或者相似）优点:提高类的透明性和复用，现有的类复用但不需改变；目标类和适配器类解耦，提高程序拓展性；符合开闭原则。缺点：适配器编写过程需要全面考虑，可能会增加系统的复杂性；降低代码可读性。分为：类适配器模式和对象适配器模式。先举个类适配器模式的例子：假如项目里原有一条水果的产品线，比如包含一个树莓类Raspberry：123456public class Raspberry &#123; public void addRaspberry() &#123; System.out.println("添加点树莓"); &#125;&#125;随着项目的拓展，现在新增了水果派产品线，新建Pie接口：1234public interface Pie &#123; void make();&#125;要将Raspberry加入到Pie产品线，又不想修改Raspberry类的代码，则可以创建一个适配器RaspberryPieAdaptor：1234567public class RaspberryPieAdaptor extends Raspberry implements Pie&#123; @Override public void make() &#123; System.out.println("制作一个派🥧"); super.addRaspberry(); &#125;&#125;适配器继承被适配的类，实现新的产品线接口。在Application里测试一波：123456public class Application &#123; public static void main(String[] args) &#123; Pie pie = new RaspberryPieAdaptor(); pie.make(); &#125;&#125;输出：12制作一个派🥧添加点树莓成功通过适配器制造了树莓派。类适配器模式的UML图很简单：对象适配器模式只需要将RaspberryPieAdaptor修改为：12345678910public class RaspberryPieAdaptor implements Pie&#123; private Raspberry raspberry = new Raspberry(); @Override public void make() &#123; System.out.println("制作一个派🥧"); raspberry.addRaspberry(); &#125;&#125;这种模式不直接继承被适配者，而是在适配器里创建被适配者。这种模式的UML图：享元模式提供了减少对象数量从而改善应用所需的对象结构的方式，运用共享技术有效地支持大量细粒度的对象。适用于：底层系统开发，解决性能问题；系统拥有大量相似对象，需要缓冲池的场景。优点：减少对象的创建，降低内存占用；缺点：关注内/外部状态，关注线程安全问题；程序的逻辑复杂化。内部状态：简单理解为享元对象的属性状态，不会因为外部的改变而改变； 外部状态：简单理解为方法参数。举个例子，新建派🥧接口Pie：1234public interface Pie &#123; void make() throws InterruptedException;&#125;其实现类水果派FruitPie：1234567891011121314151617181920212223public class FruitPie implements Pie &#123; private String name; private LocalDateTime productTime; public FruitPie(String name) &#123; this.name = name; &#125; public void setProductTime(LocalDateTime productTime) &#123; this.productTime = productTime; &#125; @Override public void make() &#123; try &#123; Thread.sleep(100); System.out.println(name + "生产时间：" + this.productTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;包含名称和生产日期属性，并且有个make方法。接着创建生产FruitPie的工厂FruitPieFactory：1234567891011121314public class FruitPieFactory &#123; private static final HashMap&lt;String, FruitPie&gt; PIE_HASH_MAP = new HashMap&lt;&gt;(); public static FruitPie produce(String name) &#123; FruitPie fruitPie = PIE_HASH_MAP.get(name); if (fruitPie == null) &#123; System.out.println("没有" + name + "制作方法，学习制作..."); fruitPie = new FruitPie(name); PIE_HASH_MAP.put(name, fruitPie); &#125; return fruitPie; &#125;&#125;代码关键是通过HashMap存储对象。编写个测试类：12345678910111213public class Application &#123; private static final String[] PIE = &#123;"🍇派", "🍈派", "🍓派", "🍒派"&#125;; public static void main(String[] args) &#123; IntStream.range(0, 10).forEach((i) -&gt; &#123; String name = PIE[(int) (Math.random() * PIE.length)]; FruitPie fruitPie = FruitPieFactory.produce(name); fruitPie.setProductTime(LocalDateTime.now()); fruitPie.make(); &#125;); &#125;&#125;输出如下所示：1234567891011121314没有🍓派制作方法，学习制作...🍓派生产时间：2019-12-19T16:13:26.397没有🍇派制作方法，学习制作...🍇派生产时间：2019-12-19T16:13:26.498🍇派生产时间：2019-12-19T16:13:26.599没有🍒派制作方法，学习制作...🍒派生产时间：2019-12-19T16:13:26.700🍒派生产时间：2019-12-19T16:13:26.800🍒派生产时间：2019-12-19T16:13:26.901没有🍈派制作方法，学习制作...🍈派生产时间：2019-12-19T16:13:27.002🍓派生产时间：2019-12-19T16:13:27.103🍇派生产时间：2019-12-19T16:13:27.203🍇派生产时间：2019-12-19T16:13:27.304从结果看，在10次循环中，只生产了4个对象，这很好的描述了系统有大量相似对象，需要缓冲池的场景。JDK中的字符串常量池，数据库连接池等都是用的享元模式。组合模式将对象组合成树形结构以表示“部分-整体”的层次结构，使客户端对单个对象和组合对象保持一致的方式处理。适用于：客户端可以忽略组合对象与单个对象的差异；处理树形结构数据。优点:层次清晰；客户端不必关系层次差异，方便控制；符合开闭原则。缺点：树形处理较为复杂。举个菜单按钮组成的树形例子。新建菜单按钮的组合抽象类AbstractMenuButton：12345678910111213141516171819202122public abstract class AbstractMenuButton &#123; public void add(AbstractMenuButton abstractMenuButton) &#123; throw new UnsupportedOperationException("不支持创建操作"); &#125; public String getName() &#123; throw new UnsupportedOperationException("不支持名称获取"); &#125; public String getType() &#123; throw new UnsupportedOperationException("不支持类型获取"); &#125; public String getIcon() &#123; throw new UnsupportedOperationException("不支持图标"); &#125; public void print() &#123; throw new UnsupportedOperationException("不支持打印操作"); &#125;&#125;组合了菜单按钮操作的基本方法。新增按钮类Button：1234567891011121314151617181920212223public class Button extends AbstractMenuButton &#123; private String name; public Button(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return this.name; &#125; @Override public String getType() &#123; return "按钮"; &#125; @Override public void print() &#123; System.out.println(getName() + "【" + getType() + "】"); &#125;&#125;按钮拥有名称属性，并且支持名称获取，类型获取和打印方法，所以重写了这三个父类方法。接着新建菜单类Menu：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Menu extends AbstractMenuButton &#123; private List&lt;AbstractMenuButton&gt; items = new ArrayList&lt;&gt;(); private String name; private String icon; private Integer level; public Menu(String name, String icon, Integer level) &#123; this.name = name; this.icon = icon; this.level = level; &#125; @Override public void add(AbstractMenuButton abstractMenuButton) &#123; items.add(abstractMenuButton); &#125; @Override public String getName() &#123; return this.name; &#125; @Override public String getType() &#123; return "菜单"; &#125; @Override public String getIcon() &#123; return this.icon; &#125; @Override public void print() &#123; System.out.println(getIcon() + getName() + "【" + getType() + "】"); for (AbstractMenuButton item : items) &#123; if (this.level != null) &#123; for (int i = 0; i &lt; this.level; i++) &#123; System.out.print(" "); &#125; &#125; item.print(); &#125; &#125;&#125;菜单包含名称、图标和层级属性，并且菜单可以包含下级（比如下级菜单，下级按钮），所以它包含一个List类型的属性items。此外，菜单包含添加下级、名称获取、类型获取、图标获取和打印方法。新建一个客户端，测试菜单按钮的层级结构：12345678910111213141516171819202122public class Application &#123; public static void main(String[] args) &#123; Menu userMenu = new Menu("用户管理", "🧑", 2); Button createUser = new Button("新增用户"); Button updateUser = new Button("修改用户"); Button deleteUser = new Button("删除用户"); userMenu.add(createUser); userMenu.add(updateUser); userMenu.add(deleteUser); Menu logMenu = new Menu("操作日志", "📃", 2); Button export = new Button("导出Excel"); logMenu.add(export); Menu systemMenu = new Menu("系统管理", "🔨", 1); systemMenu.add(userMenu); systemMenu.add(logMenu); systemMenu.print(); &#125;&#125;打印输出如下所示：1234567🔨系统管理【菜单】 🧑用户管理【菜单】 新增用户【按钮】 修改用户【按钮】 删除用户【按钮】 📃操作日志【菜单】 导出Excel【按钮】UML图如下所示：桥接模式将抽象部分和具体实现部分分离，使它们都可以独立变化。通过组合的方式建立两个类之间的关系，而不是通过继承。适用于：抽象和实体实现之间增加更多的灵活性；一个类存在多个独立变化的维度，并且需要独立拓展；不希望使用继承。优点：分离抽象部分和具体实现部分；提高了系统可拓展性；符合开闭原则和合成复用原则。缺点：增加了系统的理解和设计难度；举个例子：现有派的接口类Pie：123456public interface Pie &#123; Pie makePie(); void getType();&#125;包含制作派和获取派类型抽象方法。接着创建两个Pie的实现类，苹果派AppliePie：123456789101112public class ApplePie implements Pie &#123; @Override public Pie makePie() &#123; System.out.println("制作苹果派🍎🥧"); return new ApplePie(); &#125; @Override public void getType() &#123; System.out.println("水果派"); &#125;&#125;胡萝卜派CarrotPie：123456789101112public class CarrotPie implements Pie&#123; @Override public Pie makePie() &#123; System.out.println("制作胡萝卜派🥕🥧"); return new CarrotPie(); &#125; @Override public void getType() &#123; System.out.println("蔬菜沙拉派"); &#125;&#125;接着创建一个店铺抽象类Store，通过属性的方式和Pie相关联，目的是可以在不同的店铺实现类中灵活地制作各种派：12345678910public abstract class Store &#123; protected Pie pie; public Store(Pie pie)&#123; this.pie = pie; &#125; abstract Pie makePie();&#125;Store子类之一，山姆大叔的小店SamStore：123456789101112public class SamStore extends Store&#123; public SamStore(Pie pie) &#123; super(pie); &#125; @Override Pie makePie() &#123; System.out.print("山姆大叔的小店💒"); return pie.makePie(); &#125;&#125;Store子类之二，杰克的小店JackStore：123456789101112public class JackStore extends Store &#123; public JackStore(Pie pie) &#123; super(pie); &#125; @Override Pie makePie() &#123; System.out.print("杰克的小店💒"); return pie.makePie(); &#125;&#125;新建一个客户端，测试Pie的实现类和Store的继承类之间的自由组合：1234567891011public class Application &#123; public static void main(String[] args) &#123; Store samStore = new SamStore(new ApplePie()); Pie samStorePie = samStore.makePie(); samStorePie.getType(); Store jackStore = new JackStore(new CarrotPie()); Pie jackStorePie = jackStore.makePie(); jackStorePie.getType(); &#125;&#125;输出如下：1234山姆大叔的小店💒制作苹果派🍎🥧水果派杰克的小店💒制作胡萝卜派🥕🥧蔬菜沙拉派这个例子很好地体现了桥接模式的特点，UML图如下：代理模式为其他对象提供一种代理，以控制对这个对象的访问，代理对象在客户端和目标对象之间起到了中介的作用。适用于：保护目标对象；增强目标对象。优点：将代理对象和真实被调用的目标对象分离；降低耦合，拓展性好；保护目标对象，增强目标对象。缺点：造成类的数目增加，增加复杂度；客户端和目标对象增加代理对象，会造成处理速度变慢。静态代理通过在代码中显式地定义了一个代理类，在代理类中通过同名的方法对目标对象的方法进行包装，客户端通过调用代理类的方法来调用目标对象的方法。举个静态代理的例子：新建一个派的制作接口PieService：123public interface PieServcie &#123; void makePie();&#125;创建其实现类PieServiceImpl：12345public class PieServiceImpl implements PieServcie&#123; public void makePie() &#123; System.out.println("制作🥗派"); &#125;&#125;要对PieServiceImpl的makePie方法增强，我们需要创建一个代理对象PieServiceProxy：1234567891011121314151617181920public class PieServiceProxy &#123; private PieServcie pieServcie; public void makePie() &#123; beforeMethod(); pieServcie = new PieServiceImpl(); pieServcie.makePie(); afterMethod(); &#125; private void beforeMethod() &#123; System.out.println("准备材料"); &#125; private void afterMethod() &#123; System.out.println("保鲜"); &#125;&#125;在PieServiceProxy中我们创建了一个和PieServcie一致的同名方法makePie，方法内部调用了PieServiceImpl的makePie方法，并且在方法调用前调用了代理类的beforeMethod方法，方法调用后调用了代理类的afterMethod方法。创建客户端Application，测试：1234567public class Application &#123; public static void main(String[] args) &#123; PieServiceProxy proxy = new PieServiceProxy(); proxy.makePie(); &#125;&#125;输出：123准备材料制作🥗派保鲜这个例子的UML图如下：动态代理JDK的动态代理只能代理接口，通过接口的方法名在动态生成的代理类中调用业务实现类的同名方法。静态代理的缺点就是每需要代理一个类，就需要手写对应的代理类。这个问题可以用动态代理来解决。举个动态代理的例子：新建冰淇淋制作接口IceCreamService：123public interface IceCreamService &#123; void makeIceCream(String fruit);&#125;实现类IceCreamServiceImpl：123456public class IceCreamServiceImpl implements IceCreamService &#123; public void makeIceCream(String fruit) &#123; System.out.println("制作" + fruit + "🍦"); &#125;&#125;现在需要对IceCreamServiceImpl进行代理增强，如果使用静态代理，我们需要编写一个IceCreamServiceImplProxy类，使用动态代理的话，我们可以动态生成对应的代理类。创建DynamicProxy：12345678910111213141516171819202122232425262728public class DynamicProxy implements InvocationHandler &#123; // 代理的目标对象 private Object object; public DynamicProxy(Object object) &#123; this.object = object; &#125; public Object proxy() &#123; Class&lt;?&gt; clazz = object.getClass(); // 生成代理对象 return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; /** * @param proxy 动态生成的代理对象 * @param method 代理方法 * @param args 代理方法的方法参数 * @return 结果 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125;&#125;动态代理类通过实现InvocationHandler的invoke方法实现，proxy用于生成代理对象。剩下的步骤和静态代理类似，完善DynamicProxy：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DynamicProxy implements InvocationHandler &#123; // 代理的目标对象 private Object object; public DynamicProxy(Object object) &#123; this.object = object; &#125; public Object proxy() &#123; Class&lt;?&gt; clazz = object.getClass(); // 生成代理对象 return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; /** * @param proxy 动态生成的代理对象 * @param method 代理方法 * @param args 代理方法的方法参数 * @return 结果 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; beforeMethod(object); // 反射执行代理对象的目标方法 Object result = method.invoke(object, args); afterMethod(object); return result; &#125; private void beforeMethod(Object object) &#123; if (object instanceof PieServcie) &#123; System.out.println("准备派的材料"); &#125; else if (object instanceof IceCreamService) &#123; System.out.println("准备冰淇淋材料"); &#125; else &#123; throw new RuntimeException("暂不支持代理" + object.getClass() + "类型"); &#125; &#125; private void afterMethod(Object object) &#123; if (object instanceof PieServcie) &#123; System.out.println("保鲜派"); &#125; else if (object instanceof IceCreamService) &#123; System.out.println("保鲜冰淇淋"); &#125; else &#123; throw new RuntimeException("暂不支持代理" + object.getClass() + "类型"); &#125; &#125;&#125;创建客户端Application测试：1234567891011public class Application &#123; public static void main(String[] args) &#123; PieServcie pieServiceDynamicProxy = (PieServcie) new DynamicProxy(new PieServiceImpl()).proxy(); pieServiceDynamicProxy.makePie(); System.out.println("-----------------"); IceCreamService iceCreamServiceDynamicProxy = (IceCreamService) new DynamicProxy(new IceCreamServiceImpl()).proxy(); iceCreamServiceDynamicProxy.makeIceCream("🍓"); &#125;&#125;结果：1234567准备派的材料制作🥗派保鲜派-----------------准备冰淇淋材料制作🍓🍦保鲜冰淇淋可以看到，通过动态代理我们实现了目标方法增强，并且不需要手写目标类的代理对象。CGLib代理通过继承来实现，生成的代理类就是目标对象类的子类，通过重写业务方法来实现代理。Spring对代理模式的拓展当Bean有实现接口时，使用JDK动态代理；当Bean没有实现接口时，使用CGLib代理。可以通过以下配置强制使用CGLib代理：123spring: aop: proxy-target-class: true行为型模式模板方法模式模板方法模式定义了一个流程的骨架，由多个方法组成。并允许子类为一个或多个步骤提供实现。简而言之就是公共的不变的部分由父类统一实现，变化的部分由子类来个性化实现。优点：提高复用性；提高拓展性；符合开闭原则。缺点：类的数目增加；增加了系统实现的复杂度；父类添加新的抽象方法，所有子类都要改一遍。举个模板方法模式的例子。定义一个外卖的接口，包含下单、制作和打包配送三个步骤：12345678910111213141516171819202122232425public abstract class Takeaway &#123; final void order() &#123; System.out.println("下单"); &#125; final void packageSend() &#123; System.out.println("打包派送"); &#125; protected abstract void make(); protected boolean needTableware() &#123; return true; &#125; final void flow() &#123; this.order(); this.make(); if (needTableware()) &#123; System.out.println("赠送一次性餐具"); &#125; this.packageSend(); &#125;&#125;其中下单和打包配送行为是固定的，不同的是制作过程，所以order和packageSend方法提供了默认实现，并且由final修饰，子类不可重写。此外，我们还可以通过needTableware这个钩子方法来控制某些子类的定制化需求。新增BarbecueTakeaway继承Takeaway：123456789101112131415161718public class BarbecueTakeaway extends Takeaway &#123; private final boolean needTableware; public BarbecueTakeaway(boolean needTableware) &#123; this.needTableware = needTableware; &#125; @Override protected void make() &#123; System.out.println("制作烤肉"); &#125; @Override protected boolean needTableware() &#123; return this.needTableware; &#125;&#125;新增FruitTakeaway继承Takeaway：123456789101112public class FruitTakeaway extends Takeaway &#123; @Override protected void make() &#123; System.out.println("水果配货"); &#125; @Override protected boolean needTableware() &#123; return false; &#125;&#125;新增个客户端Application测试：12345678910public class Application &#123; public static void main(String[] args) &#123; Takeaway barbecue = new BarbecueTakeaway(true); barbecue.flow(); FruitTakeaway fruit = new FruitTakeaway(); fruit.flow(); &#125;&#125;1234567下单制作烤肉赠送一次性餐具打包派送下单水果配货打包派送UML：迭代器模式ignore策略模式策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化不会影响到使用算法的用户。策略模式常用于消除大量的if else代码。适用场景：系统有很多类，它们的区别仅仅在于行为不同；一个系统需要动态地在几种算法中选择一种；举个策略模式的例子（促销活动），定义一个促销策略接口：1234public interface PromotionStrategy &#123; void promotion();&#125;实现类之一（策略之一），满减促销策略：12345public class FullReductionPromotionStrategy implements PromotionStrategy &#123; public void promotion() &#123; System.out.println("满1000立减1"); &#125;&#125;实现类之一（策略之一），打折促销策略：12345public class DiscountPromotionStrategy implements PromotionStrategy &#123; public void promotion() &#123; System.out.println("9.9折钜惠"); &#125;&#125;创建一个客户端测试：12345678910111213141516public class Application &#123; public static void main(String[] args) &#123; // 模拟客户端传递的促销策略key String promotionKey = "fr"; PromotionStrategy strategy; if ("fr".equals(promotionKey)) &#123; strategy = new FullReductionPromotionStrategy(); &#125; else if ("ds".equals(promotionKey)) &#123; strategy = new DiscountPromotionStrategy(); &#125; else &#123; throw new RuntimeException("暂不支持该促销活动"); &#125; strategy.promotion(); &#125;&#125;输出结果：1满1000立减1策略模式常结合工厂模式来消除大量的if else代码，我们新建一个促销策略的创建工厂：123456789101112131415161718192021222324public class PromotionStrategyFactory &#123; private static final Map&lt;String, PromotionStrategy&gt; PROMOTION_STRATEGY_MAP = new HashMap&lt;&gt;(); private static final PromotionStrategy NON_PROMOTION = () -&gt; System.out.println("无促销活动"); static &#123; PROMOTION_STRATEGY_MAP.put(PromotionKey.FR, new FullReductionPromotionStrategy()); PROMOTION_STRATEGY_MAP.put(PromotionKey.DS, new DiscountPromotionStrategy()); &#125; private PromotionStrategyFactory() &#123; &#125; public static PromotionStrategy getPromotionStrategy(String promotionKey) &#123; PromotionStrategy strategy = PROMOTION_STRATEGY_MAP.get(promotionKey); return strategy == null ? NON_PROMOTION : strategy; &#125; private interface PromotionKey &#123; String FR = "fr"; String DS = "ds"; &#125;&#125;上面代码中，我们通过Map来装载促销策略，这样可以减少对象的重复创建。如果不希望在static块中一次性初始化所有促销策略，我们可以结合享元模式来推迟对象创建过程。通过这个工厂方法，上面客户端代码可以简写为：123456789public class Application &#123; public static void main(String[] args) &#123; // 模拟客户端传递的促销策略key String promotionKey = "fr"; PromotionStrategy promotionStrategy = PromotionStrategyFactory.getPromotionStrategy(promotionKey); promotionStrategy.promotion(); &#125;&#125;解释器模式用的较少，暂不记录。观察者模式观察者模式定义了对象之间的一对多依赖，让多个观察者同时监听某个主题对象，当主体对象发生变化时，它的所有观察者都会收到响应的通知。优点：观察者和被观察者之间建立一个抽象的耦合；观察者模式支持广播通信。缺点：观察者之间有过多的细节依赖，提高时间消耗及程序复杂度；应避免循环调用。JDK对观察者模式提供了支持。下面举个观察者模式的例子。创建一个博客类：1234567891011121314151617181920212223242526/** * 继承 Observable类，Blog为被观察对象 */public class Blog extends Observable &#123; private String title; public Blog(String title) &#123; this.title = title; &#125; public String getTitle() &#123; return title; &#125; public void comment(Comment comment) &#123; System.out.println(comment.getNickname() + "评论了&lt;" + this.title + "&gt; ，" + "评论内容：" + comment.getValue()); // 设置标识位 changed = true，表示被观察者发生了改变 setChanged(); // 通知观察者，可以给观察者传递数据 notifyObservers(comment); &#125;&#125;Comment类代码：1234567891011121314151617181920212223public class Comment &#123; /** * 评论者昵称 */ private String nickname; /** * 评论内容 */ private String value; public Comment(String nickname, String value) &#123; this.nickname = nickname; this.value = value; &#125; public String getValue() &#123; return value; &#125; public String getNickname() &#123; return nickname; &#125;&#125;Blog类是被观察者对象，被观察者对象需要继承JDK的Observable类，继承后，被观察者对象包含如下属性和方法：这些方法都是线程安全方法（加了synchronized同步锁）。Blog的comment方法中，当博客收到评论时，首先调用父类的setChanged()方法，设置标识位 changed = true，表示被观察者发生了改变；然后调用父类的notifyObservers(Object)方法通知所有观察者。被观察者对象创建好后，我们接着创建观察者。新建一个Author类：1234567891011121314151617181920212223public class Author implements Observer &#123; private String name; public Author(String name) &#123; this.name = name; &#125; /** * 观察者被通知后，就会调用这个方法 * * @param o 被观察者对象 * @param arg 被观察者传递过来的数据 */ @Override public void update(Observable o, Object arg) &#123; Blog blog = (Blog) o; Comment comment = (Comment) arg; System.out.println("系统感知到" + this.name + "撰写的博文&lt;" + blog.getTitle() + "&gt;收到了" + comment.getNickname() + "的评论，评论内容为：" + comment.getValue()); &#125;&#125;观察者对象需要实现JDK的Observer类，重写update方法。当被观察者对象调用了notifyObservers方法后，相应的观察者的update方法会被调用。新建一个客户端测试一下：1234567891011121314public class Application &#123; public static void main(String[] args) &#123; Blog blog = new Blog("Java从入门到放弃"); Author author = new Author("MrBird"); // 添加观察者 blog.addObserver(author); Comment comment = new Comment("Scott", "感谢楼主的文章，让我及时放弃Java，回家继承了千万家产。"); blog.comment(comment); &#125;&#125;程序输出如下：12Scott评论了&lt;Java从入门到放弃&gt; ，评论内容：感谢楼主的文章，让我及时放弃Java，回家继承了千万家产。系统感知到MrBird撰写的博文&lt;Java从入门到放弃&gt;收到了Scott的评论，评论内容为：感谢楼主的文章，让我及时放弃Java，回家继承了千万家产。值得注意的是，观察者的update方法里的逻辑最好进行异步化，这样在并发环境下可以提升程序性能。备忘录模式参考：https://www.cnblogs.com/jimoer/p/9537997.html。命令模式暂不记录。中介者模式暂不记录。职责链模式职责链模式为请求创建一个接收此次请求对象的链。适用于：一个请求的处理需要多个对象当中的一个或几个协作处理；优点：请求的发送者和接受者（请求的处理）解耦；职责链可以动态的组合。缺点：职责链太长或者处理时间过长，影响性能；职责链可能过多。举个字符串校验的例子。新建一个字符串校验抽象类：12345678910public abstract class StringValidator &#123; protected StringValidator validator; public void setNextValidator(StringValidator validator) &#123; this.validator = validator; &#125; public abstract void check(String value);&#125;StringValidator类包含了一个自身类型的成员变量，这也是该模式的设计核心，以此形成链条。创建一个校验字符串长度的类StringLengthValidator：12345678910111213public class StringLengthValidator extends StringValidator &#123; @Override public void check(String value) &#123; if (value != null &amp;&amp; value.length() != 0) &#123; System.out.println("字符串长度合法"); if (validator != null) &#123; validator.check(value); &#125; &#125; else &#123; System.out.println("字符串长度不合法"); &#125; &#125;&#125;上面代码中，在字符串长度校验合法后，我们判断父类的validator属性是否为空，不为空则调用其check方法继续下一步校验。接着再新建一个校验字符串内容的类StringValueValidator：12345678910111213public class StringValueValidator extends StringValidator &#123; @Override public void check(String value) &#123; if (value.contains("fuck")) &#123; System.out.println("字符串值不合法"); if (validator != null) &#123; validator.check(value); &#125; &#125; else &#123; System.out.println("字符串值合法"); &#125; &#125;&#125;套路和StringLengthValidator一样。接着创建一个客户端类，演示下如何让校验类形成一个链条：12345678910public class Application &#123; public static void main(String[] args) &#123; StringValidator lengthValidator = new StringLengthValidator(); StringValidator valueValidator = new StringValueValidator(); lengthValidator.setNextValidator(valueValidator); lengthValidator.check("hello"); &#125;&#125;上面代码中，通过StringValidator的setNextValidator方法，我们可以指定下一个校验类，以此形成链条，程序输出如下：12字符串长度合法字符串值合法访问者模式暂不记录🌚状态模式暂不记录🌚参考连接：https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka API使用]]></title>
    <url>%2FKafka-API%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[本节演示如何通过Java代码创建Kafka生产者、消费者和拦截器，依赖使用Kafka-clients。因为我安装的Kafka版本为2.4.1，所以依赖的版本也用2.4.1，避免兼容问题。新增一个maven项目，引入：12345&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;生产者APIKafka 的 Producer 发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator。main 线程将消息发送给 RecordAccumulator，Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Kafka broker。简单发送数据创建ProducerDemo类，编写一个简单的生产者：123456789101112131415161718192021222324252627282930public class ProducerDemo &#123; public static void main(String[] args) &#123; // 1. 生产者配置 Properties properties = new Properties(); // 指定kafka地址 properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); // 指定ack等级 properties.put(ProducerConfig.ACKS_CONFIG, "all"); // 指定重试次数，即生产者发送数据后没有收到ack应答时的重试次数 properties.put(ProducerConfig.RETRIES_CONFIG, 3); // 指定批次大小 16k = 16 * 1024 properties.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384); // 指定等待时间，单位毫秒 properties.put(ProducerConfig.LINGER_MS_CONFIG, 1); // 指定RecordAccumulator缓冲区大小 32m = 32 * 1024 * 1024 properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432); // 指定k-v序列化规则 properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer"); properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer"); // 2. 创建生产者 KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(properties); // 3. 准备数据 ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("test", "mesage"); // 4. 发送数据（不带回调） producer.send(record); // 5. 关闭连接 producer.close(); &#125;&#125;无论是创建生产者还是消费者，我们都要指定配置。生产者配置可以使用常量类ProducerConfig指定，里面包含了生产者所有可用配置，并且包含对应的解释：上面代码创建了一个kv都是String类型的生产者。配置了Kafka的地址，ack等级为all（在Kafka生产者一节中介绍过了，不赘述），重试次数为3。并且指定了生产者发送数据的批次为16k，等待时间为1ms。也就是说，要么发送的数据量达到了16k，要么等待时间超过了1ms才会真正地把数据发往Kafka。此外，我们还指定RecordAccumulator缓冲区大小，kv序列化规则采用StringSerializer。Kafka消息使用KafkaProducer对象表示，他有6个重载构造器，这在Kafka生产者介绍过了，这里我们指定了主题为test，消息内容为message。运行这段代码之前，我们先启动zk和kafka：123456# 启动zksh bin/zookeeper-server-start.sh config/zookeeper.properties# 启动kafka brokersh bin/kafka-server-start.sh config/server.properties# 启动kafka消费者sh bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test然后运行上面的程序，观察消费者输出：带回调函数KafkaProducer的send方法可以制定回调函数。回调函数会在 producer 收到 ack 时调用，为异步调用，该方法有两个参数，分别是RecordMetadata 和 Exception，如果 Exception 为 null，说明消息发送成功，如果Exception 不为 null，说明消息发送失败。改造上面的send方法：1234567891011121314151617...// 3. 准备数据ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("test", "callback-test");// 4. 发送数据（带回调）producer.send(record, (metadata, exception) -&gt; &#123; if (exception == null) &#123; // 回调函数，该方法会在 Producer 收到 ack 时调用，为异步调用 String result = String.format("消息发送成功，主题Topic: %s,分区Partition: %s,偏移量Offset: %s", metadata.topic(), metadata.partition(), metadata.offset()); System.out.println(result); &#125; else &#123; System.out.println("消息发送失败"); exception.printStackTrace(); &#125;&#125;);...运行该方法，控制台输出如下：1消息发送成功，主题Topic: test,分区Partition: 0,偏移量Offset: 4消费者：同步发送如前面所说，Kafka 的 Producer 发送消息采用的是异步发送的方式，KafkaProducer的send方法返回Future对象，所以我们可以手动调用Future对象的get方法实现同步：12345678910111213141516// 3. 准备数据ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("test", "test-sync");// 4. 发送数据（带回调）Future&lt;RecordMetadata&gt; future = producer.send(record, (metadata, exception) -&gt; &#123; if (exception == null) &#123; // 回调函数，该方法会在 Producer 收到 ack 时调用，为异步调用 String result = String.format("消息发送成功，主题Topic: %s,分区Partition: %s,偏移量Offset: %s", metadata.topic(), metadata.partition(), metadata.offset()); System.out.println(result); &#125; else &#123; System.out.println("消息发送失败"); exception.printStackTrace(); &#125;&#125;);future.get();自定义分区器自定义分区器只需要要实现Partitioner接口：123456789101112131415161718public class MyPartitioner implements Partitioner &#123; @Override public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123; return 0; &#125; @Override public void close() &#123; &#125; @Override public void configure(Map&lt;String, ?&gt; configs) &#123; &#125;&#125;partition方法中，我们可以根据主题topic，key值，序列化后的key值，value值，序列化后的value值，Kafka集群cluster信息，来个性化分区规则。要使用自定义分区器，可通过配置类指定：12// 指定自定义分区器properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class);消费者APIConsumer 消费数据时的可靠性是很容易保证的，因为数据在 Kafka 中是持久化的，故不用担心数据丢失问题。由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢复后继续消费。所以 offset 的维护是 Consumer 消费数据是必须考虑的问题。自动提交offset创建一个消费者，自动提交offset，演示消息消费：1234567891011121314151617181920212223242526272829public class ConsumerDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 1. 消费者配置 Properties properties = new Properties(); properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); // 自动提交offset properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, true); // 提交offset的时间，单位ms，即1秒钟提交一次 properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, "1000"); // 指定k-v反序列化规则 properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); // 指定消费者组 properties.put(ConsumerConfig.GROUP_ID_CONFIG, "my-group"); // 2. 创建消费者 KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(properties); // 订阅主题 consumer.subscribe(Collections.singletonList("test")); while (true)&#123; // 拉取数据，指定轮询时间为1秒 ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofSeconds(1)); for (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123; System.out.println(consumerRecord.toString()); &#125; TimeUnit.SECONDS.sleep(1); &#125; &#125;&#125;启动消费者，然后再使用生产者发送mrbird消息到test主题，消费者控制台输出如下：1ConsumerRecord(topic = test, partition = 0, leaderEpoch = 0, offset = 6, CreateTime = 1585811850841, serialized key size = -1, serialized value size = 6, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = mrbird)手动提交offset虽然自动提交 offset 十分便利，但由于其是基于时间提交的，开发人员难以把握 offset 提交的时机。因此 Kafka 还提供了手动提交 offset 的 API。手动提交 offset 的方法有两种：分别是 commitSync（同步提交）和 commitAsync（异步提交）。两者的相同点是，都会将本次 poll 的一批数据最高的偏移量提交；不同点是，commitSync 阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致，也会出现提交失败）；而 commitAsync 则没有失败重试机制，故有可能提交失败。由于同步提交 offset 有失败重试机制，故更加可靠，以下为同步提交 offset 的示例：1234567891011121314151617181920212223242526272829public class ConsumerDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 1. 消费者配置 Properties properties = new Properties(); properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); // 关闭自动提交offset properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false); // 指定k-v反序列化规则 properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); // 指定消费者组 properties.put(ConsumerConfig.GROUP_ID_CONFIG, "my-group"); // 2. 创建消费者 KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(properties); // 订阅主题 consumer.subscribe(Collections.singletonList("test")); while (true) &#123; // 拉取数据，指定轮询时间为1秒 ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofSeconds(1)); for (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123; System.out.println(consumerRecord.toString()); &#125; // 同步提交 consumer.commitSync(); TimeUnit.SECONDS.sleep(1); &#125; &#125;&#125;commitSync()也可以指定超时时间。虽然同步提交 offset 更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。更多的情况下，会选用异步提交 offset 的方式。以下为异步提交 offset 的示例：12345678910111213141516171819202122232425262728293031public class ConsumerDemo &#123; public static void main(String[] args) throws InterruptedException &#123; // 1. 消费者配置 Properties properties = new Properties(); properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); // 关闭自动提交offset properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false); // 提交offset的时间，单位ms，即1秒钟提交一次 properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, "1000"); // 指定k-v反序列化规则 properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringDeserializer"); // 指定消费者组 properties.put(ConsumerConfig.GROUP_ID_CONFIG, "my-group"); // 2. 创建消费者 KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(properties); // 订阅主题 consumer.subscribe(Collections.singletonList("test")); while (true)&#123; // 拉取数据，指定轮询时间为1秒 ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofSeconds(1)); for (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123; System.out.println(consumerRecord.toString()); &#125; // 异步提交 consumer.commitAsync(); TimeUnit.SECONDS.sleep(1); &#125; &#125;&#125;commitAsync()可以指定回调：12345678consumer.commitAsync((offsets, exception) -&gt; &#123; if (exception == null) &#123; System.out.println("提交offset: " + offsets + "成功"); &#125; else &#123; System.out.println("提交失败"); exception.printStackTrace(); &#125;&#125;);无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先提交 offset 后消费，有可能造成数据的漏消费；而先消费后提交 offset，有可能会造成数据的重复消费。拦截器Producer 拦截器(interceptor)是在 Kafka 0.10 版本被引入的，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer 允许用户指定多个 interceptor按顺序形成一个拦截器链(interceptor chain)。Intercetpor 的实现接口是 org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：configure(configs)：获取配置信息和初始化数据时调用；onSend(ProducerRecord)：在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好不要修改消息所属的 topic 和分区，否则会影响目标分区的计算；onAcknowledgement(RecordMetadata, Exception)：在返回ack时，或者发送失败时调用该方法。close：关闭 interceptor，主要用于执行一些资源清理工作。下面举个自定义拦截器的例子：定义一个拦截器链，包含两个拦截器MessageFormatInterceptor和CountInterceptor，分别用于消息加工和统计消息发送成功和失败的笔数。定义MessageFormatInterceptor：12345678910111213141516171819202122public class MessageFormatInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123; @Override public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123; return new ProducerRecord&lt;&gt;(record.topic(), record.partition(), record.timestamp(), record.key(), System.currentTimeMillis() + " - " + record.value()); &#125; @Override public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123; &#125; @Override public void close() &#123; &#125; @Override public void configure(Map&lt;String, ?&gt; configs) &#123; &#125;&#125;定义CountInterceptor：123456789101112131415161718192021222324252627282930public class CountInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123; private int errorCounter = 0; private int successCounter = 0; @Override public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123; return record; &#125; @Override public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123; if (exception == null) &#123; successCounter++; &#125; else &#123; errorCounter++; &#125; &#125; @Override public void close() &#123; System.out.println("成功笔数: " + successCounter); System.out.println("失败笔数: " + errorCounter); &#125; @Override public void configure(Map&lt;String, ?&gt; configs) &#123; &#125;&#125;其实这两个功能完全可以由一个过滤器来完成，这里仅仅是为了演示过滤器链。在生产者配置中指定这个过滤器链：12345678910111213141516171819202122232425262728293031323334public class ProducerDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 1. 生产者配置 Properties properties = new Properties(); // 指定kafka地址 properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"); // 指定ack等级 properties.put(ProducerConfig.ACKS_CONFIG, "all"); // 指定重试次数，即生产者发送数据后没有收到ack应答时的重试次数 properties.put(ProducerConfig.RETRIES_CONFIG, 3); // 指定批次大小 16k = 16 * 1024 properties.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384); // 指定等待时间，单位毫秒 properties.put(ProducerConfig.LINGER_MS_CONFIG, 1); // 指定RecordAccumulator缓冲区大小 32m = 32 * 1024 * 1024 properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432); // 指定k-v序列化规则 properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer"); properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, "org.apache.kafka.common.serialization.StringSerializer"); // 指定过滤器链 properties.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, Arrays.asList("cc.mrbird.kafka.MessageFormatInterceptor", "cc.mrbird.kafka.CountInterceptor")); // 2. 创建生产者 KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(properties); // 3. 准备数据 ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;("test", "kafka"); // 4. 发送数据 producer.send(record); // 5. 关闭连接 producer.close(); &#125;&#125;运行程序，控制台输出：12成功笔数: 1失败笔数: 0消费者：「尚硅谷大数据技术之 Kafka」 学习笔记]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka消费者]]></title>
    <url>%2FKafka%E6%B6%88%E8%B4%B9%E8%80%85.html</url>
    <content type="text"><![CDATA[Kafka消费者采用pull拉模式从broker中消费数据。与之相对的push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。消费者组消费者组（consumer group）与消费者之间密切相关。在Kafka中，多个消费者可以共同构成一个消费者组，而一个消费者只能从厲于一个消费者组，消费者组最为重要的一个功能是实现广播与单播的功能。一个消费者组可以确保其所订阅的Topic的每个分区只能被从属于该消费者组中的唯一一个消费者所消费；如果不同的消费者组订阅了同一个Topic，那么这些消费者组之间是彼此独立的，不会受到相互的干扰。因此，如果我们希望一条消思可以被多个消费者所消费，那么可以将这些消费者放到不同的消费者组中，这实际上就是广播的效果；如果希望一条消息只能被一个消费者所消费，那么可以将这些消费者放到同一个消费者组中，这实际上就是单播的效果。分区分配策略一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以必然会涉及到 partition 的分配问题，即确定那个 partition 由哪个 consumer 来消费。Kafka 有两种分配策略，一是 RoundRobin，一是 Range。RoundRobinRoundRobin即轮询的意思，比如现在有一个三个消费者ConsumerA、ConsumerB和ConsumerC组成的消费者组，同时消费TopicA主题消息，TopicA分为7个分区，如果采用RoundRobin分配策略，过程如下所示：这种轮询的方式应该很好理解。但如果消费者组消费多个主题的多个分区，会发生什么情况呢？比如现在有一个两个消费者ConsumerA和ConsumerB组成的消费者组，同时消费TopicA和TopicB主题消息，如果采用RoundRobin分配策略，过程如下所示：注：TAP0表示TopicA Partition0分区数据，以此类推。这种情况下，采用RoundRobin算法分配，多个主题会被当做一个整体来看，这个整体包含了各自的Partition，比如在Kafka-clients依赖中，与之对应的对象为TopicPartition。接着将这些TopicPartition根据其哈希值进行排序，排序后采用轮询的方式分配给消费者。但这会带来一个问题：假如上图中的消费者组中，ConsumerA只订阅了TopicA主题，ConsumerB只订阅了TopicB主题，采用RoundRobin轮询算法后，可能会出现ConsumerA消费了TopicB主题分区里的消息，ConsumerB消费了TopicA主题分区里的消息。综上所述，RoundRobin算法只适用于消费者组中消费者订阅的主题相同的情况。同时会发现，采用RoundRobin算法，消费者组里的消费者之间消费的消息个数最多相差1个。RangeKafka默认采用Range分配策略，Range顾名思义就是按范围划分的意思。比如现在有一个三个消费者ConsumerA、ConsumerB和ConsumerC组成的消费者组，同时消费TopicA主题消息，TopicA分为7个分区，如果采用Range分配策略，过程如下所示：假如现在有一个两个消费者ConsumerA和ConsumerB组成的消费者组，同时消费TopicA和TopicB主题消息，如果采用Range分配策略，过程如下所示：Range算法并不会把多个主题分区当成一个整体。从上面的例子我们可以总结出Range算法的一个弊端：那就是同一个消费者组内的消费者消费的消息数量相差可能较大。offset维护offset由消息的主题Topic+分区Partition和消费者组名称唯一确定。由于 consumer 在消费过程中可能会出现断电宕机等故障，consumer 恢复后，需要从故 障前的位置的继续消费，所以 consumer 需要实时记录自己消费到了哪个 offset，以便故障恢 复后继续消费。Kafka 0.9 版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从 0.9 版本开始， consumer 默认将 offset 保存在 Kafka 一个内置的 topic 中，该 topic 为__consumer_offsets。「尚硅谷大数据技术之 Kafka」 学习笔记]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka生产者]]></title>
    <url>%2FKafka%E7%94%9F%E4%BA%A7%E8%80%85.html</url>
    <content type="text"><![CDATA[Kafka生产者用于生产消息。通过前面的内容我们知道，Kafka的topic可以有多个分区，那么生产者如何将这些数据可靠地发送到这些分区？生产者发送数据的不同的分区的依据是什么？针对这两个疑问，这节简单记录下。为何要分区方便在集群中扩展，每个分区Partition可以通过调整以适应它所在的机器，而一个 topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；可以提高并发，因为Kafka可以以Partition为单位进行读写。生产者发送数据到不同分区的依据以Kafka-clients依赖为例，生产者生产的消息通过ProducerRecord对象表示，其重载了6个构造方法：123456public ProducerRecord (String topic, Integer partition, Long timestamp, K key, V value, Iterable&lt;Header&gt; headers)public ProducerRecord (String topic, Integer partition, Long timestamp, K key, V value)public ProducerRecord (String topic, Integer partition, K key, V value, Iterable&lt;Header&gt; headers)public ProducerRecord (String topic, Integer partition, K key, V value)public ProducerRecord (String topic, K key, V value)public ProducerRecord (String topic, V value)指明 partition 的情况下，直接将指明的值直接作为 partiton 值；没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值。所以，如果希望某组消息在Kafka集群全局有序，可以通过指定相同的消息key来实现；既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后 面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。数据可靠性的保证数据可靠性指的是： producer 发送的数据，能可靠的发送到指定的 topic。acktopic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。副本同步策略主要有如下两种：策略优点缺点半数以上完成同步，就发送 ack延迟低选举新的 leader 时，容忍 n 台节点的故障，需要 2n+1 个副本全部完成同步，才发送ack选举新的 leader 时，容忍 n 台节点的故障，需要 n+1 个副本延迟高Kafka 选择了第二种方案，原因如下：同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而 Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等所有 follower 全部接收成功，于是 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的acks 参数配置：0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还 没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据；1：producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据；-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才 返回 ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会造成数据重复。ISR由于Kafka副本同步策略选择的是表格中的第二种，即等待所有follower副本同步完成，才发送ack，那么就会带来如下问题，设想下：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢？Leader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集 合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间未向 leader 同步数据 ， 则该 follower 将被踢出ISR ， 该时间阈值由replica.lag.time.max.ms参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。数据一致性问题由于我们并不能保证Kafka集群中每时每刻follower的长度都和leader一致（即数据同步是有时延的），那么当leader挂掉选举某个follower为新的leader的时候（原先挂掉的leader恢复了成为了follower），可能会出现leader的数据比follower还少的情况。为了解决这种数据量不一致带来的混乱情况，Kafka提出了以下概念：LEO（Log End Offset）：指的是每个副本最后一个offset；HW（High Wather）：指的是消费者能见到的最大的 offset，ISR 队列中最小的 LEO。消费者和leader通信时，只能消费HW之前的数据，HW之后的数据对消费者不可见。针对这个规则：当follower发生故障时：follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。当leader发生故障时：leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。所以数据一致性并不能保证数据不丢失或者不重复，这是由ack控制的。HW规则只能保证副本之间的数据一致性！Exactly Once将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被 发送一次，即 At Most Once 语义。At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说 交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。在 0.11 版 本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局 去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。 0.11 版本的 Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 Producer 不论 向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语 义，就构成了 Kafka 的 Exactly Once 语义。即：At Least Once + 幂等性 = Exactly Once要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。Kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的 Producer 在 初始化的时候会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。而 Broker 端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker 只 会持久化一条。但是 Producer重启后，其 PID 就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨 分区跨会话的 Exactly Once。生产者事务Kafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID。为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。「尚硅谷大数据技术之 Kafka」 学习笔记]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka存储机制]]></title>
    <url>%2FKafka%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[Kafka中消息是以topic进行分类的，生产者生产消息，消费者消费消息，都是面向topic。topic是逻辑上的概念，而partition是物理上的概念，每个partition对应于一个log文件，该log文件中存储的就是producer生产的数据。Producer生产的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错恢复时，从上次的位置继续消费。topic构成在Kafka中，一个topic可以分为多个partition，一个partition分为多个segment，每个segment对应两个文件：.index和.log文件：消息存储原理由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了分片和索引机制，将每个partition分为多个segment。如前面所说，每个segment对应.index文件和.log文件。这些文件位于一个以特定规则命名的文件夹下，该文件夹的命名 规则为：topic 名称 + 分区序号。例如，我们在上一节创建了一个名称为test的topic，该topic只有一个分区，所以在Kafka日会志目录下会有个名为test-0的文件夹：这些文件的含义如下：类别作用.index偏移量索引文件，存储数据对应的偏移量.timestamp时间戳索引文件.log日志文件，存储生产者生产的数据.snaphot快照文件Leader-epoch-checkpoint保存了每一任leader开始写入消息时的offset，会定时更新。 follower被选为leader时会根据这个确定哪些消息可用index和log文件以当前segment的第一条消息的偏移量offset命名。偏移量offset是一个64位的长整形数，固定是20位数字，长度未达到，用0进行填补，索引文件和日志文件都由该作为文件名命名规则。所以从上图可以看出，我们的偏移量是从0开始的，.index和.log文件名称都为00000000000000000000。上节中，我们通过生产者发送了hello和world两个数据，所以我们可以查看下.log文件下是否有这两条数据：内容存在一些”乱码“，因为数据是经过序列化压缩的。那么数据文件.log大小有限制吗，能保存多久时间？这些我们都可以通过Kafka目录下conf/server.properties配置文件修改：12345# log文件存储时间，单位为小时，这里设置为1周log.retention.hours=168# log文件大小的最大值，这里为1g，超过这个值，则会创建新的segment（也就是新的.index和.log文件）log.segment.bytes=1073741824比如，当生产者生产数据量较多，一个segment存储不下触发分片时，在日志topic目录下你会看到类似如下所示的文件：12345600000000000000000000.index00000000000000000000.log00000000000000170410.index00000000000000170410.log00000000000000239430.index00000000000000239430.log下图展示了Kafka查找数据的过程：比如现在要查找偏移量offset为3的消息，根据.index文件命名我们可以知道，offset为3的索引应该从00000000000000000000.index里查找。根据上图所示，其对应的索引地址为756~911，所以Kafka将读取00000000000000000000.log 756~911区间的数据。「尚硅谷大数据技术之 Kafka」 学习笔记]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka入门]]></title>
    <url>%2FKafka%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[Kafka是一个分布式的基于发布/订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。消息队列模式点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）。消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。 消息被消费以后，queue 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。 Queue 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。发布/订阅模式（一对多，消费者消费数据之后不会清除消息）。消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。Kafka属于第2种模式。Kafka架构Producer ：消息生产者，就是向 kafka broker 发消息的客户端；Consumer ：消息消费者，向 kafka broker 取消息的客户端；Consumer Group （CG）：消费者组，由多个 consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由消费者组中的一个消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者；Broker ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker可以容纳多个topic；Topic ：可以理解为一个队列，生产者和消费者面向的都是一个 topic；Partition：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列；Replica：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。follower：每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 会成为新的follower。对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，offset用来唯一的标识分区中每一条记录。Kafka每个分区的数据是严格有序的，但多分区之间不能确保有序。安装与启动演示在unix环境下安装与启动Kafka。Kafka下载地址：http://kafka.apache.org/downloads，选择二进制文件下载（Binary downloads），然后解压即可。Kafka的配置文件位于config目录下，因为Kafka集成了Zookeeper，所以config目录下除了有Kafka的配置文件server.properties外，还可以看到一个Zookeeper配置文件zookeeper.properties。在启动Kafka和Zookeeper之前，我们先在Kafka解压目录下创建如下两个日志目录：1mkdir /Users/mrbird/software/kafka_2.4.1/logs/kafka-logs mkdir /Users/mrbird/software/kafka_2.4.1/logs/zk-logs分别用于存放Kafka和Zookeeper日志。修改config/zookeeper.properties：修改config/server.properties server.properties更多可用配置及含义如下：1234567891011121314151617181920#broker 的全局唯一编号，不能重复broker.id=0#删除 topic 功能使能delete.topic.enable=true#处理网络请求的线程数量num.network.threads=3#用来处理磁盘 IO 的现成数量num.io.threads=8#发送套接字的缓冲区大小socket.send.buffer.bytes=102400#接收套接字的缓冲区大小socket.receive.buffer.bytes=102400#请求套接字的缓冲区大小socket.request.max.bytes=104857600#topic 在当前 broker 上的分区个数num.partitions=1#用来恢复和清理 data 下数据的线程数量num.recovery.threads.per.data.dir=1#segment 文件保留的最长时间，超时将被删除log.retention.hours=168修改好后，我们便可以启动Kafka了。1.启动Zookeeper1sh bin/zookeeper-server-start.sh config/zookeeper.properties如果要在后台启动Zookeeper，则可以使用：1sh bin/zookeeper-server-start.sh -daemon config/zookeeper.properties2.启动Kafka1sh bin/kafka-server-start.sh config/server.properties3.创建topic1sh bin/kafka-topics.sh --zookeeper localhost:2181 --create --replication-factor 1 --partitions 1 --topic test–create 创建–topic 指定 topic 名–replication-factor 定义副本数–partitions 定义分区数上面创建了一个名称为test的topic，副本数和分区数都是1。4.启动生产者1sh bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test9092为生产者的默认端口号，指定topic为刚刚创建的test。5.启动消费者1sh bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning–from-beginning：会把主题中以往所有的数据都读取出来。启动好生产者和消费者后我们在生产者里生产几条数据:消费者成功接收到数据：常用命令查看当前服务器中的所有 topic：1sh bin/kafka-topics.sh --zookeeper localhsot:2181 --list删除 topic：1sh bin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic test需要 server.properties 中设置delete.topic.enable=true否则只是标记删除。查看某个 Topic 的详情：1sh bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic test修改分区数：1sh bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic test --partitions 2ZK的作用Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所有 topic 的分区副本分配和 leader 选举等工作。Controller 的管理工作都是依赖于 Zookeeper 的。「尚硅谷大数据技术之 Kafka」 学习笔记]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Sentinel @SentinelResource]]></title>
    <url>%2FSpring-Cloud-Alibaba-Sentinel-SentinelResource.html</url>
    <content type="text"><![CDATA[Sentinel提供了@SentinelResource注解用于定义资源，并提供可选的异常回退和Block回退。异常回退指的是@SentinelResource注解标注的方法发生Java异常时的回退处理；Block回退指的是当@SentinelResource资源访问不符合Sentinel控制台定义的规则时的回退（默认返回Blocked by Sentinel (flow limiting)）。这节简单记录下该注解的用法。框架搭建使用IDEA创建一个maven项目，artifactId为spring-cloud-alibaba-sentinelresource，然后在其下面创建两个Module（Spring Boot项目），artifactId分别为consumer和provider，充当服务消费端和服务提供端，项目结构如下图所示：spring-cloud-alibaba-sentinelresource的pom内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinelresource&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;modules&gt; &lt;module&gt;provider&lt;/module&gt; &lt;module&gt;consumer&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt; &lt;com-alibaba-cloud.version&gt;2.2.0.RELEASE&lt;/com-alibaba-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;com-alibaba-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt;引入了spring-boot-starter-web和spring-cloud-alibaba-nacos-discovery Nacos服务注册发现依赖。provider的pom的内容如下所示：12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinelresource&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;name&gt;provider&lt;/name&gt; &lt;description&gt;服务提供者&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;consumer的pom内容如下：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinelresource&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;consumer&lt;/artifactId&gt; &lt;name&gt;consumer&lt;/name&gt; &lt;description&gt;服务消费者&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;因为要演示在消费端使用@SentinelResource注解，所以我们引入了spring-cloud-starter-alibaba-sentinel依赖。provider的配置文件application.yml内容如下：12345678server: port: 8081spring: application: name: provider cloud: nacos: server-addr: localhost:8848配置了端口号，服务名和nacos地址。consumer的配置文件application.yml内容如下：123456789101112server: port: 9091spring: application: name: consumer cloud: nacos: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8080 port: 8719配置了端口号，服务名，nacos地址和sentinel控制台地址等。基本用法我们在provider下添加一个REST资源。在provider的cc.mrbird.provider目录下新建controller包，然后在该包下新建GoodsController：123456789@RestController@RequestMapping("goods")public class GoodsController &#123; @GetMapping("buy/&#123;name&#125;/&#123;count&#125;") public String buy(@PathVariable String name, @PathVariable Integer count) &#123; return String.format("购买%d份%s", count, name); &#125;&#125;接着在consumer端通过Ribbon消费这个资源。在consumer的启动类ConsumerApplication里注册RestTemplate：12345678910111213@SpringBootApplicationpublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125;在consumer的cc.mrbird.consumer下新建controller包，然后在该包下新建BuyController：12345678910111213141516171819202122232425262728293031@RestControllerpublic class BuyController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("buy/&#123;name&#125;/&#123;count&#125;") @SentinelResource(value = "buy", fallback = "buyFallback", blockHandler = "buyBlock") public String buy(@PathVariable String name, @PathVariable Integer count) &#123; if (count &gt;= 20) &#123; throw new IllegalArgumentException("购买数量过多"); &#125; if ("miband".equalsIgnoreCase(name)) &#123; throw new NullPointerException("已售罄"); &#125; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(2); params.put("name", name); params.put("count", count); return this.restTemplate.getForEntity("http://provider/goods/buy/&#123;name&#125;/&#123;count&#125;", String.class, params).getBody(); &#125; // 异常回退 public String buyFallback(@PathVariable String name, @PathVariable Integer count, Throwable throwable) &#123; return String.format("【进入fallback方法】购买%d份%s失败，%s", count, name, throwable.getMessage()); &#125; // sentinel回退 public String buyBlock(@PathVariable String name, @PathVariable Integer count, BlockException e) &#123; return String.format("【进入blockHandler方法】购买%d份%s失败，当前购买人数过多，请稍后再试", count, name); &#125;&#125;在buy方法中，我们通过Ribbon的RestTemplate访问provider的/goods/buy接口。当count参数大于20或者name参数的值为miband的时候，方法将抛出异常。buy方法上使用@SentinelResource注解标注，标识为一个sentinel资源，资源名称为buy，并且配置了fallback方法和blockHandler方法。如前面所说，当buy方法本身抛出异常时，会进入fallback指定的回退方法中；当buy方法调用不符合sentinel控制台规定的规则（如流控规则，降级规则等）时，会进入blockHander指定的block方法中。为了确保成功地进入回退方法（成功反射），它们必须满足以下规则：函数访问范围需要是public；Fallback函数，函数签名与原函数一致或末尾加一个Throwable类型的参数；Block异常处理函数，参数最后多一个BlockException，其余与原函数一致。启动provider、consumer、nacos和sentinel控制台，浏览器访问：http://localhost:9091/buy/ipad/2：我们在sentinel控制台中添加如下流控规则：QPS阈值为2。然后快速访问http://localhost:9091/buy/ipad/2：可以看到，当方法访问不符合sentinel控制台规则时，进入的是blockHandler指定的回退方法。如果访问：http://localhost:9091/buy/ipad/21 或者：http://localhost:9091/buy/miband/2方法自身抛出异常引发回退，进入的是fallback指定的回退方法。其他属性在当前类中编写回退方法会使得代码变得冗余耦合度高，我们可以将回退方法抽取出来到一个指定类中。在cc.mrbird.consumer包下新建reveal包，然后在该包下新建BuyBlockHandler：1234567public class BuyBlockHandler &#123; // sentinel回退 public static String buyBlock(@PathVariable String name, @PathVariable Integer count, BlockException e) &#123; return String.format("【进入blockHandler方法】购买%d份%s失败，当前购买人数过多，请稍后再试", count, name); &#125;&#125;可以看到我们只是将buyBlock方法挪到了BuyBlockHandler中，不过这里的方法必须是static的。接着新建BuyFallBack：1234567public class BuyFallBack &#123; // 异常回退 public static String buyFallback(@PathVariable String name, @PathVariable Integer count, Throwable throwable) &#123; return String.format("【进入fallback方法】购买%d份%s失败，%s", count, name, throwable.getMessage()); &#125;&#125;这样BuyController的代码就可以精简为：1234567891011121314151617181920212223242526@RestControllerpublic class BuyController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("buy/&#123;name&#125;/&#123;count&#125;") @SentinelResource(value = "buy", fallback = "buyFallback", fallbackClass = BuyFallBack.class, blockHandler = "buyBlock", blockHandlerClass = BuyBlockHandler.class ) public String buy(@PathVariable String name, @PathVariable Integer count) &#123; if (count &gt;= 20) &#123; throw new IllegalArgumentException("购买数量过多"); &#125; if ("miband".equalsIgnoreCase(name)) &#123; throw new NullPointerException("已售罄"); &#125; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(2); params.put("name", name); params.put("count", count); return this.restTemplate.getForEntity("http://provider/goods/buy/&#123;name&#125;/&#123;count&#125;", String.class, params).getBody(); &#125;&#125;fallbackClass和blockHandlerClass指定回退方法所在的类。此外我们也可以当遇到某个类型的异常时，不进行回退。比如：123456789101112131415161718192021222324252627@RestControllerpublic class BuyController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("buy/&#123;name&#125;/&#123;count&#125;") @SentinelResource(value = "buy", fallback = "buyFallback", fallbackClass = BuyFallBack.class, blockHandler = "buyBlock", blockHandlerClass = BuyBlockHandler.class, exceptionsToIgnore = NullPointerException.class ) public String buy(@PathVariable String name, @PathVariable Integer count) &#123; if (count &gt;= 20) &#123; throw new IllegalArgumentException("购买数量过多"); &#125; if ("miband".equalsIgnoreCase(name)) &#123; throw new NullPointerException("已售罄"); &#125; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(2); params.put("name", name); params.put("count", count); return this.restTemplate.getForEntity("http://provider/goods/buy/&#123;name&#125;/&#123;count&#125;", String.class, params).getBody(); &#125;&#125;exceptionsToIgnore指定，当遇到空指针异常时，不回退。重启consumer，浏览器访问：http://localhost:9091/buy/miband/2：可以看到，此次并没有进行回退，而是直接返回error page。本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/78.spring-cloud-alibaba-sentinelresource]]></content>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Cloud Alibaba</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Sentinel控制台详解]]></title>
    <url>%2FSentinel%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[Sentinel提供一个轻量级的开源控制台，它提供机器发现以及健康情况管理、监控（单机和集群），规则管理和推送的功能。本节将详细记录何如通过Sentinel控制台控制Sentinel客户端的各种行为。Sentinel控制台的功能主要包括：流量控制、降级控制、热点配置、系统规则和授权规则等。安装控制台Sentinel控制台下载地址：https://github.com/alibaba/Sentinel/releases，本节我们下载sentinel-dashboard-1.7.1.jar版本，下载好后使用java -jar sentinel-dashboard-1.7.1.jar命令启动即可，默认的端口号为8080：账号密码都是sentinel。更多可用的启动参数配置：Dsentinel.dashboard.auth.username=sentinel用于指定控制台的登录用户名为 sentinel；Dsentinel.dashboard.auth.password=123456用于指定控制台的登录密码为 123456，如果省略这两个参数，默认用户和密码均为 sentinel；Dserver.servlet.session.timeout=7200用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟；-Dcsp.sentinel.dashboard.server=consoleIp:port指定控制台地址和端口。搭建客户端新建一个Spring Boot项目，artifactId为spring-cloud-alibaba-sentinel-dashboard-guide，项目结构如下所示：项目pom内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-dashboard-guide&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-cloud-alibaba-sentinel-dashboard-guide&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt; &lt;com-alibaba-cloud.version&gt;2.2.0.RELEASE&lt;/com-alibaba-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;com-alibaba-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;引入了spring-cloud-starter-alibaba-sentinel和spring-boot-starter-web依赖。接着在cc.mrbird.sentinel目录下新建controller包，然后在该包下新建TestController：12345678@RestControllerpublic class TestController &#123; @GetMapping("test1") public String test1() &#123; return "test1"; &#125;&#125;最后在项目配置文件application.yml中添加如下配置：12345678910server: port: 8081spring: application: name: my-project cloud: sentinel: transport: dashboard: localhost:8080 port: 8719spring.cloud.sentinel.transport.dashboard，指定了sentinel控制台的ip和端口地址；spring.cloud.sentinel.transport.port，sentinel客户端和控制台通信的端口，默认为8719，如果这个端口已经被占用，那么sentinel会自动从8719开始依次+1扫描，直到找到未被占用的端口。启动项目，使用浏览器多次访问：http://localhost:8081/test1，然后登录sentinel控制台：在簇点链路中可以看到刚刚那笔请求，我们可以对它进行流控、降级、授权、热点等配置（控制台是懒加载的，如果没有任何请求，那么控制台也不会有任何内容）。流控规则在簇点链路列表中，点击/test1后面的流控按钮：资源名：标识资源的唯一名称，默认为请求路径，也可以在客户端中使用SentinelResource配置；针对来源：Sentinel可以针对服务调用者进行限流，填写微服务名称即spring.application.name，默认为default，不区分来源；阈值类型、单机阈值：QPS（Queries-per-second，每秒钟的请求数量）：当调用该api的QPS达到阈值的时候，进行限流；线程数：当调用该api的线程数达到阈值的时候，进行限流。是否集群：默认不集群；流控模式：直接：当api调用达到限流条件的时，直接限流；关联：当关联的资源请求达到阈值的时候，限流自己；链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，则进行限流）。流控效果：快速失败：直接失败；Warm Up：根据codeFactor（冷加载因子，默认值为3）的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值；排队等待：匀速排队，让请求匀速通过，阈值类型必须设置为QPS，否则无效。QPS直接失败演示下QPS直接失败设置及效果。点击簇点链路列表中/test1请求后面的流控按钮：上面设置的效果是，1秒钟内请求/test1资源的次数达到2次以上的时候，进行限流。点击新增按钮后，列表会跳转到”流控规则”菜单下，所以我们也可以在这里设置流控规则，不过一般还是习惯直接在簇点链路列表中直接选中资源添加流控规则。新增后，我们访问http://localhost:8081/test1，看看效果：当手速快点的时候（1秒超过2次），页面返回Blocked by Sentinel (flow limiting)。线程数直接失败改造下TestController：123456789@RestControllerpublic class TestController &#123; @GetMapping("test1") public String test1() throws InterruptedException &#123; TimeUnit.SECONDS.sleep(1); return "test1"; &#125;&#125;让方法休眠1秒，更容易出现效果。重启项目，然后在sentinel控制台中添加如下流控规则：多次访问http://localhost:8081/test1，效果：关联改造TestController，添加一个新的api接口：12345678910111213@RestControllerpublic class TestController &#123; @GetMapping("test1") public String test1() &#123; return "test1"; &#125; @GetMapping("test2") public String test2() &#123; return "test2"; &#125;&#125;重启项目，浏览器中访问下这两个请求，然后在sentinel控制台簇点链路列表中，点击test1后的流控按钮：上述流控规则表示：当1秒内访问/test2的次数大于2的时候，限流/test1。我们使用postman来密集访问/test2，然后我们手动浏览器请求/test1，看看效果。postman设置如下规则：然后点击Run按钮，我们回到浏览器，访问：http://localhost:8081/test1：可以看到/test1已经被限流了。链路在演示链路限流之前，我们先改造改造sentinel客户端代码。在项目的cc.mrbird.sentinel目录下新建service包，然后在该包下新建HelloService：1234567@Servicepublic class HelloService &#123; @SentinelResource("hello") public String hello() &#123; return "hello"; &#125;&#125;@SentinelResource(&quot;hello&quot;)将该方法标识为一个sentinel资源，名称为hello。接着在TestController中使用该资源：12345678910111213141516@RestControllerpublic class TestController &#123; @Autowired private HelloService helloService; @GetMapping("test1") public String test1() &#123; return "test1 " + helloService.hello(); &#125; @GetMapping("test2") public String test2() &#123; return "test2 " + helloService.hello(); &#125;&#125;重启项目，在浏览器中多次访问这两个api，然后查看sentinel控制台簇点链路：然后点击hello资源后面的流控按钮：上述配置的意思是，当通过/test1访问hello的时候，QPS大于1则进行限流；言外之意就是/test2访问hello请求并不受影响。但是实际测试并没有生效😡，具体可以参考issue：https://github.com/alibaba/Sentinel/issues/1213。预热Warm Up流控效果除了直接失败外，我们也可以选择预热Warm Up。Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。sentinel客户端的默认冷加载因子coldFactor为3，即请求QPS从 threshold / 3 开始，经预热时长逐渐升至设定的QPS阈值。比如：上面的配置意思是：对于/test1资源，一开始的QPS阈值为3（10/3），经过10秒后，QPS阈值达到10，过程类似于下图：效果我就不演示了，大概效果就是使用浏览器访问http://localhost:8081/test1，以最快的手速点刷新，一开始会常看到Blocked by Sentinel (flow limiting)的提示，10秒后几乎不再出现（因为你的手速很难达到1秒10下）。排队等待排队等待方式不会拒绝请求，而是严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过。修改TestController的代码：123456789101112@RestControllerpublic class TestController &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @GetMapping("test1") public String test1() &#123; log.info("test1"); return "test1"; &#125;&#125;重启项目，浏览器访问localhost:8081/test1，然后点击sentinel控制台簇点链路列表的/test1流控按钮：上述配置的含义是，访问/test1请求每秒钟最多只能1次，超过的请求排队等待，等待超过1000毫秒则超时。新增该规则后，多次快速访问localhost:8081/test1，sentinel客户端控制台日志打印如下：123452020-03-18 16:17:23.247 INFO 44688 --- [nio-8081-exec-2] c.m.sentinel.controller.TestController : test12020-03-18 16:17:24.250 INFO 44688 --- [nio-8081-exec-6] c.m.sentinel.controller.TestController : test12020-03-18 16:17:25.251 INFO 44688 --- [nio-8081-exec-5] c.m.sentinel.controller.TestController : test12020-03-18 16:17:26.251 INFO 44688 --- [nio-8081-exec-7] c.m.sentinel.controller.TestController : test12020-03-18 16:17:27.251 INFO 44688 --- [nio-8081-exec-8] c.m.sentinel.controller.TestController : test1每笔请求时间间隔1秒。降级规则降级配置页面：降级策略分为3种：RT，平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= 5，并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。RT修改TestController的代码：1234567891011@RestControllerpublic class TestController &#123; @GetMapping("test1") public String test1() throws InterruptedException &#123; // 休眠1秒 TimeUnit.SECONDS.sleep(1); return "test1"; &#125;&#125;重启项目，浏览器访问localhost:8081/test1，然后点击sentinel控制台簇点链路列表的/test1降级按钮：上面配置的含义是：如果/test1的QPS大于5，并且平均响应时间（以秒级统计）大于500（RT）毫秒，那么在未来的1秒钟（时间窗口）内，sentinel断路器打开，该api接口不可用。我们使用JMeter模拟并发访问情形：上面的QPS为10，而且我们的/test1接口响应时间在1秒左右，根据我们上面配置的降级规则，肯定会触发降级，使用JMeter测试结果如下：可以看到，程序很快就触发了降级，断路器打开，后续的请求都返回了Blocked by Sentinel (flow limiting)。停掉JMeter，浏览器访问localhost:8081/test1降级规则不再符合，所以断路器合上，请求正常响应。异常比例修改TestController的代码：12345678910@RestControllerpublic class TestController &#123; @GetMapping("test1") public String test1() &#123; // 每次请求都抛出异常 throw new RuntimeException("服务异常"); &#125;&#125;重启项目，浏览器访问localhost:8081/test1，然后点击sentinel控制台簇点链路列表的/test1降级按钮：上面的配置含义是：如果/test1的QPS大于5，并且每秒钟的请求异常比例大于0.5的话，那么在未来的1秒钟（时间窗口）内，sentinel断路器打开，该api接口不可用。也就是说，如果一秒内有10个请求进来，超过5个以上都出错，那么会触发熔断，1秒钟内这个接口不可用。还是使用上面的JMeter测试，开启JMeter后，使用浏览器访问：http://localhost:8081/test1关掉JMeter后，再次访问http://localhost:8081/test1：异常数奖及策略为异常数时表示：当指定时间窗口内，请求异常数大于等于某个值时，触发降级。比如有如下规则：上面的规则表示：在70秒内，访问/test1请求异常的次数大于等于5，则触发降级。测试一波：可以看到，当第5次访问的时候成功触发了降级。热点规则热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的数据，并对其访问进行限制。比如在TestController中有如下方法：12345@GetMapping("buy")@SentinelResource(value = "buy")public String buy(String goodName, Integer count) &#123; return "买" + count + "份" + goodName;&#125;对这个资源添加热点规则：上面的配置含义是：对buy资源添加热点规则，当第0个参数的值为miband的时候QPS阈值为10，否则为1。此外，如果第0个参数不传，那么这笔请求不受该热点规则限制。效果如下：系统规则系统规则则是针对整个系统设置限流规则，并不针对某个资源，设置页面如下：阈值类型包含以下五种：Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps minRt 估算得出。设定参考值一般是 CPU cores 2.5。CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。比较直观就不演示了。授权规则授权规则用于配置资源的黑白名单：上述配置表示：只有appA和appB才能访问hello资源。sentinel控制台规则会在客户端重启后丢失，可以配合nacos等进行配置持久化，具体可以参考云大佬的博客：https://www.sonake.com/2019/12/16/Sentinel-Nacos%E5%AE%9E%E7%8E%B0%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/。参考链接 https://github.com/alibaba/Sentinel/wiki本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/77.spring-cloud-alibaba-sentinel-dashboard-guide。]]></content>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Cloud Alibaba</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Nacos配置中心]]></title>
    <url>%2FSpring-Cloud-Alibaba-Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html</url>
    <content type="text"><![CDATA[上一节Spring Cloud Alibaba Nacos注册中心记录了Nacos作为注册中心的使用方式，这节继续记录下Nacos作为配置中心的使用方式。本节使用的Spring Cloud版本为Hoxton.SR3，Spring Cloud Alibaba版本为2.2.0.RELEASE，Spring Boot版本为2.2.3.RELEASE。框架搭建新建一个Spring Boot项目，artifactId为spring-cloud-alibaba-nacos-config，项目结构如下图所示：项目的pom内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-cloud-alibaba-nacos-config&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt; &lt;com-alibaba-cloud.version&gt;2.2.0.RELEASE&lt;/com-alibaba-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;com-alibaba-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;因为这节记录的是Nacos作为配置中心的功能，所以引入的是spring-cloud-alibaba-nacos-config依赖。基本使用在项目配置文件application.yml中添加如下配置：12345server: port: 8080spring: application: name: my-project上面配置指定应用端口为8080，应用名称为my-project。接着在resources目录下新建配置文件bootstrap.yml，在里面添加如下Nacos config配置（必须在bootstrap.yml中配置，bootstrap.yml优先级比application.yml高）：123456spring: cloud: nacos: config: server-addr: localhost:8848 file-extension: yamlspring.cloud.nacos.config.server-addr配置了Nacos配置中心的地址，也可以通过spring.cloud.nacos.server-addr指定，它们两个是等价的；spring.cloud.nacos.config.file-extension指定待会在Nacos配置中心读取的配置的格式为yaml格式。我们回到Nacos控制台http://localhost:8848/nacos，在配置列表中新建一个配置：我们新建了一个my-project.yaml配置（dataId为my-project.yaml，group为DEFAULT_GROUP，它们的具体含义下面会介绍到），配置了message: &#39;hello nacos config&#39;，创建好后，点击发布即可。接着回到我们的项目，在cc.mrbird.nacos目录下新建controller包，然后在该包下新建TestController用于测试配置获取规则：123456789101112@RestController@RefreshScopepublic class TestController &#123; @Value("$&#123;message:null&#125;") private String message; @GetMapping("message") public String getMessage() &#123; return this.message; &#125;&#125;上面代码我们从刚刚在Nacos控制台配置的配置文件中获取message配置的值，@RefreshScope用于刷新配置，即我们在Nacos控制台修改了相关配置点击发布后，我们的应用能够在不重启的情况下获取到最新的配置。启动项目，在浏览器中访问：http://localhost:8080/message：配置获取成功，在Nacos控制台中将message值修改为hello world后发布，再次访问http://localhost:8080/message：获取配置规则Nacos配置中心通过namespace、dataId和group来唯一确定一条配置。namespace，即命名空间。默认的命名空间为public，我们可以在Nacos控制台中新建命名空间；dataId，即配置文件名称，dataId的拼接格式如下：1$&#123;prefix&#125; - $&#123;spring.profiles.active&#125; . $&#123;file-extension&#125;prefix默认为pring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置；spring.profiles.active即为当前环境对应的profile。注意，当spring.profiles.active为空时，对应的连接符-也将不存在，dataId的拼接格式变成${prefix}.${file-extension}；file-extension为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension来配置。group，即配置分组，默认为DEFAULT_GROUP，可以通过spring.cloud.nacos.config.group配置。所以根据这些规则，上面示例中我们的应用名称spring.application.name为my-project，spring.cloud.nacos.config.file-extension的值为yaml，没有指定spring.profiles.active，于是dataId为my-project.yaml，分组为默认的DEFAULT_GROUP，命名空间为默认的public。这就是我们在Nacos控制台中新建配置时的根据。配置划分实战Nacos配置中心的namespace、dataId和group可以方便灵活地划分配置。比如，我们现在有一个项目需要开发，项目名称为febs，项目开发人员分为两个组：GROUP_A和GROUP_B，项目分为三个环境：开发环境dev、测试环境test和生产环境prod。假如现在GROUP_A组的组长需要在Nacos中新建一个开发环境的febs项目配置，那么他可以这样做：在Nacos控制台中新建一个名称为febs的命名空间：新建febs命名空间后，会生成一个唯一标识该命名空间的命名空间id2ef2186e-078c-4904-8643-ff5e90555456。在Nacos控制台中新建一个配置：最后在febs项目的bootstrap.yml配置文件中添加如下配置即可：1234567891011spring: profiles: active: dev cloud: nacos: config: server-addr: localhost:8848 file-extension: yaml prefix: febs namespace: '2ef2186e-078c-4904-8643-ff5e90555456' group: GROUP_A配置回滚Nacos中，修改配置点击发布后会创建一个对应的历史版本快照，我们可以在Nacos控制台的历史版本列表中找到这些快照：点击回滚按钮即可将配置恢复到指定的版本。获取多个配置除了通过上面的方式指定一个唯一配置外，我们还可以同时获取多个配置文件的内容，比如，将项目的bootstrap.yml内容修改为：123456789101112spring: cloud: nacos: config: server-addr: localhost:8848 extension-configs: - dataId: ext-config-one.yaml group: DEFAULT_GROUP refresh: true - dataId: ext-config-two.yaml group: DEFAULT_GROUP refresh: falsespring.cloud.nacos.config.extension-configs[n].dataId，指定多个配置的dataId，必须包含文件格式，支持properties、yaml或yml；spring.cloud.nacos.config.extension-configs[n].group，指定分组；spring.cloud.nacos.config.extension-configs[n].refresh，是否支持刷新。上面的配置中，我们分别从DEFAULT_GROUP中获取了ext-config-one.yaml和ext-config-two.yaml配置内容，并且ext-config-one.yaml支持刷新，ext-config-two.yaml不支持刷新。没有namespace的配置，言外之意就是Nacos目前还不支持多个配置指定不同的命名空间。我们在Nacos控制台中新建这两个配置：ext-config-one.yaml配置内容：1ext1: 'hello'ext-config-two.yaml配置内容：1ext2: 'world'在项目的TestController中添加：12345678910111213141516@RestController@RefreshScopepublic class TestController &#123; @Value("$&#123;ext1:null&#125;") private String ext1; @Value("$&#123;ext2:null&#125;") private String ext2; @GetMapping("multi") public String multiConfig() &#123; return String.format("ext1: %s ext2: %s", ext1, ext2); &#125; ...&#125;启动项目，浏览器访问：http://localhost:8080/multi：将ext1的值修改为nice，ext2的值修改为job：可以看到ext1的值更新了，ext2没有更新。多配置共享多配置共享其实和获取多个文件配置作用差不多，下面演示下多配置共享。将bootstrap.yml配置修改为：123456spring: cloud: nacos: config: server-addr: localhost:8848 shared-configs: ext-config-one.yaml,ext-config-two.yamlspring.cloud.nacos.config.shared-configs指定了共享ext-config-one.yaml和ext-config-two.yaml的配置。重启项目，访问http://localhost:8080/multi：也可以正常获取。可以看到，无论是多配置共享还是获取多个配置，要完成的事情是一样的，不过它们都有各自的局限性。多配置共享无法指定分组、无法指定命名空间、无法配置是否刷新；获取多个配置相对较为灵活，不过也不能配置命名空间。具体相关的讨论可以参考：https://github.com/alibaba/spring-cloud-alibaba/issues/141常用配置配置项key默认值说明服务端地址spring.cloud.nacos.config.server-addrDataId前缀spring.cloud.nacos.config.prefixspring.application.nameGroupspring.cloud.nacos.config.groupDEFAULT_GROUPdataID后缀及内容文件格式spring.cloud.nacos.config.file-extensionpropertiesdataId的后缀，同时也是配置内容的文件格式，目前只支持 properties配置内容的编码方式spring.cloud.nacos.config.encodeUTF-8配置的编码获取配置的超时时间spring.cloud.nacos.config.timeout3000单位为 ms配置的命名空间spring.cloud.nacos.config.namespace常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源隔离等。AccessKeyspring.cloud.nacos.config.access-keySecretKeyspring.cloud.nacos.config.secret-key相对路径spring.cloud.nacos.config.context-path服务端 API 的相对路径接入点spring.cloud.nacos.config.endpoint地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址是否开启监听和自动刷新spring.cloud.nacos.config.refresh.enabledtrue参考链接：https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.mdhttps://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_config本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/75.spring-cloud-alibaba-nacos-config。]]></content>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Cloud Alibaba</tag>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Alibaba Nacos注册中心]]></title>
    <url>%2FSpring-Cloud-Alibaba-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.html</url>
    <content type="text"><![CDATA[Nacos是一款集服务注册发现、服务配置和管理于一身的开源软件，这节主要记录Nacos的服务注册发现功能的使用。借助Spring Cloud Alibaba Nacos Discovery，我们可以轻松地使用Spring Cloud编程模型体验Nacos的服务注册发现功能。本节使用的Spring Cloud版本为Hoxton.SR3，Spring Cloud Alibaba版本为2.2.0.RELEASE，Spring Boot版本为2.2.3.RELEASE。Nacos安装因为Spring Cloud Alibaba 2.2.0.RELEASE内置的Nacos client版本为1.1.4，所以我们使用这个版本的Nacos。Nacos下载地址：https://github.com/alibaba/nacos/releases，选择nacos-server-1.1.4.zip 下载并解压：解压后，打开conf目录下的配置文件，在末尾添加数据源配置：12345spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://localhost:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=123456然后在MySQL数据库中新建nacos数据库，并导入Nacos解压包conf目录下的nacos-mysql.sql脚本，导入后，库表如下图所示：数据层准备好后，我们就可以启动Nacos了。笔者的电脑为Mac，所以这里以Unix环境为例。终端切换到Nacos解压目录下的bin目录，然后执行sh startup.sh -m standalone启动单机版Nacos。为了方便，我们也可以创建一个run.sh脚本：1234#/bin/bashsh shutdown.shsh startup.sh -m standalonetail -10f /Users/mrbird/Desktop/nacos/logs/start.out其中/Users/mrbird/Desktop/nacos为我的Nacos解压目录。启动后，浏览器访问：http://localhost:8848/nacos/#/login：说明Nacos启动成功，账号密码都为nacos。框架搭建使用IDEA创建一个maven项目，artifactId为spring-cloud-alibaba-nacos-register，然后在其下面创建两个Module（Spring Boot项目），artifactId分别为consumer和provider，充当服务消费端和服务提供端，项目结构如下图所示：spring-cloud-alibaba-nacos-register的pom内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-register&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;provider&lt;/module&gt; &lt;module&gt;consumer&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt; &lt;com-alibaba-cloud.version&gt;2.2.0.RELEASE&lt;/com-alibaba-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;com-alibaba-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt;因为本节演示的是Nacos的服务注册发现功能，所以引入的是spring-cloud-alibaba-nacos-discovery依赖。provider的pom的内容如下所示：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-register&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;name&gt;provider&lt;/name&gt; &lt;description&gt;服务提供端&lt;/description&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;consumer的pom内容如下：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-register&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;consumer&lt;/artifactId&gt; &lt;name&gt;consumer&lt;/name&gt; &lt;description&gt;服务消费端&lt;/description&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;Nacos作为注册中心在provider的cc.mrbird.provider目录下新建controller包，然后在该包下新建HelloController：123456789@RestController@RequestMapping("provide")public class HelloController &#123; @GetMapping("&#123;message&#125;") public String hello(@PathVariable String message) &#123; return String.format("hello %s", message); &#125;&#125;提供了一个REST接口，供consumer调用。然后在provider的项目配置文件application.yml里添加如下配置：12345678server: port: 8001spring: application: name: provider cloud: nacos: server-addr: localhost:8848server.port，provider服务端口为8001；spring.application.name，服务名称为providerspring.cloud.nacos.server-addr，指定Nacos注册中心的地址。provider代码准备好后，接着在consumer项目的cc.mrbird.consumer目录下新建controller包，然后在该包下新建ConsumeController：1234567891011121314151617@RestController@RequestMapping("consume")public class ConsumeController &#123; @Autowired private LoadBalancerClient loadBalancerClient; @Autowired private RestTemplate restTemplate; @GetMapping("hello/&#123;message&#125;") public String hello(@PathVariable String message) &#123; ServiceInstance serviceInstance = loadBalancerClient.choose("provider"); String path = String.format("http://%s:%s/provide/%s", serviceInstance.getHost(), serviceInstance.getPort(), message); String result = restTemplate.getForObject(path, String.class); return String.format("%s from %s %s", result, serviceInstance.getHost(), serviceInstance.getPort()); &#125;&#125;因为spring-cloud-alibaba-nacos-discovery内置了Ribbon，所以我们可以直接注入LoadBalancerClient，RestTemplate我们稍后再配置。hello()方法中我们通过服务提供者的名称provider（即provider项目配置的spring.application.name）从Nacos注册中心中获取对应的服务实例，然后访问其提供的/provide/{message} GET服务。这些在Spring Cloud Ribbon客户端负载均衡一节中都介绍过了，有不懂的可以参阅下。接着在consumer项目的cc.mrbird.consumer目录下新建configure包，然后在该包下新建ConsumerConfigure：12345678@Configurationpublic class ConsumerConfigure &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125;上面代码配置了RestTemplate Bean。最后在consumer项目的配置文件application.yml中添加如下配置：12345678server: port: 9001spring: application: name: consumer cloud: nacos: server-addr: localhost:8848配置和provider项目类似，不再赘述。分别启动provider和consumer项目：观察Nacos控制台服务列表：可以看到，两个服务都注册进来了。接着浏览器访问：http://localhost:9001/consume/hello/nacos：调用成功，说明服务发现成功。测试负载均衡如下图所示，在ProviderApplication上右键选择Copy Configuration…：然后按照下图所示填写相关内容：点击ok保存后，启动它：观察Nacos控制台，可以看到provider已经有两个实例了：然后多次访问：http://localhost:9001/consume/hello/nacos，可以看到请求是均衡的（默认为轮询算法）：Nacos注册中心配置更多可用Nacos Descovery配置：配置项Key默认值说明服务端地址spring.cloud.nacos.discovery.server-addr无Nacos Server 启动监听的ip地址和端口服务名spring.cloud.nacos.discovery.service${spring.application.name}给当前的服务命名服务分组spring.cloud.nacos.discovery.groupDEFAULT_GROUP设置服务所处的分组权重spring.cloud.nacos.discovery.weight1取值范围 1 到 100，数值越大，权重越大网卡名spring.cloud.nacos.discovery.network-interface无当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址注册的IP地址spring.cloud.nacos.discovery.ip无优先级最高注册的端口spring.cloud.nacos.discovery.port-1默认情况下不用配置，会自动探测命名空间spring.cloud.nacos.discovery.namespace无常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。AccessKeyspring.cloud.nacos.discovery.access-key无当要上阿里云时，阿里云上面的一个云账号名SecretKeyspring.cloud.nacos.discovery.secret-key无当要上阿里云时，阿里云上面的一个云账号密码Metadataspring.cloud.nacos.discovery.metadata无使用Map格式配置，用户可以根据自己的需要自定义一些和服务相关的元数据信息日志文件名spring.cloud.nacos.discovery.log-name无集群spring.cloud.nacos.discovery.cluster-nameDEFAULT配置成Nacos集群名称接入点spring.cloud.nacos.discovery.enpointUTF-8地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址是否集成Ribbonribbon.nacos.enabledtrue一般都设置成true即可是否开启Nacos Watchspring.cloud.nacos.discovery.watch.enabledtrue可以设置成false来关闭 watch本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/74.spring-cloud-alibaba-nacos-register。参考自官方文档：https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html#_spring_cloud_alibaba_nacos_discovery]]></content>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Cloud Alibaba</tag>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch异常处理]]></title>
    <url>%2FSpring-Batch%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[Spring Batch处理任务过程中如果发生了异常，默认机制是马上停止任务执行，抛出相应异常，如果任务还包含未执行的步骤也不会被执行。要改变这个默认规则，我们可以配置异常重试和异常跳过机制。异常跳过：遇到异常的时候不希望结束任务，而是跳过这个异常，继续执行；异常重试：遇到异常的时候经过指定次数的重试，如果还是失败的话，才会停止任务。除了这两个特性外，本文也会记录一些别的特性。框架搭建新建一个Spring Boot项目，版本为2.2.4.RELEASE，artifactId为spring-batch-exception，项目结构如下图所示：剩下的数据库层的准备，项目配置，依赖引入和Spring Batch入门文章中的框架搭建步骤一致，这里就不再赘述。下面我们演示下，默认情况下Spring Batch处理任务遇到异常是怎么处理的。在cc.mrbird.batch目录下新建job包，然后在该包下新建DefaultExceptionJobDemo：123456789101112131415161718192021222324252627282930@Componentpublic class DefaultExceptionJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job defaultExceptionJob() &#123; return jobBuilderFactory.get("defaultExceptionJob") .start( stepBuilderFactory.get("step") .tasklet((stepContribution, chunkContext) -&gt; &#123; // 获取执行上下文 ExecutionContext executionContext = chunkContext.getStepContext().getStepExecution().getExecutionContext(); if (executionContext.containsKey("success")) &#123; System.out.println("任务执行成功"); return RepeatStatus.FINISHED; &#125; else &#123; String errorMessage = "处理任务过程发生异常"; System.out.println(errorMessage); executionContext.put("success", true); throw new RuntimeException(errorMessage); &#125; &#125;).build() ).build(); &#125;&#125;上面代码中，我们在Step的tasklet()方法中获取了执行上下文，并且判断执行上下文中是否包含keysuccess，如果包含，则任务执行成功；如果不包含，则抛出异常（抛出异常前，在执行上下文中添加successkey）。启动项目，控制台日志打印如下：1234567891011122020-03-11 17:12:50.253 INFO 38673 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=defaultExceptionJob]] launched with the following parameters: [&#123;&#125;]2020-03-11 17:12:50.323 INFO 38673 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]处理任务过程发生异常2020-03-11 17:12:50.352 ERROR 38673 --- [ main] o.s.batch.core.step.AbstractStep : Encountered an error executing step step in job defaultExceptionJobjava.lang.RuntimeException: 处理任务过程发生异常 at cc.mrbird.batch.job.DefaultExceptionJobDemo.lambda$defaultExceptionJob$0(DefaultExceptionJobDemo.java:38) ~[classes/:na] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:407) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:331) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:273) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE]...可以看到，默认情况下，Spring Batch处理任务过程中如果发生了异常会马上停止任务的执行。再次启动项目，控制台输出如下：123452020-03-11 17:14:03.184 INFO 38691 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=defaultExceptionJob]] launched with the following parameters: [&#123;&#125;]2020-03-11 17:14:03.264 INFO 38691 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]任务执行成功2020-03-11 17:14:03.302 INFO 38691 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 37ms2020-03-11 17:14:03.326 INFO 38691 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=defaultExceptionJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 120ms因为在上次任务抛出异常前，我们在执行上下文中添加successkey（配合MySQL持久化，不会因项目启动而丢失）。异常重试Spring Batch允许我们配置任务在遇到指定异常时进行指定次数的重试。在此之前，我们先定义一个自定义异常。在cc.mrbird.batch包下新建exception包，然后在该包下新建MyJobExecutionException：12345678public class MyJobExecutionException extends Exception&#123; private static final long serialVersionUID = 7168487913507656106L; public MyJobExecutionException(String message) &#123; super(message); &#125;&#125;然后在job包下新建RetryExceptionJobDemo：12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job retryExceptionJob() &#123; return jobBuilderFactory.get("retryExceptionJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(listItemReader()) .processor(myProcessor()) .writer(list -&gt; list.forEach(System.out::println)) .faultTolerant() // 配置错误容忍 .retry(MyJobExecutionException.class) // 配置重试的异常类型 .retryLimit(3) // 重试3次，三次过后还是异常的话，则任务会结束， // 异常的次数为reader，processor和writer中的总数，这里仅在processor里演示异常重试 .build(); &#125; private ListItemReader&lt;String&gt; listItemReader() &#123; ArrayList&lt;String&gt; datas = new ArrayList&lt;&gt;(); IntStream.range(0, 5).forEach(i -&gt; datas.add(String.valueOf(i))); return new ListItemReader&lt;&gt;(datas); &#125; private ItemProcessor&lt;String, String&gt; myProcessor() &#123; return new ItemProcessor&lt;String, String&gt;() &#123; private int count; @Override public String process(String item) throws Exception &#123; System.out.println("当前处理的数据：" + item); if (count &gt;= 2) &#123; return item; &#125; else &#123; count++; throw new MyJobExecutionException("任务处理出错"); &#125; &#125; &#125;; &#125;在step()方法中，faultTolerant()表示开启容错功能，retry(MyJobExecutionException.class)表示遇到MyJobExecutionException异常时进行重试，retryLimit(3)表示如果第三次重试还是失败的话，则抛出异常，结束任务。通过前面的学习我们知道，步骤Step包括ItemReader、ItemWriter和ItemProcessor，上面配置的错误容忍是针对整个Step的，所以容忍的异常次数应该是reader，processor和writer中的总数，上面的例子仅在processor里演示异常重试。myProcessor()的代码逻辑很简单，就是在前两次的时候抛出MyJobExecutionException(&quot;任务处理出错&quot;)异常（count &lt; 2），第三次的时候正常返回item（count = 2 &gt;= 2），所以理论上上面的任务在重试两次之后正常运行。启动项目，控制台打印日志如下：123456789101112131415162020-03-12 09:04:53.359 INFO 40522 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=retryExceptionJob]] launched with the following parameters: [&#123;&#125;]2020-03-12 09:04:53.415 INFO 40522 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]当前处理的数据：0当前处理的数据：0当前处理的数据：0当前处理的数据：101当前处理的数据：2当前处理的数据：323当前处理的数据：442020-03-12 09:04:53.498 INFO 40522 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 83ms2020-03-12 09:04:53.522 INFO 40522 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=retryExceptionJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 152ms结果符合我们的预期。假如通过retryLimit(2)将重试次数设置为2，并修改任务的名称为retryExceptionJob1，启动项目看看运行结果如何：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263v2020-03-12 09:06:48.855 INFO 40610 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=retryExceptionJob1]] launched with the following parameters: [&#123;&#125;]2020-03-12 09:06:48.933 INFO 40610 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]当前处理的数据：0当前处理的数据：02020-03-12 09:06:48.979 ERROR 40610 --- [ main] o.s.batch.core.step.AbstractStep : Encountered an error executing step step in job retryExceptionJob1org.springframework.retry.RetryException: Non-skippable exception in recoverer while processing; nested exception is cc.mrbird.batch.exception.MyJobExecutionException: 任务处理出错 at org.springframework.batch.core.step.item.FaultTolerantChunkProcessor$2.recover(FaultTolerantChunkProcessor.java:289) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.retry.support.RetryTemplate.handleRetryExhausted(RetryTemplate.java:512) ~[spring-retry-1.2.5.RELEASE.jar:na] at org.springframework.retry.support.RetryTemplate.doExecute(RetryTemplate.java:351) ~[spring-retry-1.2.5.RELEASE.jar:na] at org.springframework.retry.support.RetryTemplate.execute(RetryTemplate.java:211) ~[spring-retry-1.2.5.RELEASE.jar:na] at org.springframework.batch.core.step.item.BatchRetryTemplate.execute(BatchRetryTemplate.java:217) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.FaultTolerantChunkProcessor.transform(FaultTolerantChunkProcessor.java:298) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.SimpleChunkProcessor.process(SimpleChunkProcessor.java:210) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.ChunkOrientedTasklet.execute(ChunkOrientedTasklet.java:77) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:407) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:331) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:273) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:375) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:215) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:145) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:258) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:208) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:148) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:410) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:136) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:319) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:147) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50) [spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:140) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_231] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_231] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_231] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_231] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration$PassthruAdvice.invoke(SimpleBatchConfiguration.java:127) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at com.sun.proxy.$Proxy46.run(Unknown Source) [na:na] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.execute(JobLauncherCommandLineRunner.java:192) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.executeLocalJobs(JobLauncherCommandLineRunner.java:166) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.launchJobFromProperties(JobLauncherCommandLineRunner.java:153) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.run(JobLauncherCommandLineRunner.java:148) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:784) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:768) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:322) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at cc.mrbird.batch.SpringBatchExceptionApplication.main(SpringBatchExceptionApplication.java:12) [classes/:na]Caused by: cc.mrbird.batch.exception.MyJobExecutionException: 任务处理出错 at cc.mrbird.batch.job.RetryExceptionJobDemo$1.process(RetryExceptionJobDemo.java:64) ~[classes/:na] at cc.mrbird.batch.job.RetryExceptionJobDemo$1.process(RetryExceptionJobDemo.java:55) ~[classes/:na] at org.springframework.batch.core.step.item.SimpleChunkProcessor.doProcess(SimpleChunkProcessor.java:134) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.FaultTolerantChunkProcessor$1.doWithRetry(FaultTolerantChunkProcessor.java:233) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.retry.support.RetryTemplate.doExecute(RetryTemplate.java:287) ~[spring-retry-1.2.5.RELEASE.jar:na] ... 43 common frames omitted2020-03-12 09:06:48.989 INFO 40610 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 56ms2020-03-12 09:06:49.019 INFO 40610 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=retryExceptionJob1]] completed with the following parameters: [&#123;&#125;] and the following status: [FAILED] in 152ms异常次数超过了重试次数，所以抛出了异常。异常跳过我们也可以在Step中配置异常跳过，即遇到指定类型异常时忽略跳过它，在job包下新建SkipExceptionJobDemo：123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class SkipExceptionJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job skipExceptionJob() &#123; return jobBuilderFactory.get("skipExceptionJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(listItemReader()) .processor(myProcessor()) .writer(list -&gt; list.forEach(System.out::println)) .faultTolerant() // 配置错误容忍 .skip(MyJobExecutionException.class) // 配置跳过的异常类型 .skipLimit(1) // 最多跳过1次，1次过后还是异常的话，则任务会结束， // 异常的次数为reader，processor和writer中的总数，这里仅在processor里演示异常跳过 .build(); &#125; private ListItemReader&lt;String&gt; listItemReader() &#123; ArrayList&lt;String&gt; datas = new ArrayList&lt;&gt;(); IntStream.range(0, 5).forEach(i -&gt; datas.add(String.valueOf(i))); return new ListItemReader&lt;&gt;(datas); &#125; private ItemProcessor&lt;String, String&gt; myProcessor() &#123; return item -&gt; &#123; System.out.println("当前处理的数据：" + item); if ("2".equals(item)) &#123; throw new MyJobExecutionException("任务处理出错"); &#125; else &#123; return item; &#125; &#125;; &#125;&#125;在step()方法中，faultTolerant()表示开启容错功能，skip(MyJobExecutionException.class)表示遇到MyJobExecutionException异常时跳过，skipLimit(1)表示只跳过一次。myProcessor()的逻辑是，当处理的item值为”2“的时候，抛出MyJobExecutionException(&quot;任务处理出错&quot;)异常。此外我们还可以配置SkipListener类型监听器，在cc.mrbird.batch包下新建listener包，然后在该包下新建MySkipListener：1234567891011121314151617@Componentpublic class MySkipListener implements SkipListener&lt;String, String&gt; &#123; @Override public void onSkipInRead(Throwable t) &#123; System.out.println("在读取数据的时候遇到异常并跳过，异常：" + t.getMessage()); &#125; @Override public void onSkipInWrite(String item, Throwable t) &#123; System.out.println("在输出数据的时候遇到异常并跳过，待输出数据：" + item + "，异常：" + t.getMessage()); &#125; @Override public void onSkipInProcess(String item, Throwable t) &#123; System.out.println("在处理数据的时候遇到异常并跳过，待输出数据：" + item + "，异常：" + t.getMessage()); &#125;&#125;然后将它注入到SkipExceptionJobDemo，并配置：12345678910111213141516171819202122232425@Componentpublic class SkipExceptionJobDemo &#123; .... @Autowired private MySkipListener mySkipListener; .... private Step step() &#123; return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(listItemReader()) .processor(myProcessor()) .writer(list -&gt; list.forEach(System.out::println)) .faultTolerant() // 配置错误容忍 .skip(MyJobExecutionException.class) // 配置跳过的异常类型 .skipLimit(1) // 最多跳过1次，1次过后还是异常的话，则任务会结束， // 异常的次数为reader，processor和writer中的总数，这里仅在processor里演示异常跳过 .listener(mySkipListener) .build(); &#125; ....&#125;启动项目，控制台日志打印如下：12345678910111213142020-03-12 09:23:33.528 INFO 40759 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=skipExceptionJob]] launched with the following parameters: [&#123;&#125;]2020-03-12 09:23:33.664 INFO 40759 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]当前处理的数据：0当前处理的数据：101当前处理的数据：2当前处理的数据：33在处理数据的时候遇到异常并跳过，待输出数据：2，异常：任务处理出错当前处理的数据：442020-03-12 09:23:33.854 INFO 40759 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 190ms2020-03-12 09:23:33.885 INFO 40759 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=skipExceptionJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 324ms事务问题一次Setp分为Reader、Processor和Writer三个阶段，这些阶段统称为Item。默认情况下如果错误不是发生在Reader阶段，那么没必要再去重新读取一次数据。但是某些场景下需要Reader部分也需要重新执行，比如Reader是从一个JMS队列中消费消息，当发生回滚的时候消息也会在队列上重放，因此也要将Reader纳入到回滚的事物中，根据这个场景可以使用readerIsTransactionalQueue()来配置数据重读：12345678private Step step() &#123; return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(listItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .readerIsTransactionalQueue() // 消息队列数据重读 .build();&#125;我们还可以在Step中手动配置事务属性，事物的属性包括隔离等级（isolation）、传播方式（propagation）以及过期时间（timeout）等：12345678910111213private Step step() &#123; DefaultTransactionAttribute attribute = new DefaultTransactionAttribute(); attribute.setPropagationBehavior(Propagation.REQUIRED.value()); attribute.setIsolationLevel(Isolation.DEFAULT.value()); attribute.setTimeout(30); return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(listItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .transactionAttribute(attribute) .build();&#125;重启机制默认情况下，任务执行完毕的状态为COMPLETED，再次启动项目，该任务的Step不会再执行，我们可以通过配置allowStartIfComplete(true)来实现每次项目重新启动都将执行这个Step：12345678private Step step() &#123; return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(listItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .allowStartIfComplete(true) .build();&#125;某些Step可能用于处理一些先决的任务，所以当Job再次重启时这Step就没必要再执行，可以通过设置startLimit()来限定某个Step重启的次数。当设置为1时候表示仅仅运行一次，而出现重启时将不再执行：12345678private Step step() &#123; return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(listItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .startLimit(1) .build();&#125;部分内容参考自：https://blog.csdn.net/sswltt/article/details/103817645本章源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/72.spring-batch-exception。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch任务调度]]></title>
    <url>%2FSpring-Batch%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6.html</url>
    <content type="text"><![CDATA[在前面的例子中，我们配置的任务都是在项目启动的时候自动运行，我们也可以通过JobLauncher或者JobOperator手动控制任务的运行时机，这节记录下它们的用法。框架搭建新建一个Spring Boot项目，版本为2.2.4.RELEASE，artifactId为spring-batch-launcher，项目结构如下图所示：剩下的数据库层的准备，项目配置，依赖引入和Spring Batch入门文章中的框架搭建步骤一致，这里就不再赘述。此外，本节我们需要演示在Controller里通过JobLauncher或者JobOperator调度任务，所以我们还需在pom里引入web依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;然后准备个任务，用于后续测试。在cc.mrbird.batch包下新建job包，然后在该包下新建MyJob：123456789101112131415161718192021222324252627@Componentpublic class MyJob&#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job job()&#123; return jobBuilderFactory.get("job") .start(step()) .build(); &#125; private Step step()&#123; return stepBuilderFactory.get("step") .tasklet((stepContribution, chunkContext) -&gt; &#123; StepExecution stepExecution = chunkContext.getStepContext().getStepExecution(); Map&lt;String, JobParameter&gt; parameters = stepExecution.getJobParameters().getParameters(); System.out.println(parameters.get("message").getValue()); return RepeatStatus.FINISHED; &#125;) .listener(this) .build(); &#125;&#125;在step()方法中，我们通过执行上下文获取了key为message的参数值。JobLauncher在cc.mrbird.batch包下新建controller包，然后在该包下新建JobController：12345678910111213141516171819@RestController@RequestMapping("job")public class JobController &#123; @Autowired private Job job; @Autowired private JobLauncher jobLauncher; @GetMapping("launcher/&#123;message&#125;") public String launcher(@PathVariable String message) throws Exception &#123; JobParameters parameters = new JobParametersBuilder() .addString("message", message) .toJobParameters(); // 将参数传递给任务 jobLauncher.run(job, parameters); return "success"; &#125;&#125;上面代码中，我们注入了JobLauncher和上面配置的Job，然后通过JobLauncher的run(Job job, JobParameters jobParameters)方法运行指定的任务Job，并且传递了参数。要关闭Spring Batch启动项目自动运行任务的机制，需要在项目配置文件application.yml中添加如下配置：1234spring: batch: job: enabled: false启动项目，在浏览器地址栏访问：http://localhost:8080/job/launcher/hello：项目控制台日志打印如下：123452020-03-12 10:24:31.547 INFO 41266 --- [nio-8080-exec-4] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=job]] launched with the following parameters: [&#123;message=hello&#125;]2020-03-12 10:24:31.583 INFO 41266 --- [nio-8080-exec-4] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]hello2020-03-12 10:24:31.610 INFO 41266 --- [nio-8080-exec-4] o.s.batch.core.step.AbstractStep : Step: [step] executed in 27ms2020-03-12 10:24:31.632 INFO 41266 --- [nio-8080-exec-4] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=job]] completed with the following parameters: [&#123;message=hello&#125;] and the following status: [COMPLETED] in 76ms此外，需要注意的是：同样的参数，同样的任务再次运行的时候将抛出JobInstanceAlreadyCompleteException异常，比如在浏览器中再次访问http://localhost:8080/job/launcher/hello，项目控制台日志打印如下：12345678org.springframework.batch.core.repository.JobInstanceAlreadyCompleteException: A job instance already exists and is complete for parameters=&#123;message=hello&#125;. If you want to run this job again, change the parameters. at org.springframework.batch.core.repository.support.SimpleJobRepository.createJobExecution(SimpleJobRepository.java:131) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_231] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_231] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_231] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_231] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344) ~[spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] ...所以我们在任务调度的时候，应避免参数重复。JobOperator在JobController里添加一个新的端点：1234567891011121314@RestController@RequestMapping("job")public class JobController &#123; @Autowired private JobOperator jobOperator; @GetMapping("operator/&#123;message&#125;") public String operator(@PathVariable String message) throws Exception &#123; // 传递任务名称，参数使用 kv方式 jobOperator.start("job", "message=" + message); return "success"; &#125;&#125;上面代码中，我们注入了JobOperator，JobOperator的start(String jobName, String parameters)方法传入的是任务的名称（任务在Spring IOC容器中的名称）,并且参数使用key-value的方式传递。要通过任务名称获取到相应的Bean，还需要添加一个额外的配置。在cc.mrbird.batch包下新建configure包，然后在该包下新建JobConfigure：123456789101112131415@Configurationpublic class JobConfigure &#123; /** * 注册JobRegistryBeanPostProcessor bean * 用于将任务名称和实际的任务关联起来 */ @Bean public JobRegistryBeanPostProcessor processor(JobRegistry jobRegistry, ApplicationContext applicationContext) &#123; JobRegistryBeanPostProcessor postProcessor = new JobRegistryBeanPostProcessor(); postProcessor.setJobRegistry(jobRegistry); postProcessor.setBeanFactory(applicationContext.getAutowireCapableBeanFactory()); return postProcessor; &#125;&#125;如果没有这段配置，在任务调度的时候将报org.springframework.batch.core.launch.NoSuchJobException: No job configuration with the name [job] was registered。启动任务，浏览器访问：http://localhost:8080/job/operator/mrbird：项目控制台日志打印如下：12345672020-03-12 10:51:20.174 INFO 41405 --- [nio-8080-exec-2] o.s.b.c.l.support.SimpleJobOperator : Checking status of job with name=job2020-03-12 10:51:20.183 INFO 41405 --- [nio-8080-exec-2] o.s.b.c.l.support.SimpleJobOperator : Attempting to launch job with name=job and parameters=message=mrbird2020-03-12 10:51:20.239 INFO 41405 --- [nio-8080-exec-2] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=job]] launched with the following parameters: [&#123;message=mrbird&#125;]2020-03-12 10:51:20.293 INFO 41405 --- [nio-8080-exec-2] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]mrbird2020-03-12 10:51:20.324 INFO 41405 --- [nio-8080-exec-2] o.s.batch.core.step.AbstractStep : Step: [step] executed in 31ms2020-03-12 10:51:20.344 INFO 41405 --- [nio-8080-exec-2] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=job]] completed with the following parameters: [&#123;message=mrbird&#125;] and the following status: [COMPLETED] in 83msJobOperator包含了许多实用的方法：具体可以自己尝试玩一玩。本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/73.spring-batch-launcher。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch监听器]]></title>
    <url>%2FSpring-Batch%E7%9B%91%E5%90%AC%E5%99%A8.html</url>
    <content type="text"><![CDATA[Spring Batch提供了多种监听器Listener，用于在任务处理过程中触发我们的逻辑代码。常用的监听器根据粒度从粗到细分别有：Job级别的监听器JobExecutionListener、Step级别的监听器StepExecutionListener、Chunk监听器ChunkListener、ItemReader监听器ItemReadListener、ItemWriter监听器ItemWriteListener和ItemProcessor监听器ItemProcessListener等。具体可以参考下表：监听器具体说明JobExecutionListener在Job开始之前(beforeJob)和之后(aflerJob)触发StepExecutionListener在Step开始之前(beforeStep)和之后(afterStep)触发ChunkListener在 Chunk 开始之前(beforeChunk),之后(afterChunk)和错误后(afterChunkError)触发ItemReadListener在 Read 开始之前(beforeRead&gt;,之后(afterRead)和错误后(onReadError)触发ItemProcessListener在 Processor 开始之前(beforeProcess),之后(afterProcess)和错误后(onProcessError)触发ItemWriterListener在 Writer 开始之前(beforeWrite),之后(afterWrite)和错误后(onWriteError)触发框架搭建新建一个Spring Boot项目，版本为2.2.4.RELEASE，artifactId为spring-batch-listener，项目结构如下图所示：剩下的数据库层的准备，项目配置，依赖引入和Spring Batch入门文章中的框架搭建步骤一致，这里就不再赘述。监听器演示每种监听器都可以通过两种方式使用：接口实现；注解驱动。先来看看通过实现接口的方式使用监听器。在cc.mrbird.batch包下新建listener包，然后在该包下新建MyJobExecutionListener，实现JobExecutionListener接口：12345678910111213@Componentpublic class MyJobExecutionListener implements JobExecutionListener &#123; @Override public void beforeJob(JobExecution jobExecution) &#123; System.out.println("before job execute: " + jobExecution.getJobInstance().getJobName()); &#125; @Override public void afterJob(JobExecution jobExecution) &#123; System.out.println("after job execute: " + jobExecution.getJobInstance().getJobName()); &#125;&#125;上面实现的两个方法很直观了，触发时机分别为任务执行前和任务执行后。接着看看如何使用注解驱动使用监听器。在listener包下新建MyStepExecutionListener：12345678910111213@Componentpublic class MyStepExecutionListener &#123; @BeforeStep public void breforeStep(StepExecution stepExecution) &#123; System.out.println("before step execute: " + stepExecution.getStepName()); &#125; @AfterStep public void afterStep(StepExecution stepExecution) &#123; System.out.println("after step execute: " + stepExecution.getStepName()); &#125;&#125;通过注解的方式不需要实现接口，而是在对应的方法上通过诸如@BeforeStep、@AfterStep等注解标注即可，不过方法的签名必须符合注解的要求，否则会反射失败。比如，查看@BeforeStep的源码：监听器的创建大致就这两种姿势了，下面的例子不在详细说明，直接贴代码。在listener包下继续创建MyChunkListener、MyItemReaderListener、MyItemProcessListener和MyItemWriterListener。MyChunkListener：1234567891011121314151617@Componentpublic class MyChunkListener implements ChunkListener &#123; @Override public void beforeChunk(ChunkContext context) &#123; System.out.println("before chunk: " + context.getStepContext().getStepName()); &#125; @Override public void afterChunk(ChunkContext context) &#123; System.out.println("after chunk: " + context.getStepContext().getStepName()); &#125; @Override public void afterChunkError(ChunkContext context) &#123; System.out.println("before chunk error: " + context.getStepContext().getStepName()); &#125;&#125;MyItemReaderListener：1234567891011121314151617@Componentpublic class MyItemReaderListener implements ItemReadListener&lt;String&gt; &#123; @Override public void beforeRead() &#123; System.out.println("before read"); &#125; @Override public void afterRead(String item) &#123; System.out.println("after read: " + item); &#125; @Override public void onReadError(Exception ex) &#123; System.out.println("on read error: " + ex.getMessage()); &#125;&#125;MyItemProcessListener：1234567891011121314151617@Componentpublic class MyItemProcessListener implements ItemProcessListener&lt;String, String&gt; &#123; @Override public void beforeProcess(String item) &#123; System.out.println("before process: " + item); &#125; @Override public void afterProcess(String item, String result) &#123; System.out.println("after process: " + item + " result: " + result); &#125; @Override public void onProcessError(String item, Exception e) &#123; System.out.println("on process error: " + item + " , error message: " + e.getMessage()); &#125;&#125;MyItemWriterListener：123456789101112131415161718@Componentpublic class MyItemWriterListener implements ItemWriteListener&lt;String&gt; &#123; @Override public void beforeWrite(List&lt;? extends String&gt; items) &#123; System.out.println("before write: " + items); &#125; @Override public void afterWrite(List&lt;? extends String&gt; items) &#123; System.out.println("after write: " + items); &#125; @Override public void onWriteError(Exception exception, List&lt;? extends String&gt; items) &#123; System.out.println("on write error: " + items + " , error message: " + exception.getMessage()); &#125;&#125;准备好这些监听器后，我们在cc.mrbird.batch包下新建job包，然后在该包下新建ListenerTestJobDemo：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Componentpublic class ListenerTestJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private MyJobExecutionListener myJobExecutionListener; @Autowired private MyStepExecutionListener myStepExecutionListener; @Autowired private MyChunkListener myChunkListener; @Autowired private MyItemReaderListener myItemReaderListener; @Autowired private MyItemProcessListener myItemProcessListener; @Autowired private MyItemWriterListener myItemWriterListener; @Bean public Job listenerTestJob() &#123; return jobBuilderFactory.get("listenerTestJob") .start(step()) .listener(myJobExecutionListener) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .listener(myStepExecutionListener) .&lt;String, String&gt;chunk(2) .faultTolerant() .listener(myChunkListener) .reader(reader()) .listener(myItemReaderListener) .processor(processor()) .listener(myItemProcessListener) .writer(list -&gt; list.forEach(System.out::println)) .listener(myItemWriterListener) .build(); &#125; private ItemReader&lt;String&gt; reader() &#123; List&lt;String&gt; data = Arrays.asList("java", "c++", "javascript", "python"); return new simpleReader(data); &#125; private ItemProcessor&lt;String, String&gt; processor() &#123; return item -&gt; item + " language"; &#125;&#125;class simpleReader implements ItemReader&lt;String&gt; &#123; private Iterator&lt;String&gt; iterator; public simpleReader(List&lt;String&gt; data) &#123; this.iterator = data.iterator(); &#125; @Override public String read() &#123; return iterator.hasNext() ? iterator.next() : null; &#125;&#125;上面代码我们在相应的位置配置了监听器（配置chunk监听器的时候，必须配置faultTolerant()）。启动项目，控制台日志打印如下：1234567891011121314151617181920212223242526272829303132333435363738392020-03-09 17:08:34.439 INFO 20165 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=listenerTestJob]] launched with the following parameters: [&#123;&#125;]before job execute: listenerTestJob32020-03-09 17:08:34.495 INFO 20165 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]before step execute: stepbefore chunk: stepbefore readafter read: javabefore readafter read: c++before process: javaafter process: java result: java languagebefore process: c++after process: c++ result: c++ languagebefore write: [java language, c++ language]java languagec++ languageafter write: [java language, c++ language]after chunk: stepbefore chunk: stepbefore readafter read: javascriptbefore readafter read: pythonbefore process: javascriptafter process: javascript result: javascript languagebefore process: pythonafter process: python result: python languagebefore write: [javascript language, python language]javascript languagepython languageafter write: [javascript language, python language]after chunk: stepbefore chunk: stepbefore readafter chunk: stepafter step execute: step2020-03-09 17:08:34.546 INFO 20165 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 51msafter job execute: listenerTestJob32020-03-09 17:08:34.566 INFO 20165 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=listenerTestJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 105ms从上面的运行结果我们可以看出：证实了chunk(2)表示每一批处理2个数据块；Step里的执行顺序是read -&gt; process -&gt; writer。聚合监听器每种监听器可以通过对应的聚合类组合在一起，比如有多个JobExecutionListener，则可以使用CompositeJobExecutionListener聚合它们。上面介绍的这几种监听器都有与之对应的CompositeXXXListener聚合类，这里只演示CompositeJobExecutionListener，剩下的以此类推。在job包下新建CompositeJobExecutionListenerJobDemo：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Componentpublic class CompositeJobExecutionListenerJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job compositeJobExecutionListenerJob() &#123; return jobBuilderFactory.get("compositeJobExecutionListenerJob") .start(step()) .listener(compositeJobExecutionListener()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println("执行步骤...."); return RepeatStatus.FINISHED; &#125;).build(); &#125; private CompositeJobExecutionListener compositeJobExecutionListener() &#123; CompositeJobExecutionListener listener = new CompositeJobExecutionListener(); // 任务监听器1 JobExecutionListener jobExecutionListenerOne = new JobExecutionListener() &#123; @Override public void beforeJob(JobExecution jobExecution) &#123; System.out.println("任务监听器One，before job execute: " + jobExecution.getJobInstance().getJobName()); &#125; @Override public void afterJob(JobExecution jobExecution) &#123; System.out.println("任务监听器One，after job execute: " + jobExecution.getJobInstance().getJobName()); &#125; &#125;; // 任务监听器2 JobExecutionListener jobExecutionListenerTwo = new JobExecutionListener() &#123; @Override public void beforeJob(JobExecution jobExecution) &#123; System.out.println("任务监听器Two，before job execute: " + jobExecution.getJobInstance().getJobName()); &#125; @Override public void afterJob(JobExecution jobExecution) &#123; System.out.println("任务监听器Two，after job execute: " + jobExecution.getJobInstance().getJobName()); &#125; &#125;; // 聚合 listener.setListeners(Arrays.asList(jobExecutionListenerOne, jobExecutionListenerTwo)); return listener; &#125;&#125;启动项目，控制台日志打印如下：1234567892020-03-09 17:26:47.533 INFO 20310 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=compositeJobExecutionListenerJob]] launched with the following parameters: [&#123;&#125;]任务监听器One，before job execute: compositeJobExecutionListenerJob任务监听器Two，before job execute: compositeJobExecutionListenerJob2020-03-09 17:26:47.603 INFO 20310 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]执行步骤....2020-03-09 17:26:47.660 INFO 20310 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 57ms任务监听器Two，after job execute: compositeJobExecutionListenerJob任务监听器One，after job execute: compositeJobExecutionListenerJob2020-03-09 17:26:47.693 INFO 20310 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=compositeJobExecutionListenerJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 129ms除了本文介绍的这几个监听器外，还有一些和异常处理相关的监听器，会在后续的文章中提到。本文源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/71.spring-batch-listener。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch处理数据]]></title>
    <url>%2FSpring-Batch%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[在Spring Batch中，ItemReader接口用于读取数据，ItemWriter接口用于输出数据。除此之外，我们可以通过ItemProcessor接口实现数据的处理，包括：数据校验，数据过滤和数据转换等。数据处理的时机发生于ItemReader读取数据之后，ItemWriter输出数据之前。本节记录下Spring Batch中ItemProcessor的使用。框架搭建新建一个Spring Boot项目，版本为2.2.4.RELEASE，artifactId为spring-batch-itemprocessor，项目结构如下图所示：剩下的数据库层的准备，项目配置，依赖引入和Spring Batch入门文章中的框架搭建步骤一致，这里就不再赘述。在介绍Spring Batch ItemProcessor之前，我们先准备个简单的数据读取源。在cc.mrbird.batch包下新建entity包，然后在该包下新建TestData实体类：12345678public class TestData &#123; private int id; private String field1; private String field2; private String field3; // get,set,toString略&#125;接着在cc.mrbird.batch包下新建reader包，然后在该包下创建ItemReaderConfigure：12345678910111213141516171819202122232425262728@Configurationpublic class ItemReaderConfigure &#123; @Bean public ListItemReader&lt;TestData&gt; simpleReader() &#123; List&lt;TestData&gt; data = new ArrayList&lt;&gt;(); TestData testData1 = new TestData(); testData1.setId(1); testData1.setField1("11"); testData1.setField2("12"); testData1.setField3("13"); data.add(testData1); TestData testData2 = new TestData(); testData2.setId(2); testData2.setField1("21"); testData2.setField2("22"); testData2.setField3("23"); data.add(testData2); TestData testData3 = new TestData(); testData3.setId(3); testData3.setField1("31"); testData3.setField2("32"); // 设置为空字符串，用于后面格式校验演示 testData3.setField3(""); data.add(testData3); return new ListItemReader&lt;&gt;(data); &#125;&#125;上面注册了一个ItemReader类型的Bean，后续都用它作为读取数据的来源。格式校验ItemProcessor的实现类ValidatingItemProcessor可以用于数据格式校验。举个例子，在cc.mrbird.batch包下新建job包，然后在该包下新建ValidatingItemProcessorDemo：1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class ValidatingItemProcessorDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Bean public Job validatingItemProcessorJob() &#123; return jobBuilderFactory.get("validatingItemProcessorJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .processor(validatingItemProcessor()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; private ValidatingItemProcessor&lt;TestData&gt; validatingItemProcessor() &#123; ValidatingItemProcessor&lt;TestData&gt; processor = new ValidatingItemProcessor&lt;&gt;(); processor.setValidator(value -&gt; &#123; // 对每一条数据进行校验 if ("".equals(value.getField3())) &#123; // 如果field3的值为空串，则抛异常 throw new ValidationException("field3的值不合法"); &#125; &#125;); return processor; &#125;&#125;通过ValidatingItemProcessor我们对ItemReader读取的每一条数据进行校验，如果field3的值为空串的话，则抛出ValidationException(&quot;field3的值不合法&quot;)异常。ItemProcessor通过步骤创建工厂的processor()设置。启动项目，控制台日志的打印如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253542020-03-09 14:18:47.186 INFO 17967 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=validatingItemProcessorJob]] launched with the following parameters: [&#123;&#125;]2020-03-09 14:18:47.252 INFO 17967 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;2020-03-09 14:18:47.300 ERROR 17967 --- [ main] o.s.batch.core.step.AbstractStep : Encountered an error executing step step in job validatingItemProcessorJoborg.springframework.batch.item.validator.ValidationException: field3的值不合法 at cc.mrbird.batch.entity.job.ValidatingItemProcessorDemo.lambda$validatingItemProcessor$1(ValidatingItemProcessorDemo.java:50) ~[classes/:na] at org.springframework.batch.item.validator.ValidatingItemProcessor.process(ValidatingItemProcessor.java:84) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.SimpleChunkProcessor.doProcess(SimpleChunkProcessor.java:134) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.SimpleChunkProcessor.transform(SimpleChunkProcessor.java:319) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.SimpleChunkProcessor.process(SimpleChunkProcessor.java:210) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.ChunkOrientedTasklet.execute(ChunkOrientedTasklet.java:77) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:407) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:331) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:273) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:375) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:215) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:145) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:258) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:208) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:148) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:410) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:136) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:319) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:147) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50) [spring-core-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:140) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_231] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_231] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_231] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_231] at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration$PassthruAdvice.invoke(SimpleBatchConfiguration.java:127) [spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:212) [spring-aop-5.2.4.RELEASE.jar:5.2.4.RELEASE] at com.sun.proxy.$Proxy46.run(Unknown Source) [na:na] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.execute(JobLauncherCommandLineRunner.java:192) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.executeLocalJobs(JobLauncherCommandLineRunner.java:166) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.launchJobFromProperties(JobLauncherCommandLineRunner.java:153) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.autoconfigure.batch.JobLauncherCommandLineRunner.run(JobLauncherCommandLineRunner.java:148) [spring-boot-autoconfigure-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:784) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:768) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:322) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) [spring-boot-2.2.5.RELEASE.jar:2.2.5.RELEASE] at cc.mrbird.batch.SpringBatchItemprocessorApplication.main(SpringBatchItemprocessorApplication.java:12) [classes/:na]2020-03-09 14:18:47.307 INFO 17967 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 55ms2020-03-09 14:18:47.335 INFO 17967 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=validatingItemProcessorJob]] completed with the following parameters: [&#123;&#125;] and the following status: [FAILED] in 127ms可以看到任务处理过程中抛出了预期异常，关于任务处理中如何处理异常，可以参考后续的文章。除了使用这种方式外，我们还可以使用BeanValidatingItemProcessor校验使用JSR-303注解标注的实体类。比如，在TestData类的field3属性上添加@NotBlank注解：123456789public class TestData &#123; private int id; private String field1; private String field2; @NotBlank private String field3; // get,set,toString略&#125;使用该注解需要在pom中添加spring-boot-starter-validation依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;然后在job包下新建BeanValidatingItemProcessorDemo：12345678910111213141516171819202122232425262728293031323334@Componentpublic class BeanValidatingItemProcessorDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Bean public Job beanValidatingItemProcessorJob() throws Exception &#123; return jobBuilderFactory.get("beanValidatingItemProcessorJob") .start(step()) .build(); &#125; private Step step() throws Exception &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .processor(beanValidatingItemProcessor()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; private BeanValidatingItemProcessor&lt;TestData&gt; beanValidatingItemProcessor() throws Exception &#123; BeanValidatingItemProcessor&lt;TestData&gt; beanValidatingItemProcessor = new BeanValidatingItemProcessor&lt;&gt;(); // 开启过滤，不符合规则的数据被过滤掉； beanValidatingItemProcessor.setFilter(true); beanValidatingItemProcessor.afterPropertiesSet(); return beanValidatingItemProcessor; &#125;&#125;启动项目后，控制台日志打印如下：12345672020-03-09 14:31:14.813 INFO 18100 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=beanValidatingItemProcessorJob]] launched with the following parameters: [&#123;&#125;]2020-03-09 14:31:14.873 INFO 18100 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;2020-03-09 14:31:14.959 INFO 18100 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 85ms2020-03-09 14:31:14.980 INFO 18100 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=beanValidatingItemProcessorJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 145ms2020-03-09 14:31:15.069 INFO 18100 --- [ main]可以看到，不符合规则的数据已经被排除了。如果不开启过滤beanValidatingItemProcessor.setFilter(false)，那么在遇到不符合注解校验规则的数据，将抛出如下异常：1234567org.springframework.batch.item.validator.ValidationException: Validation failed for TestData&#123;id=3, field1=&apos;31&apos;, field2=&apos;32&apos;, field3=&apos;&apos;&#125;: Field error in object &apos;item&apos; on field &apos;field3&apos;: rejected value []; codes [NotBlank.item.field3,NotBlank.field3,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [item.field3,field3]; arguments []; default message [field3]]; default message [不能为空] at org.springframework.batch.item.validator.SpringValidator.validate(SpringValidator.java:54) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.item.validator.ValidatingItemProcessor.process(ValidatingItemProcessor.java:84) ~[spring-batch-infrastructure-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.SimpleChunkProcessor.doProcess(SimpleChunkProcessor.java:134) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] at org.springframework.batch.core.step.item.SimpleChunkProcessor.transform(SimpleChunkProcessor.java:319) ~[spring-batch-core-4.2.1.RELEASE.jar:4.2.1.RELEASE] ...数据过滤通过自定义ItemProcessor的实现类，我们也可以简单地实现数据过滤。在cc.mrbird.batch包下新建processor包，然后在该包下新建TestDataFilterItemProcessor：12345678@Componentpublic class TestDataFilterItemProcessor implements ItemProcessor&lt;TestData, TestData&gt; &#123; @Override public TestData process(TestData item) &#123; // 返回null，会过滤掉这条数据 return "".equals(item.getField3()) ? null : item; &#125;&#125;TestDataFilterItemProcessor实现了ItemProcessor的process()方法，在该方法内编写具体的校验逻辑，上面代码判断TestData的field3是否为空串，是的话返回null（返回null会过滤掉这条数据）。接着在job包下新建TestDataFilterItemProcessorDemo：12345678910111213141516171819202122232425262728@Componentpublic class TestDataFilterItemProcessorDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Autowired private TestDataFilterItemProcessor testDataFilterItemProcessor; @Bean public Job testDataFilterItemProcessorJob() &#123; return jobBuilderFactory.get("testDataFilterItemProcessorJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .processor(testDataFilterItemProcessor) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125;&#125;启动项目，控制台日志打印如下：1234562020-03-09 15:03:30.932 INFO 18690 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=testDataFilterItemProcessorJob]] launched with the following parameters: [&#123;&#125;]2020-03-09 15:03:30.973 INFO 18690 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;2020-03-09 15:03:31.012 INFO 18690 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 39ms2020-03-09 15:03:31.037 INFO 18690 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=testDataFilterItemProcessorJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 95ms数据转换在processor包下新建一个ItemProcessor实现类TestDataTransformItemPorcessor：123456789@Componentpublic class TestDataTransformItemPorcessor implements ItemProcessor&lt;TestData, TestData&gt; &#123; @Override public TestData process(TestData item) &#123; // field1值拼接 hello item.setField1(item.getField1() + " hello"); return item; &#125;&#125;在job包下新建TestDataTransformItemPorcessorDemo：12345678910111213141516171819202122232425262728@Componentpublic class TestDataTransformItemPorcessorDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Autowired private TestDataTransformItemPorcessor testDataTransformItemPorcessor; @Bean public Job testDataTransformItemPorcessorJob() &#123; return jobBuilderFactory.get("testDataTransformItemPorcessorJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .processor(testDataTransformItemPorcessor) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125;&#125;启动项目，控制台日志打印如下：12345672020-03-09 15:08:55.628 INFO 18775 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=testDataTransformItemPorcessorJob]] launched with the following parameters: [&#123;&#125;]2020-03-09 15:08:55.694 INFO 18775 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11 hello&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21 hello&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;TestData&#123;id=3, field1=&apos;31 hello&apos;, field2=&apos;32&apos;, field3=&apos;&apos;&#125;2020-03-09 15:08:55.757 INFO 18775 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 63ms2020-03-09 15:08:55.781 INFO 18775 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=testDataTransformItemPorcessorJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 144ms聚合处理在创建Step的时候，除了制定一个ItemProcess外，我们可以通过CompositeItemProcessor聚合多个processor处理过程。在job包下新建CompositeItemProcessorDemo：123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class CompositeItemProcessorDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Autowired private TestDataFilterItemProcessor testDataFilterItemProcessor; @Autowired private TestDataTransformItemPorcessor testDataTransformItemPorcessor; @Bean public Job compositeItemProcessorJob() &#123; return jobBuilderFactory.get("compositeItemProcessorJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .processor(compositeItemProcessor()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; // CompositeItemProcessor组合多种中间处理器 private CompositeItemProcessor&lt;TestData, TestData&gt; compositeItemProcessor() &#123; CompositeItemProcessor&lt;TestData, TestData&gt; processor = new CompositeItemProcessor&lt;&gt;(); List&lt;ItemProcessor&lt;TestData, TestData&gt;&gt; processors = Arrays.asList(testDataFilterItemProcessor, testDataTransformItemPorcessor); // 代理两个processor processor.setDelegates(processors); return processor; &#125;&#125;上面代码中，我们通过CompositeItemProcessor聚合了前面定义的连个processor：TestDataFilterItemProcessor和TestDataTransformItemPorcessor。启动项目，控制台日志打印如下：1234562020-03-09 15:21:24.960 INFO 18882 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=compositeItemProcessorJob]] launched with the following parameters: [&#123;&#125;]2020-03-09 15:21:25.005 INFO 18882 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11 hello&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21 hello&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;2020-03-09 15:21:25.065 INFO 18882 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 60ms2020-03-09 15:21:25.104 INFO 18882 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=compositeItemProcessorJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 128ms从结果可以看到，数据不但进行了过滤，还进行了转换（拼接hello）。本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/70.spring-batch-itemprocessor。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch输出数据]]></title>
    <url>%2FSpring-Batch%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[Spring Batch输出数据通过ItemWriter接口的实现类来完成，包括FlatFileItemWriter文本数据输出、StaxEventItemWriter XML文件数据输出、JsonItemWriter JSON文件数据输出、JdbcBatchItemWriter数据库数据插入等实现，更多可用的实现可以参考：https://docs.spring.io/spring-batch/docs/4.2.x/reference/html/appendix.html#itemWritersAppendix，本文只介绍这四种比较常用的输出数据方式。框架搭建新建一个Spring Boot项目，版本为2.2.4.RELEASE，artifactId为spring-batch-itemwriter，项目结构如下图所示：剩下的数据库层的准备，项目配置，依赖引入和Spring Batch入门文章中的框架搭建步骤一致，这里就不再赘述。在介绍Spring Batch数据输出之前，我们先准备个简单的数据读取源。在cc.mrbird.batch包下新建entity包，然后在该包下新建TestData实体类：12345678public class TestData &#123; private int id; private String field1; private String field2; private String field3; // get,set,toString略&#125;接着在cc.mrbird.batch包下新建reader包，然后在该包下创建ItemReaderConfigure：123456789101112131415161718192021@Configurationpublic class ItemReaderConfigure &#123; @Bean public ListItemReader&lt;TestData&gt; simpleReader() &#123; List&lt;TestData&gt; data = new ArrayList&lt;&gt;(); TestData testData1 = new TestData(); testData1.setId(1); testData1.setField1("11"); testData1.setField2("12"); testData1.setField3("13"); data.add(testData1); TestData testData2 = new TestData(); testData2.setId(2); testData2.setField1("21"); testData2.setField2("22"); testData2.setField3("23"); data.add(testData2); return new ListItemReader&lt;&gt;(data); &#125;&#125;上面注册了一个ItemReader类型的Bean，后续都用它作为读取数据的来源。输出文本数据在cc.mrbird.batch包下新建job包，然后在该包下新建FileItemWriterDemo，用于测试Spring Batch输出数据到文本文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Componentpublic class FileItemWriterDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Bean public Job fileItemWriterJob() throws Exception &#123; return jobBuilderFactory.get("fileItemWriterJob") .start(step()) .build(); &#125; private Step step() throws Exception &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .writer(fileItemWriter()) .build(); &#125; private FlatFileItemWriter&lt;TestData&gt; fileItemWriter() throws Exception &#123; FlatFileItemWriter&lt;TestData&gt; writer = new FlatFileItemWriter&lt;&gt;(); FileSystemResource file = new FileSystemResource("/Users/mrbird/Desktop/file"); Path path = Paths.get(file.getPath()); if (!Files.exists(path)) &#123; Files.createFile(path); &#125; // 设置输出文件路径 writer.setResource(file); // 把读到的每个TestData对象转换为JSON字符串 LineAggregator&lt;TestData&gt; aggregator = item -&gt; &#123; try &#123; ObjectMapper mapper = new ObjectMapper(); return mapper.writeValueAsString(item); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return ""; &#125;; writer.setLineAggregator(aggregator); writer.afterPropertiesSet(); return writer; &#125;&#125;上面代码中，Step中的Reader使用的是我们上面创建的simpleReader，文本数据输出使用的是FlatFileItemWriter。fileItemWriter()方法的代码较为简单，这里就不赘述了。启动项目后，在/Users/mrbird/Desktop目录下（也就是我的电脑桌面上）会多出个file文件：输出xml数据同样的，xml格式数据输出需要借助spring-oxm框架，在pom中引入相关依赖：123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.11.1&lt;/version&gt;&lt;/dependency&gt;然后在job包下新建XmlFileItemWriterDemo，用于测试Spring Batch输出数据到xml文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Componentpublic class XmlFileItemWriterDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Bean public Job xmlFileItemWriterJob() throws Exception &#123; return jobBuilderFactory.get("xmlFileItemWriterJob") .start(step()) .build(); &#125; private Step step() throws Exception &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .writer(xmlFileItemWriter()) .build(); &#125; private StaxEventItemWriter&lt;TestData&gt; xmlFileItemWriter() throws IOException &#123; StaxEventItemWriter&lt;TestData&gt; writer = new StaxEventItemWriter&lt;&gt;(); // 通过XStreamMarshaller将TestData转换为xml XStreamMarshaller marshaller = new XStreamMarshaller(); Map&lt;String,Class&lt;TestData&gt;&gt; map = new HashMap&lt;&gt;(1); map.put("test", TestData.class); marshaller.setAliases(map); // 设置xml标签 writer.setRootTagName("tests"); // 设置根标签 writer.setMarshaller(marshaller); FileSystemResource file = new FileSystemResource("/Users/mrbird/Desktop/file.xml"); Path path = Paths.get(file.getPath()); if (!Files.exists(path)) &#123; Files.createFile(path); &#125; writer.setResource(file); // 设置目标文件路径 return writer; &#125;&#125;xml类型文件输出使用的是StaxEventItemWriter。启动项目后，在/Users/mrbird/Desktop目录下会多出个file.xml文件：输出JSON数据在job包下新建JsonFileItemWriterDemo，用于测试Spring Batch输出数据到json文件：12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class JsonFileItemWriterDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Bean public Job jsonFileItemWriterJob() throws Exception &#123; return jobBuilderFactory.get("jsonFileItemWriterJob") .start(step()) .build(); &#125; private Step step() throws Exception &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .writer(jsonFileItemWriter()) .build(); &#125; private JsonFileItemWriter&lt;TestData&gt; jsonFileItemWriter() throws IOException &#123; // 文件输出目标地址 FileSystemResource file = new FileSystemResource("/Users/mrbird/Desktop/file.json"); Path path = Paths.get(file.getPath()); if (!Files.exists(path)) &#123; Files.createFile(path); &#125; // 将对象转换为json JacksonJsonObjectMarshaller&lt;TestData&gt; marshaller = new JacksonJsonObjectMarshaller&lt;&gt;(); JsonFileItemWriter&lt;TestData&gt; writer = new JsonFileItemWriter&lt;&gt;(file, marshaller); // 设置别名 writer.setName("testDatasonFileItemWriter"); return writer; &#125;&#125;json类型文件输出使用的是JsonFileItemWriter。启动项目后，在/Users/mrbird/Desktop目录下会多出个file.json文件：输出数据到数据库在job包下新建DatabaseItemWriterDemo，用于测试Spring Batch输出数据到数据库：1234567891011121314151617181920212223242526272829303132333435363738394041424344@Componentpublic class DatabaseItemWriterDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Autowired private DataSource dataSource; @Bean public Job datasourceItemWriterJob() &#123; return jobBuilderFactory.get("datasourceItemWriterJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .writer(dataSourceItemWriter()) .build(); &#125; private ItemWriter&lt;TestData&gt; dataSourceItemWriter() &#123; // ItemWriter的实现类之一，mysql数据库数据写入使用JdbcBatchItemWriter， // 其他实现：MongoItemWriter,Neo4jItemWriter等 JdbcBatchItemWriter&lt;TestData&gt; writer = new JdbcBatchItemWriter&lt;&gt;(); writer.setDataSource(dataSource); // 设置数据源 String sql = "insert into TEST(id,field1,field2,field3) values (:id,:field1,:field2,:field3)"; writer.setSql(sql); // 设置插入sql脚本 // 映射TestData对象属性到占位符中的属性 BeanPropertyItemSqlParameterSourceProvider&lt;TestData&gt; provider = new BeanPropertyItemSqlParameterSourceProvider&lt;&gt;(); writer.setItemSqlParameterSourceProvider(provider); writer.afterPropertiesSet(); // 设置一些额外属性 return writer; &#125;&#125;MySQL关系型数据数据写入使用的是JdbcBatchItemWriter。在测试之前，先清空springbatch数据库TEST表数据，然后启动项目，启动后，TEST表记录如下所示：多文本输出多文本输出和上一节介绍的多文本数据读取类似，都是需要通过代理来完成。我们模拟个同时输出xml格式和普通文本格式的例子。在cc.mrbird.batch包下新建writer包，然后在该包下新建ItemWriterConfigure配置类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Configurationpublic class ItemWriterConfigure &#123; @Bean public FlatFileItemWriter&lt;TestData&gt; fileItemWriter() throws Exception &#123; FlatFileItemWriter&lt;TestData&gt; writer = new FlatFileItemWriter&lt;&gt;(); FileSystemResource file = new FileSystemResource("/Users/mrbird/Desktop/file"); Path path = Paths.get(file.getPath()); if (!Files.exists(path)) &#123; Files.createFile(path); &#125; writer.setResource(file); // 设置目标文件路径 // 把读到的每个TestData对象转换为字符串 LineAggregator&lt;TestData&gt; aggregator = item -&gt; &#123; try &#123; ObjectMapper mapper = new ObjectMapper(); return mapper.writeValueAsString(item); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return ""; &#125;; writer.setLineAggregator(aggregator); writer.afterPropertiesSet(); return writer; &#125; @Bean public StaxEventItemWriter&lt;TestData&gt; xmlFileItemWriter() throws Exception &#123; StaxEventItemWriter&lt;TestData&gt; writer = new StaxEventItemWriter&lt;&gt;(); // 通过XStreamMarshaller将TestData转换为xml XStreamMarshaller marshaller = new XStreamMarshaller(); Map&lt;String, Class&lt;TestData&gt;&gt; map = new HashMap&lt;&gt;(1); map.put("test", TestData.class); marshaller.setAliases(map); // 设置xml标签 writer.setRootTagName("tests"); // 设置根标签 writer.setMarshaller(marshaller); FileSystemResource file = new FileSystemResource("/Users/mrbird/Desktop/file.xml"); Path path = Paths.get(file.getPath()); if (!Files.exists(path)) &#123; Files.createFile(path); &#125; writer.setResource(file); // 设置目标文件路径 return writer; &#125;&#125;上面的配置类中，配置了FlatFileItemWriter和StaxEventItemWriter类型的ItemWriter Bean，代码步骤和前面介绍的一致。然后在job包下新建MultiFileItemWriteDemo，用于测试多文本输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Componentpublic class MultiFileItemWriteDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private DataSource dataSource; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Autowired private ItemStreamWriter&lt;TestData&gt; fileItemWriter; @Autowired private ItemStreamWriter&lt;TestData&gt; xmlFileItemWriter; @Bean public Job multiFileItemWriterJob() &#123; return jobBuilderFactory.get("multiFileItemWriterJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .writer(classifierMultiFileItemWriter()) .stream(fileItemWriter) .stream(xmlFileItemWriter) .build(); &#125; // 将数据分类，然后分别输出到对应的文件(此时需要将writer注册到ioc容器，否则报 // WriterNotOpenException: Writer must be open before it can be written to) private ClassifierCompositeItemWriter&lt;TestData&gt; classifierMultiFileItemWriter() &#123; ClassifierCompositeItemWriter&lt;TestData&gt; writer = new ClassifierCompositeItemWriter&lt;&gt;(); writer.setClassifier((Classifier&lt;TestData, ItemWriter&lt;? super TestData&gt;&gt;) testData -&gt; &#123; try &#123; // id能被2整除则输出到普通文本，否则输出到xml文本 return testData.getId() % 2 == 0 ? fileItemWriter : xmlFileItemWriter; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;); return writer; &#125;&#125;ClassifierCompositeItemWriter可以设置不同条件下使用不同的ItemWriter输出数据，此外在Step中，还需通过StepBuilderFactory的stream()方法传入使用到的ItemWriter（这里需要注意的是，注入的时候，类型应选择ItemStreamWriter）。在启动项目前，先删掉/Users/mrbird/Desktop目录下的文件。删掉后，启动项目，结果如下：如果不想用分类，希望所有数据都输出到对应格式的文本中，则可以使用CompositeItemWriter作为代理输出，修改MultiFileItemWriteDemo：1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class MultiFileItemWriteDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private ListItemReader&lt;TestData&gt; simpleReader; @Autowired private ItemStreamWriter&lt;TestData&gt; fileItemWriter; @Autowired private ItemStreamWriter&lt;TestData&gt; xmlFileItemWriter; @Bean public Job multiFileItemWriterJob() &#123; return jobBuilderFactory.get("multiFileItemWriterJob2") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(simpleReader) .writer(multiFileItemWriter()) .build(); &#125; // 输出数据到多个文件 private CompositeItemWriter&lt;TestData&gt; multiFileItemWriter() &#123; // 使用CompositeItemWriter代理 CompositeItemWriter&lt;TestData&gt; writer = new CompositeItemWriter&lt;&gt;(); // 设置具体写代理 writer.setDelegates(Arrays.asList(fileItemWriter, xmlFileItemWriter)); return writer; &#125;&#125;在启动项目前，先删掉/Users/mrbird/Desktop目录下的文件。删掉后，启动项目，结果如下：本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/69.spring-batch-itemwriter。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch读取数据]]></title>
    <url>%2FSpring-Batch%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[Spring Batch读取数据通过ItemReader接口的实现类来完成，包括FlatFileItemReader文本数据读取、StaxEventItemReader XML文件数据读取、JsonItemReader JSON文件数据读取、JdbcPagingItemReader数据库分页数据读取等实现，更多可用的实现可以参考：https://docs.spring.io/spring-batch/docs/4.2.x/reference/html/appendix.html#itemReadersAppendix，本文只介绍这四种比较常用的读取数据方式。框架搭建新建一个Spring Boot项目，版本为2.2.4.RELEASE，artifactId为spring-batch-itemreader，项目结构如下图所示：剩下的数据库层的准备，项目配置，依赖引入和Spring Batch入门文章中的框架搭建步骤一致，这里就不再赘述。简单数据读取前面提到，Spring Batch读取数据是通过ItemReader接口的实现类来完成的，所以我们可以自定义一个ItemReader的实现类，实现简单数据的读取。在cc.mrbird.batch包下新建reader包，然后在该包下新建ItemReader接口的实现类MySimpleIteamReader：1234567891011121314public class MySimpleIteamReader implements ItemReader&lt;String&gt; &#123; private Iterator&lt;String&gt; iterator; public MySimpleIteamReader(List&lt;String&gt; data) &#123; this.iterator = data.iterator(); &#125; @Override public String read() &#123; // 数据一个接着一个读取 return iterator.hasNext() ? iterator.next() : null; &#125;&#125;泛型指定读取数据的格式，这里读取的是String类型的List，read()方法的实现也很简单，就是遍历集合数据。接着在cc.mrbird.batch包下新建job包，然后在该包下新建MySimpleItemReaderDemo类，用于测试我们定义的MySimpleIteamReader，MySimpleItemReaderDemo类代码如下：12345678910111213141516171819202122232425262728@Componentpublic class MySimpleItemReaderDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job mySimpleItemReaderJob() &#123; return jobBuilderFactory.get("mySimpleItemReaderJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;String, String&gt;chunk(2) .reader(mySimpleItemReader()) .writer(list -&gt; list.forEach(System.out::println)) // 简单输出，后面再详细介绍writer .build(); &#125; private ItemReader&lt;String&gt; mySimpleItemReader() &#123; List&lt;String&gt; data = Arrays.asList("java", "c++", "javascript", "python"); return new MySimpleIteamReader(data); &#125;&#125;上面代码中，我们通过mySimpleItemReader()方法创建了一个MySimpleIteamReader，并且传入了List数据。上面代码大体和上一节中介绍的差不多，最主要的区别就是Step的创建过程稍有不同。在MySimpleItemReaderDemo类中，我们通过StepBuilderFactory创建步骤Step，不过不再是使用tasklet()方法创建，而是使用chunk()方法。chunk字面上的意思是“块”的意思，可以简单理解为数据块，泛型&lt;String, String&gt;用于指定读取的数据和输出的数据类型，构造器入参指定了数据块的大小，比如指定为2时表示每当读取2组数据后做一次数据输出处理。接着reader()方法指定读取数据的方式，该方法接收ItemReader的实现类，这里使用的是我们自定义的MySimpleIteamReader。writer()方法指定数据输出方式，因为这块不是本文的重点，所以先简单遍历输出即可。启动项目，控制台日志打印如下：123456782020-03-07 11:17:32.303 INFO 28381 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=mySimpleItemReaderJob]] launched with the following parameters: [&#123;&#125;]2020-03-07 11:17:32.369 INFO 28381 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]javac++javascriptpython2020-03-07 11:17:32.428 INFO 28381 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 59ms2020-03-07 11:17:32.451 INFO 28381 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=mySimpleItemReaderJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 125ms文本数据读取Spring Batch读取文本类型数据可以通过FlatFileItemReader实现，在演示怎么使用之前，我们先准备好数据文件。在resources目录下新建file文件，内容如下：1234567// 演示文件数据读取1,11,12,132,21,22,233,31,32,334,41,42,435,51,52,536,61,62,63file的数据是一行一行以逗号分隔的数据（在批处理业务中，文本类型的数据文件一般都是有一定规律的）。在文本数据读取的过程中，我们需要将读取的数据转换为POJO对象存储，所以我们需要创建一个与之对应的POJO对象。在cc.mrbird.batch包下新建entity包，然后在该包下新建TestData类：12345678public class TestData &#123; private int id; private String field1; private String field2; private String field3; // get,set,toString略&#125;因为file文本中的一行数据经过逗号分隔后为1、11、12、13，所以我们创建的与之对应的POJO TestData包含4个属性id、field1、field2和field3。接着在job包下新建FileItemReaderDemo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Componentpublic class FileItemReaderDemo &#123; // 任务创建工厂 @Autowired private JobBuilderFactory jobBuilderFactory; // 步骤创建工厂 @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job fileItemReaderJob() &#123; return jobBuilderFactory.get("fileItemReaderJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(fileItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; private ItemReader&lt;TestData&gt; fileItemReader() &#123; FlatFileItemReader&lt;TestData&gt; reader = new FlatFileItemReader&lt;&gt;(); reader.setResource(new ClassPathResource("file")); // 设置文件资源地址 reader.setLinesToSkip(1); // 忽略第一行 // AbstractLineTokenizer的三个实现类之一，以固定分隔符处理行数据读取, // 使用默认构造器的时候，使用逗号作为分隔符，也可以通过有参构造器来指定分隔符 DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer(); // 设置属性名，类似于表头 tokenizer.setNames("id", "field1", "field2", "field3"); // 将每行数据转换为TestData对象 DefaultLineMapper&lt;TestData&gt; mapper = new DefaultLineMapper&lt;&gt;(); // 设置LineTokenizer mapper.setLineTokenizer(tokenizer); // 设置映射方式，即读取到的文本怎么转换为对应的POJO mapper.setFieldSetMapper(fieldSet -&gt; &#123; TestData data = new TestData(); data.setId(fieldSet.readInt("id")); data.setField1(fieldSet.readString("field1")); data.setField2(fieldSet.readString("field2")); data.setField3(fieldSet.readString("field3")); return data; &#125;); reader.setLineMapper(mapper); return reader; &#125;&#125;上面代码中，我们在fileItemReader()方法里编写了具体的文本数据读取代码，过程参考注释即可。DelimitedLineTokenizer分隔符行处理器的默认构造器源码如下所示：常量DELIMITER_COMMA的值为public static final String DELIMITER_COMMA = &quot;,&quot;;，假如我们的数据并不是用逗号分隔，而是用|等字符分隔的话，可以使用它的有参构造器指定：1DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer("|");DelimitedLineTokenizer是AbstractLineTokenizer三个实现类之一：顾名思义，FixedLengthTokenizer通过指定的固定长度来截取数据，RegexLineTokenizer通过正则表达式来匹配数据，这里就不演示了，有兴趣的可以自己玩玩。编写好FileItemReaderDemo后，启动项目，控制台日志打印如下：123456789102020-03-07 12:06:11.876 INFO 29042 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=fileItemReaderJob]] launched with the following parameters: [&#123;&#125;]2020-03-07 12:06:11.937 INFO 29042 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;TestData&#123;id=3, field1=&apos;31&apos;, field2=&apos;32&apos;, field3=&apos;33&apos;&#125;TestData&#123;id=4, field1=&apos;41&apos;, field2=&apos;42&apos;, field3=&apos;43&apos;&#125;TestData&#123;id=5, field1=&apos;51&apos;, field2=&apos;52&apos;, field3=&apos;53&apos;&#125;TestData&#123;id=6, field1=&apos;61&apos;, field2=&apos;62&apos;, field3=&apos;63&apos;&#125;2020-03-07 12:06:12.020 INFO 29042 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 83ms2020-03-07 12:06:12.044 INFO 29042 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=fileItemReaderJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 146ms数据库数据读取在演示从数据库中读取数据之前，我们先准备好测试数据。在springbatch数据库中新建一张TEST表，SQL语句如下所示：1234567891011121314151617181920212223-- ------------------------------ Table structure for TEST-- ----------------------------DROP TABLE IF EXISTS `TEST`;CREATE TABLE `TEST` ( `id` bigint(10) NOT NULL COMMENT 'ID', `field1` varchar(10) NOT NULL COMMENT '字段一', `field2` varchar(10) NOT NULL COMMENT '字段二', `field3` varchar(10) NOT NULL COMMENT '字段三', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------ Records of TEST-- ----------------------------BEGIN;INSERT INTO `TEST` VALUES (1, '11', '12', '13');INSERT INTO `TEST` VALUES (2, '21', '22', '23');INSERT INTO `TEST` VALUES (3, '31', '32', '33');INSERT INTO `TEST` VALUES (4, '41', '42', '43');INSERT INTO `TEST` VALUES (5, '51', '52', '53');INSERT INTO `TEST` VALUES (6, '61', '62', '63');COMMIT;TEST表的字段和上面创建的TestData实体类一致。然后在job包下新建DataSourceItemReaderDemo类，测试从数据库中读取数据：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Componentpublic class DataSourceItemReaderDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; // 注入数据源 @Autowired private DataSource dataSource; @Bean public Job dataSourceItemReaderJob() throws Exception &#123; return jobBuilderFactory.get("dataSourceItemReaderJob") .start(step()) .build(); &#125; private Step step() throws Exception &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(dataSourceItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; private ItemReader&lt;TestData&gt; dataSourceItemReader() throws Exception &#123; JdbcPagingItemReader&lt;TestData&gt; reader = new JdbcPagingItemReader&lt;&gt;(); reader.setDataSource(dataSource); // 设置数据源 reader.setFetchSize(5); // 每次取多少条记录 reader.setPageSize(5); // 设置每页数据量 // 指定sql查询语句 select id,field1,field2,field3 from TEST MySqlPagingQueryProvider provider = new MySqlPagingQueryProvider(); provider.setSelectClause("id,field1,field2,field3"); //设置查询字段 provider.setFromClause("from TEST"); // 设置从哪张表查询 // 将读取到的数据转换为TestData对象 reader.setRowMapper((resultSet, rowNum) -&gt; &#123; TestData data = new TestData(); data.setId(resultSet.getInt(1)); data.setField1(resultSet.getString(2)); // 读取第一个字段，类型为String data.setField2(resultSet.getString(3)); data.setField3(resultSet.getString(4)); return data; &#125;); Map&lt;String, Order&gt; sort = new HashMap&lt;&gt;(1); sort.put("id", Order.ASCENDING); provider.setSortKeys(sort); // 设置排序,通过id 升序 reader.setQueryProvider(provider); // 设置namedParameterJdbcTemplate等属性 reader.afterPropertiesSet(); return reader; &#125;&#125;dataSourceItemReader()方法中的主要步骤就是：通过JdbcPagingItemReader设置对应的数据源，然后设置数据量、获取数据的sql语句、排序规则和查询结果与POJO的映射规则等。方法末尾之所以需要调用JdbcPagingItemReader的afterPropertiesSet()方法是因为需要设置JDBC模板（afterPropertiesSet()方法源码）：启动项目，控制台日志打印如下：123456789102020-03-07 16:01:05.366 INFO 30264 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=dataSourceItemReaderJob]] launched with the following parameters: [&#123;&#125;]2020-03-07 16:01:05.420 INFO 30264 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;TestData&#123;id=3, field1=&apos;31&apos;, field2=&apos;32&apos;, field3=&apos;33&apos;&#125;TestData&#123;id=4, field1=&apos;41&apos;, field2=&apos;42&apos;, field3=&apos;43&apos;&#125;TestData&#123;id=5, field1=&apos;51&apos;, field2=&apos;52&apos;, field3=&apos;53&apos;&#125;TestData&#123;id=6, field1=&apos;61&apos;, field2=&apos;62&apos;, field3=&apos;63&apos;&#125;2020-03-07 16:01:05.512 INFO 30264 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 92ms2020-03-07 16:01:05.534 INFO 30264 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=dataSourceItemReaderJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 147msXML数据读取Spring Batch借助Spring OXM可以轻松地实现xml格式数据文件读取。在resources目录下新建file.xml，内容如下所示：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;tests&gt; &lt;test&gt; &lt;id&gt;1&lt;/id&gt; &lt;field1&gt;11&lt;/field1&gt; &lt;field2&gt;12&lt;/field2&gt; &lt;field3&gt;13&lt;/field3&gt; &lt;/test&gt; &lt;test&gt; &lt;id&gt;2&lt;/id&gt; &lt;field1&gt;21&lt;/field1&gt; &lt;field2&gt;22&lt;/field2&gt; &lt;field3&gt;23&lt;/field3&gt; &lt;/test&gt; &lt;test&gt; &lt;id&gt;3&lt;/id&gt; &lt;field1&gt;31&lt;/field1&gt; &lt;field2&gt;32&lt;/field2&gt; &lt;field3&gt;33&lt;/field3&gt; &lt;/test&gt; &lt;test&gt; &lt;id&gt;4&lt;/id&gt; &lt;field1&gt;41&lt;/field1&gt; &lt;field2&gt;42&lt;/field2&gt; &lt;field3&gt;43&lt;/field3&gt; &lt;/test&gt; &lt;test&gt; &lt;id&gt;5&lt;/id&gt; &lt;field1&gt;51&lt;/field1&gt; &lt;field2&gt;52&lt;/field2&gt; &lt;field3&gt;53&lt;/field3&gt; &lt;/test&gt; &lt;test&gt; &lt;id&gt;6&lt;/id&gt; &lt;field1&gt;61&lt;/field1&gt; &lt;field2&gt;62&lt;/field2&gt; &lt;field3&gt;63&lt;/field3&gt; &lt;/test&gt;&lt;/tests&gt;xml文件内容由一组一组的&lt;test&gt;&lt;/test&gt;标签组成，&lt;test&gt;标签又包含四组子标签，标签名称和TestData实体类属性一一对应。准备好xml文件后，我们在pom中引入spring-oxm依赖：123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.11.1&lt;/version&gt;&lt;/dependency&gt;接着在job包下新建XmlFileItemReaderDemo，演示xml文件数据获取：1234567891011121314151617181920212223242526272829303132333435363738@Componentpublic class XmlFileItemReaderDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job xmlFileItemReaderJob() &#123; return jobBuilderFactory.get("xmlFileItemReaderJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(xmlFileItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; private ItemReader&lt;TestData&gt; xmlFileItemReader() &#123; StaxEventItemReader&lt;TestData&gt; reader = new StaxEventItemReader&lt;&gt;(); reader.setResource(new ClassPathResource("file.xml")); // 设置xml文件源 reader.setFragmentRootElementName("test"); // 指定xml文件的根标签 // 将xml数据转换为TestData对象 XStreamMarshaller marshaller = new XStreamMarshaller(); // 指定需要转换的目标数据类型 Map&lt;String, Class&lt;TestData&gt;&gt; map = new HashMap&lt;&gt;(1); map.put("test", TestData.class); marshaller.setAliases(map); reader.setUnmarshaller(marshaller); return reader; &#125;&#125;在xmlFileItemReader()方法中，我们通过StaxEventItemReader读取xml文件，代码较简单，看注释即可。启动项目，控制台日志打印如下：12345678910020-03-07 16:23:47.775 INFO 30450 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=xmlFileItemReaderJob]] launched with the following parameters: [&#123;&#125;]2020-03-07 16:23:47.820 INFO 30450 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;TestData&#123;id=3, field1=&apos;31&apos;, field2=&apos;32&apos;, field3=&apos;33&apos;&#125;TestData&#123;id=4, field1=&apos;41&apos;, field2=&apos;42&apos;, field3=&apos;43&apos;&#125;TestData&#123;id=5, field1=&apos;51&apos;, field2=&apos;52&apos;, field3=&apos;53&apos;&#125;TestData&#123;id=6, field1=&apos;61&apos;, field2=&apos;62&apos;, field3=&apos;63&apos;&#125;2020-03-07 16:23:47.961 INFO 30450 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 140ms2020-03-07 16:23:47.984 INFO 30450 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=xmlFileItemReaderJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 200msJSON数据读取在resources目录下新建file.json文件，内容如下：1234567891011121314151617181920[ &#123; "id": 1, "field1": "11", "field2": "12", "field3": "13" &#125;, &#123; "id": 2, "field1": "21", "field2": "22", "field3": "23" &#125;, &#123; "id": 3, "field1": "31", "field2": "32", "field3": "33" &#125;]JSON对象属性和TestData对象属性一一对应。在job包下新建JSONFileItemReaderDemo，用于测试JSON文件数据读取：12345678910111213141516171819202122232425262728293031323334@Componentpublic class JSONFileItemReaderDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job jsonFileItemReaderJob() &#123; return jobBuilderFactory.get("jsonFileItemReaderJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(jsonItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; private ItemReader&lt;TestData&gt; jsonItemReader() &#123; // 设置json文件地址 ClassPathResource resource = new ClassPathResource("file.json"); // 设置json文件转换的目标对象类型 JacksonJsonObjectReader&lt;TestData&gt; jacksonJsonObjectReader = new JacksonJsonObjectReader&lt;&gt;(TestData.class); JsonItemReader&lt;TestData&gt; reader = new JsonItemReader&lt;&gt;(resource, jacksonJsonObjectReader); // 给reader设置一个别名 reader.setName("testDataJsonItemReader"); return reader; &#125;&#125;启动项目，控制台输出如下：12345672020-03-07 16:40:52.508 INFO 30599 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jsonFileItemReaderJob]] launched with the following parameters: [&#123;&#125;]2020-03-07 16:40:52.554 INFO 30599 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;TestData&#123;id=3, field1=&apos;31&apos;, field2=&apos;32&apos;, field3=&apos;33&apos;&#125;2020-03-07 16:40:52.622 INFO 30599 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 67ms2020-03-07 16:40:52.642 INFO 30599 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=jsonFileItemReaderJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 124ms多文本数据读取多文本的数据读取本质还是单文件数据读取，区别就是多文件读取需要在单文件读取的方式上设置一层代理。在resources目录下新建两个文件file1和file2，file1内容如下所示：1234567// 演示文件数据读取1,11,12,132,21,22,233,31,32,334,41,42,435,51,52,536,61,62,63file2内容如下所示：123// 演示文件数据读取7,71,72,738,81,82,83然后在job包下新建MultiFileIteamReaderDemo，演示多文件数据读取：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Componentpublic class MultiFileIteamReaderDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job multiFileItemReaderJob() &#123; return jobBuilderFactory.get("multiFileItemReaderJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .&lt;TestData, TestData&gt;chunk(2) .reader(multiFileItemReader()) .writer(list -&gt; list.forEach(System.out::println)) .build(); &#125; private ItemReader&lt;TestData&gt; multiFileItemReader() &#123; MultiResourceItemReader&lt;TestData&gt; reader = new MultiResourceItemReader&lt;&gt;(); reader.setDelegate(fileItemReader()); // 设置文件读取代理，方法可以使用前面文件读取中的例子 Resource[] resources = new Resource[]&#123; new ClassPathResource("file1"), new ClassPathResource("file2") &#125;; reader.setResources(resources); // 设置多文件源 return reader; &#125; private FlatFileItemReader&lt;TestData&gt; fileItemReader() &#123; FlatFileItemReader&lt;TestData&gt; reader = new FlatFileItemReader&lt;&gt;(); reader.setLinesToSkip(1); // 忽略第一行 // AbstractLineTokenizer的三个实现类之一，以固定分隔符处理行数据读取, // 使用默认构造器的时候，使用逗号作为分隔符，也可以通过有参构造器来指定分隔符 DelimitedLineTokenizer tokenizer = new DelimitedLineTokenizer(); // 设置属姓名，类似于表头 tokenizer.setNames("id", "field1", "field2", "field3"); // 将每行数据转换为TestData对象 DefaultLineMapper&lt;TestData&gt; mapper = new DefaultLineMapper&lt;&gt;(); mapper.setLineTokenizer(tokenizer); // 设置映射方式 mapper.setFieldSetMapper(fieldSet -&gt; &#123; TestData data = new TestData(); data.setId(fieldSet.readInt("id")); data.setField1(fieldSet.readString("field1")); data.setField2(fieldSet.readString("field2")); data.setField3(fieldSet.readString("field3")); return data; &#125;); reader.setLineMapper(mapper); return reader; &#125;&#125;上面代码中fileItemReader()方法在文本数据读取中介绍过了，多文件读取的关键在于multiFileItemReader()方法，该方法通过MultiResourceItemReader对象设置了多个文件的目标地址，并且将单文件的读取方式设置为代理。启动项目，控制台日志打印如下：1234567891011122020-03-07 16:55:24.480 INFO 30749 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=multiFileItemReaderJob]] launched with the following parameters: [&#123;&#125;]2020-03-07 16:55:24.536 INFO 30749 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]TestData&#123;id=1, field1=&apos;11&apos;, field2=&apos;12&apos;, field3=&apos;13&apos;&#125;TestData&#123;id=2, field1=&apos;21&apos;, field2=&apos;22&apos;, field3=&apos;23&apos;&#125;TestData&#123;id=3, field1=&apos;31&apos;, field2=&apos;32&apos;, field3=&apos;33&apos;&#125;TestData&#123;id=4, field1=&apos;41&apos;, field2=&apos;42&apos;, field3=&apos;43&apos;&#125;TestData&#123;id=5, field1=&apos;51&apos;, field2=&apos;52&apos;, field3=&apos;53&apos;&#125;TestData&#123;id=6, field1=&apos;61&apos;, field2=&apos;62&apos;, field3=&apos;63&apos;&#125;TestData&#123;id=7, field1=&apos;71&apos;, field2=&apos;72&apos;, field3=&apos;73&apos;&#125;TestData&#123;id=8, field1=&apos;81&apos;, field2=&apos;82&apos;, field3=&apos;83&apos;&#125;2020-03-07 16:55:24.617 INFO 30749 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 81ms2020-03-07 16:55:24.643 INFO 30749 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=multiFileItemReaderJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 153ms本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/68.spring-batch-itemreader。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Batch入门]]></title>
    <url>%2FSpring-Batch%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[企业中经常会有需要批处理才能完成的业务操作，比如：自动化地处理大批量复杂的数据，如月结计算；重复性地处理大批量数据，如费率计算；充当内部系统和外部系统的数据纽带，中间需要对数据进行格式化，校验，转换处理等。Spring Batch是一个轻量级但功能又十分全面的批处理框架，本节我们将通过一些简单的例子来入门Spring Batch。框架搭建新建一个Spring Boot项目，版本为2.2.4.RELEASE，artifactId为spring-batch-start，项目结构如下图所示：然后在pom中引入Spring Batch、MySQL和JDBC依赖，引入后pom内容如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-batch-start&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-batch-start&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-batch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;在编写代码之前，我们先来简单了解下Spring Batch的组成：Spring Batch里最基本的单元就是任务Job，一个Job由若干个步骤Step组成。任务启动器Job Launcher负责运行Job，任务存储仓库Job Repository存储着Job的执行状态，参数和日志等信息。Job处理任务又可以分为三大类：数据读取Item Reader、数据中间处理Item Processor和数据输出Item Writer。任务存储仓库可以是关系型数据库MySQL，非关系型数据库MongoDB或者直接存储在内存中，本篇使用的是MySQL作为任务存储仓库。新建一个名称为springbatch的MySQL数据库，然后导入org.springframework.batch.core目录下的schema-mysql.sql文件： 导入后，库表如下图所示：然后在项目的配置文件application.yml里添加MySQL相关配置：123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/springbatch username: root password: 123456接着在Spring Boot的入口类上添加@EnableBatchProcessing注解，表示开启Spring Batch批处理功能：1234567@SpringBootApplication@EnableBatchProcessingpublic class SpringBatchStartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBatchStartApplication.class, args); &#125;&#125;至此，基本框架搭建好了，下面开始配置一个简单的任务。编写第一个任务在cc.mrbird.batch目录下新建job包，然后在该包下新建一个FirstJobDemo类，代码如下所示：1234567891011121314151617181920212223@Componentpublic class FirstJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job firstJob() &#123; return jobBuilderFactory.get("firstJob") .start(step()) .build(); &#125; private Step step() &#123; return stepBuilderFactory.get("step") .tasklet((contribution, chunkContext) -&gt; &#123; System.out.println("执行步骤...."); return RepeatStatus.FINISHED; &#125;).build(); &#125;&#125;上面代码中，我们注入了JobBuilderFactory任务创建工厂和StepBuilderFactory步骤创建工厂，分别用于创建任务Job和步骤Step。JobBuilderFactory的get方法用于创建一个指定名称的任务，start方法指定任务的开始步骤，步骤通过StepBuilderFactory构建。步骤Step由若干个小任务Tasklet组成，所以我们通过tasklet方法创建。tasklet方法接收一个Tasklet类型参数，Tasklet是一个函数是接口，源码如下：1234public interface Tasklet &#123; @Nullable RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;&#125;所以我们可以使用lambda表达式创建一个匿名实现：1234(contribution, chunkContext) -&gt; &#123; System.out.println("执行步骤...."); return RepeatStatus.FINISHED;&#125;该匿名实现必须返回一个明确的执行状态，这里返回RepeatStatus.FINISHED表示该小任务执行成功，正常结束。此外，需要注意的是，我们配置的任务Job必须注册到Spring IOC容器中，并且任务的名称和步骤的名称组成唯一。比如上面的例子，我们的任务名称为firstJob，步骤的名称为step，如果存在别的任务和步骤组合也叫这个名称的话，则会执行失败。启动项目，控制台打印日志如下：123456...2020-03-06 11:01:11.785 INFO 17324 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=firstJob]] launched with the following parameters: [&#123;&#125;]2020-03-06 11:01:11.846 INFO 17324 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step]执行步骤....2020-03-06 11:01:11.886 INFO 17324 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step] executed in 40ms2020-03-06 11:01:11.909 INFO 17324 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=firstJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 101ms可以看到，任务成功执行了，数据库的库表也将记录相关运行日志。重新启动项目，控制台并不会再次打印出任务执行日志，因为Job名称和 Step名称组成唯一，执行完的不可重复的任务，不会再次执行。多步骤任务一个复杂的任务一般包含多个步骤，下面举个多步骤任务的例子。在job包下新建MultiStepJobDemo类：1234567891011121314151617181920212223242526272829303132333435363738394041@Componentpublic class MultiStepJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job multiStepJob() &#123; return jobBuilderFactory.get("multiStepJob") .start(step1()) .next(step2()) .next(step3()) .build(); &#125; private Step step1() &#123; return stepBuilderFactory.get("step1") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤一操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step2() &#123; return stepBuilderFactory.get("step2") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤二操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step3() &#123; return stepBuilderFactory.get("step3") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤三操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125;&#125;上面代码中，我们通过step1()、step2()和step3()三个方法创建了三个步骤。Job里要使用这些步骤，只需要通过JobBuilderFactory的start方法指定第一个步骤，然后通过next方法不断地指定下一个步骤即可。启动项目，控制台打印日志如下：12345678910112020-03-06 13:52:52.188 INFO 18472 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=multiStepJob]] launched with the following parameters: [&#123;&#125;]2020-03-06 13:52:52.222 INFO 18472 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step1]执行步骤一操作。。。2020-03-06 13:52:52.251 INFO 18472 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step1] executed in 29ms2020-03-06 13:52:52.292 INFO 18472 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step2]执行步骤二操作。。。2020-03-06 13:52:52.323 INFO 18472 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step2] executed in 30ms2020-03-06 13:52:52.375 INFO 18472 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step3]执行步骤三操作。。。2020-03-06 13:52:52.405 INFO 18472 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step3] executed in 29ms2020-03-06 13:52:52.428 INFO 18472 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=multiStepJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 231ms三个步骤依次执行成功。多个步骤在执行过程中也可以通过上一个步骤的执行状态来决定是否执行下一个步骤，修改上面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243@Componentpublic class MultiStepJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job multiStepJob() &#123; return jobBuilderFactory.get("multiStepJob2") .start(step1()) .on(ExitStatus.COMPLETED.getExitCode()).to(step2()) .from(step2()) .on(ExitStatus.COMPLETED.getExitCode()).to(step3()) .from(step3()).end() .build(); &#125; private Step step1() &#123; return stepBuilderFactory.get("step1") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤一操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step2() &#123; return stepBuilderFactory.get("step2") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤二操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step3() &#123; return stepBuilderFactory.get("step3") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤三操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125;&#125;multiStepJob()方法的含义是：multiStepJob2任务先执行step1，当step1状态为完成时，接着执行step2，当step2的状态为完成时，接着执行step3。ExitStatus.COMPLETED常量表示任务顺利执行完毕，正常退出，该类还包含以下几种退出状态：1234567891011121314151617181920212223242526272829303132333435363738394041public class ExitStatus implements Serializable, Comparable&lt;ExitStatus&gt; &#123; /** * Convenient constant value representing unknown state - assumed not * continuable. */ public static final ExitStatus UNKNOWN = new ExitStatus("UNKNOWN"); /** * Convenient constant value representing continuable state where processing * is still taking place, so no further action is required. Used for * asynchronous execution scenarios where the processing is happening in * another thread or process and the caller is not required to wait for the * result. */ public static final ExitStatus EXECUTING = new ExitStatus("EXECUTING"); /** * Convenient constant value representing finished processing. */ public static final ExitStatus COMPLETED = new ExitStatus("COMPLETED"); /** * Convenient constant value representing job that did no processing (e.g. * because it was already complete). */ public static final ExitStatus NOOP = new ExitStatus("NOOP"); /** * Convenient constant value representing finished processing with an error. */ public static final ExitStatus FAILED = new ExitStatus("FAILED"); /** * Convenient constant value representing finished processing with * interrupted status. */ public static final ExitStatus STOPPED = new ExitStatus("STOPPED"); ...&#125;启动项目，控制台日志打印如下：12345678910112020-03-06 14:21:49.384 INFO 18745 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=multiStepJob2]] launched with the following parameters: [&#123;&#125;]2020-03-06 14:21:49.427 INFO 18745 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step1]执行步骤一操作。。。2020-03-06 14:21:49.456 INFO 18745 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step1] executed in 29ms2020-03-06 14:21:49.501 INFO 18745 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step2]执行步骤二操作。。。2020-03-06 14:21:49.527 INFO 18745 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step2] executed in 26ms2020-03-06 14:21:49.576 INFO 18745 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step3]执行步骤三操作。。。2020-03-06 14:21:49.604 INFO 18745 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step3] executed in 28ms2020-03-06 14:21:49.629 INFO 18745 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=multiStepJob2]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 238msFlow的用法Flow的作用就是可以将多个步骤Step组合在一起然后再组装到任务Job中。举个Flow的例子，在job包下新建FlowJobDemo类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Componentpublic class FlowJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job flowJob() &#123; return jobBuilderFactory.get("flowJob") .start(flow()) .next(step3()) .end() .build(); &#125; private Step step1() &#123; return stepBuilderFactory.get("step1") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤一操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step2() &#123; return stepBuilderFactory.get("step2") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤二操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step3() &#123; return stepBuilderFactory.get("step3") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤三操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; // 创建一个flow对象，包含若干个step private Flow flow() &#123; return new FlowBuilder&lt;Flow&gt;("flow") .start(step1()) .next(step2()) .build(); &#125;&#125;上面代码中，我们通过FlowBuilder将step1和step2组合在一起，创建了一个名为flow的Flow，然后再将其赋给任务Job。使用Flow和Step构建Job的区别是，Job流程中包含Flow类型的时候需要在build()方法前调用end()方法。启动程序，控制台日志打印如下：12345678910112020-03-06 14:36:42.621 INFO 18865 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=flowJob]] launched with the following parameters: [&#123;&#125;]2020-03-06 14:36:42.667 INFO 18865 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step1]执行步骤一操作。。。2020-03-06 14:36:42.697 INFO 18865 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step1] executed in 30ms2020-03-06 14:36:42.744 INFO 18865 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step2]执行步骤二操作。。。2020-03-06 14:36:42.771 INFO 18865 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step2] executed in 27ms2020-03-06 14:36:42.824 INFO 18865 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step3]执行步骤三操作。。。2020-03-06 14:36:42.850 INFO 18865 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step3] executed in 25ms2020-03-06 14:36:42.874 INFO 18865 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=flowJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 245ms并行执行任务中的步骤除了可以串行执行（一个接着一个执行）外，还可以并行执行，并行执行在特定的业务需求下可以提供任务执行效率。将任务并行化只需两个简单步骤：将步骤Step转换为Flow；任务Job中指定并行Flow。举个例子，在job包下新建SplitJobDemo类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Componentpublic class SplitJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Bean public Job splitJob() &#123; return jobBuilderFactory.get("splitJob") .start(flow1()) .split(new SimpleAsyncTaskExecutor()).add(flow2()) .end() .build(); &#125; private Step step1() &#123; return stepBuilderFactory.get("step1") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤一操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step2() &#123; return stepBuilderFactory.get("step2") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤二操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step3() &#123; return stepBuilderFactory.get("step3") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤三操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Flow flow1() &#123; return new FlowBuilder&lt;Flow&gt;("flow1") .start(step1()) .next(step2()) .build(); &#125; private Flow flow2() &#123; return new FlowBuilder&lt;Flow&gt;("flow2") .start(step3()) .build(); &#125;&#125;上面例子中，我们创建了两个Flow：flow1（包含step1和step2）和flow2（包含step3）。然后通过JobBuilderFactory的split方法，指定一个异步执行器，将flow1和flow2异步执行（也就是并行）。启动项目，控制台日志打印如下：12345678910112020-03-06 15:25:43.602 INFO 19449 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=splitJob]] launched with the following parameters: [&#123;&#125;]2020-03-06 15:25:43.643 INFO 19449 --- [cTaskExecutor-1] o.s.batch.core.job.SimpleStepHandler : Executing step: [step3]2020-03-06 15:25:43.650 INFO 19449 --- [cTaskExecutor-2] o.s.batch.core.job.SimpleStepHandler : Executing step: [step1]执行步骤三操作。。。执行步骤一操作。。。2020-03-06 15:25:43.673 INFO 19449 --- [cTaskExecutor-2] o.s.batch.core.step.AbstractStep : Step: [step1] executed in 23ms2020-03-06 15:25:43.674 INFO 19449 --- [cTaskExecutor-1] o.s.batch.core.step.AbstractStep : Step: [step3] executed in 31ms2020-03-06 15:25:43.714 INFO 19449 --- [cTaskExecutor-2] o.s.batch.core.job.SimpleStepHandler : Executing step: [step2]执行步骤二操作。。。2020-03-06 15:25:43.738 INFO 19449 --- [cTaskExecutor-2] o.s.batch.core.step.AbstractStep : Step: [step2] executed in 24ms2020-03-06 15:25:43.758 INFO 19449 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=splitJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 146ms可以看到step3并没有在step2后才执行，说明步骤已经是并行化的（开启并行化后，并行的步骤执行顺序并不能100%确定，因为线程调度具有不确定性）。任务决策器决策器的作用就是可以指定程序在不同的情况下运行不同的任务流程，比如今天是周末，则让任务执行step1和step2，如果是工作日，则之心step1和step3。使用决策器前，我们需要自定义一个决策器的实现。在cc.mrbird.batch包下新建decider包，然后创建MyDecider类，实现JobExecutionDecider接口：1234567891011121314@Componentpublic class MyDecider implements JobExecutionDecider &#123; @Override public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) &#123; LocalDate now = LocalDate.now(); DayOfWeek dayOfWeek = now.getDayOfWeek(); if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) &#123; return new FlowExecutionStatus("weekend"); &#125; else &#123; return new FlowExecutionStatus("workingDay"); &#125; &#125;&#125;MyDecider实现JobExecutionDecider接口的decide方法，该方法返回FlowExecutionStatus。上面的逻辑是：判断今天是否是周末，如果是，返回FlowExecutionStatus(&quot;weekend&quot;)状态，否则返回FlowExecutionStatus(&quot;workingDay&quot;)状态。下面演示如何在任务Job里使用决策器。在job包下新建DeciderJobDemo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Componentpublic class DeciderJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private MyDecider myDecider; @Bean public Job deciderJob() &#123; return jobBuilderFactory.get("deciderJob") .start(step1()) .next(myDecider) .from(myDecider).on("weekend").to(step2()) .from(myDecider).on("workingDay").to(step3()) .from(step3()).on("*").to(step4()) .end() .build(); &#125; private Step step1() &#123; return stepBuilderFactory.get("step1") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤一操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step2() &#123; return stepBuilderFactory.get("step2") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤二操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step3() &#123; return stepBuilderFactory.get("step3") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤三操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125; private Step step4() &#123; return stepBuilderFactory.get("step4") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("执行步骤四操作。。。"); return RepeatStatus.FINISHED; &#125;).build(); &#125;上面代码中，我们注入了自定义决策器MyDecider，然后在jobDecider()方法里使用了该决策器：1234567891011@Beanpublic Job deciderJob() &#123; return jobBuilderFactory.get("deciderJob") .start(step1()) .next(myDecider) .from(myDecider).on("weekend").to(step2()) .from(myDecider).on("workingDay").to(step3()) .from(step3()).on("*").to(step4()) .end() .build();&#125;这段代码的含义是：任务deciderJob首先执行step1，然后指定自定义决策器，如果决策器返回weekend，那么执行step2，如果决策器返回workingDay，那么执行step3。如果执行了step3，那么无论step3的结果是什么，都将执行step4。启动项目，控制台输出如下所示：12345678910112020-03-06 16:09:10.541 INFO 19873 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=deciderJob]] launched with the following parameters: [&#123;&#125;]2020-03-06 16:09:10.609 INFO 19873 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step1]执行步骤一操作。。。2020-03-06 16:09:10.641 INFO 19873 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step1] executed in 32ms2020-03-06 16:09:10.692 INFO 19873 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step3]执行步骤三操作。。。2020-03-06 16:09:10.723 INFO 19873 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step3] executed in 31ms2020-03-06 16:09:10.769 INFO 19873 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [step4]执行步骤四操作。。。2020-03-06 16:09:10.797 INFO 19873 --- [ main] o.s.batch.core.step.AbstractStep : Step: [step4] executed in 27ms2020-03-06 16:09:10.818 INFO 19873 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [FlowJob: [name=deciderJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 256ms因为今天是2020年03月06日星期五，是工作日，所以任务执行了step1、step3和step4。任务嵌套任务Job除了可以由Step或者Flow构成外，我们还可以将多个任务Job转换为特殊的Step，然后再赋给另一个任务Job，这就是任务的嵌套。举个例子，在job包下新建NestedJobDemo类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Componentpublic class NestedJobDemo &#123; @Autowired private JobBuilderFactory jobBuilderFactory; @Autowired private StepBuilderFactory stepBuilderFactory; @Autowired private JobLauncher jobLauncher; @Autowired private JobRepository jobRepository; @Autowired private PlatformTransactionManager platformTransactionManager; // 父任务 @Bean public Job parentJob() &#123; return jobBuilderFactory.get("parentJob") .start(childJobOneStep()) .next(childJobTwoStep()) .build(); &#125; // 将任务转换为特殊的步骤 private Step childJobOneStep() &#123; return new JobStepBuilder(new StepBuilder("childJobOneStep")) .job(childJobOne()) .launcher(jobLauncher) .repository(jobRepository) .transactionManager(platformTransactionManager) .build(); &#125; // 将任务转换为特殊的步骤 private Step childJobTwoStep() &#123; return new JobStepBuilder(new StepBuilder("childJobTwoStep")) .job(childJobTwo()) .launcher(jobLauncher) .repository(jobRepository) .transactionManager(platformTransactionManager) .build(); &#125; // 子任务一 private Job childJobOne() &#123; return jobBuilderFactory.get("childJobOne") .start( stepBuilderFactory.get("childJobOneStep") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("子任务一执行步骤。。。"); return RepeatStatus.FINISHED; &#125;).build() ).build(); &#125; // 子任务二 private Job childJobTwo() &#123; return jobBuilderFactory.get("childJobTwo") .start( stepBuilderFactory.get("childJobTwoStep") .tasklet((stepContribution, chunkContext) -&gt; &#123; System.out.println("子任务二执行步骤。。。"); return RepeatStatus.FINISHED; &#125;).build() ).build(); &#125;&#125;上面代码中，我们通过childJobOne()和childJobTwo()方法创建了两个任务Job，这里没什么好说的，前面都介绍过。关键在于childJobOneStep()方法和childJobTwoStep()方法。在childJobOneStep()方法中，我们通过JobStepBuilder构建了一个名称为childJobOneStep的Step，顾名思义，它是一个任务型Step的构造工厂，可以将任务转换为“特殊”的步骤。在构建过程中，我们还需要传入任务执行器JobLauncher、任务仓库JobRepository和事务管理器PlatformTransactionManager。将任务转换为特殊的步骤后，将其赋给父任务parentJob即可，流程和前面介绍的一致。配置好后，启动项目，控制台输出如下所示：123456789101112131415162020-03-06 16:58:39.771 INFO 21588 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=parentJob]] launched with the following parameters: [&#123;&#125;]2020-03-06 16:58:39.812 INFO 21588 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [childJobOneStep]2020-03-06 16:58:39.866 INFO 21588 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=childJobOne]] launched with the following parameters: [&#123;&#125;]2020-03-06 16:58:39.908 INFO 21588 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [childJobOneStep]子任务一执行步骤。。。2020-03-06 16:58:39.940 INFO 21588 --- [ main] o.s.batch.core.step.AbstractStep : Step: [childJobOneStep] executed in 32ms2020-03-06 16:58:39.960 INFO 21588 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=childJobOne]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 86ms2020-03-06 16:58:39.983 INFO 21588 --- [ main] o.s.batch.core.step.AbstractStep : Step: [childJobOneStep] executed in 171ms2020-03-06 16:58:40.019 INFO 21588 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [childJobTwoStep]2020-03-06 16:58:40.067 INFO 21588 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=childJobTwo]] launched with the following parameters: [&#123;&#125;]2020-03-06 16:58:40.102 INFO 21588 --- [ main] o.s.batch.core.job.SimpleStepHandler : Executing step: [childJobTwoStep]子任务二执行步骤。。。2020-03-06 16:58:40.130 INFO 21588 --- [ main] o.s.batch.core.step.AbstractStep : Step: [childJobTwoStep] executed in 28ms2020-03-06 16:58:40.152 INFO 21588 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=childJobTwo]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 75ms2020-03-06 16:58:40.157 INFO 21588 --- [ main] o.s.batch.core.step.AbstractStep : Step: [childJobTwoStep] executed in 138ms2020-03-06 16:58:40.177 INFO 21588 --- [ main] o.s.b.c.l.support.SimpleJobLauncher : Job: [SimpleJob: [name=parentJob]] completed with the following parameters: [&#123;&#125;] and the following status: [COMPLETED] in 398ms本节源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/67.spring-batch-start。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合WebSocket]]></title>
    <url>%2FSpring-Boot%E6%95%B4%E5%90%88WebSocket.html</url>
    <content type="text"><![CDATA[本节简单介绍下如何在Spring Boot引入WebSocket，实现简单的客户端与服务端建立长连接并互发送文本消息。框架搭建新建一个Spring Boot项目，artifactId为spring-boot-websocket-socketjs，项目结构如下图所示：项目的pom内容如下：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-websocket-socketjs&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-websocket-socketjs&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;引入了spring-boot-starter-websocket和spring-boot-starter-web依赖。构建服务端在cc.mrbird.socket目录下新建handler包，然后在该包下新建MyStringWebSocketHandler继承TextWebSocketHandler：12345678910111213141516171819202122232425262728293031323334353637383940414243@Componentpublic class MyStringWebSocketHandler extends TextWebSocketHandler &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Override public void afterConnectionEstablished(WebSocketSession session) &#123; log.info("和客户端建立连接"); &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; session.close(CloseStatus.SERVER_ERROR); log.error("连接异常", exception); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123; super.afterConnectionClosed(session, status); log.info("和客户端断开连接"); &#125; @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; // 获取到客户端发送过来的消息 String receiveMessage = message.getPayload(); log.info(receiveMessage); // 发送消息给客户端 session.sendMessage(new TextMessage(fakeAi(receiveMessage))); // 关闭连接 // session.close(CloseStatus.NORMAL); &#125; private static String fakeAi(String input) &#123; if (input == null || "".equals(input)) &#123; return "你说什么？没听清︎"; &#125; return input.replace('你', '我') .replace("吗", "") .replace('?', '!') .replace('？', '！'); &#125;&#125;该类重写了父类AbstractWebSocketHandler的四个方法：afterConnectionEstablished，和客户端链接成功的时候触发该方法；handleTransportError，和客户端连接失败的时候触发该方法；afterConnectionClosed，和客户端断开连接的时候触发该方法；handleTextMessage，和客户端建立连接后，处理客户端发送的请求。WebSocketSession对象代表每个客户端会话，包含许多实用方法：方法见名知意，就不赘述了。此外，因为我们的目的是实现和客户端的通信，并且内容为文本内容，所以我们继承的是TextWebSocketHandler；如果传输的是二进制内容，则可以继承BinaryWebSocketHandler，更多信息可以自行查看WebSocketHandler的子类。接着在cc.mrbird.socket目录下新建configure包，然后在该包下新建WebSocketServerConfigure配置类：123456789101112@Configuration@EnableWebSocketpublic class WebSocketServerConfigure implements WebSocketConfigurer &#123; @Autowired private MyStringWebSocketHandler myStringWebSocketHandler; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; registry.addHandler(myStringWebSocketHandler, "/connect").withSockJS(); &#125;&#125;@EnableWebSocket用于开启WebSocket相关功能，我们注入了上面创建的MyStringWebSocketHandler，并将其注册到了WebSocketHandlerRegistry。上面代码的含义是，当客户端通过/connecturl和服务端连接通信时，使用MyStringWebSocketHandler处理会话。withSockJS的含义是，通信的客户端是通过SockJS实现的，下面会介绍到。构建客户端SockJS是一个JS插件，用于构建WebSocket，兼容性好。在resources目录下新建static包，然后在该包下新建client.html：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;WebSocket客户端&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/sockjs-client/0.3.4/sockjs.min.js"&gt;&lt;/script&gt; &lt;link href="https://cdn.bootcss.com/twitter-bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt; .jumbotron &#123; width: 100%; &#125; #text &#123; height: 3rem; font-size: 1rem; line-height: 3rem; margin: 1rem; &#125; .btn &#123; margin-right: 5px; &#125; #connect &#123; margin-left: 1rem; &#125; #log &#123; margin: 1rem 0 0 1rem; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="jumbotron"&gt; &lt;input type="text" placeholder="请输入你想传输的内容" id="text" class="col-lg-12"/&gt; &lt;input type="button" value="连接" class="btn btn-info" id="connect" onclick="connect()"/&gt; &lt;input type="button" value="发送" class="btn btn-success" id="sent" disabled="disabled" onclick="sent()"/&gt; &lt;input type="button" value="断开" class="btn btn-danger" id="disconnect" disabled="disabled" onclick="disconnect()"/&gt; &lt;div id="log"&gt; &lt;p&gt;聊天记录:&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; let text = document.querySelector('#text'); let connectBtn = document.querySelector("#connect"); let sentBtn = document.querySelector("#sent"); let disconnectBtn = document.querySelector("#disconnect"); let logDiv = document.querySelector("#log"); let ws = null; function connect() &#123; let targetUri = "/connect"; ws = new SockJS(targetUri); ws.onopen = function () &#123; setConnected(true); log('和服务端连接成功！'); &#125;; ws.onmessage = function (event) &#123; log('服务端说：' + event.data); &#125;; ws.onclose = function () &#123; setConnected(false); log('和服务端断开连接！') &#125; &#125; function sent() &#123; if (ws != null) &#123; ws.send(text.value); log('客户端说：' + text.value); &#125; else &#123; log('请先建立连接！') &#125; &#125; function disconnect() &#123; if (ws != null) &#123; ws.close(); ws = null; &#125; setConnected(false); &#125; function log(value) &#123; let content = document.createElement('p'); content.innerHTML = value; logDiv.appendChild(content); text.value = ''; &#125; function setConnected(connected) &#123; connectBtn.disabled = connected; disconnectBtn.disabled = !connected; sentBtn.disabled = !connected; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;html，css那些都不重要，重要的是我们引入了SockJS库。在connect()方法中，我们通过new SockJS(/connect)和上面的服务端建立了Socket通信。SockJS对象包含几个常用的实用方法：onopen，和服务端讲了连接后的回调方法；onmessage，服务端返回消息时的回调方法；onclose，和服务端断开连接的回调方法；send，发送消息给服务端；close，断开和服务端的连接。上面的JS较为简单，其他逻辑自己看看吧。通信测试启动项目，浏览器访问：http://localhost:8080/client.html：源码连接：https://github.com/wuyouzhuguli/SpringAll/tree/master/76.spring-boot-websocket-socketjs。]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>WebSocket</tag>
        <tag>SockJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Spring Boot Starter]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89Spring-Boot-Starter.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FEBS Cloud常见问题汇总]]></title>
    <url>%2FFEBS-Cloud%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[记录群友的高频问点。如需补充，欢迎在下方留言。点击登录页面弹窗问题有两种情况会导致这个问题：原因一：请求头携带的client信息不正确；解决办法：修改febs-cloud-web工程src目录下setting.js文件的authorizationValue值：这个值怎么来的？查看数据库febs_cloud_base下的oauth_client_details表：比如我们使用client_id为febs这个client，它的client_secert是经过BCRY加密的，原密码值可以同功能origin_secret查看，由上图可知，是123456，然后到http://tool.chinaz.com/Tools/Base64.aspx网站：Base64加密得到的值ZmViczoxMjM0NTY=前面拼接上Basic空格就是最终authorizationValue值：Basic ZmViczoxMjM0NTY=。原因二：数据库中没有oauth_client_details这张表。解决办法：没有这张表的原因很简单，oauth_client_details表的additional_info字段长度为4096，5.7版本以下的MySQL不支持：所以要解决这个问题，你可以手动在SQL中将oauth_client_details表的additional_info字段长度修改为500，然后重新导入；或者将您的MySQL升级到5.7以上的版本。数据源不存在问题比如在启动febs-auth项目的时候，控制台抛出请检查数据源之类的问题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:156) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:544) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:141) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:747) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397) at org.springframework.boot.SpringApplication.run(SpringApplication.java:315) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1215) at cc.mrbird.febs.auth.FebsAuthApplication.main(FebsAuthApplication.java:25)Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:126) at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.&lt;init&gt;(TomcatWebServer.java:88) at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:438) at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:191) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:180) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:153) ... 8 common frames omittedCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;servletEndpointRegistrar&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpoint/web/ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method &apos;servletEndpointRegistrar&apos; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;healthEndpoint&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &apos;healthEndpoint&apos; parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;healthContributorRegistry&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &apos;healthContributorRegistry&apos; parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthContributorAutoConfiguration&apos;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos; defined in class path resource [com/baomidou/dynamic/datasource/spring/boot/autoconfigure/DynamicDataSourceAutoConfiguration.class]: Invocation of init method failed; nested exception is java.lang.RuntimeException: dynamic-datasource Please check the setting of primary at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:645) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:625) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:207) at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:211) at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:202) at org.springframework.boot.web.servlet.ServletContextInitializerBeans.addServletContextInitializerBeans(ServletContextInitializerBeans.java:96) at org.springframework.boot.web.servlet.ServletContextInitializerBeans.&lt;init&gt;(ServletContextInitializerBeans.java:85) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.getServletContextInitializerBeans(ServletWebServerApplicationContext.java:253) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.selfInitialize(ServletWebServerApplicationContext.java:227) at org.springframework.boot.web.embedded.tomcat.TomcatStarter.onStartup(TomcatStarter.java:53) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5135) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:841) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1384) at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1374) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:909) at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:262) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) at org.apache.catalina.core.StandardService.startInternal(StandardService.java:421) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:930) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) at org.apache.catalina.startup.Tomcat.start(Tomcat.java:459) at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:107) ... 13 common frames omittedCaused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar]: Factory method &apos;servletEndpointRegistrar&apos; threw exception; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;healthEndpoint&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &apos;healthEndpoint&apos; parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;healthContributorRegistry&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &apos;healthContributorRegistry&apos; parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthContributorAutoConfiguration&apos;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos; defined in class path resource [com/baomidou/dynamic/datasource/spring/boot/autoconfigure/DynamicDataSourceAutoConfiguration.class]: Invocation of init method failed; nested exception is java.lang.RuntimeException: dynamic-datasource Please check the setting of primary at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:640) ... 53 common frames omittedCaused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;healthEndpoint&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &apos;healthEndpoint&apos; parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;healthContributorRegistry&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &apos;healthContributorRegistry&apos; parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthContributorAutoConfiguration&apos;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos; defined in class path resource [com/baomidou/dynamic/datasource/spring/boot/autoconfigure/DynamicDataSourceAutoConfiguration.class]: Invocation of init method failed; nested exception is java.lang.RuntimeException: dynamic-datasource Please check the setting of primary at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:787) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:528) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1108) at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.createEndpointBean(EndpointDiscoverer.java:143) at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.createEndpointBeans(EndpointDiscoverer.java:133) at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.discoverEndpoints(EndpointDiscoverer.java:122) at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.getEndpoints(EndpointDiscoverer.java:116) at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.servletEndpointRegistrar(ServletEndpointManagementContextConfiguration.java:65) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ... 54 common frames omittedCaused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;healthContributorRegistry&apos; defined in class path resource [org/springframework/boot/actuate/autoconfigure/health/HealthEndpointConfiguration.class]: Unsatisfied dependency expressed through method &apos;healthContributorRegistry&apos; parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthContributorAutoConfiguration&apos;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos; defined in class path resource [com/baomidou/dynamic/datasource/spring/boot/autoconfigure/DynamicDataSourceAutoConfiguration.class]: Invocation of init method failed; nested exception is java.lang.RuntimeException: dynamic-datasource Please check the setting of primary at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:787) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:528) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:874) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:778) ... 74 common frames omittedCaused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;org.springframework.boot.actuate.autoconfigure.jdbc.DataSourceHealthContributorAutoConfiguration&apos;: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos; defined in class path resource [com/baomidou/dynamic/datasource/spring/boot/autoconfigure/DynamicDataSourceAutoConfiguration.class]: Invocation of init method failed; nested exception is java.lang.RuntimeException: dynamic-datasource Please check the setting of primary at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:787) at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:226) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:400) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1338) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1177) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1503) at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1467) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1386) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1245) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:874) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:778) ... 88 common frames omittedCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos; defined in class path resource [com/baomidou/dynamic/datasource/spring/boot/autoconfigure/DynamicDataSourceAutoConfiguration.class]: Invocation of init method failed; nested exception is java.lang.RuntimeException: dynamic-datasource Please check the setting of primary at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1803) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1503) at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1467) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1386) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1245) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:874) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:778) ... 114 common frames omittedCaused by: java.lang.RuntimeException: dynamic-datasource Please check the setting of primary at com.baomidou.dynamic.datasource.DynamicRoutingDataSource.afterPropertiesSet(DynamicRoutingDataSource.java:219) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1862) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1799) ... 128 common frames omitted原因可能有如下两种：原因一：项目环境变量中没有配置nacos地址；解决办法，在febs-auth（这里只是以febs-auth为例）项目的环境变量中配置nacos地址： 原因二：项目无法从nacos中找到对应的配置。解决办法：这种情况比较少见，不过如果出现了，八成是因为你在项目配置文件中配置的后缀是yaml，而nacos控制台中配置的确是yml。rabbitmq问题在启动febs-server-system或者febs-server-test项目的时候，控制台抛出AMQP相关异常：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147org.springframework.amqp.AmqpIOException: java.io.IOException at org.springframework.amqp.rabbit.support.RabbitExceptionTranslator.convertRabbitAccessException(RabbitExceptionTranslator.java:71) at org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.createBareConnection(AbstractConnectionFactory.java:510) at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:751) at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.createConnection(ConnectionFactoryUtils.java:214) at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:2092) at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:2065) at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:2045) at org.springframework.boot.actuate.amqp.RabbitHealthIndicator.getVersion(RabbitHealthIndicator.java:49) at org.springframework.boot.actuate.amqp.RabbitHealthIndicator.doHealthCheck(RabbitHealthIndicator.java:44) at org.springframework.boot.actuate.health.AbstractHealthIndicator.health(AbstractHealthIndicator.java:82) at org.springframework.boot.actuate.health.HealthIndicator.getHealth(HealthIndicator.java:37) at org.springframework.boot.actuate.health.HealthEndpointWebExtension.getHealth(HealthEndpointWebExtension.java:92) at org.springframework.boot.actuate.health.HealthEndpointWebExtension.getHealth(HealthEndpointWebExtension.java:42) at org.springframework.boot.actuate.health.HealthEndpointSupport.getContribution(HealthEndpointSupport.java:106) at org.springframework.boot.actuate.health.HealthEndpointSupport.getAggregateHealth(HealthEndpointSupport.java:116) at org.springframework.boot.actuate.health.HealthEndpointSupport.getContribution(HealthEndpointSupport.java:103) at org.springframework.boot.actuate.health.HealthEndpointSupport.getHealth(HealthEndpointSupport.java:81) at org.springframework.boot.actuate.health.HealthEndpointSupport.getHealth(HealthEndpointSupport.java:68) at org.springframework.boot.actuate.health.HealthEndpointWebExtension.health(HealthEndpointWebExtension.java:80) at org.springframework.boot.actuate.health.HealthEndpointWebExtension.health(HealthEndpointWebExtension.java:69) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:279) at org.springframework.boot.actuate.endpoint.invoke.reflect.ReflectiveOperationInvoker.invoke(ReflectiveOperationInvoker.java:77) at org.springframework.boot.actuate.endpoint.annotation.AbstractDiscoveredOperation.invoke(AbstractDiscoveredOperation.java:60) at org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$ServletWebOperationAdapter.handle(AbstractWebMvcEndpointHandlerMapping.java:305) at org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$OperationHandler.handle(AbstractWebMvcEndpointHandlerMapping.java:388) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at brave.servlet.TracingFilter.doFilter(TracingFilter.java:65) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilterInternal(BasicAuthenticationFilter.java:154) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(OAuth2AuthenticationProcessingFilter.java:176) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.cloud.sleuth.instrument.web.ExceptionLoggingFilter.doFilter(ExceptionLoggingFilter.java:50) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at brave.servlet.TracingFilter.doFilter(TracingFilter.java:82) at org.springframework.cloud.sleuth.instrument.web.LazyTracingFilter.doFilter(TraceWebServletAutoConfiguration.java:138) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:108) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:526) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:861) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1579) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)Caused by: java.io.IOException: null at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:129) at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:125) at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:147) at com.rabbitmq.client.impl.AMQConnection.start(AMQConnection.java:403) at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:1115) at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:1063) at org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.connect(AbstractConnectionFactory.java:526) at org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.createBareConnection(AbstractConnectionFactory.java:473) ... 127 common frames omittedCaused by: com.rabbitmq.client.ShutdownSignalException: connection error; protocol method: #method&lt;connection.close&gt;(reply-code=530, reply-text=NOT_ALLOWED - access to vhost &apos;/&apos; refused for user &apos;febs&apos;, class-id=10, method-id=40) at com.rabbitmq.utility.ValueOrException.getValue(ValueOrException.java:66) at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:36) at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:502) at com.rabbitmq.client.impl.AMQChannel.privateRpc(AMQChannel.java:293) at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:141) ... 132 common frames omitted解决办法：请确保当前rabbitmq账号拥有权限。比如我们在配置文件中配置的rabbitmq的账号为：123456... rabbitmq: host: $&#123;rabbitmq.url&#125; port: 5672 username: febs password: 123456浏览器登录：http://localhost:15672/，默认账号密码都为为guest：可以看到，febs账号没有设置权限，点击febs用户名，设置权限：这时候再次启动febs-server-system或febs-server-test即可。febs-monitor-admin中有服务红叉叉此类问题都好解决，只需要点击对应报红叉叉的微服务就能看的详细的错误信息，比如： 在febs-server-system项目的配置文件febs-server-system.properties：无论是什么原因导致红叉叉，点击进去都能看到对应的错误提示，有了错误提示，问题便很好解决了。swagger认证页面出错在swagger页面点击Authorize按钮的时候，页面出现错误：此类问题一般是你form表单填写的内容有误，请仔细核实。本地如何体验社交登录具体参考：https://www.kancloud.cn/mrbird/spring-cloud/1411213]]></content>
      <tags>
        <tag>FEBS</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA中使用Docker插件]]></title>
    <url>%2FIDEA-Docker-Plugin.html</url>
    <content type="text"><![CDATA[在Windows上如果没有安装docker for windows的话，是没办法构建Docker镜像的。这种情况下，如果要通过fat jar构建docker镜像的话，只能将fat jar上传到安装了docker服务的Linux服务器上，然后编写Dockerfile构建。这种方式比较麻烦，这里记录下如何通过IDEA的Docker插件远程构建Docker镜像。Docker开启远程访问假如我在CentOS虚拟机上安装好了Docker，IP地址为192.168.33.11，我们可以修改Docker的配置，开启远程访问权限：12# 修改Docker配置vi /lib/systemd/system/docker.service修改的地方如下图所示：修改保存后，重启Docker服务：12systemctl daemon-reload systemctl restart docker.service重启后，验证下2375端口是否是通的：1curl 192.168.33.11:2375/info如果返回了一坨JSON数据，说明🆗。IDEA使用Docker插件IDEA Ultimate版本已经默认安装了Docker插件（没有的话去插件市场下载安装下就可以了）。点击IDEA -&gt; File -&gt; Settings… -&gt; Build,Execution,Deployment -&gt; Docker：填写远程Docker地址，如果显示Connection Successfully说明连接远程Docker服务成功。新建一个简单的Spring Boot项目，pom如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;然后用maven打包，打包后项目根目录的target下会有如下fat jar：在项目根目录下新建Dockerfile，内容如下所示：12345FROM openjdk:8u212-jreMAINTAINER MrBird 852252810@qq.comCOPY target/demo-0.0.1.jar /demo-0.0.1.jarENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/demo-0.0.1.jar&quot;]然后点击IDEA -&gt; Run -&gt; Edit Configrations…选择远程的Docker服务，填写镜像标签内容，点击保存后，运行：通过日志来看，镜像构建是成功的：可以看到远程服务器上已经包含了该Docker镜像：可以到服务器上验证下：]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes服务发现总结]]></title>
    <url>%2FKubernetes-Service-Discovery-Summary.html</url>
    <content type="text"><![CDATA[Kubernetes服务发现主要可以归为三种情形：1.Kubernetes集群内部间服务如何互相通信；2.Kuberntes集群外部如何访问集群内部服务；3.Kubernetes集群内部如何访问集群外部服务。这节针对这三种情况做个总结。集群间服务通信1.通过Pod IP相互通信，但是Pod具有不确定性，Pod IP会发生改变，所以这种方式并不推荐。2.部署Pod对应的Service，访问Service IP，请求负载均衡转发服务到各个对应的Pod实例。比如有如下配置文件demo.yml：12345678910111213141516171819202122232425262728293031apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-dspec: selector: matchLabels: name: web-app replicas: 3 template: metadata: labels: name: web-app spec: containers: - name: nginx image: nginx ports: - containerPort: 80---apiVersion: v1kind: Servicemetadata: name: nginx-sspec: ports: - port: 8080 targetPort: 80 protocol: TCP selector: name: web-app运行该配置，查看Service对应的IP：通过Service IP和端口就能访问对应的Pod服务:但是我们事先并不知道Service的IP是多少，如果我们在启动服务后再去配置这个IP的话，这个过程也是非常麻烦的，所幸我们可以通过DNS解决这个问题，也就是下面这种方式：3.部署Pod对应的Service，通过ServiceName，请求负载均衡转发服务到各个对应的Pod实例。通过下面这段配置部署一个新的Pod服务：123456789101112apiVersion: v1kind: Podmetadata: name: centos-podspec: containers: - name: centos image: centos command: - sh - -c - 'while true; do sleep 360000000; done'进入到该容器内部，测试下是否可以访问上面创建的Service：试着通过ServiceName访问Nginx服务：可以看到效果是一样的。这得益于Kube-dns，具体的格式为：&lt;service_name&gt;.&lt;namespace&gt;.svc.&lt;cluster_domain&gt;其中，&lt;cluster_domain&gt;默认值为cluster.local，可以通过kubelet的--cluster-domain=SomeDomain参数进行设置。为了在Pod中调用其他Service，kubelet会自动在容器中创建域名解析配置：所以除了使用curl nginx-s:8080访问外，以下这些也是等效的：12345curl nginx-s.default:8080curl nginx-s.default.svc:8080curl nginx-s.default.svc.cluster.local:8080所以我们现在可以不用事先知道Service的IP了，只要事先知道ServiceName即可（ServiceName是我们自己定义的）。4.通过Headless Service，返回Pod的所有实例。有时候我们并不需要Service的负载均衡功能，而是手动获取Service对应的Pod实例，自己决定如何访问。创建一个Headless Service配置：12345678910apiVersion: v1kind: Servicemetadata: name: nginx-headless-sspec: ports: - port: 8080 clusterIP: None selector: name: web-app创建该Headless Service，然后到centos-pod容器内部查询DNS记录：如果没有nslookup命令，可以使用yum -y install bind-utils命令安装。可以看到，通过解析nginx-headless-s DNS，返回了三个Nginx Pod实例地址。集群外部访问内部1.Pod指定hostPort，或者开启hostNetwork，这样外部就可以通过Pod宿主机IP+Pod端口访问了，但Pod调度的不确定性，这种方式不推荐；2.通过Service的NodePort暴露服务，如果服务较多的话不推荐，因为这种方式会在集群中的所有节点上都暴露该端口，所以当服务多的时候很容易造成端口冲突，并且端口维护不便；3.通过Ingress集中暴露服务，要暴露的服务较多的时候推荐。这三种方式是前面博客中都有介绍到，所以就不赘述了。集群内部访问外部1.直接通过外部服务的IP和端口进行访问；2.通过Service和Endpoint绑定，集群内的服务通过DNS访问集群外部服务（推荐）。创建如下配置（test-remote.yml）：12345678910111213141516171819apiVersion: v1kind: Servicemetadata: name: remote-sspec: ports: - protocol: TCP port: 8081 targetPort: 8080---apiVersion: v1kind: Endpointsmetadata: name: remote-ssubsets: - addresses: - ip: 192.168.73.42 ports: - port: 8080Service和Endpoints名称一样，所以他们会绑定上，通过访问remote-s Service便可以访问到对应的Endpoint地址192.168.73.42:8080服务（这是个我在集群外部，通过Spring Boot搭建的简单web服务）。运行该配置后，在master节点上，测试是否可以访问：我们进到centos-pod容器内部，通过服务名称看看是否可以访问到：可以看到这种方式也是没问题的，推荐使用这种方式，可以降低耦合度。]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Ingress]]></title>
    <url>%2FKubernetes-Ingress.html</url>
    <content type="text"><![CDATA[在Kubernetes Service基础一节中，我们了解到可以通过设置Service NodePort向Kubernetes集群外部暴露端口，外部服务可以通过Kubernetes集群节点IP+NodePort访问集群内部资源。当集群内部服务众多时，需要暴露的端口也会越来越多。这样不仅端口维护困难，集群边界也变得“千疮百孔”。针对这个问题，Kubernetes提供了Ingress来解决，Ingress对象用于配置外部请求转发到集群内部服务的具体规则，而实际的转发操作由Ingress Controller来完成。假设我们的Kubernetes集群中分别存在2个实例的tomcat和nginx Deployment，并且有对应的Service。加入Ingress后，我们可以实现如下图所示的服务暴露方式：Ingress ControllerIngress Controller并不是Kubernetes对象，而是根据Ingress对象配置，实现具体转发功能的组件统称。除了Kubernetes官方维护的GCE和Ingress Nginx外，还有许多第三方维护的实现。这里以用的较多的Ingress Nginx为例，实现Ingress Controller的部署。因为Ingress Controller是用于处理集群外部请求访问集群内部服务的组件，所以我们需要思考，如何将Ingress Controller暴露出去。最为常见的方式主要有以下两种：创建和Intress Controller对应的Service服务，Service通过NodePort将服务端口暴露出去；将Ingress Controller部署到几个固定的节点上，然后通过HostPort将端口映射出去，最外层通过LVS+keepalive实现负载均衡。因为第1种方式需要在请求链路中再加一层Service服务，性能可能会有耗损，所以我们选择第2种方式。为了简化过程，这里只在一个节点上部署Ingress Controller，比如我们可以选择在Node1节点上部署。给Node1节点打个标签：1kubectl label node node1 type="ingress"下载Ingress Nginx配置文件：1wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml修改该配置文件：1vi mandatory.yaml修改部分如下所示:创建该配置文件：1kubectl create -f mandatory.yaml查看是否创建成功：使用浏览器访问http://192.168.33.12/：因为还没有创建Ingress，所以页面响应暂时为404。Ingress在创建Ingress对象前，我们需要准备好tomcat和nginx服务，供待会演示，创建demo.yml：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162---apiVersion: apps/v1kind: Deploymentmetadata: name: tomcat-appspec: selector: matchLabels: name: tomcat replicas: 2 template: metadata: labels: name: tomcat spec: containers: - name: tomcat image: tomcat:8.0.51-alpine ports: - containerPort: 8080---apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-appspec: selector: matchLabels: name: nginx replicas: 2 template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80---apiVersion: v1kind: Servicemetadata: name: tomcat-servicespec: ports: - port: 8080 targetPort: 8080 selector: name: tomcat---apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: ports: - port: 8081 targetPort: 80 selector: name: nginx创建：1kubectl create -f demo.yml查看是否创建成功：接着创建Ingress配置文件（ingress.yml）:1234567891011121314151617181920apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: ingressspec: rules: - host: tomcat.mrbird.cc http: paths: - path: / backend: serviceName: tomcat-service servicePort: 8080 - host: nginx.mrbird.cc http: paths: - path: / backend: serviceName: nginx-service servicePort: 8081根据上述配置，当我们访问tomcat.mrbird.cc根路径的时候，请求将转发到名称为tomcat-service，端口为8080的service上，根据上面demo.yml的配置，该service对应两个tomcat pod；访问nginx.mrbird.cc根路径的时候，请求将转发到nginx-service。创建该Ingress：1kubectl create -f ingress.yml从图中可以看出，当我们访问tomcat.mrbird.cc/的时候，请求会均衡地转发到10.244.1.10:8080/和10.244.2.15:8080/。在Windows上配置hosts域名解析：浏览器访问http://tomcat.mrbird.cc/：访问http://nginx.mrbird.cc/：结果符合我们的预期。Ingress Nginx实质上就是一个nginx服务，它可以自动通过我们的Ingress配置，生成相应的nginx配置文件，我们可以进入到Ingress Nginx容器内部证实这一点:在配置文件中，可以看到下面这些配置（仅截取tomcat.mrbird.cc配置）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125...## start server tomcat.mrbird.ccserver &#123; server_name tomcat.mrbird.cc ; listen 80 ; listen [::]:80 ; listen 443 ssl http2 ; listen [::]:443 ssl http2 ; set $proxy_upstream_name &quot;-&quot;; ssl_certificate_by_lua_block &#123; certificate.call() &#125; location / &#123; set $namespace &quot;default&quot;; set $ingress_name &quot;ingress&quot;; set $service_name &quot;tomcat-service&quot;; set $service_port &quot;8080&quot;; set $location_path &quot;/&quot;; rewrite_by_lua_block &#123; lua_ingress.rewrite(&#123; force_ssl_redirect = false, ssl_redirect = true, force_no_ssl_redirect = false, use_port_in_redirects = false, &#125;) balancer.rewrite() plugins.run() &#125; header_filter_by_lua_block &#123; plugins.run() &#125; body_filter_by_lua_block &#123; &#125; log_by_lua_block &#123; balancer.log() monitor.call() plugins.run() &#125; port_in_redirect off; set $balancer_ewma_score -1; set $proxy_upstream_name &quot;default-tomcat-service-8080&quot;; set $proxy_host $proxy_upstream_name; set $pass_access_scheme $scheme; set $pass_server_port $server_port; set $best_http_host $http_host; set $pass_port $pass_server_port; set $proxy_alternative_upstream_name &quot;&quot;; client_max_body_size 1m; proxy_set_header Host $best_http_host; # Pass the extracted client certificate to the backend # Allow websocket connections proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header X-Request-ID $req_id; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Host $best_http_host; proxy_set_header X-Forwarded-Port $pass_port; proxy_set_header X-Forwarded-Proto $pass_access_scheme; proxy_set_header X-Scheme $pass_access_scheme; # Pass the original X-Forwarded-For proxy_set_header X-Original-Forwarded-For $http_x_forwarded_for; # mitigate HTTPoxy Vulnerability # https://www.nginx.com/blog/mitigating-the-httpoxy-vulnerability-with-nginx/ proxy_set_header Proxy &quot;&quot;; # Custom headers to proxied server proxy_connect_timeout 5s; proxy_send_timeout 60s; proxy_read_timeout 60s; proxy_buffering off; proxy_buffer_size 4k; proxy_buffers 4 4k; proxy_max_temp_file_size 1024m; proxy_request_buffering on; proxy_http_version 1.1; proxy_cookie_domain off; proxy_cookie_path off; # In case of errors try the next upstream server before returning an error proxy_next_upstream error timeout; proxy_next_upstream_timeout 0; proxy_next_upstream_tries 3; proxy_pass http://upstream_balancer; proxy_redirect off; &#125;&#125;## end server tomcat.mrbird.cc...更多Ingress配置可以参考官方文档：https://v1-12.docs.kubernetes.io/zh/docs/concepts/services-networking/ingress/。]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes StatefulSet]]></title>
    <url>%2FKubernetes-StatefulSet.html</url>
    <content type="text"><![CDATA[前面介绍的Pod管理对象，如RC/RS、Deployment、DaemonSet等都是面向无状态服务的，而对于有状态的应用，比如MySQL集群，MongoDB集群等，则可以使用StatefulSet来完成。有状态的应用集群通常有以下这些特点：每个节点都有固定的身份ID，通过这个ID，集群中的成员可以相互发现并通信；集群的规模是比较固定的，集群规模不能随意变动；集群中的每个节点都是有状态的，通常会持久化数据到永久存储中。StatefulSet特性通过StatefulSet搭建的集群通常有以下这些特性：StatefulSet里的每个Pod都有稳定、唯一的网络标识，可以用来发现集群内的其他成员。假设StatefulSet的名称为nginx，那么第1个Pod叫nginx-0，第2个叫nginx-1，以此类推；StatefulSet控制的Pod副本的启停顺序是受控的，操作第n个Pod时，前n-1个Pod已经是运行且准备好的状态。StatefulSet里的Pod采用稳定的持久化存储卷，通过PV或PVC来实现，删除Pod时默认不会删除与StatefulSet相关的存储卷（为了保证数据的安全）；配合Headless Service使用，用于发现和控制Pod实例数量。StatefulSet实践下面使用StatefulSet搭建个Nginx集群，持久化存储使用上一节搭建的名称为managed-nfs-storage的StorageClass。创建nginx-headless-service.yml配置文件：12345678910111213apiVersion: v1kind: Servicemetadata: name: nginx labels: name: nginxspec: ports: - port: 80 targetPort: 80 clusterIP: None # 表明为Headleass Service selector: role: web-app创建该Headless Service：1kubectl create -f nginx-headless-service.yml接着创建nginx-statefulset.yml配置文件：123456789101112131415161718192021222324252627282930313233apiVersion: apps/v1kind: StatefulSetmetadata: name: nginx-scspec: serviceName: "nginx" # 对应刚刚创建的Headless Service名称 replicas: 3 selector: matchLabels: role: web-app template: metadata: labels: role: web-app spec: terminationGracePeriodSeconds: 10 containers: - name: nginx image: nginx ports: - containerPort: 80 volumeMounts: - mountPath: /usr/share/nginx/html name: nginx-persistent-storage # 和下面的pvc名称对应 volumeClaimTemplates: # pvc模板 - metadata: name: nginx-persistent-storage # pvc名称 spec: storageClassName: managed-nfs-storage # 指定StorageClass名称 accessModes: ["ReadWriteMany"] resources: requests: storage: 100Mi创建该StatefulSet，观察pod的创建过程：可以看到，pod的创建是严格one by one的，因为我们定义的StatefulSet的名称位nginx-sc，所以Pod的名称分别位nginx-sc-0、nginx-sc-1和nginx-sc-2。查看对应的PVC和PV：状态为Bound。删除Pod，再次观察Pod的创建过程：可以看到顺序性是严格保证的。进入到Pod内部，查看其hostname：hostname和pod名称一致。到192.168.33.13的/nfs目录下可以看到挂载了三个nginx目录：《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes StorageClass实践]]></title>
    <url>%2FKubernetes-StorageClass-Practice.html</url>
    <content type="text"><![CDATA[手动创建PV不仅繁琐，还可能造成资源浪费。比如某个PV定义的存储空间为10Gi，该PV被某个声明需要8Gi内存的PVC绑定上了，这时候该PV处于Bound状态，无法再和别的PVC进行绑定，PV上剩下的2Gi内存实际上浪费的。StorageClass可以根据PVC的声明，动态创建对应的PV，这样不仅省去了创建PV的过程，还实现了存储资源的动态供应。StorageClass构成StorageClass的定义主要包括名称、后端存储的提供者（provisioner）和后端存储的相关参数配置。StorageClass一旦被创建出来，则将无法修改。如需更改，则只能删除原StorageClass的定义重建。举个简单的StorageClass配置：1234567apiVersion: storage.k8s.io/v1kind: StorageClassmetadata: name: managed-nfs-storage # StorageClass名称provisioner: fuseim.pri/ifs # 指定具体存储的提供者parameters: # 后端存储相关参数配置 archiveOnDelete: "false"不同的StorageClass主要区别在于：不同的存储提供者需要填写不同的参数配置，下面实现个NFS作为动态StorageClass存储的例子。基于NFS存储类型的实践NFS环境在上一节已经搭建好了，IP为192.168.33.13，路径为/nfs。在master节点上克隆相关代码：1git clone https://github.com/kubernetes-incubator/external-storage.git切换到external-storage/nfs-client/deploy目录：1cd external-storage/nfs-client/deploy创建RBAC：1kubectl create -f rbac.yml接着部署NFS Client Provisioner，部署前修改deployment.yml：123456789101112131415161718192021222324252627282930313233343536373839404142apiVersion: apps/v1kind: Deploymentmetadata: name: nfs-client-provisioner labels: app: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: defaultspec: replicas: 1 selector: matchLabels: app: nfs-client-provisioner strategy: type: Recreate selector: matchLabels: app: nfs-client-provisioner template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: quay.io/external_storage/nfs-client-provisioner:latest volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: mrbird.cc/nfs # 名称随你定义 - name: NFS_SERVER value: 192.168.33.13 # NFS 服务IP - name: NFS_PATH value: /nfs # NFS 目录 volumes: - name: nfs-client-root nfs: server: 192.168.33.13 # NFS 服务IP path: /nfs # NFS 目录然后创建该deployment：1kubectl create -f deployment.yml修改class.yaml配置：1234567apiVersion: storage.k8s.io/v1kind: StorageClassmetadata: name: managed-nfs-storage # StorageClass名称，随你定义provisioner: mrbird.cc/nfs # 和上面deployment里定义的一致parameters: archiveOnDelete: "false"创建这个StorageClass：1kubectl create -f class.yml创建PVC，PVC的定义对应test-claim.yml：1234567891011kind: PersistentVolumeClaimapiVersion: v1metadata: name: test-claimspec: storageClassName: managed-nfs-storage # 指定StorageClass名称，即我们上面定义的StorageClass accessModes: - ReadWriteMany resources: requests: storage: 1Mi创建这个PVC:1kubectl create -f test-claim.yml状态为Bound，说明已经成功绑定上了存储。查看PV，会看到系统自动创建了PV： 自动创建的PV名称为pvc-3b8c5364-aadb-4b07-a3b5-fddad280fc98。最后，修改test-pod.yml配置：123456789101112131415161718192021kind: PodapiVersion: v1metadata: name: test-podspec: containers: - name: test-pod image: busybox # 修改为这个，原先的镜像地址需要科学上网 command: - "/bin/sh" args: - "-c" - "touch /mnt/SUCCESS &amp;&amp; exit 0 || exit 1" volumeMounts: - name: nfs-pvc mountPath: "/mnt" restartPolicy: "Never" volumes: - name: nfs-pvc persistentVolumeClaim: claimName: test-claim # 指定PVC名称，对应上面创建的PVC该Pod主要就是通过busybox在/mnt目录下创建了个SUCCESS文件。创建该Pod：1kubectl create -f test-pod.yml状态为Completed，说明busybox成功执行完了命令并结束了。如果一切顺利的话，在192.168.33.13的/nfs目录下会看到busybox pod创建的SUCCESS文件:可以看到/nfs目录下新增了一个目录，目录名称格式为：[namespace]-[pvc名称]-[pv名称]。我们还可以玩一下另一个测试，新建一个test-pod-rc.yml文件：12345678910111213141516171819202122232425262728apiVersion: v1kind: ReplicationControllermetadata: name: busyboxspec: replicas: 2 # 副本数为2，为了测试共享存储 selector: name: busybox template: metadata: labels: name: busybox spec: containers: - image: busybox command: - sh - -c - 'while true; do sleep $(($RANDOM % 5 + 5)); done' imagePullPolicy: IfNotPresent name: busybox volumeMounts: - name: nfs mountPath: "/mnt" volumes: - name: nfs persistentVolumeClaim: claimName: test-claim # 指定PVC名称，对应上面创建的PVC上面busybox做的事情很简单，就是无限期休眠。创建该rc：可以看到，pod分别部署到了node1和node2上。到node1节点上，进入busybox容器内部的/mnt目录，在该目录下创建一个hello文件：然后到node2节点上，进入busybox容器内部/mnt目录，观察刚刚在node1节点busybox容器内部创建的hello文件是否已经同步过来了：可以看到，文件同步成功。并且前面例子创建SUCCESS也同步过来了，这是因为它们指定了同一个PVC。回到NFS服务器的/nfs目录下，可以看到刚刚创建的hello文件：]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes PV/PVC]]></title>
    <url>%2FKubernetes-PV-PVC.html</url>
    <content type="text"><![CDATA[在Kubernetes中，我们虽然可以使用volume将容器内目录挂载到宿主机目录上，但由于Pod调度的不确定性，这种数据存储方式是不牢靠的。对于有状态的应用，我们希望无论Pod被调度到哪个节点上，它们的数据总能够完整地恢复，这时候我们就不能用volume挂载了，而应该使用“网络共享存储”。PV/PVC就是用于解决问题而存在的，它们屏蔽了底层存储实现的细节，使得我们很容易上手使用。PVPersistentVolume（PV）是对底层网络共享存储的抽象，将共享存储定义为一种“资源”，Kubernetes支持的PV类型如下：类型描述AWSElasticBlockStoreAWS公有云提供的ElasticBlockStoreAzureFileAzure公有云提供的FileAzureDiskAzure公有云提供的DiskCephFS一种开源共享存储系统FC（Fibre Channel）光纤存储设备FlexVolume一种插件式的存储机制Flocker一种开源共享存储系统GCEPersistentDiskGCE公有云提供的PersistentDiskGlusterfs一种开源共享存储系统HostPath宿主机目录，仅用于单机测试iSCSIiSCSI存储设备Local本地存储设备，从Kubernetes 1.7版本引入，到1.14版本时更新为稳定版，目前可以通过指定块（Block）设备提供Local PV，或通过社区开发的sig-storage-local-static-provisioner插件https://github.com/kubernetes-sigs/sigstorage-local-static-provisioner来管理Local PV的生命周期NFS网络文件系统Portworx VolumesPortworx提供的存储服务Quobyte VolumesQuobyte提供的存储服务RBD（Ceph Block Device）Ceph块存储ScaleIO VolumesDellEMC的存储设备StorageOSStorageOS提供的存储服务VsphereVolumeVMWare提供的存储系统举个PV配置文件例子：12345678910111213apiVersion: v1kind: PersistentVolumemetadata: name: nfsspec: capacity: storage: 1Gi # 具有1Gi内存 accessModes: - ReadWriteMany # 具有读写权限，允许被多个Node挂载 persistentVolumeReclaimPolicy: Retain # 回收策略，这里为保留 nfs: # pv类型为NFS类型 server: 192.168.33.13 path: "/nfs"PV支持的accessModes有：ReadWriteOnce（RWO）：读写权限，并且只能被单个Node挂载。ReadOnlyMany（ROX）：只读权限，允许被多个Node挂载。ReadWriteMany（RWX）：读写权限，允许被多个Node挂载。不同的存储提供者支持的accessModes：Volume PluginReadWriteOnceReadOnlyManyReadWriteManyAWSElasticBlockStore✓--AzureFile✓✓✓AzureDisk✓--CephFS✓✓✓Cinder✓--CSIdepends on the driverdepends on the driverdepends on the driverFC✓✓-FlexVolume✓✓depends on the driverFlocker✓--GCEPersistentDisk✓✓-Glusterfs✓✓✓HostPath✓--iSCSI✓✓-Quobyte✓✓✓NFS✓✓✓RBD✓✓-VsphereVolume✓-- (works when Pods are collocated)PortworxVolume✓-✓ScaleIO✓✓-StorageOS✓--PV支持的persistentVolumeReclaimPolicy有：Retain，不清理, 保留 Volume（需要手动清理）Recycle，删除数据，（只有 NFS 和 HostPath 支持）Delete，删除存储资源，比如删除 AWS EBS 卷（只有 AWS EBS, GCE PD, Azure Disk 和 Cinder 支持）PV声明周期：Available：空闲状态；Bound：已经绑定到某个PVC上；Released：对应的PVC已经被删除，但资源还没有被集群收回；Failed：PV自动回收失败。PVCPersistentVolumeClaim（PVC），对存储资源的需求申请，主要包括存储空间请求、访问模式、PV选择条件和存储类别等信息的设置。只有PVC和PV相匹配，才能绑定上。定义一个PVC配置：12345678910kind: PersistentVolumeClaimapiVersion: v1metadata: name: nfsspec: accessModes: - ReadWriteMany resources: requests: storage: 1Gi该PVC声明了需要1Gi存储空间，访问模式为ReadWriteMany，刚刚定义的PV符合这个要求，所以会被绑定上。实践因为NFS类型存储演示起来方便，所以这里选择使用NFS作为存储提供者。在Kubeadm安装Kubernetes1.16.2集群一节中，我们曾在以下虚拟机上搭建了Kubernetes集群:操作系统IP角色CPU核心数内存Hostnamecentos7192.168.33.11master24096Mmastercentos7192.168.33.12worker24096Mnode1centos7192.168.33.13worker24096Mnode2为了方便，这里就不再创建新的虚拟机安装NFS，直接在192.168.33.13节点上准备好NFS环境。在192.168.33.13节点上执行以下bash命令：12345678# 创建目录mkdir /nfs# 修改权限chmod 777 /nfs# 创建exports文件vim /etc/exportsexports内容如下所示：1/nfs *(rw,insecure,sync,no_subtree_check,no_root_squash)让配置生效：1exportfs -r启动NFS：1234systemctl enable nfssystemctl enable rpcbindsystemctl restart nfssystemctl restart rpcbind接着在master节点上，创建test-pv-pvc.yml配置文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495apiVersion: v1kind: PersistentVolumemetadata: name: nfs-pvspec: capacity: storage: 1Gi accessModes: - ReadWriteMany nfs: server: 192.168.33.13 path: "/nfs"---apiVersion: v1kind: PersistentVolumeClaimmetadata: name: nfs-pvcspec: accessModes: - ReadWriteMany resources: requests: storage: 1Gi---apiVersion: v1kind: ReplicationControllermetadata: name: busyboxspec: replicas: 1 selector: name: busybox template: metadata: labels: name: busybox spec: containers: - image: busybox command: - sh - -c - 'while true; do echo hello world &gt; /mnt/index.html; sleep $(($RANDOM % 5 + 5)); done' imagePullPolicy: IfNotPresent name: busybox volumeMounts: - name: nfs mountPath: "/mnt" volumes: - name: nfs persistentVolumeClaim: claimName: nfs-pvc---apiVersion: v1kind: ReplicationControllermetadata: name: nginxspec: replicas: 1 selector: name: nginx template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx ports: - name: web containerPort: 80 volumeMounts: - name: nfs mountPath: "/usr/share/nginx/html" volumes: - name: nfs persistentVolumeClaim: claimName: nfs-pvc---kind: ServiceapiVersion: v1metadata: name: nginx-servicespec: ports: - port: 80 nodePort: 30000 type: NodePort selector: name: nginx上面的配置文件效果可以用下面这张图表示：主要过程就是busybox通过nfs-pvc绑定了nfs-pv，然后定时将hello world写到容器内部/mnt/index.html文件中，而容器内部/mnt和PV的/nfs目录挂载；nginx也通过nfs-pvc绑定了nfs-pv，将/nfs目录和容器内部/usr/share/nginx/html目录挂载；我们后续可以通过访问浏览器http://192.168.33.11:30000/地址查看效果。创建该配置文件:查看192.168.33.13虚拟机/nfs目录下是否已经存在index.html文件，并查看内容：浏览器访问http://192.168.33.11:30000/：说明整个流程没问题。]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CI/CD实践笔记]]></title>
    <url>%2FCI-CD-Practice-Note.html</url>
    <content type="text"><![CDATA[CICD（Continuous Integration/Continuous Deployment），持续集成持续部署的意思。完成CICD实践需要Kubernetes集群，Harbor，GitLab和Jenkins等软件配合完成，在前面几篇博客中，我已经搭建好了Kubernetes集群，并且在master节点（192.168.33.11,CentOS）上安装好了Harbor、GitLab和Jenkins，有需要可以参考下。实践准备CICD流程图CICD的大致流程如下图所示：开发者将最新代码提交到GitLab仓库；GitLab WebHook触发Jenkins构建流水线：2.1 拉取最新代码；2.2 Maven打包，打包过程中会先进行单元测试；2.3 单元测试通过，构建Docker镜像；2.4 将最新镜像推送到Harbor；2.5 更新Kubernetes相关配置镜像版本。Kubernetes感知到镜像更新，从Harbor拉取最新镜像，滚动升级；开发者看到最新的代码效果。项目准备这里我们在Windows上使用IDEA、Spring Boot构建一个简单的Java Web项目，项目名为demo，项目pom如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;在Boot入口类中添加一个简单的Controller方法：12345678910111213@RestController@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @GetMapping("hello") public String index() &#123; return "hello world"; &#125;&#125;上面方法提供了一个/hello接口，简单返回hello world信息。接着编写一个简单的单元测试：代码如下：1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcclass DemoApplicationTests &#123; @Autowired private MockMvc mockMvc; @Test void testIndex() throws Exception &#123; mockMvc.perform(MockMvcRequestBuilders.get("/hello")) .andExpect(MockMvcResultMatchers.content().string("hello world")); &#125;&#125;最后在项目的根目录下新建一个Dockerfile：12345FROM openjdk:8u212-jreMAINTAINER MrBird 852252810@qq.comCOPY target/demo-0.0.1-SNAPSHOT.jar /demo-0.0.1-SNAPSHOT.jarENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/demo-0.0.1-SNAPSHOT.jar&quot;]至此简单的Java Web项目就准备好了。GitLab准备注册一个新的GitLab账号，比如mrbird，然后在GitLab新建一个项目，名称为Demo：因为我们后续需要在Windows下将项目提交到GitLab，并在192.168.33.11上拉取该项目，所以我们需要在Windows和192.168.33.11服务器上生成SSH Key，并添加到GitLab中。在Windows及192.168.33.11虚拟机通过下面的命令生成SSH Key：123ssh-keygen -t rsa -C "852252810@qq.com"cat ~/.ssh/id_rsa.pub将SSH Key添加到GitLab：这样我们后续的push和pull操作就不需要输入用户名了。接着我们将上面创建的Demo项目推送到GitLab中（在IDEA的Terminal窗口中操作，个人习惯用命令行）：123456789101112131415# 配置Gitgit config --global user.name &quot;mrbird&quot;git config --global user.email &quot;852252810@qq.com&quot;# 初始化Git仓库git init# commitgit commit -am init# 添加远程仓库git remote add origin ssh://git@gitlab.mrbird.cc:2223/mrbird/demo.git# 推送到远程仓库git push origin master推送成功后，回到GitLab页面可以看到项目已经推送OK了：Kubernetes部署SpringBoot项目在192.168.33.11服务器上将刚刚的项目从GitLab中克隆下来:1git clone ssh://git@gitlab.mrbird.cc:2223/mrbird/demo.git因为打包需要Maven环境，所以接着配置Maven：12345678# 下载Maven安装包wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.tar.gz# 解压tar -xzvf apache-maven-3.6.2-bin.tar.gz# 修改环境变量vim /etc/profile添加如下内容：12M2_HOME=/home/vagrant/apache-maven-3.6.2export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/bin让修改生效：1source /etc/profile验证下是否安装成功：环境准备好后，将目录切换到刚刚git clone的demo目录下，执行mvn clean package命令，完成后可以看到fat jar：接着执行docker build -t docker.mrbird.cc/febs/demo .命令构建docker镜像：构建成功后执行docker push docker.mrbird.cc/febs/demo命令推送到Harbor：访问Harbor管理页面，可以看到镜像已经推送上来了：接着编写个简单的Kubernetes配置文件（demo.yml）：123456789101112131415161718192021222324252627282930313233343536373839apiVersion: v1kind: Servicemetadata: name: demo-servicespec: type: NodePort ports: - port: 8080 targetPort: 8080 nodePort: 30000 selector: name: demo-app---apiVersion: apps/v1kind: Deploymentmetadata: name: demo-deploymentspec: selector: matchLabels: name: demo-app replicas: 2 template: metadata: labels: name: demo-app spec: containers: - name: demo image: docker.mrbird.cc/febs/demo ports: - containerPort: 8080 resources: limits: cpu: 500m memory: 500Mi requests: cpu: 200m memory: 200Mi运行该配置:使用浏览器访问http://192.168.33.11:30000/hello:至此Spring Boot项目已经成功运行在Kubernetes集群中了，接下来开始演示如何进行CICD。CICD实践就如上面CICD流程图所示，第一步将本地开发代码push到GitLab已经实现了，接下来开始配置GitLab WebHook。GitLab WebHook在Jenkins中创建流水线前，先修改两处Jenkins配置。点击Jenkins管理页面的系统管理菜单 -&gt; 全局安全配置：关闭CSRF保护和开启匿名用户具有可读权限。然后点击新建任务菜单，新增一个名称为demo的流水线，勾选触发远程构建：令牌设置为666666，触发地址为JENKINS_URL/job/demo/build?token=TOKEN_NAME，我们需要将这个地址配置为GitLab的WebHook中。打开GitLab的Demo项目页面，点击左侧的设置菜单：选择integrations：其中http://192.168.33.11:8081为我的Jenkins地址，对应JENKINS_URL；666666是我们设置的令牌，对应TOKEN_NAME。触发事件选择push event就行。保存WebHook的时候如果提示Url is blocked: Requests to the local network are not allowed的话，可以使用admin@example.com账号登录GitLab（密码就是你第一次登录修改的密码），然后点击Admin Area-&gt;Settings-&gt;Network：勾选Allow requests to the local network from web hooks and services即可。保存后，重新使用mrbird账号登录重新配置WebHook即可。配置好后，测试一下：页面弹出如下提示说明配置🆗：代码拉取Maven打包前需要先用git命令将代码拉取下来。编辑刚刚创建的流水线，在Pipeline script中添加如下代码：12345678910111213141516#!groovypipeline &#123; agent any environment &#123; REPOSITORY="ssh://git@gitlab.mrbird.cc:2223/mrbird/demo.git" &#125; stages &#123; stage('拉取代码') &#123; steps &#123; echo "从GitLab地址$&#123;REPOSITORY&#125;拉取代码" deleteDir() git "$&#123;REPOSITORY&#125;" &#125; &#125; &#125;&#125;Pipeline script的基本模板为：123456789101112131415#!groovypipeline &#123; agent any environment &#123; // 定义全局变量 &#125; stages &#123; // 可以定义多个阶段 stage('阶段名称') &#123; steps &#123; // 具体步骤 &#125; &#125; &#125;&#125;回到上面的Pipeline script代码，我们主要做了下面几件事：在environment中定义GitLab项目仓库地址变量，方便下面直接引用；通过echo命令输出，方便后续从日志中观察跟踪；通过deleteDir()清空工作区；通过git &quot;${REPOSITORY}&quot;从指定Git仓库拉取代码。其中，使用environment中的变量时候，一定要用&quot;${xx}&quot;的方式引用；第3第4步的命令可以通过流水线语法来生成，比如生成清空当前目录的命令：生成通过Git拉取代码的命令：修改好流水线后，点击立即构建，看看我们的配置是否🆗：从日志来看，代码拉取是成功的。Maven打包和单元测试Jenkins 通过shell脚本调用mvn 命令的时候，是从/usr/bin 文件夹中找命令的，这个时候需要做个软链接：1ln -s /home/vagrant/apache-maven-3.6.2/bin/mvn /usr/bin/mvn更新流水线的Pipeline script，添加maven打包阶段命令：12345678910111213141516171819202122#!groovypipeline &#123; agent any environment &#123; REPOSITORY="ssh://git@gitlab.mrbird.cc:2223/mrbird/demo.git" &#125; stages &#123; stage('拉取代码') &#123; steps &#123; echo "从GitLab地址$&#123;REPOSITORY&#125;拉取代码" deleteDir() git "$&#123;REPOSITORY&#125;" &#125; &#125; stage('代码编译及单元测试') &#123; steps &#123; echo "开始编译代码和单元测试" sh "mvn -U -am clean package" &#125; &#125; &#125;&#125;maven打包前会自动运行我们在项目里写好的单元测试，修改后，点击立即构建，查看日志（截取关键部分）：可以看到单元测试及打包成功。构建镜像及推送镜像构建和推送涉及命令较多，所以可以定义一个脚本：1vim build_push.sh脚本内容如下所示：123456789101112#!/bin/bashMODULE=$1TIME=`date &quot;+%Y%m%d%H%M&quot;`GIT_REVISION=`git log -1 --pretty=format:&quot;%h&quot;`IMAGE_NAME=docker.mrbird.cc/febs/$&#123;MODULE&#125;:$&#123;TIME&#125;_$&#123;GIT_REVISION&#125;docker build -t $&#123;IMAGE_NAME&#125; .docker push $&#123;IMAGE_NAME&#125;echo &quot;$&#123;IMAGE_NAME&#125;&quot; &gt; image_name上面脚本定义了三个变量：MODULE，模块名称，由脚本执行的时候传入；TIME，时间字符串；GIT_REVISION，git 提交历史哈希码的前7位；IMAGE_NAME，镜像名称。脚本做的事情很简单，根据当前目录的Dockerfile构建Docker镜像，然后将镜像推送到Harbor仓库，推送后，将镜像名称写到当前目录下的image_name文件中（供后续使用）。给脚本添加可执行权限：1chmod +x build_push.sh修改Pipeline script，新增构建镜像及推送阶段命令：1234567891011121314151617181920212223242526272829#!groovypipeline &#123; agent any environment &#123; REPOSITORY=&quot;ssh://git@gitlab.mrbird.cc:2223/mrbird/demo.git&quot; SCRIPT_PATH=&quot;/home/vagrant/bash&quot; &#125; stages &#123; stage(&apos;拉取代码&apos;) &#123; steps &#123; echo &quot;从GitLab地址$&#123;REPOSITORY&#125;拉取代码&quot; deleteDir() git &quot;$&#123;REPOSITORY&#125;&quot; &#125; &#125; stage(&apos;代码编译及单元测试&apos;) &#123; steps &#123; echo &quot;开始编译代码和单元测试&quot; sh &quot;mvn -U -am clean package&quot; &#125; &#125; stage(&apos;Docker镜像构建及推送&apos;) &#123; steps &#123; echo &quot;开始构建Docker镜像并推送到Harbor&quot; sh &quot;$&#123;SCRIPT_PATH&#125;/build_push.sh demo&quot; &#125; &#125; &#125;&#125;其中SCRIPT_PATH是上面定义的脚本的路径。修改好Pipeline script，重新点击立即构建，截取和这部分相关的日志：查看镜像列表：Kubernetes Deployment升级在/home/vagrant/bash目录下新建deploy.sh脚本：12345#!/bin/bashIMAGE=`cat image_name`kubectl set image deployment/demo-deployment demo=$&#123;IMAGE&#125;脚本内容很简单，就是通过kubectl命令升级相关Pod的镜像，镜像名称从image_name文件中读取。修改Pipeline script，添加Kubernetes Deployment升级阶段命令：1234567891011121314151617181920212223242526272829303132333435#!groovypipeline &#123; agent any environment &#123; REPOSITORY="ssh://git@gitlab.mrbird.cc:2223/mrbird/demo.git" SCRIPT_PATH="/home/vagrant/bash" &#125; stages &#123; stage('拉取代码') &#123; steps &#123; echo "从GitLab地址$&#123;REPOSITORY&#125;拉取代码" deleteDir() git "$&#123;REPOSITORY&#125;" &#125; &#125; stage('代码编译及单元测试') &#123; steps &#123; echo "开始编译代码和单元测试" sh "mvn -U -am clean package" &#125; &#125; stage('Docker镜像构建及推送') &#123; steps &#123; echo "开始构建Docker镜像并推送到Harbor" sh "$&#123;SCRIPT_PATH&#125;/build_push.sh demo" &#125; &#125; stage('更新Kubernetes Deployment') &#123; steps &#123; echo "开始更新Kubernetes Deployment" sh "$&#123;SCRIPT_PATH&#125;/deploy.sh" &#125; &#125; &#125;&#125;修改后，点击立即构建：至此我们整条CICD流程就已经都通了，下面测试下CICD。效果测试如上面所示，我们访问http://192.168.33.11:30000/hello，页面返回hello world，我们在IDEA中修改Controller方法：同时修改单元测试方法：修改后在IDEA的命令窗口输入：123git commit -am updategit push origin master将最新的代码提交到GitLab后，过一小会刷新http://192.168.33.11:30000/hello，可以看到，我们修改的内容已经生效了：]]></content>
      <tags>
        <tag>GitLab</tag>
        <tag>CI/CD</tag>
        <tag>DevOps</tag>
        <tag>Harbor</tag>
        <tag>Kubernetes</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab & Jenkins安装小记]]></title>
    <url>%2FGitLab-Jenkins-Install-Note.html</url>
    <content type="text"><![CDATA[在CentOS下安装GitLab和Jenkins。安装GitLab传统方式安装GitLab比较麻烦，所以这里我们使用Docker安装GitLab，拉取官方镜像：1docker pull gitlab/gitlab-ce:latest镜像有点大，耐心等待。拉取好后，编写一个启动脚本：12345678910111213cat &lt;&lt;EOF &gt; run_gitlab.sh#!/bin/bashdocker stop gitlabdocker rm gitlabdocker run -d \ --hostname gitlab.mrbird.cc \ -p 8443:443 -p 8080:80 -p 2223:22 \ --name gitlab \ -v /gitlab/config:/etc/gitlab \ -v /gitlab/logs:/var/log/gitlab \ -v /gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latestEOF--hostname gitlab.mrbird.cc绑定域名，端口映射了下，防止和宿主机冲突。执行chmod u+x run_gitlab.sh添加可执行权限，然后运行sh run_gitlab.sh启动GitLab。执行启动脚本后，使用docker logs -f gitlab查看启动日志，第一次启动比较慢，当日志定时输出/metrics内容时说明GitLab已启动完毕：12==&gt; /var/log/gitlab/gitlab-rails/sidekiq_exporter.log &lt;==[2019-11-03T03:35:18.170+0000] 127.0.0.1 - - [03/Nov/2019:03:35:18 UTC] &quot;GET /metrics HTTP/1.1&quot; 200 6162 &quot;-&quot; &quot;Prometheus/2.12.0&quot;启动后，修改gitlab.rb文件：1vim /gitlab/config/gitlab.rb开启这段配置，并且端口号改为上面指定的2223：然后执行sh run_gitlab.sh重启即可。重启后，在虚拟机和windows里添加hosts解析：1192.168.33.11 gitlab.mrbird.cc使用浏览器访问http://gitlab.mrbird.cc:8080/：GitLab还是比较占内存的，在安装GitLab前请确保内存够用🌚：1234docker stats gitlabCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSd8edbda28f9f gitlab 6.80% 1.944GiB / 3.701GiB 52.54% 130kB / 2.29MB 118MB / 2.52MB 281安装JenkinsJenkins的话，推荐用传统方式安装，这样宿主机上安装的maven、docker、kubectl等命令可以直接使用。在安装Jenkins之前，需要有Java（我安装的是1.8版本）环境，在CentOS7上安装JDK的过程就不演示了，之前在https://mrbird.cc/FEBS-Vue-Document.html中也有介绍过。安装好JDK后，下载Jenkins war包：1wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war编写一个启动脚本run_jenkins.sh：1vim run_jenkins.sh内容如下所示：123#!/bin/bashnohup java -jar jenkins.war --httpPort=8081 &amp;授权：1chmod u+x run_jenkins.sh启动Jenkins：1sh run_jenkins.sh当启动日志输出如下内容时，说明jenkins已成功启动：1234567891011121314***************************************************************************************************************************************************************************************Jenkins initial setup is required. An admin user has been created and a password generated.Please use the following password to proceed to installation:6ddc10e56b574f27a360986f84da19fcThis may also be found at: /root/.jenkins/secrets/initialAdminPassword***************************************************************************************************************************************************************************************其中6ddc10e56b574f27a360986f84da19fc为Jenkins的密码，该密码也可以在/root/.jenkins/secrets/initialAdminPassword文件找到。使用浏览器访问http://192.168.33.11:8081/：输入上面的密码，进入：点击“选择插件安装”，然后Pipelines and Continuous Delivery一栏中的所有插件都勾选上：然后点击安装即可，安装结束后，接着创建用户：点击重启：用刚刚创建的用户登录即可：]]></content>
      <tags>
        <tag>GitLab</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Docker镜像仓库Harbor]]></title>
    <url>%2FHarbor.html</url>
    <content type="text"><![CDATA[Harbor是一款开源的Docker镜像存储仓库，其扩展了Docker Distribution，在此基础上添加了我们常用的功能，比如安全认证，RBAC用户权限管理，可视化页面操作等功能。Harbor还支持多个Harbor仓库间的相互拷贝，以实现Docker镜像仓库的高可用。这节我们在CentOS虚拟机（192.168.33.11）上搭建个单机版的Harbor体验一下。安装Harbor在Harbor的GitHub仓库：https://github.com/goharbor/harbor/releases下载离线版本（offline），我选择的版本是1.8.4：下载后，将压缩包harbor-offline-installer-v1.8.4.tgz上传到192.168.33.11服务器上：解压压缩包：修改Harbor配置文件：将hostname修改为宿主机IP即可：然后执行当前目录下的install.sh脚本进行安装。安装过程中出现如下错误：根据https://docs.docker.com/compose/install/安装docker compose后重新执行install.sh脚本。出现如下信息时，安装成功:使用浏览器访问http://192.168.33.11/地址，可以看到Harbor的管理界面：默认的用户名密码为：admin，Harbor12345，登录后：为了后续推送镜像方便，我们需要给192.168.33.11配置域名，添加hosts解析：1192.168.33.11 docker.mrbird.cc创建用户和项目在http://192.168.33.11/Harbor管理界面下新增一个用户：然后新增一个项目：在该项目下添加刚刚创建的mrbird用户：接着在192.168.33.11上进行登录:用户名和密码就是刚刚在控制台创建的mrbird用户和密码。但是登录失败了，要登录到http docker仓库，需要添加一些配置：1vim /etc/docker/daemon.json添加如下内容：重启docker：1sudo service docker restart然后重新登录即可：测试镜像推拉拉取nginx:1.17.5镜像：1docker pull nginx:1.17.5打标签:1docker tag nginx:1.17.5 docker.mrbird.cc/febs/nginx:1.17.5标签格式为[docker仓库域名]:[项目名称]:[镜像]。将docker.mrbird.cc/febs/nginx:1.17.5推送到Harbor：1docker push docker.mrbird.cc/febs/nginx回到Harbor控制台，可以看到在febs项目下已经存在一个nginx镜像：在192.168.33.12服务器上添加docker.mrbird.cc的解析，然后拉取刚刚的镜像，看看是否成功：1docker pull docker.mrbird.cc/febs/nginx:1.17.5拉取成功。]]></content>
      <tags>
        <tag>Harbor</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes资源管理]]></title>
    <url>%2FKubernetes-Resource-Management.html</url>
    <content type="text"><![CDATA[通过前面的学习我们知道，我们可以通过requests和limits给Pod指定资源配置，但如果每个Pod都要指定的话略显繁琐，我们可以使用LimitRange指定一个全局的默认配置；此外通过ResourceQuota对象，我们可以定义资源配额，这个资源配额可以为每个命名空间都提供一个总体的资源使用的限制：它可以限制命名空间中某种类型的对象的总数目上限，也可以设置命名空间中Pod可以使用的计算资源的总上限。LimitRange在使用LimitRange之前先创建一个命名空间：1234apiVersion: v1kind: Namespacemetadata: name: test-resource然后定义LimitRange配置（limit-range.yml）:1234567891011121314151617181920212223242526272829303132apiVersion: v1kind: LimitRangemetadata: name: limit-range-examplespec: limits: - max: cpu: 2 memory: 2Gi min: cpu: 200m memory: 6Mi maxLimitRequestRatio: cpu: 3 memory: 2 type: Pod - default: cpu: 300m memory: 200Mi defaultRequest: cpu: 200m memory: 100Mi max: cpu: 2 memory: 1Gi min: cpu: 100m memory: 3Mi maxLimitRequestRatio: cpu: 5 memory: 4 type: Container创建该LimitRange：可以看到配置已经生效了。下面介绍下这些配置的含义：上面配置分为Pod和Container配置，Container资源配置对应每个Docker容器的资源配置，Pod资源配置对应一个Pod中所有容器资源的总和。其中Pod和Container都可以指定min，max和maxLimitRequestRatio：min：指定资源的下限，即最低资源配置不能低于这个值；max：指定资源的上限，即最高资源使用不能高于这个值；maxLimitRequestRatio：该值用于指定requests和limits值比例的上限。相较于Pod，Container还可以指定defaultRequest和default（实际上就是defaultLimit，不懂为什么Kubernetes不用这个名称😵）：defaultRequest：全局容器的默认requests值；default：全局容器的默认limits值。下面我们举几个例子，看看我们创建的LimitRange是否生效。定义一个Pod配置文件（test-default.yml）：12345678910apiVersion: v1kind: Podmetadata: name: test-defaultspec: containers: - name: nginx image: nginx ports: - containerPort: 80创建该Pod：可以看到我们在test-default.yml中并没有定义requests和limits配置，但是通过Pod实例的yaml可以看到它已经指定了这两个值，而这些正是上面我们在LimitRange中定义的默认值。接着定义一个新的Pod配置（test-max.yml）:1234567891011121314apiVersion: v1kind: Podmetadata: name: test-maxspec: containers: - name: nginx image: nginx ports: - containerPort: 80 resources: limits: cpu: 3 memory: 500Mi创建该Pod：可以看到在创建的时候就报错了，因为上面的cpu配置即超过了LimtRange中定义的Container的cpu最高配置，也超过了Pod的cpu的最高配置。再创建一个Pod配置（test-ratio.yml）：1234567891011121314151617apiVersion: v1kind: Podmetadata: name: test-ratiospec: containers: - name: nginx image: nginx ports: - containerPort: 80 resources: limits: cpu: 2 memory: 500Mi requests: cpu: 300m memory: 50Mi创建该Pod：可以看到也报错了，因为requests和limits的比例不符合LimitRange的maxLimitRequestRatio配置。LimitRange的测试先到这里吧，通过上面三个例子大体也能感受到LimitRange的作用了。ResourceQuotaResourceQuota用于管理资源配额，这个资源配额可以为每个命名空间都提供一个总体的资源使用的限制。资源配额主要分为以下几个类型：计算资源配额资源名称说明Cpu所有非终止状态的Pod，CPU Requests的总和不能超过该值limits.cpu所有非终止状态的Pod， CPU Limits的总和不能超过该值limits.memory所有非终止状态的Pod，内存 Limits的总和不能超过该值Memory所有非终止状态的Pod， 内存 Requests的总和不能超过该值requests.cpu所有非终止状态的Pod，CPU Requests的总和不能超过该值requests.memory所有非终止状态的Pod， 内存Requests的总和不能超过该值存储资源配额资源名称说明requests.storage所有PVC，存储请求总量不能超过此值PersistentVolumeclaims在该命名空间中能存在的持久卷的总数上限.storageclass.storage.k8s.io/requests.storage和该存储类关联的所有PVC，存储请求总和不能超过此值.storageclass.storage.k8s.io/persistentvolumeclaims和该存储类关联的所有PVC的总和对象数量配额资源名称说明Configmaps在该命名空间中能存在的ConfigMap的总数上限Pods在该命名空间中能存在的非终止状态Pod的总数上限，Pod终止状态等价于Pod的status.phase in(Failed, Succeeded) = trueReplicationcontrollers在该命名空间中能存在的RC的总数上限Resourcequtas在该命名空间中能存在的资源配额项的总数上限Services在该命名空间中能存在的Service的总数上限service.loadbalancers在该命名空间中能存在的负载均衡的总数上限services.nodeports在该命名空间中能存在的NodePort的总数上限Secrets在该命名空间中能存在的Secret的总数上限测试在测试ResourceQuota之前我们也先创建一个命名空间：1234apiVersion: v1kind: Namespacemetadata: name: quota-ns创建个简单的ResourceQuota配置（test-quota.yml）：1234567apiVersion: v1kind: ResourceQuotametadata: name: test-quotaspec: hard: pods: &quot;4&quot;创建该ResourceQuota：接着定义一个RC配置（nginx-rc.yml）：12345678910111213141516171819apiVersion: v1kind: ReplicationControllermetadata: name: nginx-rcspec: replicas: 3 selector: name: nginx template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 80创建该RC:可以看到，已经有3个Pod实例了，如果将Pod数量扩大到5，看看会怎样：最终也只会有4个Pod实例，因为我们在上面ResourceQuota中指定的最大Pod数量为4。《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Namespace&Context]]></title>
    <url>%2FKubernetes-Namespaces-Context.html</url>
    <content type="text"><![CDATA[在一个组织内部，不同的工作组可以在同一个Kubernetes集群中工作，Kubernetes通过命名空间和Context的设置对不同的工作组进行区分，使得它们既可以共享同一个Kubernetes集群的服务，也能够互不干扰。Namespace的创建Kubernetes集群会帮我们创建一个名称为default的命名空间：默认情况下，我们的pod、rc、service等Kubernetes资源都是使用这个命名空间，此外我们也可以创建自己的命名空间。定义一个命名空间配置dev-namesapce.yml：1234apiVersion: v1kind: Namespacemetadata: name: dev # dev命名空间创建该命名空间：使用Namespace使用命名空间只需要在创建Kubernetes资源对象的时候指定即可，比如创建一个tomcat-rc.yml，并指定命名空间为dev：123456789101112131415161718192021apiVersion: v1kind: ReplicationControllermetadata: name: tomcat-rc namespace: dev # 指定命名空间spec: replicas: 2 selector: name: tomcat template: metadata: name: tomcat labels: name: tomcat spec: containers: - name: tomcat image: tomcat ports: - containerPort: 8080 hostPort: 8081创建该rc：可以看到，defalut命名空间下并没有任何pod，而dev命名空间下则有两个tomcat pod实例。命名空间只是名称上的隔离，不同命名空间下的pod，service等还是可以相互访问的。Context的创建和使用我们可以通过创建Context（上下文），指定使用的命名空间，然后使用该Context，来完成默认的命名空间切换。在创建Context前，我们查看下Kubernetes默认的配置：可以看到，当前默认的Context名称为kubernetes-admin@kubernetes，由此可以推断，它和defalut这个命名空间挂钩。创建一个新的Context，名称为ctx-dev，命名空间使用上面创建的dev：其中/root/.kube/config为Kubernetes配置。创建成功后，我们使用ctx-dev这个Context：可以看到，现在不需要指定-n dev就可以获取到dev命名空间下的pod了，也证实了Context的切换是成功的。如果想要恢复默认的Context，将Context指定为kubernetes-admin@kubernetes：]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Service基础]]></title>
    <url>%2FKubernetes-Service-Basic.html</url>
    <content type="text"><![CDATA[Kubernetes可以为一组具有相同功能的Pod提供一个统一的入口地址，并且将请求均衡的转发到各个对应的Pod上。本节主要记录Service的一些基本用法。基本用法创建一个Tomcat RC（tomcat-rc.yml）:12345678910111213141516171819apiVersion: v1kind: ReplicationControllermetadata: name: tomcat-rcspec: replicas: 2 selector: name: tomcat template: metadata: name: tomcat labels: name: tomcat spec: containers: - name: tomcat image: tomcat ports: - containerPort: 8080创建该RC：我们可以通过Node IP + Container Port在Kubernetes集群中访问Tomcat：由于Pod是Kubernetes集群范围内的虚拟概念，集群外的客户端无法通过Pod的IP和端口访问，我们可以将Pod的端口号映射到宿主机，以使客户端应用能够通过物理机访问容器应用，修改刚刚的tomcat-rc.yml，添加hostPort：1234567891011121314151617181920apiVersion: v1kind: ReplicationControllermetadata: name: tomcat-rcspec: replicas: 2 selector: name: tomcat template: metadata: name: tomcat labels: name: tomcat spec: containers: - name: tomcat image: tomcat ports: - containerPort: 8080 hostPort: 8081 # 新增更新该RC：可以看到tomcat pod被分配到了node1和node2上，所以我们可以在宿主机外使用或者访问tomcat：但是我们知道，Pod的IP地址是不可靠的，例如当Pod所在的Node发生故障时，Pod将被Kubernetes重新调度到另一个Node，Pod的IP地址将发生变化。所以我们可以定义一个tomcat pod的统一访问入口，这就是Service的作用。创建Service有两种方式：1.kubectl expose命令来创建Service1kubectl expose rc tomcat-rc现在我们就可以通过Service的clusterIP + Port来访问了：Service地址10.1.187.222:8080均衡的负载到了两个tomcat pod上（10.244.1.19:8080和10.244.4.13:8080）2.通过配置文件创建定义一个tomcat-service.yml：12345678910apiVersion: v1kind: Servicemetadata: name: tomcat-servicespec: ports: - port: 8081 # service端口 targetPort: 8080 # 目标端口 selector: name: tomcat # 选择器，选择name=tomcat的pod创建该Service：同样，Service默认是不能外部访问的，如果想让外部能够访问到tomcat service，我们也需要将Service的端口映射到物理机，修改上面的tomcat-service.yml：123456789101112apiVersion: v1kind: Servicemetadata: name: tomcat-servicespec: type: NodePort # 新增 ports: - port: 8081 targetPort: 8080 nodePort: 30000 # 新增 selector: name: tomcat上面配置通过设置nodePort（范围30000-32767）映射到物理机，同时设置Service的类型为NodePort，创建该Service：现在我们就可以通过宿主机的IP+30000访问tomcat了：负载均衡策略Kubernetes Service提供了两种负载分发策略：RoundRobin和SessionAffinity：RoundRobin：轮询模式（默认），即轮询将请求转发到后端的各个Pod上。SessionAffinity：基于客户端IP地址进行会话保持的模式，即第1次将某个客户端发起的请求转发到后端的某个Pod上，之后从相同的客户端发起的请求都将被转发到后端相同的Pod上。可以通过设置service.spec.sessionAffinity=ClientIP来启用SessionAffinity策略：12345678910111213apiVersion: v1kind: Servicemetadata: name: tomcat-servicespec: type: NodePort sessionAffinity: ClientIP # 采用SessionAffinity策略 ports: - port: 8081 targetPort: 8080 nodePort: 30000 selector: name: tomcatHeadless ServiceHeadless Service不提供ClusterIP，仅通过Label Selector将后端的Pod列表返回给调用的客户端。创建tomcat-headless-service.yml：12345678910apiVersion: v1kind: Servicemetadata: name: tomcat-headless-servicespec: ports: - port: 8080 clusterIP: None # 设置clusterIP为None，表示headless service selector: name: tomcat创建该headless service：《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Pod扩容与缩容]]></title>
    <url>%2FKubernetes-Pod-Expansion-Contraction.html</url>
    <content type="text"><![CDATA[针对不同时期流量的大小我们可以给Pod扩缩容，Kubernetes支持通过kubectl命令手动扩缩容，也支持通过HPA自动横向扩缩容。手动扩缩容现有如下deployment配置（nginx-deployment.yml）：1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deploymentspec: selector: matchLabels: name: nginx replicas: 3 template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx:1.7.9 imagePullPolicy: IfNotPresent ports: - containerPort: 80创建该Deployment：有3个nginx实例，现在用下面这条命令将nginx实例扩充到5个：1kubectl scale deployment nginx-deployment --replicas 5缩容：1kubectl scale deployment nginx-deployment --replicas 1HPAHPA能够根据特定指标完成目标Pod的自动扩缩容。创建一个与上面nginx-deployment相对应的HPA（nginx-deployment-hpa.yml）：123456789101112apiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata: name: nginx-deployment-hpa-v1spec: maxReplicas: 6 minReplicas: 2 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: nginx-deployment targetCPUUtilizationPercentage: 50主要参数如下：scaleTargetRef：目标作用对象，可以是Deployment、ReplicationController或ReplicaSet。targetCPUUtilizationPercentage：期望每个Pod的CPU使用率都为50%，该使用率基于Pod设置的CPU Request值进行计算，例如该值为200m，那么系统将维持Pod的实际CPU使用值为100m。minReplicas和maxReplicas：Pod副本数量的最小值和最大值，系统将在这个范围内进行自动扩缩容操作，并维持每个Pod的CPU使用率为50%。使用HPA，需要预先安装Metrics Server，用于采集Pod的CPU使用率。《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Pod升级与回滚]]></title>
    <url>%2FKubernetes-Pod-Upgrade-And-Rollback.html</url>
    <content type="text"><![CDATA[当集群中的某个服务需要升级时，我们需要停止目前与该服务相关的所有Pod，然后下载新版本镜像并创建新的Pod。如果集群规模比较大，则这个工作变成了一个挑战，而且先全部停止然后逐步升级的方式会导致较长时间的服务不可用。Kubernetes提供了滚动升级功能来解决上述问题。如果在更新过程中发生了错误，则还可以通过回滚操作恢复Pod的版本。Deployment升级现有如下deployment定义（nginx-deployment.yml）：1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deploymentspec: selector: matchLabels: name: nginx replicas: 3 template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx:1.7.9 imagePullPolicy: IfNotPresent ports: - containerPort: 80创建该deployment：通过kubectl命令将nginx的版本更新到1.9.1：1kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1查看滚动升级的过程：查看Pod，会发现名称已经改变了：上述滚动升级的过程可以用下图表示：查看Deployment nginx-deployment的详细事件信息可以证明这一点：1kubectl describe deployments/nginx-deployment查看rs：默认的升级策略为RollingUpdate（滚动更新），Kubernetes还支持Recreate（重建）策略：Recreate：先杀掉所有正在运行的Pod，然后创建新的Pod。RollingUpdate：以滚动更新的方式来逐个更新Pod。同时，可以通过设置spec.strategy.rollingUpdate下的两个参数（maxUnavailable和maxSurge）来控制滚动更新的过程。RollingUpdate的两个参数含义如下：maxUnavailable：用于指定Deployment在更新过程中不可用状态的Pod数量的上限。该maxUnavailable的数值可以是绝对值（例如1）或Pod期望的副本数的百分比（例如10%）。maxSurge：用于指定在Deployment更新Pod的过程中Pod总数超过Pod期望副本数部分的最大值。该maxSurge的数值可以是绝对值（例如5）或Pod期望副本数的百分比（例如10%）。此外，除了使用kubectl命令升级外，我们也可以直接通过修改deployment.yml的方式来完成。Deployment回滚如果升级后效果不满意的话，我们也可以将Deployment回滚到升级之前，使用下面这条命令查看滚动升级的历史：1kubectl rollout history deployment/nginx-deploymentREVISION为升级的历史版本，我们只完成了nginx从1.7.9升级到1.9.1的过程，所以REVISION 1表示nginx为1.7.9的版本，REVISION 2表示nginx为1.9.1的版本。因为我们在创建deployment的时候没有加上--record=true参数，所以CHANGE-CACSE列是空的。需要查看特定版本的详细信息，则可以加上–revision=参数：要将nginx回退到1.7.9版本，我们可以将REVISION指定为1：1kubectl rollout undo deployment/nginx-deployment --to-revision=1暂停与恢复因为Deployment配置一旦修改就会触发升级操作，所以当修改的地方较多的时候就会频繁触发升级。我们可以先暂停升级操作，当所有配置都修改好后再恢复升级。暂停：1kubectl rollout pause deployment/nginx-deployment暂停后，对nginx-deployment的修改不会触发升级。修改好后，恢复升级：1kubectl rollout resume deployment/nginx-deployment其他Pod管理对象升级策略DaemonSetDaemonSet的升级策略包括两种：OnDelete和RollingUpdate：OnDelete（默认）：在创建好新的DaemonSet配置之后，新的Pod并不会被自动创建，直到用户手动删除旧版本的Pod，才触发新建操作。RollingUpdate：和前面介绍的一致，不过不支持rollout，只能通过将配置改回去来实现。StatefulSet支持Recreate、OnDelete和RollingUpdate。《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Pod管理对象与调度策略]]></title>
    <url>%2FKubernetes-Pod-Mananger.html</url>
    <content type="text"><![CDATA[在前面的学习中我们了解到，在Kubernetes中，Pod管理对象主要有RC(RS)、Deployment、StatefulSet、DaemonSet和Job（CronJob）等。其中RC(RS)和Deployment的用法已经大致了解，这里主要记录下StatefulSet、DaemonSet和Job（CronJob）的用法。默认情况下，Pod管理对象在创建Pod的时候是根据系统自动调度算法来完成部署的，我们可以设置调度策略来实现Pod的精准调度。Pod调度策略NodeSelector我们可以该某个节点Node设置标签，然后通过NodeSelector让Pod调度到该节点上。前面搭建的Kubernetes集群有两个worker节点node1和node2，我们给node2打个标签：1kubectl label nodes node2 tier=frontend接着定义一个RC配置（node-select-pod.yml）：1234567891011121314151617181920apiVersion: v1kind: ReplicationControllermetadata: name: test-rcspec: replicas: 1 selector: name: nginx template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 nodeSelector: tier: frontend创建该RC，观察Pod最终调度的节点：可以看到nginx pod已经成功调度到了node2节点上。Kubernetes会给每个node贴上一些默认的标签，通过kubectl get node node1 -o yaml可以看到这些默认的标签：12345beta.kubernetes.io/arch: amd64beta.kubernetes.io/os: linuxkubernetes.io/arch: amd64kubernetes.io/hostname: node1kubernetes.io/os: linux这些默认的标签在下面这些调度策略中也是蛮常用的。NodeAffinityAffinity[əˈfɪnəti]：亲和力，喜好。NodeAffinity为Node亲和力调度，主要有两个规则（名称有点长，快18cm了吧）:RequiredDuringSchedulingIgnoredDuringExecution：必须满足指定的规则才可以调度Pod，硬规则。PreferredDuringSchedulingIgnoredDuringExecution：软规则，最好满足所列出的条件才调度Pod。IgnoredDuringExecution的意思是，如果一个Pod已经调度到某个节点上了，然后这个节点的标签发生了改变，那么不影响已经调度好的Pod，ignore。定义一个配置文件（node-affinity.yml），用于演示NodeAffinity：1234567891011121314151617181920212223242526272829303132333435apiVersion: v1kind: ReplicationControllermetadata: name: test-rcspec: replicas: 1 selector: name: nginx template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: beta.kubernetes.io/arch operator: In values: - amd64 preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: disk-type operator: In values: - ssd上面配置使得RC在调度nginx pod的时候需要满足：节点具有beta.kubernetes.io/arch=amd64标签，如果具有disk-type=ssd标签就更好了，换句话说就是希望nginx pod调度在cpu架构为amd，磁盘为ssd的节点上。上面配置中，操作符operator除了可以使用In外，还可以使用NotIn、Exists、DoesNotExist、Gt、Lt。NodeAffinity规则设置需要注意的几个点：如果nodeAffinity指定了多个nodeSelectorTerms，那么其中一个能够匹配成功即可；如果在nodeSelectorTerms中有多个matchExpressions，则一个节点必须满足所有matchExpressions才能运行该Pod。运行上面这个配置：可以看到，因为node1和node2都具有beta.kubernetes.io/arch=amd64标签，而没有disk-type=ssd标签，所以nginx pod有可能被调度到node1也有可能被调度到node2。我们给node1添加disk-type=ssd标签，重新运行上面的配置文件：可以看到，nginx pod被调度到了node1上。PodAffinityPodAffinity指的是Pod亲和力调度股则，比如某些节点已经存在一些Pod了，新的Pod在调度的时候希望和指定Pod在一台节点上，亦或有意避开和指定Pod在一台节点上，这时候就可以用PodAffinity实现。NodeAffinity规则设置也是通过requiredDuringSchedulingIgnoredDuringExecution和PreferredDuringSchedulingIgnoredDuringExecution实现的。此外，NodeAffinity还需要设置topology（拓扑规则），意为表达节点所属的topology范围：kubernetes.io/hostname（节点所处的服务器）failure-domain.beta.kubernetes.io/zone（节点所处的服务器云盘分区）failure-domain.beta.kubernetes.io/region（节点所处的服务器云盘所在的地区）要演示PodAffinity的使用，需要先创建一个参照Pod，创建一个参照Pod的配置文件（flag-pod.yml）:12345678910111213apiVersion: v1kind: Podmetadata: name: flag-pod labels: tier: frontend app: flag-nginxspec: containers: - name: flag-nginx image: nginx ports: - containerPort: 8081这个Pod具有tier=frontend和app=flag-nginx标签。创建这个参照Pod：参照pod运行在了node1节点上。创建好后，接着定义一个新的配置类（pod-affinity.yml）：1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: pod-affinityspec: containers: - name: nginx image: nginx ports: - containerPort: 80 affinity: podAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: tier operator: In values: - frontend topologyKey: kubernetes.io/hostname上述配置要求，nginx pod需要和标签包含tier=frontend的Pod分配在同一个Node上（topologyKey: kubernetes.io/hostname），创建该Pod，观察它被调度到哪个节点上了：podAntiAffinity和podAffinity刚好相反，举个例子，创建一个新的配置类（pod-affinity-two.yml）：1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: pod-affinity-twospec: containers: - name: nginx image: nginx ports: - containerPort: 80 affinity: podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: - flag-nginx topologyKey: kubernetes.io/hostname上面配置希望nginx pod不和app=flag-nginx的Pod在同一个节点。创建该Pod，观察它被调度到哪个节点上了：可以看到，它和flag-nginx处于不同的节点，位于node2。Taints &amp; TolerationsTaints用于给节点添加污点，而Tolerations用于定义Pod对节点污点的容忍度。在Node上设置一个或多个Taint之后，除非Pod明确声明能够容忍这些污点，否则无法在这些Node上运行。Toleration是Pod的属性，让Pod能够（注意，只是能够，而非必须）运行在标注了Taint的Node上。给节点设置污点的语法为：1kubectl taint nodes [nodeName] key=value:rule其中rule的取值有：NoScheudle：不调度；PreferNoSchedule：最好不要调度；NoExecute：不运行；PreferNoExecute：最好不运行。NoSchedule和NoExecute区别：NoSchedule不调度，如果是在调度后设置的污点，并且Pod没有容忍该污点，也能继续执行NoExecute不执行，如果是在调度后设置的污点，并且Pod没有容忍该污点，则会被驱逐。可以设置驱逐时间tolerationSeconds: xx。我们给node1节点设置一个污点：1kubectl taint nodes node1 aa=bb:NoSchedule然后新建一个Pod配置类（pod-taint-test.yml）：123456789101112131415apiVersion: v1kind: Podmetadata: name: pod-taintspec: containers: - name: nginx image: nginx ports: - containerPort: 80 tolerations: - key: "aa" operator: "Equal" value: "bb" effect: "NoSchedule"Pod的Toleration声明中的key和effect需要与Taint的设置保持一致，并且满足以下条件之一：operator的值是Exists（无须指定value），如：12345...... tolerations: - key: "aa" operator: "Exists" effect: "NoSchedule"operator的值是Equal并且value相等。如果不指定operator，则默认值为Equal。另外，有如下两个特例：空的key配合Exists操作符能够匹配所有的键和值；空的effect匹配所有的effect。回到pod-taint-test.yml，该配置文件定义nginx pod可以容忍aa=bb:NoSchedule这个污点，所以它有可能会被调度到node1上。创建该Pod，观察：这时候在nginx pod所运行的节点node1上新增一个污点：1kubectl taint nodes node1 cc=dd:NoExecute观察nginx pod情况：可以看到它被驱逐了，已经没有正在运行的pod了。Pod Priority Preemption我们可以给Pod指定优先级，优先级可以通过PriorityClass对象创建，比如创建一个优先级为10000的PriorityClass：1234567apiVersion: scheduling.k8s.io/v1kind: PriorityClassmetadata: name: hign-priorityvalue: 10000globalDefault: falsedescription: "10000优先级"上述文件定义了一个名为high-priority的优先级类别，优先级为10000，数字越大，优先越高。超过一亿的数字被系统保留，用于指派给系统组件。优先级创建后，可以在Pod定义中引用该优先级：12345678...spec: containers: - name: nginx image: nginx ports: - containerPort: 80 priorityClassName: hign-priorityPod管理对象JobJob是一种特殊的Pod管理对象，是一种一次性Pod运行任务，任务结束后，Pod的生命周期也就结束了。定义一个Job配置类（job.yml）：123456789101112apiVersion: batch/v1kind: Jobmetadata: name: job-exspec: template: spec: containers: - name: job image: busybox command: ["echo", "hello job"] restartPolicy: NeverJob的重启策略restartPolicy只支持Never和OnFailure。创建这个Job：查看Job状态：COMPLETIONS 1/1表示总共需要执行1个任务，共执行完1个任务。查看对应Pod的状态：状态为Completed。查看Job日志：Job还可以设置并发数量和总Job数，修改上面的job.yml：1234567891011121314apiVersion: batch/v1kind: Jobmetadata: name: job-exspec: parallelism: 2 # 并发数2 completions: 6 # 总的Job数量 template: spec: containers: - name: job image: busybox command: ["echo", "hello job"] restartPolicy: Never运行该Job： 查看Pod：CronJobCronJob顾名思义就是支持Cron表达式的Job，不过Kubernetes的Cron表达式和传统的Cron表达式不太一样，不支持到秒级。具体规则如下：1Minutes Hours DayofMonth Month DayofWeek YearMinutes：可出现, - * / 这4个字符，有效范围为0～59的整数。Hours：可出现, - * /这4个字符， 有效范围为0～23的整数。DayofMonth：可出现, - * / ? L W C 这8个字符，有效范围为0～31的整数。Month：可出现, - * /这4个字符，有效范围为1～12的整数或JAN～DEC。DayofWeek：可出现, - * / ? L C ＃这8个字符，有效范围为1～7的整数或SUN～SAT。1表示星期天，2表示星期一，以此类推。上面特殊字符的含义如下：*：表示匹配该域的任意值，假如在Minutes域使用*，则表示每分钟都会触发事件。/：表示从起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域设置为5/20，则意味着第1次触发在第5min时，接下来每20min触发一次，将在第25min、第45min等时刻分别触发。定义一个CronJob的配置类（cron-job.yml）：123456789101112131415apiVersion: batch/v1beta1kind: CronJobmetadata: name: cron-job-exspec: schedule: "*/1 * * * *" jobTemplate: spec: template: spec: containers: - name: hello image: busybox command: ["sh", "-c", "date;echo hello cronJob"] restartPolicy: Never上面的定时任务每分钟执行一次。创建该CronJob：过个两三分钟查看运行情况：DaemonSetDaemonSet适用于在每个Node都需要运行一个Pod的时候使用，比如：每一个Node上运行一个日志采集、性能监控的Pod。比如我们现在需要在每个节点上都部署一个node-exporter来采集节点信息，可以通过DaemonSet来实现。定义一个DaemonSet配置文件（daemonset.yml）：123456789101112131415161718apiVersion: apps/v1kind: DaemonSetmetadata: name: node-exporter-dspec: selector: matchLabels: name: node-exporter template: metadata: labels: name: node-exporter spec: containers: - name: node-exporter image: prom/node-exporter ports: - containerPort: 9100创建该DaemonSet之前先删除上面在node1节点上创建的污点：12kubectl taint nodes node1 aa:NoSchedule-kubectl taint nodes node1 cc:NoExecute-创建该DaemonSet，然后观察Pod信息，看是否每个节点都部署了一个实例：StatefulSet系统学习PV/PVC后再深入。《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes Pod基础]]></title>
    <url>%2FKubernetes-Pod-Basic.html</url>
    <content type="text"><![CDATA[Pod是Kubernetes的最小调度单位，包含一个或者多个容器（比如Docker容器），容器间共享网络和存储。这节主要记录什么是静态Pod，Pod容器如何共享存储，如何使用ConfigMap管理Pod配置，如何使用Downward API获取Pod信息等。静态Pod静态Pod是由kubelet创建并管理的特殊的Pod，无法和Pod管理对象关联，并且不能通过API Server关联。创建静态Pod有配置文件方式和HTTP方式：配置文件方式在搭建Kubernetes集群的时候，从启动Master节点的日志可以看出，静态Pod的目录位于/etc/kubernetes/manifests：在该目录下创建静态Pod文件：12cd /etc/kubernetes/manifestsvim static-pod.yaml内容如下所示：12345678910111213apiVersion: v1kind: Podmetadata: name: static-pod labels: name: static-podspec: containers: - name: static-nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 80过了一会查看Pod：于静态Pod无法通过API Server直接管理，所以在Master上尝试删除这个Pod时，会使其变成Pending状态，且不会被删除。删除该Pod的操作只能是到其所在Node上将其定义文件static-pod.yaml从/etc/kubernetes/manifests目录下删除：HTTP方式过设置kubelet的启动参数--manifest-url，kubelet将会定期从该URL地址下载Pod的定义文件，并以.yaml或.json文件的格式进行解析，然后创建Pod。Pod容器共享Volume同一个Pod的多个容器间可以共享Pod级别的Volume，举个例子：1vim pod-volume.yml内容如下所示：123456789101112131415161718192021222324apiVersion: v1kind: Podmetadata: name: pod-volumespec: containers: - name: tomcat image: tomcat imagePullPolicy: IfNotPresent ports: - containerPort: 8080 volumeMounts: - mountPath: /usr/local/tomcat/logs name: logs - name: busybox image: busybox imagePullPolicy: IfNotPresent command: ["sh", "-c", "tail -f /logs/catalina*.log"] volumeMounts: - mountPath: /logs name: logs volumes: - name: logs emptyDir: &#123;&#125;上面Pod定义中，创建了一个Pod级别的Volume，名称为logs，类型为emptyDir。这个Volume同时挂载到了tomcat的/usr/local/tomcat/logs目录下，也挂载到了busybox的/logs目录下。创建该Pod：1kubectl create -f pod-volume.yml这里的tomcat镜像比较大，大概有500MB左右，所以在创建之前，最好在Kubernetes集群的每个节点中配置Docker镜像加速地址。当pod-volume状态为ready后，查看busybox的日志：该日志为tomcat的启动日志，说明上面挂载的Volume生效了，可以通过查看tomcat/usr/local/tomcat/logs目录下和busybox/logs目录下的内容来证明这一点：ConfigMapConfigMap以一个或多个key:value的形式保存在Kubernetes系统中供应用使用，既可以用于表示一个变量的值（例如version=v1），也可以用于表示一个完整配置文件的内容（例如server.xml=&lt;?xml...&gt;...）。创建ConfigMap创建ConfigMap主要有两种方式：1.通过yml文件创建创建simple-cm.yml文件，内容如下所示：1234567apiVersion: v1kind: ConfigMapmetadata: name: simple-cmdata: version: v1 release: stable该ConfigMap仅包含两个简单的值version和releases。创建该ConfigMap：1kubectl create -f simple-cm.yml查看该ConfigMap：在定义ConfigMap的时候，value除了可以使用简单的值外，还可以是整个配置文件的内容。创建file-cm.yml，内容如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758apiVersion: v1kind: ConfigMapmetadata: name: file-cmdata: serverXml: | &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener"/&gt; &lt;Listener SSLEngine="on" className="org.apache.catalina.core.AprLifecycleListener"/&gt; &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener"/&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"/&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener"/&gt; &lt;GlobalNamingResources&gt; &lt;Resource auth="Container" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" name="UserDatabase" pathname="conf/tomcat-users.xml" type="org.apache.catalina.UserDatabase"/&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443"/&gt; &lt;Engine defaultHost="localhost" name="Catalina"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host appBase="webapps" autoDeploy="true" name="localhost" unpackWARs="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" prefix="localhost_access_log" suffix=".txt"/&gt; &lt;Context docBase="D:\Code\apache-tomcat-8.5.32\webapps\tj_certification" path="/tj_certification" reloadable="true" source="org.eclipse.jst.jee.server:tj_certification"/&gt;&lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; serverProperties: "1catalina.org.apache.juli.AsyncFileHandler.level = FINE 1catalina.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs 1catalina.org.apache.juli.AsyncFileHandler.prefix = catalina. 2localhost.org.apache.juli.AsyncFileHandler.level = FINE 2localhost.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs 2localhost.org.apache.juli.AsyncFileHandler.prefix = localhost. 3manager.org.apache.juli.AsyncFileHandler.level = FINE 3manager.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs 3manager.org.apache.juli.AsyncFileHandler.prefix = manager. 4host-manager.org.apache.juli.AsyncFileHandler.level = FINE 4host-manager.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs 4host-manager.org.apache.juli.AsyncFileHandler.prefix = host-manager. java.util.logging.ConsoleHandler.level = FINE java.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatter org.apache.catalina.core.ContainerBase.[Catalina].[localhost].level = INFO org.apache.catalina.core.ContainerBase.[Catalina].[localhost].handlers = 2localhost.org.apache.juli.AsyncFileHandler org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].level = INFO org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager].handlers = 3manager.org.apache.juli.AsyncFileHandler org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].level = INFO org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/host-manager].handlers = 4host-manager.org.apache.juli.AsyncFileHandler"创建该ConfigMap：2.直接通过Kubectl命令创建通过kubectl命令创建ConfigMap主要有以下三种用法：通过–from-file参数从文件中进行创建，可以指定key的名称，也可以在一个命令行中创建包含多个key的ConfigMap，语法为：1kubectl cerate configmap [NAME] --from-file=[key=]source --from-file=[key=]source通过–from-file参数从目录中进行创建，该目录下的每个配置文件名都被设置为key，文件的内容被设置为value，语法为：1kubectl cerate configmap [NAME] --from-file=config-file-dir使用–from-literal时会从文本中进行创建，直接将指定的key#=value#创建为ConfigMap的内容，语法为：1kubectl cerate configmap [NAME] --from-literal=key1=value1 --from-literal=key2=value2比如使用kubectl命令创建一个和simple-cm效果一样的ConfigMap：使用kubectl命令创建一个和file-cm效果一样的ConfigMap：首先在当前目录下准备好两个配置文件server.xml和server.properties：然后使用kubectl命令创建：Pod容器使用ConfigMapPod的容器要使用ConfigMap主要有两种方式：通过环境变量获取ConfigMap中的内容;通过Volume挂载的方式将ConfigMap中的内容挂载为容器内部的文件或目录。通过环境变量的方式创建一个Pod配置（simple-cm-pod.yml）：1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: simple-cm-podspec: containers: - name: busybox image: busybox command: ["sh", "-c", "env | grep ENV"] # 打印名称包含ENV的环境变量 env: - name: ENVVERSION # 定义环境变量名称 valueFrom: # 值来自... configMapKeyRef: # ConfigMap键的引用 key: version # ConfigMap的key name: simple-cm # ConfigMap的名称 - name: ENVRELEASE valueFrom: configMapKeyRef: key: release name: simple-cm创建该Pod，并查看日志：可以看到，值已经成功从ConfigMap里去到了。如果要引用某个ConfigMap的所有内容，可以使用下面这种方式。定义一个Pod配置（simple-cm-pod-all.uyml）：123456789101112apiVersion: v1kind: Podmetadata: name: simple-cm-pod-allspec: containers: - name: busybox image: busybox command: ["sh", "-c", "env"] envFrom: - configMapRef: name: simple-cm创建该Pod，并查看日志：通过Volume挂载的方式创建一个Pod配置（file-cm-pod.yml）：12345678910111213141516171819202122apiVersion: v1kind: Podmetadata: name: file-cm-podspec: containers: - name: tomcat image: tomcat ports: - containerPort: 8080 volumeMounts: - mountPath: /configs # 容器挂载目录为/configs name: config-vm # 引用下面定义的这个Volume volumes: - name: config-vm # volume名称为config-vm configMap: # 通过ConfigMap获取 name: file-cm # 引用名称为file-cm的ConfigMap items: - key: serverXml # ConfigMap里配置的key path: server.xml # 值使用server.xml文件进行挂载 - key: serverProperties path: server.properties创建该Pod，并进入到容器内部观察/configs目录下文件内容：可以看到名称为file-cm的ConfigMap内容已经成功挂载到了tomcat容器内部。如果在引用ConfigMap时不指定items，则使用volumeMount方式在容器内的目录下为每个item都生成一个文件名为key的文件。在Pod对ConfigMap进行挂载（volumeMount）操作时，在容器内部只能挂载为“目录”，无法挂载为“文件”。在挂载到容器内部后，在目录下将包含ConfigMap定义的每个item，如果在该目录下原来还有其他文件，则容器内的该目录将被挂载的ConfigMap覆盖。Downward APIDownward API用于将Pod相关信息注入到容器内部，主要有环境变量和Volume挂载两种方式。环境变量创建一个Pod配置（dapi-pod.yml）：12345678910111213141516171819202122apiVersion: v1kind: Podmetadata: name: dapi-podspec: containers: - name: busybox image: busybox command: ["sh", "-c", "env | grep MY_POD"] env: - name: MY_POD_NAME valueFrom: fieldRef: fieldPath: metadata.name # 通过downward api获取当前pod名称 - name: MY_POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace # 通过downward api获取当前pod namespace - name: MY_POD_IP valueFrom: fieldRef: fieldPath: status.podIP # 通过downward api获取当前pod IP创建该Pod，并查看日志：通过环境变量的方式还可以将容器的requests和limits信息注入到容器的环境变量中，创建一个Pod配置（dapi-pod-container-vars.yml）：1234567891011121314151617181920212223242526272829303132333435363738394041424344apiVersion: v1kind: Podmetadata: name: dapi-pod-container-varsspec: containers: - name: busybox image: busybox command: ["sh", "-c"] args: - while true;do echo -en '\n'; printenv MY_CPU_REQUEST MY_CPU_LIMIT; printenv MY_MEM_REQUEST MY_MEM_LIMIT; sleep 3600; done; resources: requests: memory: "32Mi" cpu: "125m" limits: memory: "64Mi" cpu: "250m" env: - name: MY_CPU_REQUEST valueFrom: resourceFieldRef: resource: requests.cpu containerName: busybox - name: MY_CPU_LIMIT valueFrom: resourceFieldRef: resource: limits.cpu containerName: busybox - name: MY_MEM_REQUEST valueFrom: resourceFieldRef: resource: request.memory containerName: busybox - name: MY_MEM_LIMIT valueFrom: resourceFieldRef: resource: limits.memory containerName: busybox创建该Pod并观察日志：通过Volume挂载我们可以通过Downward API将Pod的Label，Annotation等信息挂载到容器内部文件中，新建一个Pod配置（dapi-pod-volumes.yml）：1234567891011121314151617181920212223242526272829apiVersion: v1kind: Podmetadata: name: dapi-pod-volume labels: tier: frontend release: canary environment: dev annotations: builder: mrbird blog: https://mrbird.ccspec: containers: - name: busybox image: busybox command: ["sh", "-c", "sleep 36000"] volumeMounts: - mountPath: /podinfo # 挂载路径 name: pod-info volumes: - name: pod-info downwardAPI: # 通过downward api获取pod labels和annations信息 items: - path: "labels" # 挂载文件名称 fieldRef: fieldPath: metadata.labels # 挂载内容 - path: "annotation" fieldRef: fieldPath: metadata.annotations创建该Pod，并进入到容器/podinfo目录观察结果：Pod生命周期阶段描述PendingPod 已被 Kubernetes 接受，但尚未创建一个或多个容器镜像。这包括被调度之前的时间以及通过网络下载镜像所花费的时间，执行需要一段时间。RunningPod 已经被绑定到了一个节点，所有容器已被创建。至少一个容器正在运行，或者正在启动或重新启动。Succeeded所有容器成功终止，也不会重启。Failed所有容器终止，至少有一个容器以失败方式终止。也就是说，这个容器要么已非 0 状态退出，要么被系统终止。Unknown由于一些原因，Pod 的状态无法获取，通常是与 Pod 通信时出错导致的。三种重启策略：Always：当容器失效时，由kubelet自动重启该容器；OnFailure：当容器终止运行且退出码不为0时，由kubelet自动重启该容器；Never：不论容器运行状态如何，kubelet都不会重启该容器。结合Pod的状态和重启策略，以下为一些常见的状态转换场景：Pod包含的容器数Pod当前的状态发生事件Pod的结果状态RestarPolicy=AlwaysRestartPolicy=OnFailureRestartPolicy=Never包含1个容器Running容器成功退出RunningSucceededSucceeded包含1个容器Running容器失败退出RunningRunningFailed包含两个容器Running1个容器失败退出RunningRunningRunning包含两个容器Running容器被OOM杀掉RunningRunningFailed《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes基础]]></title>
    <url>%2FKubernetes-Basic.html</url>
    <content type="text"><![CDATA[上一节我们已经成功搭建了Kubernetes集群，Kubernetes包含了大量的概念和术语，比如Master、Node、Pod、Replication Controller、Service等等，在深入学习Kubernetes之前，有必要捋清Kubernetes架构设计和这些术语的含义。Kubernetes架构Kubernetes基本架构如下图所示：由上图我们可以看出，Kubernetes集群节点可分为Master和Node：Master：指的是集群中的控制节点，负责管理和控制整个集群。基本上我们对Kubernetes集群的操作都是在Master节点上完成的；Node：除了Master外，Kubernetes集群中其他节点称为Node。每个Node都将负责运行Master指派的Docker容器，当某个Node宕机后，这些工作会被Master转移到别的Node上。Master节点上主要包含了以下这些关接的进程:API Server：提供了HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程；Controller Manager：负责维护集群的状态，比如故障检测，扩缩容，滚动更新等等；Scheduler：负责资源的调度，按照预定的策略把pod调度到指定的node节点；etcd：存储Kubernetes集群信息。Node节点上主要包含了以下这些关接的进程:kubelet：负责Pod对应的容器的创建、启停等任务；kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件；docker：Docker引擎，负责本机的容器创建和管理工作；pod：Pod是Kubernetes中能够创建和部署的最小单元，是Kubernetes集群中的一个应用实例。Pod包含了一个“根容器”Pause和多个Docker容器；Kubernetes节点间的网络通信通过网络插件实现，比如Flannel，Calico等。Pod管理对象Pod管理对象指的是Kubernetes中可以用于创建和管理Pod的组件，比如RC(RS)，Deployment，StableSet等等。在了解这些组件前，先来看看Pod的组成：Pod包含一个Pause容器和多个Docker容器，Pause容器用于管理这些Docker容器。Pod可以通过yaml文件来创建，下面举个简单的例子:12345678910111213apiVersion: v1kind: Pod # kind为pod表明这是一个pod定义metadata: name: nginx-pod # pod名称为nginx-pod labels: # 定义标签信息（label） name: nginx spec: containers: - name: nginx # 容器名称 image: nginx # 基于nginx镜像构建 imagePullPolicy: IfNotPresent # 镜像拉取规则，不存在则远程拉取 ports: - containerPort: 80 # 端口每个Pod都包含一个唯一的IP地址，称为Pod IP，Kubernetes集群内的任意两个Pod之间都能正常通信。Pod IP加上上面定义的80端口，组成了一个Endpoint，代表此Pod里的一个服务进程的对外通信地址。Pod的相关内容存储在Volume中，Pod的相关运行记录可以通过Event查看：在定义Pod的时候我们也可以指定资源资源限额，资源主要包括CPU和Memory：在Kubernetes中，1m表示千分之一CPU，即1000m表示一个CPU；常用单位有KiB、MiB和GiB等，是二进制表示的字节单位，1 KiB（KibiByte）= 2^10 Bytes = 1024 Bytes = 8192 Bits。在Kubernetes里，一个计算资源进行配额限定时需要设定以下两个参数：Requests：该资源的最小申请量，系统必须满足要求；Limits：该资源最大允许使用的量，不能被突破，当容器试图使用超过这个量的资源时，可能会被Kubernetes“杀掉”并重启。比如修改上面的Pod配置文件，定义资源配额：1234567891011121314151617181920apiVersion: v1kind: Pod metadata: name: nginx-pod labels: name: nginxspec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 80 resources: requests: memory: "64Mi" # 至少需要64MiB内存 cpu: "200m" # 至少需要0.2个CPU limits: memory: "128Mi" # 内存消耗不能多于128MiB cpu: "500m" # CPU消耗不能多于0.5除了直接使用Pod配置文件来创建Pod外，更为常用的是使用Pod管理对象RC(RS)、Deployment等创建和管理Pod。RC(RS)RC全称Replication Controller（副本控制器）,用于控制任意时刻指定Pod的数量都符合预期值。RC配置文件一般包含以下三个部分：期望的Pod副本数量；用于筛选Pod的Label Selector；创建Pod的模板（当数量少于预期的时候，用这个模板创建Pod）。举个RC yaml的例子：12345678910111213141516171819apiVersion: v1kind: ReplicationController # 表示RCmetadata: name: nginx-rc # RC控制器名称为nginx-rcspec: replicas: 3 # 期望Pod的副本数量为3 selector: name: nginx # Label筛选器，筛选出Label包含（name=nginx）的Pod template: # Pod创建模板，格式基本和我们上面定义的Pod yaml一致 metadata: labels: name: nginx spec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 80通过这个RC，我们可以实现：在Kubernetes集群中，任意时刻都存在3个运行着Nginx容器的Pod，即通过这个RC我们创建了一个Nginx数量为3的Nginx集群（其中一种可能性）：在Kubernetes的发展中，RC升级为了Replica Set，俗称RS，语法大致和RC一致。RS和RC最大的区别在于：RS拥有更为🐂🍺的Pod筛选器。比如：12345678910111213apiVersion: apps/v1kind: ReplicaSetmetadata: name: frontendspec: replicas: 2 selector: matchLabels: tier: frontend matchExpressions: - &#123;key: release, operator: In, values: [stable, snapshot]&#125; template: ...上面的RS筛选Pod规则为：筛选标签包含tier为frontend，并且release的值为stable或者snapshot的Pod。总之，RC(RS)的作用为:Pod的创建及数量控制；通过改变RC里的Pod副本数量，可以实现Pod的扩容或缩容；通过改变RC里Pod模板中的镜像版本，可以实现Pod的滚动升级。DeploymentDeployment可以看成是RS的升级版组件，内部使用RS管理Pod，和RS相比最大的不同在于Deployment可以随时查看Pod的部署状态。Deployment的yaml配置和RS差不多，举个Deployment yaml的例子(nginx-deployment.yml):1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deploymentspec: selector: matchLabels: name: nginx replicas: 3 template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 80除了kind，其他都和RS差不多。在Kubernetes集群中创建该Deployment：READY：集群中准备就绪的Pod数量；UP-TO-DATE：最新版本的Pod的副本数量，用于指示在滚动升级的过程中，有多少个Pod副本已经成功升级；AVAILABLE：当前集群中可用的Pod副本数量，即集群中当前存活的Pod数量。查看RS和Pod：可以看到它们的关系为deployment -&gt; rs -&gt; pods：StatefulSetStatefulSet（有状态集合）可以看成是Deployment的一个变种，适合用于构建MySQL集群、MongoDB集群等有状态的集群，这些集群有以下这些共同特点：集群规模相对固定，不能随意变动；集群中每个Pod都是有状态的，即数据会被持久化到存储中；每个Pod都有固定的ID。StatefulSet创建的Pod集群符合上面的需求，具有如下特点:每个Pod的名称在创建前就可以确定下来了。比如StatefulSet的名称为mysql，那么第一个Pod叫mysql-0，第二个叫mysql-1，以此类推；Pod的启停试是按照顺序来的；Pod通过PV或者PVC来持久化存储。这里就先不深入研究StatefulSet了，后面再找机会研究。JobJob是一种特殊的Pod管理对象，是一种一次性Pod运行任务，任务结束后，Pod的生命周期也就结束了。Kubernetes中支持Cron表达式的任务称为CronJob，后面接触到了再仔细研究😪。Label就如上面所说，Label就是用于给Pod打标签用的，供Pod管理对象、Service等筛选使用。HPA除了使用kubectl scale命令修改Pod数量实现扩容或者缩容外，我们可以借助HPA（Horizontal Pod Autoscaling，Pod横向自动扩展）来完成Pod的自动化扩缩容。举个HPA的例子：123456789101112apiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata: name: nginx-hpa namespace: defaultspec: maxReplicas: 10 minReplicas: 3 scaleTargetRef: kind: Deployment name: nginx-deployment targetCPUUtilizationPercentage: 80上面定义了一个名为nginx-hpa的HPA，监控名称为nginx-deployment的Deployment中的Pod，当其targetCPUUtilizationPercentage的值大于80%时，将发生动态扩容行为，并且Pod的数量必须再3~10之间。targetCPUUtilizationPercentage指的是Pod一分钟内CPU使用率的算数平均值。比如Pod的requests cpu为0.4，当前CPU使用量为0.3，则CPU使用率为75%。所以要使用HPA的功能，Pod必须指定了requests cpu值。ServiceService、RC和Pod之间的关系如下图所示：从图中可以看出，Service是外界访问Pod的桥梁，Service通过Label Selector来筛选处符合的Pod，将请求均衡的转发到目标Pod上。前面例子中，我们通过Deployment创建了三个Nginx Pod，但现在外界并不能直接访问它们，我们可以创建一个Service来实现这个需求：1vim nginx-service.yml内容如下所示：123456789101112apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: ports: - port: 8080 targetPort: 80 nodePort: 30001 type: NodePort selector: name: nginx上面配置中spec.ports定义了三个端口，在了解这三个端口的含义之前，我们先了解下下面这三个IP的含义：Node IP：Node的IP地址，Node是部署在宿主机上的，所以实际上就是宿主机的IP地址，不会发生改变；Pod IP：Pod的IP地址，由于动态扩缩容、宕机转移等原因，这个IP经常会发生改变；Cluster IP：Service的IP地址，在一个完整的Service生命周期内是不会改变的。其中Pod IP和Cluster IP是属于Kubernetes集群范围内的，外界无法直接访问。再回头看上面三个端口的含义：port：指定Service的端口号；targetPort：目标Pod的端口，根据前面nginx-deployment的定义，这里应该指定为80；nodePort：在Node上开启的监听端口，用于外界通过Cluster IP:nodePort来访问对应的Service。使用nodePort时，需要将Service的type指定为NodePort，并且nodePort有范围限制，必须在30000-32767之间。使用kubectl create -f nginx-service.yml创建该Service：查看Service和endpoint：现在我们就可以通过node1 Ip:nodePort来访问Nginx Pod服务了：VolumeVolume是Pod上能够被多个Docker容器访问的共享目录，Volume的生命周期和Pod相关，与Docker容器无关。可以在定义Pod的时候指定Volume：12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: nginx-pod labels: name: nginxspec: volumes: - name: nginx-data emptyDir: &#123;&#125; containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 80 volumeMounts: - mountPath: /etc/nginx name: nginx-data通常情况下，我们都是现在Pod里声明一个Volume，然后在容器里引用该Volume，并挂载到容器的某个目录上。比较常用的Volume类型有：emptyDir：一个emptyDir Volume是在Pod分配到Node时创建的。从它的名称就可以看出，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为这是Kubernetes自动分配的一个目录，当Pod从Node上移除时，emptyDir中的数据也会被永久删除；hostPath为在Pod上挂载宿主机上的文件或目录，比如：12345spec: volumes: - name: "persistend-storage" hostPath: path: "/data"PV,PVCPV(Persistent Volume)是Kubernetes集群中的某个网络存储对应的一块存储，不属于任何Node，但可以在每个Node上访问；PVC(Persistent Volume Claim，PV声明)，某个Pod需要用到PV前，必须先定义PVC。定一个NFS类型的PV，声明需要10Gi存储：123456789101112apiVersion: v1kind: PersistentVolumemetadata: name: pv01spec: capacity: storage: 10Gi accessModes: - ReadWriteOnce nfs: path: /somepath server: 127.17.0.2该PV声明了127.17.0.2NFS系统下的/somepath目录作为网络存储，内存为10Gi，该PV名称为pv01。accessModes有以下三种模式：ReadWriteOnce：读写权限，并且只能被单个Node挂载；ReadOnlyMany：只读权限，允许被多个Node挂载；ReadWriteMany：读写权限，允许被多个Node挂载。接着定义一个PVC：12345678910apiVersion: v1kind: PersistentVolumeClaimmetadata: name: pvclaimspec: accessModes: - ReadWriteOnce resources: requests: storage: 8Gi该PVC声明了需要8Gi存储空间，刚刚定义的PV符合这个要求，所以会被绑定上。定义了PVC后，就可以在Pod里引用了：12345spec: volumes: - name: podpv persistentVolumeClaim: claimName: pvclaimPV具有以下几种状态：Available：空闲状态；Bound：已经绑定到某个PVC上；Released：对应的PVC已经被删除，但资源还没有被集群收回；Failed：PV自动回收失败。NamespaceNamespace顾名思义，命名空间，用于资源隔离。默认Kubernetes会创建default命名空间，并且Pod，RC等都是用该命名空间。我们可以定义自己的命名空间：1234apiVersion: v1kind: Namespacemetadata: name: febs在创建Pod等资源的时候就可以指定该命名空间了：12345678apiVersion: v1kind: Podmetadata: name: nginx-pod namespace: febs labels: name: nginx...AnnotationAnnotation是用户任意定义的附加信息，便于外部工具查找，比如版本信息，build信息等。ConfigMap学过Docker的都知道，我们可以使用挂载目录的方式将宿主机中的配置文件映射到Docker容器内。但这在集群环境下，要挂载的配置文件过多，不仅麻烦而且容易出错，Kubernete的ConfigMap就是用于解决这个问题的。ConfigMap存储了大量key-value配置，存储在etcd中，通过Volume的方式映射到目标Pod内，成为一份配置文件，ConfigMap实质上就是一个配置中心。《Kubernetes权威指南(第4版)》读书笔记]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes1.16.2安装Dashboard]]></title>
    <url>%2FKubernetes1-16-2-install-Dashboard.html</url>
    <content type="text"><![CDATA[Kubernetes Dashboard是Kubernetes提供的Web用户界面，通过Dashboard我们可以将容器化的应用部署到Kubernetes集群中，对容器化的应用进行故障排除以及集群资源管理；可以通过Dashboard查看集群应用详情，创建或修改单个Kubernetes资源（例如Deployments，Jobs，DaemonSets等）。安装Dashboard上节我们搭建的Kubernetes集群版本为1.16.2，截至目前为止，与该版本对应的Dashboard版本为v2.0.0-beta5，可以通过https://github.com/kubernetes/dashboard/releases查看：下载该版本的Dashboard yaml文件：1wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta5/aio/deploy/recommended.yaml修改该配置文件：1vim recommended.yaml修改的内容如下图所示：接着创建证书：123456789101112131415161718mkdir dashboard-certscd dashboard-certs/#创建命名空间kubectl create namespace kubernetes-dashboard#创建key文件openssl genrsa -out dashboard.key 2048#证书请求openssl req -days 36000 -new -out dashboard.csr -key dashboard.key -subj &apos;/CN=dashboard-cert&apos;#自签证书openssl x509 -req -in dashboard.csr -signkey dashboard.key -out dashboard.crt#创建kubernetes-dashboard-certs对象kubectl create secret generic kubernetes-dashboard-certs --from-file=dashboard.key --from-file=dashboard.crt -n kubernetes-dashboard然后执行kubectl create -f ../recommended.yaml命令安装Dashboard。使用kubectl get service -n kubernetes-dashboard -o wide命令查看是否部署成功：创建账号与授权Dashboard部署好后，接着创建账号：1vim dashboard-admin.yaml内容如下所示：1234567apiVersion: v1kind: ServiceAccountmetadata: labels: k8s-app: kubernetes-dashboard name: dashboard-admin namespace: kubernetes-dashboard创建该账号：1kubectl create -f dashboard-admin.yaml账号创建好后，接着为其授权：1vim dashboard-admin-bind-cluster-role.yaml内容如下所示：1234567891011121314apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: dashboard-admin-bind-cluster-role labels: k8s-app: kubernetes-dashboardroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: dashboard-admin namespace: kubernetes-dashboard授权：1kubectl create -f dashboard-admin-bind-cluster-role.yaml访问Dashboard使用浏览器访问https://192.168.33.12:30008/#/login：选择Token，Token的值可以用下面的命令获取：1kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep dashboard-admin | awk &apos;&#123;print $1&#125;&apos;)复制该Token到Dashboard：点击Sign In：安装Metrics Service上面Dashboard的CPU Usage (cores)和Memory Usage (bytes)列是空的，这是因为Kubernetes的早期版本依靠Heapster来实现完整的性能数据采集和监控功能，Kubernetes从1.8版本开始，性能数据开始以Metrics API的方式提供标准化接口，并且从1.10版本开始将Heapster替换为Metrics Server。首先在master节点上安装git：1yum install git然后克隆Metrics Server GitHub仓库：1git clone https://github.com/kubernetes-sigs/metrics-server.git修改metrics-server-deployment.yaml：1vim metrics-server/deploy/1.8+/metrics-server-deployment.yaml修改内容如下图所示：1234567...... imagePullPolicy: IfNotPresent command: - /metrics-server - --kubelet-preferred-address-types=InternalIP - --kubelet-insecure-tls......因为默认metrics service的镜像地址需要科学上网才能拉取，所以在创建之前，我们在node1和node2节点先执行以下操作准备镜像：12docker pull bluersw/metrics-server-amd64:v0.3.6docker tag bluersw/metrics-server-amd64:v0.3.6 k8s.gcr.io/metrics-server-amd64:v0.3.6然后回到master节点，执行：1kubectl create -f metrics-server/deploy/1.8+/稍等片刻，然后执行kubectl top nodes便可以看到每个节点的CPU和内存使用率了：回到Dashboard：]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubeadm安装Kubernetes1.16.2集群]]></title>
    <url>%2FKubeadm-install-Kubernetes1-16-2-cluster.html</url>
    <content type="text"><![CDATA[Kubernetes从1.4版本开始后就引入了kubeadm用于简化集群搭建的过程，在Kubernetes 1.13版本中，kubeadm工具进入GA阶段，可用于生产环境Kubernetes集群搭建。本节将使用Kubeadm搭建Kubernetes1.16.2集群，宿主机采用3台Vagrant构建的Centos7虚拟机，配置如下所示（Kubernetes推荐宿主机最低内存不能低于2G，CPU核心数最低不能低于2）：操作系统IP角色CPU核心数内存Hostnamecentos7192.168.33.11master24096Mmastercentos7192.168.33.12worker24096Mnode1centos7192.168.33.13worker24096Mnode2分享下我的Vagrantfile配置：1234567891011121314151617181920212223242526272829Vagrant.configure("2") do |config| config.vm.box = "centos/7" config.vm.define "one" do |one| one.vm.network "private_network", ip: "192.168.33.11" one.vm.hostname = "master" one.vm.provider "virtualbox" do |v| v.memory = 4096 v.cpus = 2 end end config.vm.define "two" do |two| two.vm.network "private_network", ip: "192.168.33.12" two.vm.hostname = "node1" two.vm.provider "virtualbox" do |v| v.memory = 4096 v.cpus = 2 end end config.vm.define "three" do |three| three.vm.network "private_network", ip: "192.168.33.13" three.vm.hostname = "node2" three.vm.provider "virtualbox" do |v| v.memory = 4096 v.cpus = 2 end endend启动后如下所示：准备工作下面这些准备工作分别在3台机器上使用root账号操作：1.安装必要软件：1yum install -y net-tools.x86_64 vim wget2.配置hosts：1vim /etc/hosts内容如下所示：123192.168.33.11 master192.168.33.12 node1192.168.33.13 node23.关闭防火墙：为了避免kubernetes的Master节点和各个工作节点的Node节点间的通信出现问题，我们可以关闭本地搭建的Centos虚拟机的防火墙。生产环境推荐的做法是在防火墙上配置各个组件需要相互通信的端口。12systemctl disable firewalldsystemctl stop firewalld4.禁用SELinux，让容器可以顺利地读取主机文件系统：1setenforce 01sed -i &apos;s/^SELINUX=enforcing$/SELINUX=disabled/&apos; /etc/selinux/config5.安装18.09版本的docker：因为本节需要安装的kubernetes集群版本为1.16.2，而该版本的kubernetes最高支持的docker版本为18.09。可以通过该地址查看kubernetes和docker的版本对应关系：https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.16.md#downloads-for-v1160：安装必要依赖:123yum install -y yum-utils \ device-mapper-persistent-data \ lvm2添加docker稳定版仓库：123yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo安装18.09版本：1yum install docker-ce-18.09.0 docker-ce-cli-18.09.0 containerd.io启动docker，并设置开机自启：1systemctl enable docker &amp;&amp; systemctl start docker修改/etc/docker/daemon.json文件:1vim /etc/docker/daemon.json内容如下所示：123&#123; &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]&#125;重启docker：12systemctl daemon-reloadsystemctl restart docker6.将桥接的IPv4流量传递到iptables的链1234cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1EOF1sysctl --system7.关闭swapSwap是操作系统在内存吃紧的情况申请的虚拟内存，按照Kubernetes官网的说法，Swap会对Kubernetes的性能造成影响，不推荐使用Swap。1swapoff -a安装Master准备工作完毕后，接着开始在192.168.33.11 Master虚拟机上安装Kubernetes Master。1.配置国内的kubernetes源：1234567891011cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF2.安装kubelet、kubeadm和kubectl工具：1yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes3.启动kubelet并设置开机自启：1systemctl enable kubelet &amp;&amp; systemctl start kubelet4.使用下面这条命令启动master：12345kubeadm init --kubernetes-version=v1.16.2 \--pod-network-cidr=10.244.0.0/16 \--service-cidr=10.1.0.0/16 \--apiserver-advertise-address=192.168.33.11 \--image-repository registry.aliyuncs.com/google_containers配置含义如下：kubernetes-version: 用于指定k8s版本，这里指定为最新的1.16.2版本；apiserver-advertise-address：用于指定kube-apiserver监听的ip地址，就是master本机IP地址。pod-network-cidr：因为后面我们选择flannel作为Pod的网络插件，所以这里需要指定Pod的网络范围为10.244.0.0/16service-cidr：用于指定SVC的网络范围；image-repository: 其中默认的镜像仓库k8s.gcr.io没有科学上网的话无法访问，我们可以将它修改为国内的阿里镜像仓库registry.aliyuncs.com/google_containers启动时，需要拉取镜像，过程比较缓慢耐心等待即可。如果你想先拉好镜像再启动，你可以使用kubeadm config images list命令列出需要拉取的镜像。启动成功后，你会看到类似如下提示:12345678910111213141516Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.33.11:6443 --token yf7sct.o63ceq25gxdu71cd \ --discovery-token-ca-cert-hash sha256:bcd15ddd7432d393d3831c75ac7673f582d4e9895ff2c579c3f545d2a5d3026e意思是，如果你想要非root用户也能使用kubectl命令的话，需要执行下面这些操作：123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config而如果你是root用户的话，直接运行下面这段命令即可：1export KUBECONFIG=/etc/kubernetes/admin.conf而下面这段则是用于工作节点Node加入Master集群用的，后面会使用到12kubeadm join 192.168.33.11:6443 --token yf7sct.o63ceq25gxdu71cd \ --discovery-token-ca-cert-hash sha256:bcd15ddd7432d393d3831c75ac7673f582d4e9895ff2c579c3f545d2a5d3026e安装Node节点，加入集群接着在192.168.33.12和192.168.33.13虚拟机上操作。和安装Master步骤一样，先安装好kubeadm相关工具，然后执行下面这条命令将Node加入到集群：12kubeadm join 192.168.33.11:6443 --token yf7sct.o63ceq25gxdu71cd \ --discovery-token-ca-cert-hash sha256:bcd15ddd7432d393d3831c75ac7673f582d4e9895ff2c579c3f545d2a5d3026e当输出如下内容是说明加入成功：安装网络插件在Master上执行kubectl get nodes命令，会发现Kubernetes提示Master为NotReady状态，这是因为还没有安装CNI网络插件：对于CNI网络插件，可以有许多选择，请参考https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network的说明。这里我选择的flannel：1wget https://raw.githubusercontent.com/coreos/flannel/2140ac876ef134e0ed5af15c65e414cf26827915/Documentation/kube-flannel.yml修改kube-flannel.yml：1vim kube-flannel.yml修改的地方如下所示：1234567891011......containers: - name: kube-flannel image: quay.io/coreos/flannel:v0.11.0-amd64 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr - --iface=eth1 # 新增部分......Vagrant 在多主机模式下有多个网卡，eth0 网卡用于nat转发访问公网，而eth1网卡才是主机真正的IP，在这种情况下直接部署k8s flannel 插件会导致CoreDNS无法工作，所以我们需要添加上面这条配置强制flannel使用eth1。安装flannel：1kubectl create -f kube-flannel.yml输出如下所示时，表示安装成功：稍等片刻后，再次查看节点状态：可以看到所有节点都是Ready状态。执行kubectl get pods --all-namespaces，验证Kubernetes集群的相关Pod是否都正常创建并运行：到这里通过Kubeadm安装Kubernetes 1.16.2集群已经成功了。如果安装失败，则可以执行kubeadm reset命令将主机恢复原状，重新执行kubeadm init命令，再次进行安装。小试牛刀为了快速地验证一下上面搭建集群是否可用，我们创建一个Nginx Deployment：123kubectl create deployment nginx --image=nginx kubectl expose deployment nginx --port=80 --type=NodePort使用命令kubectl get pod,svc查看是否正常：使用命令kubectl get pods,svc -o wide查看该Pod具体位于哪一个节点：可以看到其位于Node2节点，该节点IP为192.168.33.13，端口为30935，使用浏览器访问该地址：使用kubectl get pods命令查看Pod的情况:使用kubectl delete命令删除这个Pod看看会怎样：可以看到，刚刚的名为xxx的Pod处于Terminating（结束中）的状态，而另一个新的名为xxx的Pod正处于ContainerCreating（创建中）状态，因为默认情况下，replicas的值为1，Kubernetes集群会始终保持Nginx的实例为1。要删除Nginx可以通过删除deployment来完成，使用kubectl get deployments命令查看当前的deployment：使用命令kubectl delete deployment nginx：实际中我们一般通过yml或者json文件来创建应用，下面我们使用yml的方式创建一个3实例的Nginx集群：1vim nginx-rc.yml内容如下所示：12345678910111213141516171819apiVersion: v1kind: ReplicationControllermetadata: name: nginx-rcspec: replicas: 3 selector: name: nginx template: metadata: labels: name: nginx spec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent ports: - containerPort: 801vim nginx-service.yml内容如下所示：123456789101112apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: ports: - port: 8080 targetPort: 80 protocol: TCP type: NodePort selector: name: nginx接着执行下面这两条命令启动Nginx集群：12kubectl create -f nginx-rc.ymlkubectl create -f nginx-service.yml使用kubectl get pods命令查看Pod情况:使用kubectl get services命令查看Service情况：使用kubectl describe svc nginx-service命令查看Nginx Service详情：使用命令kubectl get pods,svc -o wide查看Nginx Pod具体位于哪一个节点：可以看到在node1和node2节点上都有Nginx的Pod，使用浏览器访问http://192.168.33.12:32631/或者http://192.168.33.13:32631/：删除的话执行下面这两条命令即可：12kubectl delete -f nginx-service.ymlkubectl delete -f nginx-rc.yml]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Troubleshooting 基础]]></title>
    <url>%2FJava%20Troubleshooting%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[本文基于Java8。JVM参数类型JVM的参数基本可以分为以下三种类型：标准参数在各个版本中基本不会发生变化的标准参数，比如有：-help：查看帮助；-server：切换为server模式；-client：切换为client模式；-version：查看JDK版本；-showversion：输出产品版本并继续。更多标准参数可以通过java -help查看。X参数X参数也称为非标准化参数，在各个JDK版本中可能存在差异，比如有：-Xint：解释执行；-Xcomp：第一次使用就编译成本地代码；-Xmixed：混合模式，JVM自己来决定是否编译成本地代码。XX参数XX也是非标准化参数，主要用于JVM调优和问题定位，XX参数分为两大类型：Boolean类型，格式：-XX:[+-]&lt;name&gt;标识启用或禁用name属性，比如：-XX:+PrintGCDetails-XX:+UseG1GC非Boolean类型（key-value形式），格式：-XX:&lt;name&gt;=&lt;value&gt;表示name属性的值是value，比如：-XX:MaxGCPauseMillis=500-XX:GCTimeRatio=19运行时JVM参数查看-XX:+PrintFlagsInitial：查看参数初始值，=表示默认值，:=表示修改后的值。-XX:+PrintFlagsFinal：查看参数最终值。-XX:+UnlockExperimentalVMOptions：解锁实验参数。-XX:+UnlockDiagnosticVMOptions：解锁诊断参数。-XX:+PrintCommandLineFlags：打印命令行参数。 上面这些命令查看的参数值对应的进程为执行当前命令进程，如果需要查看某个运行时Java应用相关参数，则可以使用下面这些命令：jps：查看Java进程ID，-l显示完整启动类名。jinfo：查看运行时Java程序相关参数值，使用方式jinfo -flag [参数名] [进程ID]。比如当前有一个正常运行的boot-app.jar，查看其最大堆内存：jstat统计JVM信息jstat可以监控许多JVM信息，下面逐一演示，演示基于boot-app.jar，进程号为4425。class监控类加载器行为信息：各列含义如下：Loaded：已加载类数量；Bytes：已加载类大小，单位为KB；Unloaded：已卸载类数量；Bytes：已卸载类大小，单位为KB；Time：执行类加载和卸载所花费的时间。compiler监控HotSpot VM实时编译器信息：Compiled：执行的编译任务数量；Failed：编译失败任务数量；Invalid：无效的编译数量；Time：编译耗时；FailedType：上次编译失败的类型；FailedMethod：编译失败的类名和方法。gc统计堆区GC信息：S0C：当前幸存者0区大小，单位KB；S1C：当前幸存者1区大小，单位KB；S0U：幸存者0区已使用内存大小，单位KB；S1U：幸存者1区已使用内存大小，单位KB；EC：伊甸园区大小，单位KB；EU：伊甸园区已使用内存大小，单位KB；OC：老年代内存大小，单位KB；OU：老年代已使用内存大小，单位KB；MC：元空间大小，单位KB；MU：元空间已使用内存大小，单位KB；CCSC：压缩类空间大小，单位KB；CCSU：压缩类空间已使用内存大小，单位KB；YGC：YGC次数；YGCT：YGC耗时；FGC：FGC次数；FGCT：FGC耗时；GCT：GC总耗时。gccapacity和GC相关的一些内存大小统计信息：部分列含义和-gc相同，下面仅列出不同部分：NGCMN：新生代最小内存大小，单位KB；NGCMX：新生代最大内存大小，单位KB；NGC：新生代当前内存大小，单位KB；OGCMN：老年代最小内存大小，单位KB；OGCMX：老年代最大内存大小，单位KB；MCMN：元空间最小内存大小，单位KB；MCMX：元空间最大内存大小，单位KB；CCSMN：压缩类空间最小内存大小，单位KB；CCSMX：压缩类空间最大内存大小，单位KB。gcutilGC信息摘要、总览：部分列含义和-gc相同，下面仅列出不同部分：S0：幸存者0区内存使用率；S1：幸存者1区内存使用率；E：伊甸园区内存使用率；O：老年代内存使用率；M：元空间内存使用率；CCS：压缩类空间内存使用率。gccause大部分和-gcutil一致，新增了LGCC和GCC：LGCC：最后一次GC的原因；GCC：当前GC原因。gcnew一些和新生代GC相关的统计信息：部分列含义和-gc相同，下面仅列出不同部分：TT：Tenuring threshold，即当前对象从新生代晋升到老年代的年龄阈值（JVM动态调整）；MTT：MaxTenuringThreshold，最大可设晋升阈值（默认值，或者我们手动设置的值）；DSS：期望的幸存区的大小（从上面截图可以看出，值为21504KB，和幸存者0区、幸存者1区一样大，即DSS的值为当前幸存者区的一半。DSS的计算公式为：当前幸存者区 * TargetSurvivorRatio/100，TargetSurvivorRatio的默认值为50，所以DSS计算出来为当前幸存者区的一半。关于对象从新生代晋升到老年代的细节可以参考这篇博文：https://www.cnblogs.com/wangshen31/p/10427802.html）gcnewcapacity统计新生代容量相关信息：部分列含义和-gc、-gccapacity相同，下面仅列出不同部分：S0CMX：幸存者0区最大内存，单位KB；S1CMX：幸存者1区最大内存，单位KB；ECMX：伊甸园区最大内存，单位KB；gcold一些和老年代GC相关统计信息：这些列含义都已涉及，不再赘述。gcoldcapacity一些和老年代容量相关统计信息：这些列含义都已涉及，不再赘述。gcmetacapacity一些和元空间容量相关统计信息：这些列含义都已涉及，不再赘述。printcompilationHotSpot VM编译方法信息统计：Compiled：近期编译方法数；Size：近期编译方法字节数；Type：近期编译方法类型；Method：近期编译的方法类名和方法名。上面的jstat命令输出的是当前统计信息，我们还可以打印出一段时间内的统计信息，比如每隔1秒输出一次，共输出5次：jmap+JProfiler内存溢出实战jmap可以为Java进程打印出内存信息。Java程序内存溢出一般分为堆内存溢出和元空间内存溢出，内存溢出后，我们可以通过JProfiler（eclipse MAT也行，本文不介绍）软件分析内存映像文件来定位问题所在。场景构建首先模拟堆内存溢出和元空间内存溢出场景。新建一个SpringBoot项目，然后创建一个OutOfMemoryController：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import jdk.internal.org.objectweb.asm.ClassWriter;import jdk.internal.org.objectweb.asm.Opcodes;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.List;@RestControllerpublic class OutOfMemoryController extends ClassLoader &#123; private List&lt;User&gt; data = new ArrayList&lt;&gt;(); @GetMapping("heap") public void heapOutOfMemory() &#123; long i = 0; while (true) &#123; i += 1; data.add(new User("test" + i, i)); &#125; &#125; @GetMapping("metaspace") public void metaspaceOutOfMemory() &#123; OutOfMemoryController controller = new OutOfMemoryController(); int i = 0; while (true) &#123; i += 1; String className = "Class" + i; // 创建ClassWriter对象，用于生成类的二进制字节码 ClassWriter classWriter = new ClassWriter(0); // 指定版本号、修饰符、类名、包名、父类和接口 classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, className, null, "java/lang/Object", null); byte[] bytes = classWriter.toByteArray(); // 加载类 controller.defineClass(className, bytes, 0, bytes.length); &#125; &#125; static class User &#123; private String username; private Long id; public User(String username, Long id) &#123; this.username = username; this.id = id; &#125; &#125;&#125;在heapOutOfMemory方法中，我们不断创建User对象，并添加到成员变量data集合中，强引用无法得到释放，最终导致堆内存溢出；在metaspaceOutOfMemory()方法中，我们不断加载新的class，最终元空间也将内存溢出。为了测试方便，我们通过参数-Xms64m -Xmx64m -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=64m限制堆和元空间大小。启动Boot应用，访问http://localhost:8080/heap，结果如下：123456789101112131415161718192021222324252627282930313233java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) ~[na:1.8.0_231] at java.util.Arrays.copyOf(Arrays.java:3181) ~[na:1.8.0_231] at java.util.ArrayList.grow(ArrayList.java:265) ~[na:1.8.0_231] at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239) ~[na:1.8.0_231] at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231) ~[na:1.8.0_231] at java.util.ArrayList.add(ArrayList.java:462) ~[na:1.8.0_231] at cc.mrbird.spring.boot.demo.controller.OutOfMemoryController.heapOutOfMemory(OutOfMemoryController.java:21) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_231] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_231] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_231] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_231] at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]重启应用，访问http://localhost:8080/metaspace，结果如下：123456789101112131415161718192021222324252627282930313233java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_231] at java.lang.ClassLoader.defineClass(ClassLoader.java:756) ~[na:1.8.0_231] at java.lang.ClassLoader.defineClass(ClassLoader.java:635) ~[na:1.8.0_231] at cc.mrbird.spring.boot.demo.controller.OutOfMemoryController.metaspaceOutOfMemory(OutOfMemoryController.java:38) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_231] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_231] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_231] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_231] at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]场景构建完毕。导出内存映像文件导出内存映像文件分为异常自动导出和通过jmap命令导出两种方式。内存溢出自动导出添加-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/mrbird/Desktop参数，表示内存溢出时，导出Dump文件，路径为/Users/mrbird/Desktop。添加后，启动应用，访问http://localhost:8080/heap，控制台打印：12345java.lang.OutOfMemoryError: Java heap spaceDumping heap to /Users/mrbird/Desktop/java_pid22958.hprof ...Heap dump file created [76362786 bytes in 0.348 secs]...桌面多了个java_pid22958.hprof文件。重启应用，访问http://localhost:8080/metaspace， 桌面多了个java_pid23003.hprof文件。jmap命令导出含义为，通过jmap命令导出dump文件，format=b表示导出二进制文件，file=/Users/mrbird/Desktop/java_23003.hprof表示导出到/Users/mrbird/Desktop/java_23003.hprof文件中，最后跟上进程号。导出后，我的桌面上多了个java_23003.hprof文件。JProfiler分析dump文件使用JProfiler软件打开上面导出的java_pid22958.hprof文件：这一页展示了各class对应实例内存占用从大到小排列情况。点击Biggest Objects查看大文件：在最大的对象上右键选择Use Retained Objects查看对象占用情况：可以看到里面密密麻麻的都是我们不断往里添加的User对象。一个User对象的大小为112bytes，整个集合对象占了将近40M。打开java_pid23003.hprof文件，和上面的步骤一样，查看Use Retained Objects：可以看到导致元空间溢出的原因是因为我们加载过多class所致。jstack定位死循环、死锁jstack可以打印出指定Java进程内部线程的堆栈信息。因为下面示例需要使用到top命令，该命令在Mac、Linux上有些差异，所以下面例子选择在Linux上演示，我的虚拟机IP为192.168.33.10。在上面的SpringBoot项目中，新建一个LoopController：12345678910@RestControllerpublic class LoopController &#123; @GetMapping("loop") public void loop() &#123; while (true) &#123; &#125; &#125;&#125;loop方法里制造死循环，启动项目，访问http://192.168.33.10:8080/loop后，使用top命令查看进程情况：可以看到，进程ID为5806的进程CUP使用率飙到了100%，这个进程就是我们的boot-app：然后接着使用top -p 5806 -H查看5806进程内部各线程情况：可以看到占用CPU资源的线程的ID为5830。因为通过jstack查看Java应用线程时，线程ID为16进制格式，所以我们需要将5830转换为16进制数：1printf &quot;%x&quot; 5830结果为16c6。使用jstack 5806 &gt; 5806.txt命令将5806进程的Java线程情况导出到5806.txt文件中，导出后，通过vim命令搜索16c6，结果如下所示：可以看到，占用CPU的线程为http-nio-8080-exec-1，对应出问题的代码为cc.mrbird.spring.boot.demo.controller.LoopController.loop的第11行。死循环问题定位完毕后，我们再新建一个LockController来模拟死锁情况：123456789101112131415161718192021222324252627282930313233343536@RestControllerpublic class DeadLockController &#123; private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); @GetMapping("lock") public String lock() &#123; new Thread(() -&gt; &#123; synchronized (lock1) &#123; sleep(); synchronized (lock2) &#123; System.out.println("thread1"); &#125; &#125; &#125;, "thread1").start(); new Thread(() -&gt; &#123; synchronized (lock2) &#123; sleep(); synchronized (lock1) &#123; System.out.println("thread2"); &#125; &#125; &#125;, "thread2").start(); return "0000"; &#125; private void sleep() &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;启动项目，访问http://192.168.33.10:8080/lock，然后使用jstatck命令查看Java线程情况：可以看到存在一个死锁，thread1和thread2线程互相等待锁获取。jvisualvm监控jvisualvm是JDK自带的监控Java进程的图形化工具，命令行输入jvisualvm即可启动。监控本地进程启动jvisualvm，在本地列表里可以看到本机正在运行的Java进程：双击pid为41202的boot应用进程：各tab功能：概述：显示JDK版本、进程ID，JVM参数配置等基础信息；监视：以图形化界面显示CPU使用率，内存使用情况，类加载信息，线程信息等，同时可以手动触发GC，导出堆内存Dump等；线程：当前进程的Java线程列表，同时也可以导出线程Dump文件；抽样器：可以对当前进程的CPU使用率内存占用情况进行抽样分析；Profiler：对抽样进行性能分析；Visual GC：安装的一个插件，用于图形化显示堆内存情况。个人常用的功能有监视页面的内存Dump和线程页面的线程Dump，它们功能和上面介绍的jmap、jstack类似。浏览器访问http://localhost:8080/heap后，点击监视页面的“堆Dump”按钮：然后在内存占用较大的User类上右键选择在实例视图中显示：可以看到通过引用追踪，我们可以定位到内存溢出的地方为OutOfMemoryController的data成员变量，类型为ArrayList，内部使用Object数组装载User。这个功能和上面使用JProfiler解析Dump文件追踪内存泄露原因类似。除了追踪内存问题，我们可以通过点击线程页面的线程Dump按钮导出线程Dump文件来分析进程里的Java线程情况，这和jstack功能类似。重启boot应用，重新使用jvisualvm连接，访问http://localhost:8080/loop：可以看到名称为http-nio-8080-exec-1的线程CPU使用率为100%，点击线程Dump按钮导出Dump文件：通过线程名称定位到问题代码。重启boot应用，重新使用jvisualvm连接，访问http://localhost:8080/lock：可以看到jvisualvm检查到了死锁，通过dump文件分析死锁原因：除了导出Dump文件外，jvisualvm也可以导入上面我们通过jmap命令导出的Dump文件，这里就不演示了。监控远程进程远程运行的Java进程也可以通过jvisualvm监控。以在虚拟机192.168.33.10中运行的boot应用为例，要进行远程监控，需要在启动命令上配置jmx配置：12345678nohup java -Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=8081 \-Dcom.sun.management.jmxremote.ssl=false \-Dcom.sun.management.jmxremote.authenticate=false \-Djava.net.preferIPv4Stack=true \-Djava.rmi.server.hostname=192.168.33.10 \-Xms200m -Xmx200m \-jar boot-app.jar &amp;-Dcom.sun.management.jmxremote：表示开启jmx远程连接；-Dcom.sun.management.jmxremote.port=8081：表示jmx端口号为8081；-Dcom.sun.management.jmxremote.ssl=false：放了方便，这里不使用SSL连接；-Dcom.sun.management.jmxremote.authenticate=false：为了方便，这里不使用用户名密码认证；-Djava.net.preferIPv4Stack=true：表示使用ipv4；-Djava.rmi.server.hostname=192.168.33.10：指定主机地址。配置好后，运行该脚本启动boot项目，然后在jvisualvm的远程列表中添加远程主机：然后添加jmx连接：连接成功后，就可以通过jvisualvm监控远程Java进程了：附录1 - Dump文件中线程状态Thread StateDescriptionNEWThe thread has not yet started.RUNNABLEThe thread is executing in the JVM.BLOCKEDThe thread is blocked waiting for a monitor lock.WAITINGThe thread is waiting indefinitely for another thread to perform a particular action.TIMED_WAITINGThe thread is waiting for another thread to perform an action for up to a specified waiting time.TERMINATEDThe thread has exited.参考链接：https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 垃圾回收]]></title>
    <url>%2FJava-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E2%99%BB%EF%B8%8F.html</url>
    <content type="text"><![CDATA[Java中的垃圾指的是运行程序中没有任何指针指向的对象，这些对象就是需要被回收的垃圾。Java中的垃圾回收器GC可以及时回收没用的对象资源，确保程序在长时间运行下不会内存溢出；同时GC还可以进行内存碎片整理，以便JVM分配新的对象。垃圾回收相关概念在了解JVM垃圾回收之前，先储备一些相关概念。System.gc()调用System.gc()或者Runtime.getRuntime().gc()会显式触发Full GC，然而该方法调用并无法保证JVM 100%会调用垃圾回收器。一般情况下，垃圾回收是自动进行的，无需手动触发。内存溢出与泄露内存溢出：内存溢出对应的异常为OutOfMemoryError，指的是没有空闲内存，并且垃圾回收器也无法提供更多内存。引发内存溢出主要有以下两种情况：分配对象时，可用内存不足，触发垃圾回收。垃圾回收后，还是没有足够空间分配对象，则OOM；分配一个超级大的对象，直接超过堆的最大值，JVM直接OOM。内存泄露：指的是存在不再被使用的对象，但是GC又不能回收他们。STWStop The World简称STW，指的是GC事件发生过程中，会产生应用程序的停顿，整个应用程序都会被暂停。下面即将介绍的可达性分析算法会导致STW，因为：分析工作必须在一个能确保一致性的快照中进行；一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上；如果分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。GC完成之后，STW便随之结束。并行与并发程序的并行与并发和垃圾回收器的并行与并发概念有所不同，先来看看程序中的并行与并发。程序并行与并发并发（Concurrent）：操作系统中，一个时间段内有几个程序都处于已启动运行到运行完毕之间，这几个程序都是在同一个处理器上运行。并发并不是真正意义上的“同时进行”，只是CPU把一个时间划分为几个时间片段，然后在这几个时间片段之间来回切换。由于CPU处理的速度非常快，我们感觉上以为多个应用程序同时在进行；并行（parallel）：当系统有多个CPU时（或者一个CPU有多个核时），另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。程序的并行与并发如下图所示：垃圾回收并行与并发并行：多个垃圾回收线程同时进行（如果只有一个回收线程，那么称之为串行），此时用户线程仍处于等待状态；并发：用户线程和垃圾回收线程同时进行，用户线程不停顿。垃圾回收器的并行与并发如下图所示：引用ReferenceJDK1.2之后，Java对引用的概念进行了扩充，分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）和终结器引用（Final Reference）：强引用最传统的引用定义，程序中普遍存在的引用赋值，类似Object obj = new Object()这种引用关系。无论在任何情况下，只要强引用关系还在，垃圾回收器就永远不会回收掉被引用的对象。软引用软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统即将要发生内存溢出异常前，会被放入到Reference Queue，进行二次回收。简而言之就是内存不足时回收。软引用常用来实现内存敏感的缓存，比如内存充足时，就是用缓存，内存不足时就清除缓存，避免程序OOM。软引用例子：123Object obj = new Object();SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(obj);obj = null;弱引用弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发生弱引用，不管系统堆空间是否充足，都会回收。简而言之就是发现即回收。弱引用例子：123Object obj = new Object();WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(obj);obj = null;虚引用一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅存在虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。此外，我们无法通过虚引用来获取被引用的对象，当调用虚引用的get方法获取对象时，将返回null。虚引用必须和引用队列一起使用：12345Object obj = new Object();ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(obj, referenceQueue);obj = null;phantomReference.get(); // null虚引用对象被垃圾回收器回收后，会将这个虚引用加入引用队列，已通知应用程序对象回收情况。虚引用的唯一作用是用于跟踪垃圾回收过程（通过观察引用队列里是否有对应的虚引用）。终结器引用略🐶。垃圾回收算法垃圾回收分为标记阶段（对象存活判断）和清除阶段（垃圾对象回收）。标记阶段：在堆中存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已死亡对象。只有被标记为已经死亡的对象，GC才会进行回收释放内存空间。这个阶段的算法包括引用计数算法和可达性分析算法；清除阶段：当成功区分出内存中的存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放内存。目前JVM中比较常见的三种垃圾算法是标记清除算法、复制算法和标记压缩算法。引用计数算法引用计数算法（Reference Counting）算法对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象Object，只要有任何一个对象引用了它，则它的引用计数器加1，引用失效时，引用计数器就减1。所以当一个对象的引用计数器值为0时，说明该对象不再被引用，可进行回收。优点：实现简单，效率高，垃圾回收没有延迟；缺点：计数器的存在增加了存储空间的开销；每次赋值都需要更新计数器，增加了程序时间开销；致命问题：无法处理循环引用的情况（正因为如此，Java压根没有使用该算法）。举个循环引用的例子：上面例子中，Object1的引用计数器值为1，但实际可能这三个对象都已经不再被使用，它们的引用计数器的值都不为0，无法被回收，这就导致了内存泄露。可达性分析算法可达性分析算法同样具备实现简单执行高效等特点，并且还解决了引用计数算法无法处理的循环引用问题，可达性分析算法也叫根搜索算法、追踪性垃圾收集算法。算法思路可达性分析算法的基本思路：以根对象集合（GC Roots）为起点，从上至下搜索被根对象连接的目标对象是否可达，搜索走过的路径称为引用链；如果目标对象没有任何引用链相连，则是不可达的，意味着对象已经死亡属于垃圾；只有那些能够被根对象集合直接或者间接连接的对象才是存活对象。如下图所示：绿色对象为存活对象，它们直接或间接与GC Roots相连，橙色对象为可回收对象。那么哪些对象可以作为GC Roots呢？Java中，GC Roots包括以下几类元素：虚拟机栈中引用的对象；本地方法栈内引用的对象；方法区中类静态属性引用的对象，如Java类的引用类型静态变量；方法区中常量引用的对象；所有被synchronized持有的对象；Java虚拟机内部引用；反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。在使用可达性分析算法判断内存是否可回收时，分析工作必须在一个能保障一致性的快照中进行。这点也是导致GC进行时必须Stop The World（STW，程序暂停）的一个重要原因。对象复活演示对象的finalization机制：当垃圾回收器回收一个垃圾对象之前，总会先调用这个对象的finalize()方法，用于在对象回收时进行资源释放。finalize()方法为Object的一个非final方法，所以子类可以进行重写。因为finalize()方法的存在，Java中一个对象可能处于三种状态：可触及的，从GC Roots开始可以到达该对象；可复活的，对象的所有引用都被释放，但对象可能在finalize()方法中复活；不可触及的，对象的finalize()方法被调用，并且没有复活。不可触及的对象不可能被复活，因为finalize()方法只会被调用一次。判断一个对象是否可回收需要经历两次标记过程：如果对象到GC Roots没有引用链，那么进行第一次标记；对已经标记了的对象进行筛选，判断对象是否有必要执行finalize()方法：如果对象没有重写finalize()方法，或者finalize()方法已经被调用过，则该对象是不可触及的；如果重写了，但还没执行过，则该对象会被放入F-Queue队列；GC对F-Queue队列中的对象进行遍历，如果对象在finalize()方法中与引用链上的任意一个对象建立了联系，那么该对象被复活，从F-Queue队列中移出。当该对象再次出现没有引用的情况时，finalize()方法不会再被调用，该对象直接被判定为不可触及。finalize()方法执行是由虚拟机自动创建的低优先级的Finalizer线程触发，举个例子：123456public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; TimeUnit.SECONDS.sleep(120); &#125;&#125;启动main线程，让程序阻塞，然后用jvisualvm观察线程状态：举个对象通过finalize()方法复活的例子：1234567891011121314151617181920212223242526272829303132333435363738394041public class Test &#123; /** * 静态类变量，属于GC Roots */ public static Test obj; @Override protected void finalize() &#123; System.out.println("finalize方法中不做任何事情"); &#125; public static void main(String[] args) &#123; try &#123; obj = new Test(); // 移除对象引用链 obj = null; System.gc(); System.out.println("第一次GC"); // 因为Finalizer线程优先级很低，让程序暂停2秒，确保finalize()方法调用 TimeUnit.SECONDS.sleep(2); isAlive(obj); obj = null; System.gc(); System.out.println("第二次GC"); TimeUnit.SECONDS.sleep(2); isAlive(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static void isAlive(Object obj) &#123; if (obj == null) &#123; System.out.println("对象已死"); &#125; else &#123; System.out.println("对象还活着"); &#125; &#125;&#125;上面代码中，Test类重写了finalize()方法，但方法内没有可以让对象复活的逻辑。程序输出如下：12345第一次GCfinalize方法中不做任何事情对象已死第二次GC对象已死可以看到，将obj置为null后，第一次GC，该对象就已经被回收。下面往finalize()方法中添加逻辑，让对象复活：123456789101112131415161718192021222324252627282930313233343536373839404142public class Test &#123; /** * 静态类变量，属于GC Roots */ public static Test obj; @Override protected void finalize() &#123; System.out.println("复活obj"); obj = this; &#125; public static void main(String[] args) &#123; try &#123; obj = new Test(); // 移除对象引用链 obj = null; System.gc(); System.out.println("第一次GC"); // 因为Finalizer线程优先级很低，让程序暂停2秒，确保finalize()方法调用 TimeUnit.SECONDS.sleep(2); isAlive(obj); obj = null; System.gc(); System.out.println("第二次GC"); TimeUnit.SECONDS.sleep(2); isAlive(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static void isAlive(Object obj) &#123; if (obj == null) &#123; System.out.println("对象已死"); &#125; else &#123; System.out.println("对象还活着"); &#125; &#125;&#125;程序输出如下：12345第一次GC复活obj对象还活着第二次GC对象已死上面例子也证明了finalize()方法最多只被执行一次。严禁主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用，因为： 1. 在finalize()方法里可能导致对象复活； 2. finalize()方法执行时间没有保障，如果对象不被回收，finalize()方法没有执行机会； 3. 一个糟糕的finalize()方法会严重影响GC性能。标记清除算法标记清除算法执行过程：当内存快被耗尽时，会停止整个程序（STW），进行两项工作：标记：回收器从GC Roots开始遍历，标记所有可达对象（在对象头中进行标记）；清除：回收器对堆内存进行从头到尾线性遍历，如果对象头中没有标记，则说明是不可达对象，进行回收（回收细节：JVM会维护一个空闲地址列表，把可回收对象的地址存放进来，这个时候对象并没有真正被删掉，下次新对象进行分配时候直接覆盖可回收对象）。缺点：效率不是很高，因为要进行两次遍历工作；STW会影响用户体验；这种方式整理出来的内存不是连续的，碎片化。复制算法为了解决标记清除算法的缺点，复制算法提出了新思路。复制算法的基本思想：将内存一分为二，每次只使用其中一块。GC时，将存活的对象复制到另一块未使用的内存中，然后当前内存块的对象全部清除，两个内存块交互角色，如次循环反复（堆内存中的幸存者0区和1区就是这么搞的）。优点：不需要进行两次遍历，效率更高；复制算法可以保证空间连续性，没有碎片问题。当然也有缺点：内存只有一半是可用的，浪费了内存空间；对象复制后，地址肯定变了，那么栈中对象的引用地址也要改变，这就增加了时间开销；极端情况下，假如当前内存块中没有垃圾，那么需要将所有存活对象都复制到另一块内存，费力不讨好。标记压缩算法标记压缩算法是标记清除算法的改进版本，基本思路是：标记：和标记清除算法的标记阶段一致；压缩：将存活的对象压缩（移动）到内存的一端，按顺序排放，之后清理边界外的所有空间。使用标记压缩算法后，我们就没必要维护一个内存空闲列表了，只需要记录内存使用的末端地址即可，有新对象需要分配内存时，只需要从这个末端地址开始继续往后排，然后更新这个末端地址即可（这种分配方式也称为指针碰撞）。优点：没有碎片化问题；不会像复制算法那样，浪费一半的内存空间。缺点：从效率上来看，因为多了压缩对象过程，所以不及标记清除算法；涉及到对象的移动，所以栈中的引用地址也要变，也会增加时间开销；压缩过程中，也需要STW。算法比较与实际应用可以看到，没有完美的垃圾回收算法，大家都有优缺点：标记清除标记压缩复制速度中等最慢最快内存开销少，但有碎片少，没有碎片多，没有碎片移动对象否是是没有最完美的算法，只有最合适的算法。我们可以在堆内存中针对不同区域的特性使用不同的回收算法，取长补短（分代收集）：新生代：该区域的对象大多朝生夕死，存活率低，回收频繁，所以复制算法非常适合用于该区域；老年代：老年代内存区域较大，对象生命周期长，回收不那么频繁，所以这个区域一般使用标记清除或者标记压缩算法。增量收集算法*上述的三种垃圾回收算法都要进行STW，如果一次性将所有的垃圾进行处理，会造成系统长时间的停顿，为了改善这个问题，增量收集算法应运而生。增量收集算法让垃圾收集线程和应用程序交替执行，每次垃圾收集线程只收集一小片区域的内存，接着切换到应用程序线程，以此反复，直到垃圾收集完成。但该算法的基础还是传统的标记清除算法和复制算法。优点：没有长时间的STW；缺点：线程切换会使得垃圾回收的总体成本上升，造成系统吞吐量下降。垃圾回收器垃圾回收器性能指标吞吐量：程序运行时间占总运行时间（总运行时间=程序运行时间+垃圾回收时间）的比例，垃圾回收时间越少，吞吐量越高；暂停时间：STW的时间；内存占用：Java堆所占的大小。以上三点构成不可能三角，即一款垃圾回收器不可能同时满足三点。随着硬件水平的提升，内存占用不再是我们关注的重点，评估垃圾回收器性能时，重点关注吞吐量和暂停时间。吞吐量和暂停时间是相互矛盾的，目前我们追求的效果是：在最大吞吐量优先的情况下，减小暂停时间。垃圾回收器发展历史1999年JDK 1.3.1 发布第一款串行方式的Serial GC，ParNew垃圾回收器是Serial回收器的多线程版本；2002年2月26，Parallel GC和Concurrent Mark Sweep GC（CMS）跟随JDK 1.4.2一起发布；Parallel GC在JDK 1.6后称为HotSpot默认GC；2012年，在JDK 1.7u4版本中，G1可用；2017年，JDK 9中，G1成为默认垃圾回收器，CMS被标记为过时；2018年3月，JDK 10中提升G1并行性；2018年9月，JDK 11引入了Epsilon垃圾回收器，同时引入ZGC（实验版本）；2019年3月，JDK 12发布，增强G1，并引入Shenandoah GC（实验版本）；2019年9月，JDK 13发布，增强ZGC；2020年3月，JDK 14发布，删除CMS，拓展ZGC在MAC和Windows上的应用。垃圾回收器组合7款经典垃圾回收器间的组合关系：说明：两个回收器间有连线，说明它们可以搭配使用；Serial Old作为CMS出现“Concurrent Mode Failure”失败的后备预案；G1可用于新生代和老年代；红色虚线连线：JDK 8将这两组组合声明为废弃，并在JDK 9中完全移除；绿色虚线连线：JDK 14中，弃用了该组合；绿色虚线边框：JDK 14中，删除了CMS。默认垃圾回收器查看编写一段简单的java程序：123456public class Test &#123; public static void main(String[] args) &#123; System.out.println("hello"); &#125;&#125;添加-XX:+PrintCommandLineFlagsJVM参数配置，在JDK 8环境下程序输出：12-XX:InitialHeapSize=536870912 -XX:MaxHeapSize=8589934592 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC hello-XX:+UseParallelGC说明JDK 8默认的垃圾回收器为Parallel。在JDK 9环境下输出：12-XX:G1ConcRefinementThreads=10 -XX:InitialHeapSize=536870912 -XX:MaxHeapSize=8589934592 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC hello-XX:+UseG1GC说明JDK 9默认的垃圾回收器为G1。经典垃圾回收器介绍Serial、Serial Old回收器Serial垃圾回收器为单线程串行回收器，为HotSpot中Client模式下默认的新生代垃圾回收器，采用复制算法、串行回收和STW机制进行内存回收；Serial Old垃圾回收器为Serial提供的老年代垃圾回收器，采用标记压缩算法、串行回收和STW机制进行内存回收：Serial Old是运行在Client模式下默认的老年代垃圾回收器；Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS回收器的后备垃圾收集方案。Serial适用于运行在Client模式下的虚拟机或者内存不大（几十MB到一两百MB）的环境下，因为是串行的，有较长时间的STW，所以并不适用于要求快响应、交互较强的应用。可以通过XX:+UseSerialGC参数启用Serial回收器，表示新生代使用Serial，老年代使用Serial Old。ParNew回收器ParNew是Parallel New两个词的简写，是Serial的多线程版本垃圾回收器。ParNew是很多JVM运行在Server模式下新生代的默认垃圾回收器，采用复制算法，并行回收和STW机制进行内存回收。可以通过XX:+UseParNewGC参数启用ParNew回收器，表示新生代使用ParNew，老年代不受影响。Serial、ParNew搭配Serial Old回收器示意图：图片来自于https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/691189/Parallel、Parallel Old回收器Parallel Scavenge回收器也是作用于新生代，同样采用复制算法，并行回收和STW机制。Parallel Scavenge和ParNew对比：Parallel Scavenge为吞吐量优先的垃圾回收器；Parallel Scavenge具有自适应调节策略。JDK 1.6提供了用于老年代的并行垃圾回收器 —— Parallel Old回收器，用于替代Serial Old回收器。Parallel采用标记压缩、并行回收和STW机制。可以通过-XX:+UseParallelGC指定新生代使用Parallel Scavenge回收器；-XX:+UseParallelOldGC指定老年代使用Parallel Old回收器，它们是成对存在的，开启一个另一个也会开启。此外还可以通过-XX:ParallelGCThreads=设置并行回收器的线程数：默认情况下，当CPU数量小于8个时，-XX:ParallelGCThreads=的值等于CPU数量；当CPU数量大于8个，-XX:ParallelGCThreads=的值等于3+5*CPU_COUNT/8。-XX:+UseAdaptiveSizePolicy开启Parallel Scavenge的自适应调节策略：该模式下，年轻代大小、伊甸园区和幸存者区的比例、晋升老年代的对象年龄阈值都会自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。CMS回收器JDK 1.5 HotSpot推出了一款真正意义上的并发回收器 —— CMS（Concurrent-Mark-Sweep），第一次实现了让垃圾回收线程和用户线程同时工作。CMS的关注点在于尽可能缩短垃圾收集时用户线程停顿的时间。CMS作为一款老年代的垃圾回收器，不能和新生代垃圾回收器Parallel Scavenge搭配使用，只能和ParNew或者Serial搭配使用。CMS回收器示意图：图片来自于https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/691189/主要分为以下几个步骤：初始标记（Initial-Mark）：所有用户线程暂停（STW），这个阶段仅仅标记出GC Roots能直接关联到的对象，所以速度非常快，STW时间很短；并发标记（Concurrent-Mark）：该阶段从GC Roots直接关联对象开始遍历整个对象链，虽然这个过程耗时较长，但并不需要暂停用户线程，并发执行，没有STW；重新标记（Remark）：由于上一步用户线程也在执行，所以这一步用于修正因用户线程继续运行而导致标记发生变动的那一部分对象的标记记录。这个阶段会比初始标记阶段耗时长一点，但远比并发标记阶段低；并发清除（Concurrent-Sweep）：该阶段清理删除垃圾，回收空间。由于没有移动对象，所以该阶段也不需要STW。CMS的优缺点都很明显：优点：并发收集；低延迟。缺点：会产生碎片。因为清理阶段用户线线程还在执行，所以只能采用不移动对象的标记-清除算法，而该算法会产生碎片问题；对CPU资源敏感。CPU资源除了用于用户线程外，还需分配一部分用于处理垃圾回收，降低了吞吐量；无法处理浮动垃圾。并发标记阶段，用户线程并未停止，该阶段也会产生垃圾， CMS无法对这些垃圾进行标记，只能留到下次GC时处理。此外，CMS在回收过程中，因为用户线程并没有中断，所以还需确保用户线程有足够的内存可用。换句话说，CMS回收器不能等老年代即将被填满时才去回收，而应当堆内存使用率到达一定阈值时，便开始进行回收。如果CMS运行期间预留内存不足，就会出现一次“Concurrent Mode Failure”失败，虚拟机会启动后备方案，临时启用Serial Old回收器来完成老年代的垃圾回收。CMS回收器可设置参数：-XX:+UseConcMarkSweepGC，开启CMS GC，开启后，-XX:+UseParNewGC会自动打开；-XX:CMSInitiatingOccupanyFraction=，设置堆内存使用率阈值，一旦达到这个阈值，CMS开始进行回收（JDK5及之前，默认值为68，JDK6及以上版本默认值为92%）；-XX:+UseCMSCompactAtFullCollection，指定在CMS回收完老年代后，对内存空间进行压缩处理，以避免碎片化问题；-XX:CMSFullGCsBeforeCompaction，设置执行多少次CMS GC后，对内存空间进行压缩整理；-XX:ParallelCMSThreads=，设置CMS的线程数。默认启动的线程数为(ParallelGCThreads+3)/4。我们知道，当CPU个数小于8时，ParallelGCThreads的默认值为CPU个数，所以对于一个8核CPU，默认启动的CMS线程数为3，换句话说只有62.5%的CPU资源用于处理用户线程。所以CMS不适合吞吐量要求高的场景。G1回收器G1（Garbage First）回收器把堆内存分割成很多不相关的区域（region，物理上不连续），使用不同区域来表示伊甸园区，幸存者区和老年代。G1会避免对整个Java堆进行垃圾收集，它会跟踪各个region里垃圾回收的价值大小（回收所获得的空间大小及所需时间的经验值），在后台维护一个优先列表，每次根据允许收集时间，优先回收价值最大的region。region的说明图片来自于https://tech.meituan.com/2016/09/23/g1.htmlE表示伊甸园区，S表示幸存者区、O表示老年代，空白表示未使用的内存区域；一个region在同一时间内只能属于一种角色；G1新增了一个全新的内存区域——Humongous，主要用于存放大对象。G1回收垃圾过程如下图所示：图片来自于https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/691189/主要分为以下几个步骤：初始标记：仅仅是标记GC Roots能直接关联的对象，需要STW，但这个过程非常快；并发标记：从GC Roots出发，对堆中对象进行可达性分析，找出存活对象，该阶段耗时较长，但是可与用户线程并发执行；最终标记：主要修正在并发标记阶段因为用户线程继续运行而导致标记记录产生变动的那一部分对象的标记记录，需要STW；筛选回收：将各个region分区的回收价值和成本进行排序，根据用户所期望的停顿时间制定回收计划。这阶段停顿用户线程，STW。G1回收器的优缺点：优点：并行与并发；分代收集，可以采用不同的算法处理不同的对象；空间整合，标记压缩算法意味着不会产生内存碎片；可预测的停顿时间，能让使用者明确指定一个长度为M毫秒时间片段内，消耗在垃圾回收的时间不超过N毫秒（根据优先列表优先回收价值最大的region）。缺点：在小内存环境下和CMS相比没有优势，G1适合大的堆内存；在用户程序运行过程中，G1无论是为了垃圾回收产生的内存占用，还是程序运行时的额外执行负载都要比CMS高。G1回收器相关参数设置：-XX:+UseG1GC，开启G1 GC；-XX:G1HeapRegionSize=，设置region的大小。值为2的幂，范围是1MB到32MB之间，目标是根据最小堆内存大小划分出约2048个区域。所以如果这个值设置为2MB，那么堆最小内存大约为4GB；-XX:MaxGCPauseMillis=，设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值为200ms；-XX:ParallelGCThread=，设置STW时GC线程数值，最多设置为8；-XX:ConcGCThreads=，设置并发标记的线程数，推荐值为ParallelGCThread的1/4左右；-XX:InitiatingHeapOccupancyPercent=，设置触发并发GC周期的Java堆占用率阈值，超过这个值就触发GC，默认值为45。总结上面这几款经典的垃圾回收器各有特点，具体使用的时候需要根据具体的情况选用不同的垃圾回收器：垃圾回收器分类作用位置使用算法特点适用场景Serial串行新生代复制算法响应速度优先适用于单CPU环境下的Client模式ParNew并行新生代复制算法响应速度优先多CPU环境Server模式下与CMS配合使用Parallel并行新生代复制算法吞吐量优先适用于后台运算而不需要太多交互的场景Serial Old串行老年代标记-压缩算法响应速度优先单CPU环境下的Client模式Parallel Old并行老年代标记-压缩算法吞吐量优先适用于后台运算而不需要太多交互的场景CMS并发老年代标记-压缩算法响应速度优先适用于互联网或B/S业务G1并行与并发新生代、老年代复制算法标记-压缩算法响应速度优先面向服务端应用新垃圾回收器介绍Epsilon回收器略🐶Shenandoah回收器略🐶ZGC回收器略🐶http://www.atguigu.com/download_detail.shtml?v=279 学习笔记]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字符串详解]]></title>
    <url>%2FJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[String基本特性String字符串使用一对&quot;&quot;表示；String类为final的，不可被继承；String实现了Serializable接口，可序列化；实现了Comparable接口，表示可比较；JDK8及之前，String内部使用char[]存储字符串数据；JDK9之后使用byte[]；字符串常量池中不会存储相同内容的字符串。因为String是final的，所以它是不可变的，String的不可变性体现在：当字符串重新赋值、拼接操作和调用String的replace()方法修改制定字符时，都需要重新指定内存区域赋值，不能使用原有的value进行赋值。比如：1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; String a = "hello"; String b = "hello"; b += " world"; System.out.println(a); // hello System.out.println(b); // hello world String c = "test"; String d = c.replaceFirst("t", "b"); System.out.println(c); // test System.out.println(d); // best &#125;&#125;通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中：1234567public class StringTest &#123; public static void main(String[] args) &#123; String a = "hello"; String b = "hello"; System.out.println(a == b); // true &#125;&#125;a和b都指向字符串常量池中唯一一份hello（因为字符串常量池中不会存储相同内容的字符串），可以使用debug证明：可以看到，代码还未执行String a = &quot;hello&quot;时，堆内存中String的个数为1227；执行完String a = &quot;hello&quot;时，堆内存中String的个数为1228；执行完String b = &quot;hello&quot;时，堆内存中String的个数还是为1228。字符串常量池（StringTable）是一个固定大小的Hashtable，可以使用-XX:StringTableSize设置长度：jdk6时，StringTable的长度是固定的，为1009。这个值不是很大，所以当池中String过多时，会造成Hash冲突，导致链表变长，性能下降；jdk7时，StringTable的默认长度是60013；jdk8时，1009是可设置的最小值。String内存分配在jdk6及之前，字符串常量池存放在永久代（方法区）；jdk7开始至今，字符串常量池存放在堆内存中。比如：12345678910public class StringTest &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); int i = 0; while (true) &#123; // intern方法将字符串存放到字符串常量池中，下面详细介绍 set.add(String.valueOf(i++).intern()); &#125; &#125;&#125;这个例子在jdk6中，设置参数：-XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m，运行结果如下：123Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at cc.mrbird.jvm.learn.StringTest.main(StringTest.java:11)证明了jdk6中，字符串常量池存放在永久代。在jdk8中，设置参数：-XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=10m -Xms6m -Xmx6m，运行结果如下：123456Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.HashMap.resize(HashMap.java:704) at java.util.HashMap.putVal(HashMap.java:663) at java.util.HashMap.put(HashMap.java:612) at java.util.HashSet.add(HashSet.java:220) at cc.mrbird.jvm.learn.StringTest.main(StringTest.java:11)证明了jdk8中，字符串常量池存放在堆中。String拼接操作字符串拼接操作主要分为以下两种：常量与常量的拼接结果放在常量池，编译期会进行优化；只要拼接一方有一个是变量，结果就在堆中，内部使用StringBuilder拼接。举几个字符串拼接的例子：字面量拼接（属于常量拼接）：1234567public class StringTest &#123; public static void main(String[] args) &#123; String a = "h" + "e" + "l" + "l" + "o"; String b = "hello"; System.out.println(a == b); // true &#125;&#125;使用IDEA查看对应的class文件可以发下，编译器将其优化为了如下结果：变量a的声明编译器优化为了String a = &quot;hello&quot;，所以a、b指向的是字符串常量池中的同一个对象，故a == b为true。拼接方包含变量：12345678910111213public class StringTest &#123; public static void main(String[] args) &#123; String a = "javascript"; String b = "java"; String c = "script"; String d = b + "script"; String e = "java" + c; String f = b + c; System.out.println(a == d); // false System.out.println(a == e); // false System.out.println(a == f); // false &#125;&#125;可以看到，只要字符串拼接一方包含变量，结果都是在堆中；a为字符串常量池中的javascript的引用，d为堆中value为javascript的String对象的引用，所以a == d为false，下面以此类推。通过字节码指令也可以证明，String d = b + &quot;script&quot;内部使用StringBuilder拼接：所以String d = b + &quot;script&quot;相当于new StringBuilder().append(b).append(&quot;script&quot;).toString()。查看StringBuilder的toString()方法：所以d实际指向的是StringBuilder的toString()方法里new String()创建的对象地址。再来看个拼接例子：12345678public class StringTest &#123; public static void main(String[] args) &#123; String a = "javascript"; final String b = "java"; String c = b + "script"; System.out.println(a == c); // true &#125;&#125;因为b是final的，不是“变量”，所以这种情况实际上也是常量与常量的拼接，编译器会进行优化：StringBuilder与String拼接性能对比当涉及多次字符串拼接操作时，无论是编程规范还是IDEA都会提示我们使用StringBuilder而非手动使用+拼接，因为前者不仅性能更优而且更省内存。举个例子：123456789101112public class StringTest &#123; public static void main(String[] args) throws InterruptedException &#123; long start = System.currentTimeMillis(); int capacity = 100000; String a = ""; for (int i = 0; i &lt; capacity; i++) &#123; a = a + "a"; &#125; System.out.println("耗时：" + (System.currentTimeMillis() - start) + " ms"); // 耗时：3866 ms TimeUnit.SECONDS.sleep(100); &#125;&#125;使用JProfiler查看内存占用情况：通过前面的内容我们知道，在循环体中，我们实际是创建了100000个StringBuilder对象和100000个String对象。现在我们将拼接操作改为StringBuilder：123456789101112public class StringTest &#123; public static void main(String[] args) throws InterruptedException &#123; long start = System.currentTimeMillis(); int capacity = 100000; StringBuilder a = new StringBuilder(); for (int i = 0; i &lt; capacity; i++) &#123; a.append("a"); &#125; System.out.println("耗时：" + (System.currentTimeMillis() - start) + " ms"); //耗时：7 ms TimeUnit.SECONDS.sleep(100); &#125;&#125;可以看到无论是内存占用还是耗时，使用StringBuilder远优于String手动拼接，这是因为使用StringBuilder的方式自始至终只创建过一个StringBuilder对象。查看StringBuilder的空参构造器：内部调用了父类的有参构造器：所以当我们调用new StringBuilder()时，实际上创建的是一个长度为16的char型数组。查看StringBuilder的append方法：查看父类的append方法：可以看到内部涉及到数组扩容的操作，所以当我们使用StringBuilder的时候，如果能够确定最终字符串的长度，我们可以在创建StringBuilder的时候使用有参构造器来指定容量，这样可以避免后期的扩容耗时。总结：多次字符串拼接操作推荐使用StringBuilder（线程安全使用StringBuffer），最好指定容量。intern()方法intern()方法简单来说就是在字符串常量池中添加指定字符串。在不同版本jdk中有不同的表现，总结如下：在jdk6中，将指定字符串对象尝试放入到常量池。如果常量池中有，则不会放入，返回常量池中已有的对象的地址；如果常量池中没有，则会将当前字符串对象复制一份，然后将复制的放入常量池，并返回常量池中该对象的地址。在jdk7及之后版本，将指定字符串对象尝试放入到常量池。如果常量池中有，则不会放入，返回常量池中已有的对象地址；如果常量池中没有，则会把当前字符串对象的引用地址复制一份放入常量池中，并返回常量池中该引用地址。可以看到在不同版本中，intern()方法最主要的区别在于当常量池中没有指定对象时的操作。在举例intern()方法的使用前，我们先看看下面这两个例子：例一：12345public class StringTest &#123; public static void main(String[] args) &#123; String a = new String("hello"); &#125;&#125;上面main方法中，创建了几个对象？查看字节码：所以上面实际上是创建了两个对象，一个是堆中通过new关键字创建的String对象；一个是字符串常量池中的hello。例二：12345public class StringTest &#123; public static void main(String[] args) &#123; String a = new String("hello") + new String("world"); &#125;&#125;上面main方法中，创建了几个对象？通过上面我们知道new String(&quot;hello&quot;)和new String(&quot;world&quot;)操作创建了四个对象，并且变量拼接内部实际用的是StringBuilder，所以上面还额外创建了一个StringBuilder对象。使用StringBuilder的append方法后，最终调用了StringBuilder的toString方法，该方法内部又创建了一个String对象。所以上面main方法中实际创建了6个对象：new StringBuilder()；new String(“hello”)；常量池中的”hello”；new String(“world”)；常量池中的”world”；toString方法内部创建的new String(“helloworld”)。查看上面代码的字节码也可以证明：此外需要明确的一点是：上面代码中，并没有在常量池中创建”helloworld”！！！查看StringBuilder的toString方法的字节码：有了这两个例子的储备后，我们就可以举几个intern()方法的例子了：例一：12345678public class StringTest &#123; public static void main(String[] args) &#123; String a = new String("hello"); a.intern(); String b = "hello"; System.out.println(a == b); &#125;&#125;上面例子无论是jdk6还是jdk7及以后的版本都返回false。String a = new String(&quot;hello&quot;);代码执行后，堆中通过new创建了一个String(“hello”)对象，字符串常量池中存在”hello”。当执行a.intern()代码时，由于字符串常量池中已经包含”hello”，所以直接返回”hello”的地址。例二：12345678public class StringTest &#123; public static void main(String[] args) &#123; String c = new String("java") + new String("script"); c.intern(); String d = "javascript"; System.out.println(c == d); &#125;&#125;上面例子，在jdk6中返回false，jdk7及之后返回true。String c = new String(&quot;java&quot;) + new String(&quot;script&quot;)代码执行后，字符串常量池中并没有”javascript”。通过前面的介绍我们知道，当字符串常量池中没有目标字符串时，不同版本jdk调用intern()方法内部操作细节不同：jdk6时：常量池中没有”javascript”，则会将当前字符串对象复制一份，然后将复制的放入常量池，并返回常量池中该对象的地址，如下图所示：c和d指向的地址不同，所以返回false。jdk7及之后：常量池中没有”javascript”，则会把当前字符串对象的引用地址复制一份放入常量池中，并返回常量池中该引用地址，如下图所示：c和d指向的地址是一样的，所以返回true。下面再举几个例子供大家思考🤔：1234567891011public class StringTest &#123; public static void main(String[] args) &#123; String a = new String("java") + new String("script"); String b = "javascript"; a.intern(); System.out.println(a == b); // jdk6，jdk7都返回false String c = a.intern(); System.out.println(c == b); // true &#125;&#125;http://www.atguigu.com/download_detail.shtml?v=279 学习笔记]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对象实例化过程]]></title>
    <url>%2FJava%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[本节记录下Java对象实例化过程的一些细节。对象实例化几种方式Java程序中，创建对象主要有以下几种方式：new 关键字创建；通过new关键字调用类构造器创建对象；调用对象的getXXXInstance方法（单例模式）；XXXBuilder/XXXFactory。反射，Class的newInstance方法或者Constructor的newInstance方法；使用类的clone方法；使用反序列化；第三方库Objenesis。对象创建步骤创建对象过程分为以下几个步骤：判断对象对应的类是否已经加载（类加载三个步骤：加载、链接和初始化）；为对象分配内存。计算对象占用空间大小，然后在堆中划分一块内存存放对象。内存分配存在以下两种情况：内存规整时，使用指针碰撞。所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲那一边挪一段与对象大小相等的距离即可。内存不规整时，虚拟机需要维护一个列表，使用空闲列表分配。这种情况下，已使用的内存和未使用的内存相互交错，虚拟机维护了一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新空闲列表。选择哪种分配方式由Java堆内存是否规整决定，而Java堆内存是否规整又取决于垃圾收集器是否带有压缩的功能。处理并发安全问题。虚拟机通过CAS和TLAB来确保并对象创建时的线程安全问题；初始化分配到的空间。内存分配好后，虚拟机将分配到的内存空间都初始化为零值（即默认值，不包括对象头）。设置对象头。将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存放在对象的对象头中。执行&lt;init&gt;方法进行初始化。&lt;init&gt;方法包含了初始化成员变量、执行实例化代码块和调用类的构造方法：1234567891011121314 public class Test &#123; private int a = 111; private int b; private int c; &#123; b = 222; &#125; public Test() &#123; c = 333; &#125;&#125;使用jclasslib查看其&lt;init&gt;method：再次证明了&lt;init&gt;方法包含了初始化成员变量、执行实例化代码块和调用类的构造方法。对象内存布局堆空间里的对象内部包含了以下几个结构：对象头。对象头包含两部分数据：运行时元数据：HashCode、对象年龄、锁状态标志、线程持有的锁等信息；类型指针：指向类元数据，确定对象所属的类型。如果对象是数组，则还需记录数组的长度。实例数据。即类中定义的各种类型属性（包括从父类继承下来的和本身定义的）。实例数据存放具有一定规则：相同宽度的字段总是被分配在一起；父类中定义的变量会出现在子类之前。对齐填充：不是必须的，也没有特殊含义，起到占位符的作用。下面通过一个例子来演示对象的内存布局。现有如下代码：1234567891011121314151617181920212223public class Customer &#123; int id = 100; String name; Account account; &#123; name = "大客户"; &#125; public Customer() &#123; account = new Account(); &#125; public static void main(String[] args) &#123; Customer customer = new Customer(); &#125;&#125;class Account &#123;&#125;main方法创建Customer对象后，相关内存布局如下图所示：http://www.atguigu.com/download_detail.shtml?v=279 学习笔记]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java方法调用细节]]></title>
    <url>%2FJava%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82.html</url>
    <content type="text"><![CDATA[JVM中，类加载过程链接阶段的解析步骤包含将符号引用转换为调用方法的直接引用过程，该过程与方法的绑定机制有关，这节记录下Java方法调用的一些细节。方法绑定机制在聊方法绑定机制之前，我们需要先知道什么是静态链接和动态链接。静态链接：类加载过程中，如果被调用的目标方法在编译期就可以唯一确定，运行期间不会发生改变，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。动态链接：和静态链接相反，如果被调用的目标方法在编译期无法确定下来，只能够在运行期间将调用方法的符号引用转换为直接引用，这种情况被称为动态链接。静态链接和动态链接对应的方法绑定机制分别为早期绑定和晚期绑定。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，仅仅发生一次。举个例子，新建TEST类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Test &#123; public void showBrand(Car car) &#123; car.brand(); &#125; public void showPower(Engine engine) &#123; engine.power(); &#125;&#125;interface Car &#123; void brand();&#125;class Engine &#123; void power() &#123; System.out.println("0马力"); &#125;&#125;class Volvo extends Engine implements Car &#123; @Override public void brand() &#123; System.out.println("Volvo V60 T5"); &#125; @Override void power() &#123; System.out.println("254马力"); &#125;&#125;class Benz extends Engine implements Car &#123; @Override public void brand() &#123; System.out.println("C 200L"); &#125; @Override void power() &#123; System.out.println("156马力"); &#125;&#125;上面代码中，包含一个Car接口和Engine类；Volvo类和Benz类分别都继承了Engine类实现了Car接口，然后都重写了Car接口的brand方法和Engine父类的power方法。Test类的showBrand方法参数为Car接口，showPower方法的参数为Engine类，因为它们在编译期都无法确定参数具体是哪一个类，所以都为晚期绑定。改造Volvo类：12345678910111213141516class Volvo extends Engine implements Car &#123; public Volvo() &#123; super(); &#125; @Override public void brand() &#123; System.out.println("Volvo V60 T5"); &#125; @Override void power() &#123; System.out.println("254马力"); &#125;&#125;我们在Volvo类中添加了一个空参构造器，并调用了父类的空参构造器，因为父类空参构造器可以唯一确定下来就是Engine的空参构造器，在编译期就可以唯一确定，所以这种称为早期绑定。tips：构造方法可以看成是一种特殊的方法，通过jclasslib插件也可以看到，类的构造器也划分在Methods列表中：虚方法和非虚方法非虚方法：方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法。静态方法、私有方法、final方法、实例构造器和父类方法都是非虚方法，其余的方法都称为虚方法；虚方法：和非虚方法相反。方法调用虚拟机指令虚拟机中提供了以下几条方法调用指令：invokestatic：调用静态方法；invokespecial：调用方法（构造器）、私有方法及父类方法；invokevirtual：调用所有虚方法和final修饰的方法；invokeinterface：调用接口方法。Java7后，虚拟机又新增了一个动态调用指令：invokedynamic：动态解析处需要调用的方法，然后执行（实际应用体现在Java8的lambda表达式）。举个例子：1234567891011121314151617181920212223242526272829public class Father &#123; public static void staticMethod() &#123; &#125; public void superMethod() &#123; &#125; protected final void finalMethod() &#123; &#125;&#125;class Son extends Father &#123; public Son() &#123; super(); &#125; public void test() &#123; Father.staticMethod(); privateMethod(); super.superMethod(); finalMethod(); &#125; private void privateMethod() &#123; &#125;&#125;通过jclasslib查看Son类test方法字节码：Son类的无参构造器字节码：前面例子中test类的showBrand方法字节码：前面例子中test类的showPower方法字节码：invokedynamic指令lambda表达式例子（修改Son类，添加dynamicMethod）：123456789101112131415161718192021class Son extends Father &#123; public Son() &#123; super(); &#125; public void test() &#123; Father.staticMethod(); privateMethod(); super.superMethod(); finalMethod(); dynamicMethod(System.out::println); &#125; private void privateMethod() &#123; &#125; public void dynamicMethod(Consumer&lt;String&gt; consumer) &#123; &#125;&#125;查看其test方法字节码：方法重写本质Java方法在被调用时遵循以下几个步骤：找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C；如果在类型C中找到与常量中的描述相符合的方法，则进行访问权限校验，如果校验通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常；否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程；如果始终没找到合适的方法，则抛出java.lang.AbstractMethodError异常。如果方法调用每次都需要按照上面四个步骤搜索的话，势必会消耗一定的性能。所以为了提高性能，JVM采用在类的方法区建立一个虚方法表来实现（非虚方法可以唯一确定，不需要查找，所以没有非虚方法表），使用索引表来代替查找。虚方法表在类加载的链接阶段（解析阶段）被创建。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习笔记]]></title>
    <url>%2FJVM-Learn.html</url>
    <content type="text"><![CDATA[JVM结构JVM（hotspot）结构概览如下图所示：上图中，灰色部分（Java栈，本地方法栈和程序计数器）是线程私有，不存在线程安全问题，橙色部分（方法区和堆）为线程共享区。类加载器类加载器(Class Loader)负责加载class文件，class文件在文件开头有特定的标识。类加载器将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎Execution Engine决定。类加载示意图：类加载器识别的class文件除了是.class格式外，文件的开头还得有特殊的标识，使用文本编辑器打开一个class格式的文件：1234567891011121314151617cafe babe 0000 0034 0010 0a00 0300 0d07000e 0700 0f01 0006 3c69 6e69 743e 01000328 2956 0100 0443 6f64 6501 000f 4c696e65 4e75 6d62 6572 5461 626c 6501 00124c6f 6361 6c56 6172 6961 626c 6554 61626c65 0100 0474 6869 7301 0014 4c63 632f6d72 6269 7264 2f63 6173 2f54 6573 743b0100 0a53 6f75 7263 6546 696c 6501 00095465 7374 2e6a 6176 610c 0004 0005 01001263 632f 6d72 6269 7264 2f63 6173 2f546573 7401 0010 6a61 7661 2f6c 616e 672f4f62 6a65 6374 0021 0002 0003 0000 00000001 0001 0004 0005 0001 0006 0000 002f0001 0001 0000 0005 2ab7 0001 b100 00000200 0700 0000 0600 0100 0000 0300 08000000 0c00 0100 0000 0500 0900 0a00 00000100 0b00 0000 0200 0c这个特定的标识就是十六进制字符cafe babe。类加载器分类类加载器分为4种：启动类加载器启动类加载器BootstrapClassLoader也叫根加载器，是虚拟机自带的加载器，底层由C++实现，用于加载$JAVA_HOME/jre/lib/rt.jar包内的class文件。rt.jar是Java基础类库，包含Java运行环境所需的基础类：举个例子：123456public class Test &#123; public static void main(String[] args) &#123; Object object = new Object(); System.out.println(object.getClass().getClassLoader()); &#125;&#125;Object为Java自带的类，运行结果如下：1null并没有返回预期的BootstrapClassLoader，这是因为BootstrapClassLoader底层是由C++实现的，并非Java实现。拓展类加载器拓展类加载器ExtClassLoader是虚拟机自带的加载器，由Java语言实现，用于加载$JAVA_HOME/jre/lib/ext/**.jar目录下的class文件：这部分主要是Java在迭代过程中，一些拓展的功能。比如：123456public class Test &#123; public static void main(String[] args) &#123; ZipInfo zipInfo = new ZipInfo(); System.out.println(zipInfo.getClass().getClassLoader()); &#125;&#125;ZipInfo是$JAVA_HOME/jre/lib/ext/zipfs.jar包里的一个类，程序运行结果如下：1sun.misc.Launcher$ExtClassLoader@5e2de80c应用程序类加载器应用程序类加载器AppClassLoader是虚拟机自带的加载器，用于加载当前应用的classpath的所有类，也就是我们自己写的那些Java代码，比如：12345public class Test &#123; public static void main(String[] args) &#123; System.out.println(Test.class.getClassLoader()); &#125;&#125;程序运行结果：1sun.misc.Launcher$AppClassLoader@18b4aac2用户自定义加载器除了使用上面三种JVM自带的类加载器外，我们也可以通过继承Java.lang.ClassLoader抽象类自定义一个类加载器。这四种类加载器的关系如下图所示：它们的关系是一种父子关系，我们可以通过代码验证：12345678public class Test &#123; public static void main(String[] args) &#123; Class&lt;Test&gt; testClass = Test.class; System.out.println(testClass.getClassLoader()); System.out.println(testClass.getClassLoader().getParent()); System.out.println(testClass.getClassLoader().getParent().getParent()); &#125;&#125;程序运行结果如下所示：123sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@61bbe9banull类加载步骤类的加载过程分为三个步骤：加载Loading通过一个类的全类名获取其二进制字节流，将这个二进制流代表的静态存储结构转化为方法区的运行时数据结构，然后在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口。链接Linking该过程又可以分为三个阶段：验证Verfication，准备Preparation和解析Resolution）。验证阶段用于确保加载的Class文件的字节流包含的信息是否符合虚拟机要求，保证其正确性合法性；准备阶段为类变量（static修饰的变量）分配内存并根据对象类型设置相应的默认初始值（比如int类型为0，Integer类型为null）。这里不包含常量，因为常量在编译的时候分配，准备阶段会显示初始化。类的实例变量不会在这个阶段准备初始化。解析阶段用于将符号引用转换为直接引用。观察如下代码：1234567public class Test &#123; public static void main(String[] args) &#123; String str = "hello"; System.out.println(str); &#125;&#125;使用javap -v命令查看其字节码：可以看到常量池中有许多符号引用（比如#2），解析阶段就是将其解析为直接引用（比如#2表示字符串常量hello）的过程。初始化Initialization该阶段就是执行类的构造器方法&lt;clinit&gt;()的过程 ；该方法并不是类的构造器，不需要我们自己定义，是javac编译器自动搜集类中的所有类变量的赋值动作和静态代码块中的语句合并而来；创建一个简单的类，包含一个名为aaa的类变量：123456789101112public class Test &#123; private static int aaa = 1; static &#123; aaa = 200; &#125; public static void main(String[] args) &#123; System.out.println(Test.aaa); &#125;&#125;然后通过IDEA的jclasslib插件查看该类的class文件对应的字节码：可以看到上面所说的构造器方法&lt;clinit&gt;()，指令的操作就是为所有类变量赋值以及静态代码块中的操作。换句话说，如果一个类不包含类变量和静态代码块，那么它的字节码中就不会有构造器方法&lt;clinit&gt;()。构造器方法中的指令按照语句在源代码中出现的顺序执行；观察如下代码：123456789101112131415public class Test &#123; private static int aaa = 1; static &#123; aaa = 200; bbb = 300; &#125; private static int bbb = 2; public static void main(String[] args) &#123; System.out.println(Test.bbb); &#125;&#125;上面程序输出结果为2，因为构造器方法中的指令按照语句在源代码中出现的顺序执行，查看构造器方法&lt;clinit&gt;()指令来证明这一点：这里还有一个细节，就是为什么在静态代码块下面才定义的类变量bbb，在静态代码块中可以进行修改呢？这就是Linking阶段中准备阶段所做的事情，准备阶段为类变量（static修饰的变量）分配内存并根据对象类型设置相应的默认初始值。这个时候bbb已经被分配并赋予默认初始值了，所以static块中可以使用该变量（换句话说，实例变量不行）。12345678910111213141516public class Test &#123; private static int aaa = 1; static &#123; aaa = 200; System.out.println(Test.bbb); bbb = 300; &#125; private static int bbb = 2; public static void main(String[] args) &#123; System.out.println(Test.bbb); &#125;&#125;上面输出0 2。下面代码直接编译失败：1234567891011121314151617public class Test &#123; private static int aaa = 1; static &#123; aaa = 200; System.out.println(Test.bbb); bbb = 300; ccc = 400; &#125; private static int bbb = 2; private int ccc = 3; public static void main(String[] args) &#123; System.out.println(Test.bbb); &#125;&#125;因为ccc还没分配初始化呢。若该类包含父类，那么JVM会保证父类的&lt;clinit&gt;()先执行完毕；虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。观察如下代码：12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; Runnable r = () -&gt; &#123; System.out.println(Thread.currentThread().getName() + "开始"); new Hello(); System.out.println(Thread.currentThread().getName() + "结束"); &#125;; new Thread(r, "线程1").start(); new Thread(r, "线程2").start(); &#125;&#125;class Hello &#123; static &#123; if (true) &#123; System.out.println(Thread.currentThread().getName() + "初始化当前类"); while (true) &#123; &#125; &#125; &#125;&#125;程序启动后，main线程启动两个子线程，控制台输出如下：123线程1开始线程2开始线程1初始化当前类然后程序block住，这说明了虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。双亲委派机制聊到类加载器不得不提的另一个话题就是双亲委派机制，在了解什么是双亲委派机制之前，我们先来看个例子：在src/main/java目录下新建java.lang包，然后在该包下新建一个String类：String类的代码如下所示：1234567package java.lang;public class String &#123; public static void main(String[] args) &#123; System.out.println("helo"); &#125;&#125;程序输出结果：123错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为: public static void main(String[] args)否则 JavaFX 应用程序类必须扩展javafx.application.Application所谓的双亲委派机制就是：当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此。只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。所以上面的例子中，AppClassLoader委派给它的父类ExtClassLoader去加载，ExtClassLoader又委托给它的父类BootstrapClassLoader去加载。BootstrapClassLoader从它的加载路径$JAVA_HOME/jre/lib/rt.jar下找到了java.lang.String类，即rt.jar包下的String类，而该类里并没有main方法，所以便抛出了如上异常。采用双亲委派的一个好处是：就如上面所说，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个String对象，所以我们自定义的Java类并不会污染JDK自带的那些类（即使全类名一样），这种保护机制也叫沙箱安全机制。程序计数器程序计数器(Program Counter Register)又叫PC寄存器。每个线程都有一个程序计数器，是线程私有的。它是一个指针，指向方法区中的方法字节码，用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。如果执行的是一个Native方法，那这个计数器的值为undefied。为什么需要程序计数器呢？因为CPU需要不停地切换各个线程，有了程序计数器后，当CPU切换回来后，我们就可以知道接着从哪开始继续执行程序，举个例子，现有如下代码：123456789public class Test &#123; public static void main(String[] args) &#123; int a = 1; int b = 2; int c = a + b; System.out.println(c); &#125;&#125;查看其字节码：假如当前线程的程序计数器存储的指令地址为6，这时候CPU切换到别的线程中处理工作；一段时间后，当前线程重新获取了CPU时间片继续执行时，根据程序计数器存的6就知道，当前需要执行iadd（即a+b操作）指令。执行引擎会将这条指令翻译为机器指令，然后CPU执行该运算操作。虚拟机栈（Java栈）虚拟机栈也称为Java栈，每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用。和PC寄存器一样，虚拟机栈的生命周期和线程一致。虚拟机栈主管Java程序的运行，它保存方法的局部变量（8种基本数据类型，对象引用地址）、部分结果，并参与方法的调用和返回。虚拟机栈示意图如下所示：JVM对虚拟机栈的操作只有压栈（入栈）和出栈操作，遵循FILO原则；在一个活动线程中，一个时间点只会有一个活动的栈帧，即当前正在执行方法对应的栈帧（当前栈帧）；如果一个方法调用了另一个方法，那么对应的新的栈帧将会被创建出来，放在栈顶，成为新的当前栈帧。编写一个简单代码，使用debug的方式来观察入栈和出栈操作：1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; new Test().method1(); &#125; public void method1() &#123; System.out.println("method1 start"); method2(); System.out.println("method1 finish"); &#125; private void method2() &#123; System.out.println("method2 start"); method3(); System.out.println("method2 finish"); &#125; private void method3() &#123; System.out.println("method3 start"); method4(); System.out.println("method3 finish"); &#125; private void method4() &#123; System.out.println("method4 start"); System.out.println("method4 finish"); &#125;&#125;可以看到，执行main方法后，main方法首先入栈，接着调用method1方法，method1方法入栈；method1调用method2，method2入栈；method2调用method3，method3入栈；method3调用method4，method4入栈；method4执行结束，正常退出，method4出栈；method4出栈后，当前栈帧变为method3对应的栈帧；method3执行结束正常退出，method3出栈……以此类推，最终main方法执行结束出栈，程序结束。Java方法执行结束正常退出和抛出异常这两种情况会导致栈帧被弹出（退出）。虚拟机栈大小调整Java虚拟机规范允许虚拟机栈的大小固定不变或者动态扩展。固定情况下：如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，则抛出StackOverflowError异常；可动态扩展情况下：尝试扩展的时候无法申请到足够的内存；或者在创建新的线程的时候没有足够的内存去创建对应的虚拟机栈，则会抛出OutOfMemoryError异常。不同平台的虚拟机栈默认大小不同：Linux/x64 (64-bit): 1024 KBmacOS (64-bit): 1024 KBOracle Solaris/x64 (64-bit): 1024 KBWindows: 默认值取决于虚拟内存。我们可以通过-Xss设置虚拟机栈大小，默认单位为字节。也可以通过k或者K指定单位为KB，m或M指定单位为MB，g或G指定单位为GB。下面这组配置都是将虚拟机栈大小设置为1024KB：123-Xss1m-Xss1024k-Xss1048576虚拟机栈越大，方法调用深度越深，举个例子：123456789public class Test &#123; private static int count = 1; public static void main(String[] args) &#123; System.out.println(count); count++; main(args); &#125;&#125;在macOS平台下，虚拟机栈的默认大小为1024KB，程序运行结果如下：1234567891011......1081710818108191082010821108221082310824*** java.lang.instrument ASSERTION FAILED ***: &quot;!errorOutstanding&quot; with message transform method call failed at JPLISAgent.c line: 844Exception in thread &quot;main&quot; java.lang.StackOverflowError程序输出10824后抛出StackOverflowError；我们通过-Xss200k命令将虚拟机栈大小调整为200KB再观察输出结果：1234567891011......121412151216121712181219*** java.lang.instrument ASSERTION FAILED ***: &quot;!errorOutstanding&quot; with message transform method call failed at JPLISAgent.c line: 844*** java.lang.instrument ASSERTION FAILED ***: &quot;!errorOutstanding&quot; with message transform method call failed at JPLISAgent.c line: 844*** java.lang.instrument ASSERTION FAILED ***: &quot;!errorOutstanding&quot; with message transform method call failed at JPLISAgent.c line: 844Exception in thread &quot;main&quot; java.lang.StackOverflowError可以看到，方法调用深度明显变小了。栈帧内部结构每个栈帧包含5个组成部分：局部变量表（Local Variables）、操作数栈（Operand Stack）、动态链接（Dynamic Linking）、方法返回地址（Return Address）和一些附加信息：局部变量表局部变量表是一个数字数组，用于存储方法参数和方法体内的局部变量。下面Test类包含hello静态方法：1234567public class Test &#123; public static void hello(String name) &#123; Date date = new Date(); int count = 1; &#125;&#125;使用javap -v命令查看其字节码：非静态方法的局部变量表和静态方法相比，多了个this对象（即当前类）：1234567public class Test &#123; public void halo(String name) &#123; Date date = new Date(); int count = 1; &#125;&#125;可以看到，非静态方法的局部变量表首位就存放了this对象，这也是静态方法内无法使用this的原因（因为静态方法的局部变量表中没有this对象）。局部变量表数组容量的大小在编译期就可以唯一确定下来，并保存在方法的Code属性的maximum locacl variables数据项中，就拿上面Test类的hello方法来说，其字节码里已经指明了局部变量表的大小：通过jclasslib插件也可以看到局部变量表的大小：局部变量表的最基本单元是变量槽（Slot）。局部变量表中32位以内的数据类型（除long和double外）只占用一个slot，64位类型（long和double）占用两个slot。举个例子：123456789public class Test &#123; public static void hello(String name) &#123; Date date = new Date(); long number = 200L; double salary = 6000.0; int count = 1; &#125;&#125;此外，通过局部变量表包含的信息，我们还可以得出局部变量的作用范围。举个例子，当前有如下代码：查看其字节码：以方法参数name为例，查看LocalVariableTable，name参数对应的Start列的值为0，表示其在第0行字节码指令处生效（通过LineNumberTable我们可以知道，第0行字节码指令对应程序中的第6行代码）；Length列的值为3，说明name参数的有效作用域长度为3，因为name是在第0行字节码指令处生效的，所以name在0 ~ 2行字节码指令范围内有效（通过LineNumberTable的对应关系，我们也可以知道name在我们的代码中作用域范围为第6行到第7行）。局部变量表的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量很有可能会复用过期局部变量的槽位。举个例子，现有如下代码：12345678910public class Test &#123; public static void hello(String name) &#123; &#123; int a = 1; System.out.println(a); &#125; int b = 2; &#125;&#125;查看其局部变量表：可以看到局部变量a和b的槽位都是1，说明槽位重复利用了。这是因为在定义局部变量b的时候，局部变量a已经出了作用域失效销毁了，但是局部变量表的槽位已经开辟了，所以局部变量b直接重复利用索引为1的槽位。操作数栈每一个独立的栈帧中除了包含局部变量表外，还包含一个FILO的操作数栈，用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。每个操作数栈都有一个明确的深度，在编译期已经确定下来：123456789public class Test &#123; public int add() &#123; int a = 1; int b = 1; int c = a + b; return c; &#125;&#125;查看其字节码：栈中的任何一个元素都可以是任意的Java数据类型，32bit的类型占用一个栈深度，64bit的类型占用两个栈单位深度：123456public class Test &#123; public void test() &#123; int a = 1; &#125;&#125;查看其字节码：操作数栈深度为1。将代码的局部变量a类型改为64bit的double类型：123456public class Test &#123; public void test() &#123; double b = 1.0; &#125;&#125;操作数栈深度为2。操作数栈在方法的执行过程中，根据字节码指令往栈中写入数据或提取数据，即入栈和出栈操作。虽然栈是用数组实现的，但根据栈的特性，对栈中数据访问不能通过索引，而是只能通过标准的入栈和出栈操作来完成一次数据访问。下面通过一个例子来感受PC寄存器，局部变量表和操作数栈是如何相互配合完成一次方法的执行，代码如下所示：12345678public class Test &#123; public void add() &#123; int a = 15; int b = 1; int c = a + b; &#125;&#125;在查看字节码指令之前，先记录下几个入栈出栈的字节码指令含义：当int取值 -1 ~ 5 采用iconst指令入栈；取值 -128 ~ 127（byte有效范围）采用bipush指令入栈；取值 -32768 ~ 32767（short有效范围）采用sipush指令入栈；取值 -2147483648 ~ 2147483647（int有效范围）采用ldc指令入栈；istore，栈顶元素出栈，保存到局部变量表中；iload，从局部变量表中加载数据入栈。更多字节码指令含义后续深入学习Java虚拟机字节码指令再说🌚。上面方法对应的字节码如下：指令执行过程中，PC寄存器，局部变量表和操作数栈状态如下图所示：如果被调用的方法带有返回值的话，其返回值会被压入当前栈帧的操作数栈中。动态链接在Java源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里，动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用，比如：12345public class Test &#123; public void hello() &#123; System.out.println("hello"); &#125;&#125;其字节码中的常量池如下：比如符号#27就表示为一个打印流。方法返回地址存放调用该方法的pc寄存器的值。一个方法的结束分为以下两种方式：正常执行结束；出现未处理异常，非正常退出。无论是哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc寄存器的值作为返回地址，即调用该方法的指令的下一条指令地址；异常退出时，返回地址需要通过异常表来确定。一些附加信息比如对程序调式提供的支持信息。本地方法接口本地方法接口(Native Interface)的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。Java诞生的时候是 C/C++横行的时候，要想立足，必须调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码。比如查看java.lang.Thread类源码就会发现当中存在许多native方法：native方法没有方法体（因为不是Java实现），所以看上去像是“接口”一样，故得名本地方法接口。本地方法栈如前所述，虚拟机栈用于管理Java方法的调用，而本地方法栈则是用于管理本地方法的调用。堆（Heap）堆（Heap）一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。堆中保存着所有引用类型的真实信息，以方便执行器执行。堆在逻辑上分为三个区域：Java7：Java8：可以看到，在Java7时代，堆分为新生区（新生区包含伊甸园区和幸存区，幸存区又包含幸存者0区和幸存者1区。此外，幸存者0区又称为From区，幸存者1区又称为To区，From区和To区并不是固定的，复制之后交互，谁空谁是To），养老区和永久代；在Java8中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。元空间与永久代之间最大的区别在于：永久代使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存（所以在上图中，我用虚线表示）。堆之所以要分区是因为：Java程序中不同对象的生命周期不同，70%~99%对象都是临时对象，这类对象在新生区“朝生夕死”。如果没有分区，GC时搜集垃圾需要对整个堆内存进行扫描；分区后，回收这些“朝生夕死”的对象，只需要在小范围的区域中（新生区）搜集垃圾。所以，分区的唯一理由就是为了优化GC性能。堆空间对象分配过程下面通过一个例子来讲述这几个区的交互逻辑：1.几乎任何新的对象都是在伊甸园区被new出来创建，刚开始的时候两个幸存者区和养老区都是空的：2.随着对象的不断创建，伊甸园区空间逐渐被填满：3.这时候将触发一次Minor GC（Young GC），删除未引用的对象，GC剩下来的还存在引用的对象将移动到幸存者0区，然后清空伊甸园区：4.随着对象的创建，伊甸园区空间又满了，再一次触发Minor GC，删除未引用的对象，留下存在引用的对象。这次和上一次Minor GC有些不同，这轮GC留下的对象将被移动到幸存者1区，并且上一轮GC留下来的存储在幸存者0区的对象年龄递增并移动到幸存者1区。当所有幸存对象都移动到幸存者1区后，幸存者0区和伊甸园区空间清除：5.随着对象的创建伊甸园区空间再一次满了，触发了第三次Minor GC，这一次幸存区空间将发生互换，GC留下来的幸存者将移动到幸存者0区，幸存者1区的幸存对象年龄递增后也移动到幸存者0区，然后伊甸园区和幸存者1区的空间被清除：6.随着Minor GC的不断发生，幸存对象在两个幸存区不断地交换存储，年龄也不断递增。如此反反复复之后，当幸存对象的年龄达到指定的阈值（这个例子中是8，由JVM参数MaxTenuringThreshold决定）后，它们将被移动到养老区：7.随着上述过程的不断出现，当养老区快满时，将触发Major GC（Full GC）进行养老区的内存清理。若养老区执行了GC之后发现依然无法进行对象的保存，就会产生OOM异常。一个对象被放置到养老区除了它的年龄达到阈值外，以下几种情况也会使得该对象直接被放置到养老区：对象创建后，无法放置到伊甸园区（比如伊甸园区的大小为10m，新的对象大小为11m，伊甸园区不够放，触发YGC。YGC后伊甸园区被清空，但还是无法容下11m的“超大对象”，所以直接放置到养老区。当然如果养老区放置不下则会触发FGC，FGC后还放不下则OOM）；YGC后，对象无法放置到幸存者To区也会直接晋升到养老区；如果幸存区中相同年龄的所有对象大小大于幸存区空间的一半，年龄大于或等于这些对象年龄的对象可以直接进入养老区，无需等到年龄阈值。堆参数以JDK1.8+HotSpot为例，常用的可调整的堆参数有：参数含义-Xms，等价于-XX:InitialHeapSize设置堆的初始内存大小，默认为物理内存的1/64-Xmx，等价于-XX:MaxHeapSize设置堆的最大内存大小，默认为物理内存的1/4-XX:Newratio设置新生区和养老区的比例，比如值为2（默认值），则养老区是新生区的2倍，即养老区占据堆内存的2/3-XX:Surviorratio设置伊甸园区和一个幸存区的比例，比如值为8（默认值）则表示伊甸园区占新生区的8/10（两个幸存区是一样大的）-Xmn设置堆新生区的内存大小（一般不使用）-XX:MaxTenuringThreshold设置转入养老区的存活次数，默认值为15-XX:+PrintFlagsInitial查看所有参数的默认初始值-XX:+PrintFlagsFinal查看所有参数的最终值（被我们修改后的值不再是默认初始值）剩下所有可用参数可以查看oracle官方文档：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html。生产环境中，推荐将-Xms和-Xmx设置为一样大，因为这样做的话在Java垃圾回收清理完堆区后不需要重新计算堆区大小，从而提高性能。此外，要在程序中输出详细的GC处理日志，可以使用-XX:+PrintGCDetails。比如，我的电脑内存为32GB，所以堆的默认初始值大小为500MB左右，堆的最大值大约为8000MB左右：123456789public class Test &#123; public static void main(String[] args) &#123; long maxMemory = Runtime.getRuntime().maxMemory(); long totalMemory = Runtime.getRuntime().totalMemory(); System.out.println("堆内存的初始值" + totalMemory / 1024 / 1024 + "mb"); System.out.println("堆内存的最大值" + maxMemory / 1024 / 1024 + "mb"); &#125;&#125;程序输出：12堆内存的初始值491mb堆内存的最大值7282mb可以通过IDEA调整堆的大小：我们将堆内存的初始大小和最大值都设置为10mb，并且开启GC日志打印，重新运行下面这段程序：123456789public class Test &#123; public static void main(String[] args) &#123; long maxMemory = Runtime.getRuntime().maxMemory(); long totalMemory = Runtime.getRuntime().totalMemory(); System.out.println("堆内存的初始值" + totalMemory / 1024 + "kb"); System.out.println("堆内存的最大值" + maxMemory / 1024 + "kb"); &#125;&#125;输出如下所示：1234567891011堆内存的初始值9728kb堆内存的最大值9728kbHeap PSYoungGen total 2560K, used 1388K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000) eden space 2048K, 67% used [0x00000007bfd00000,0x00000007bfe5b370,0x00000007bff00000) from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 7168K, used 0K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000) object space 7168K, 0% used [0x00000007bf600000,0x00000007bf600000,0x00000007bfd00000) Metaspace used 2947K, capacity 4496K, committed 4864K, reserved 1056768K class space used 320K, capacity 388K, committed 512K, reserved 1048576K可以看到，PSYoungGen（新生区）的总内存大小为2560k，ParOldGen（养老区）的总内存大小为7168k，总和刚好是9728K，这也说明了：Java8后的堆物理上只分为新生区和养老区，Metaspace（元空间）不占用堆内存，而是直接使用物理内存。那为什么我们设置的堆内存大小是10m（10240kb），控制台输出却只有9728kb呢？从上面的例子我们知道，幸存者区分为0区和1区，根据复制算法的特点，这两个区同一时刻总有一个区是空的，所以控制台输出的内存计算方式为：2048K(eden space)+512K(from space or to space)+7168K(ParOldGen)=9728K。9728K再加一个幸存区的大小512K刚好是10240K。再举个OOM的例子，使用刚刚-Xms10m -Xmx10m -XX:+PrintGCDetails的设置，运行下面这段程序：12345678public class Test &#123; public static void main(String[] args) &#123; String value = "hello"; while (true) &#123; value += value + new Random().nextInt(1000000000) + new Random().nextInt(1000000000); &#125; &#125;&#125;输出如下：12345678910111213141516171819202122232425262728[GC (Allocation Failure) [PSYoungGen: 1893K-&gt;491K(2560K)] 1893K-&gt;597K(9728K), 0.0007246 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2207K-&gt;496K(2560K)] 2313K-&gt;1153K(9728K), 0.0008383 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2007K-&gt;496K(2560K)] 2664K-&gt;1897K(9728K), 0.0009456 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 2021K-&gt;496K(2560K)] 4894K-&gt;4113K(9728K), 0.0010814 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1359K-&gt;496K(2560K)] 6448K-&gt;5600K(9728K), 0.0015792 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 496K-&gt;496K(1536K)] 5600K-&gt;5600K(8704K), 0.0006416 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 496K-&gt;0K(1536K)] [ParOldGen: 5104K-&gt;2585K(7168K)] 5600K-&gt;2585K(8704K), [Metaspace: 2982K-&gt;2982K(1056768K)], 0.0044783 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 61K-&gt;192K(2048K)] 7061K-&gt;7192K(9216K), 0.0012566 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 192K-&gt;0K(2048K)] [ParOldGen: 7000K-&gt;1840K(7168K)] 7192K-&gt;1840K(9216K), [Metaspace: 3042K-&gt;3042K(1056768K)], 0.0072023 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 65K-&gt;160K(2048K)] 6321K-&gt;6416K(9216K), 0.0022603 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 160K-&gt;0K(2048K)] [ParOldGen: 6256K-&gt;4785K(7168K)] 6416K-&gt;4785K(9216K), [Metaspace: 3076K-&gt;3076K(1056768K)], 0.0056740 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 4785K-&gt;4785K(9216K), 0.0003871 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 4785K-&gt;4765K(7168K)] 4785K-&gt;4765K(9216K), [Metaspace: 3076K-&gt;3076K(1056768K)], 0.0049903 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] Heap PSYoungGen total 2048K, used 59K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000) eden space 1024K, 5% used [0x00000007bfd00000,0x00000007bfd0efb8,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) ParOldGen total 7168K, used 4765K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000) object space 7168K, 66% used [0x00000007bf600000,0x00000007bfaa77b8,0x00000007bfd00000) Metaspace used 3113K, capacity 4496K, committed 4864K, reserved 1056768K class space used 339K, capacity 388K, committed 512K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:674) at java.lang.StringBuilder.append(StringBuilder.java:208) at cc.mrbird.Test.main(Test.java:19)可以看到，经过数次的GC和Full GC后，堆内存还是无法腾出空间，最终抛出OOM错误。日志的含义如下图所示：Young GC（Minor GC）：Full GC（Major GC）：TLABJVM对伊甸园区继续进行划分，为每个线程分配了一个私有缓存区域，这块区域就是TLAB（Thread Local Allocation Buffer）。多线程同时分配内存时，使用TLAB可以避免一系列非线程安全问题，同时还能够提升内存分配的吞吐量。尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选：我们可以使用-XX:UseTLAB设置是否开启TLAB，举个例子：1234567public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; TimeUnit.SECONDS.sleep(100); &#125;&#125;运行main方法：可以看到TLAB默认是开启的。TLAB空间的内存非常小，仅占整个伊甸园区的1%，可以通过-XX:TLABWasteTargetPercent设置TLAB空间所占用伊甸园区空间的百分比。有了TLAB的概念后，我们就不能说堆空间一定是线程共享的了。方法区方法区并不是所谓的存储方法的区域，而是供各线程共享的运行时内存区域。它存储了已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。方法区也是一种规范，在不同虚拟机里头实现是不一样的，最典型的实现就是HotSpot虚拟机Java8之前的永久代(PermGen space)和Java8的元空间(Metaspace)。设置方法区大小方法区的大小决定了系统可以加载多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机则会抛出java.lang.OutOfMemoryError: PermGen space（Java 7）或者java.lang.OutOfMemoryError: Metaspace（Java 8）内存溢出错误。以Java8版本为例，我们可以使用-XX:MetaspaceSize=size设置元空间初始大小，-XX:MaxMetaspaceSize=size设置元空间最大值。默认情况下，在windows平台上，-XX:MetaspaceSize值为21M，-XX:MaxMetaspaceSize值为-1，即没有限制，所以极端情况下如果不断地加载类，虚拟机会耗尽所有可用的系统内存。下面举个元空间OOM的例子：1234567891011121314151617181920212223242526import com.sun.org.apache.bcel.internal.util.ClassLoader;import com.sun.xml.internal.ws.org.objectweb.asm.ClassWriter;import jdk.internal.org.objectweb.asm.Opcodes;public class Test extends ClassLoader &#123; public static void main(String[] args) &#123; int count = 0; try &#123; Test test = new Test(); for (int i = 0; i &lt; 10000; i++) &#123; String className = "Class" + i; // 创建ClassWriter对象，用于生成类的二进制字节码 ClassWriter classWriter = new ClassWriter(0); // 指定版本号、修饰符、类名、包名、父类和接口 classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, className, null, "java/lang/Object", null); byte[] bytes = classWriter.toByteArray(); // 加载类 test.defineClass(className, bytes, 0, bytes.length); count++; &#125; &#125; finally &#123; System.out.println(count); &#125; &#125;&#125;上面例子中，我们尝试加载10000个类，通过参数-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m将元空间大小设置为固定大小10M，运行上面的程序控制台输出：方法区、堆、栈关系方法区和堆、栈的关系如下图所示：123456public class Bird &#123; public static void main(String[] args) &#123; Bird bird = new Bird(); &#125;&#125;方法区内部结构方法区内部主要存储了以下内容（不同JDK版本内容有所不同，具体参考下面“方法区演进”）：类型信息对每个加载的类型（类class、接口 interface、枚举enum、注解 annotation），JVM必须在方法区中存储以下类型信息：这个类型的完整有效名称（包名.类名）；这个类型直接父类的完整有效名（interface和java.lang.Object没有父类）；这个类的修饰符（public，abstract，final）；这个类型直接接口的一个有序列表（一个类可以实现多个接口）。方法信息方法信息包含了这个类的所有方法信息（包括构造器），这些信息和其声明顺序一致：方法名称；方法的返回值类型（没有返回值则是void）；方法参数的数量和类型（有序）；方法的修饰符（public，private，protected，static，final，synchronized，native，abstract）；方法的字节码、操作数栈、局部变量表及其大小（abstract和native方法除外）；异常表（abstract和native方法除外）。域信息域Field我们也常称为属性，字段。域信息包含：域的声明顺序；域的相关信息，包括名称、类型、修饰符（public，private，protected，static，final，volatile，transient）。JIT代码缓存这部分在👇执行引擎中再做说明。运行时常量池在上面虚拟机栈的介绍中，我们知道类字节码反编译后，会有一个constant pool的结构，俗称为常量池，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。虚拟机栈的动态链接就是将符号引用（这些符号引用的集合就是常量池）转换为直接引用（符号引用对应的具体信息，这些具体信息的集合就是运行时常量池，存在方法区中）的过程。静态变量静态变量就是使用static修饰的域信息。静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。静态变量也成为类变量，类变量被类的所有实例共享，即使没有类实例时你也可以访问它：1234567891011121314public class Test &#123; private static String hello = "hello"; private static void hello() &#123; System.out.println("hello"); &#125; public static void main(String[] args) &#123; Test test = null; test.hello(); System.out.println(test.hello); &#125;&#125;上面程序运行并不会报空指针异常。通过final修饰的静态变量我们俗称常量。常量在编译的时候就会被分配具体值：12345public class Test &#123; private static String hello = "hello"; private static final String HELLO = "hello";&#125;通过javap -v -p Test.class查看其字节码：通过上面的学习我们知道，静态变量（类变量）在类加载过程的初始化阶段才会被赋值。演示方法区内部结构下面通过字节码内容来查看上面这些信息，现有如下代码：1234567891011121314151617181920public class Test extends Object implements Cloneable, Serializable &#123; private static String hello = "hello"; private static final String HELLO = "hello"; public int a = 0; public void method1() &#123; System.out.println("method1"); &#125; public static String method2(String name) &#123; try &#123; int a = 1; int b = a / 0; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return name; &#125;&#125;通过javap -v -p Test.class查看其字节码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171Classfile /Users/mrbird/idea workspace/JVM-Learn/target/classes/cc/mrbird/jvm/learn/Test.class Last modified 2019-4-01; size 1016 bytes MD5 checksum ab0309674b0f0b5fbd0766af035efe0a Compiled from "Test.java"// 类型信息public class cc.mrbird.jvm.learn.Test implements java.lang.Cloneable,java.io.Serializable minor version: 0 major version: 52 // 类的修饰符 flags: ACC_PUBLIC, ACC_SUPER// 常量池Constant pool: #1 = Methodref #11.#38 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #10.#39 // cc/mrbird/jvm/learn/Test.a:I #3 = Fieldref #40.#41 // java/lang/System.out:Ljava/io/PrintStream; #4 = String #27 // method1 #5 = Methodref #42.#43 // java/io/PrintStream.println:(Ljava/lang/String;)V #6 = Class #44 // java/lang/Exception #7 = Methodref #6.#45 // java/lang/Exception.printStackTrace:()V #8 = String #14 // hello #9 = Fieldref #10.#46 // cc/mrbird/jvm/learn/Test.hello:Ljava/lang/String; #10 = Class #47 // cc/mrbird/jvm/learn/Test #11 = Class #48 // java/lang/Object #12 = Class #49 // java/lang/Cloneable #13 = Class #50 // java/io/Serializable #14 = Utf8 hello #15 = Utf8 Ljava/lang/String; #16 = Utf8 HELLO #17 = Utf8 ConstantValue #18 = Utf8 a #19 = Utf8 I #20 = Utf8 &lt;init&gt; #21 = Utf8 ()V #22 = Utf8 Code #23 = Utf8 LineNumberTable #24 = Utf8 LocalVariableTable #25 = Utf8 this #26 = Utf8 Lcc/mrbird/jvm/learn/Test; #27 = Utf8 method1 #28 = Utf8 method2 #29 = Utf8 (Ljava/lang/String;)Ljava/lang/String; #30 = Utf8 e #31 = Utf8 Ljava/lang/Exception; #32 = Utf8 name #33 = Utf8 StackMapTable #34 = Class #44 // java/lang/Exception #35 = Utf8 &lt;clinit&gt; #36 = Utf8 SourceFile #37 = Utf8 Test.java #38 = NameAndType #20:#21 // "&lt;init&gt;":()V #39 = NameAndType #18:#19 // a:I #40 = Class #51 // java/lang/System #41 = NameAndType #52:#53 // out:Ljava/io/PrintStream; #42 = Class #54 // java/io/PrintStream #43 = NameAndType #55:#56 // println:(Ljava/lang/String;)V #44 = Utf8 java/lang/Exception #45 = NameAndType #57:#21 // printStackTrace:()V #46 = NameAndType #14:#15 // hello:Ljava/lang/String; #47 = Utf8 cc/mrbird/jvm/learn/Test #48 = Utf8 java/lang/Object #49 = Utf8 java/lang/Cloneable #50 = Utf8 java/io/Serializable #51 = Utf8 java/lang/System #52 = Utf8 out #53 = Utf8 Ljava/io/PrintStream; #54 = Utf8 java/io/PrintStream #55 = Utf8 println #56 = Utf8 (Ljava/lang/String;)V #57 = Utf8 printStackTrace&#123; // 域信息 private static java.lang.String hello; descriptor: Ljava/lang/String; flags: ACC_PRIVATE, ACC_STATIC // 域信息 private static final java.lang.String HELLO; descriptor: Ljava/lang/String; flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL ConstantValue: String hello // 域信息 public int a; descriptor: I flags: ACC_PUBLIC // 方法信息 public cc.mrbird.jvm.learn.Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: iconst_0 6: putfield #2 // Field a:I 9: return LineNumberTable: line 5: 0 line 9: 4 LocalVariableTable: Start Length Slot Name Signature 0 10 0 this Lcc/mrbird/jvm/learn/Test; // 方法信息 public void method1(); descriptor: ()V flags: ACC_PUBLIC Code: // 操作数栈大小，局部变量表大小，参数个数 stack=2, locals=1, args_size=1 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String method1 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 this Lcc/mrbird/jvm/learn/Test; // 方法信息 public static java.lang.String method2(java.lang.String); descriptor: (Ljava/lang/String;)Ljava/lang/String; flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: iconst_1 1: istore_1 2: iload_1 3: iconst_0 4: idiv 5: istore_2 6: goto 14 9: astore_1 10: aload_1 11: invokevirtual #7 // Method java/lang/Exception.printStackTrace:()V 14: aload_0 15: areturn // 异常表 Exception table: from to target type 0 6 9 Class java/lang/Exception LineNumberTable: line 17: 0 line 18: 2 line 21: 6 line 19: 9 line 20: 10 line 22: 14 // 局部变量表 LocalVariableTable: Start Length Slot Name Signature 2 4 1 a I 10 4 1 e Ljava/lang/Exception; 0 16 0 name Ljava/lang/String; StackMapTable: number_of_entries = 2 frame_type = 73 /* same_locals_1_stack_item */ stack = [ class java/lang/Exception ] frame_type = 4 /* same */ static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 0: ldc #8 // String hello 2: putstatic #9 // Field hello:Ljava/lang/String; 5: return LineNumberTable: line 7: 0&#125;SourceFile: "Test.java"方法区的演进随着JDK的迭代升级，Hotspot中方法区的存储的内容发生了如下变化（上面介绍的方法区的内部结构是经典情况下的，具体还是需要看JDK是什么版本）：版本描述jdk1.6及之前有永久代（permanent generation），静态变量存放在永久代上jdk1.7有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中jdk1.8及之后无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍然保存在堆中上面说的静态变量在JDK1.6之前存放在永久代，JDK1.7后移动到堆空间指的是变量本身，变量对应的对象实例一直都是在堆空间分配的。举个例子：123456789101112131415public class StaticObjTest &#123; static class Test &#123; static ObjectHolder staticObj = new ObjectHolder(); ObjectHolder instanceObj = new ObjectHolder(); void foo() &#123; ObjectHolder localObj = new ObjectHolder(); &#125; &#125; private static class ObjectHolder &#123; &#125;&#125;这个例子中，三个new ObjectHolder()的创建，都是在堆中分配的，localObj是方法foo内的局部变量，存放在虚拟机栈的局部变量表中；instanceObj为成员变量，随着对象实例的创建也分配在堆中；静态变量staticObj根据JDK版本的不同存放位置也不同，JDK1.6及之前，存放在永久代中，JDK1.7及之后存放到堆中。永久代为什么会被元空间替代？因为永久代的大小是很难确定的，如果一个程序动态加载的类过多就很容易触发永久代的Full GC（Full GC代价大，耗时长，影响程序性能）甚至OOM，程序直接奔溃；而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，这样元空间就基本不会因为触发Full GC和OOM了。字符串常量池（StringTable）为什么要放到堆中？因为如果将StringTable放在永久代的话回收效率很低，在Full GC的时候才会触发。而Full GC是老年代的空间不足、永久代不足时才会触发。这就导致 StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。方法区垃圾回收方法区也存在垃圾回收，方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。执行引擎类加载器加载的字节码并不能够直接运行在操作系统之上，因为字节码指令不是本地机器指令，执行引擎（Execute Engine）的任务就是讲字节码指令解释为对应平台上的本地机器指令。通俗地讲，执行引擎就是将高级语言翻译为本地机器语言的翻译官。解释器和JIT编译器解释器（Interpreter）：JVM在程序运行时通过解释器逐行将字节码转为本地机器指令执行；JIT编译器（Just In Time Compiler，即时编译器）：解释器的优点是程序一启动就可以马上发挥作用，逐行翻译字节码执行程序。而对于一些高频的代码（如循环体内代码和高频调用方法等），如果每次执行都用解释器逐行将字节码翻译为机器指令的话，势必会造成浪费，所以我们可以通过即时编译器将这部分高频代码直接编译为机器指令然后缓存在方法区中（上面介绍方法区内部组成时提到过JIT代码缓存），以此提高执行效率。和解释器相比，即时编译器的缺点就是编译需要耗费一定时间。正因为JVM在执行Java代码的时候，通常会将解释执行和编译执行二者结合起来进行，所以Java也可以说是一种半编译半解释型语言。热点代码hotspot通过两种方式来确定当前代码是否为热点代码：方法调用计数器：统计方法调用的次数；回边计数器：统计循环体执行的循环次数。当一个方法被调用时，会先检查该方法是否存在被JIT编译器编译过的版本，如果存在，则使用编译后的本地代码执行；如果不存在，则将方法的调用计数器加1，然后判断方法调用计数器和回边计数器之和是否超过方法调用计数器的阈值。如果超过，则会向JIT编译器提交一个该方法的代码编译请求。上面的阈值可以使用-XX:CompileThreshold设定，默认值在Client模式下是1500，在Server模式下是10000。方法调用计数器统计的并不是方法被调用的绝对次数，而是在一定时间范围内的次数。超过这个时间范围，这个方法计数器就会减少一半，这个过程称为热度衰减，这个时间周期称为半衰周期。可以通过-XX:CounterHalfLifeTime设置半衰周期（单位S），-XX:-UseCounterDecay来关闭热度衰减。模式设置默认情况下，hotspot采用混合模式架构（即解释器和JIT编译器并存的架构），我们可以通过下面这些指令来切换模式：-Xint：完全采用解释器模式执行程序；-Xcomp：完全采用即时编译器模式执行程序，如果即时编译器出现问题，解释器会介入执行；-Xmixed：混合模式。JIT编译器分类hotspot内置两种JIT编译器：Client Compiler和Server Compiler，也称为C1编译器和C2编译器。我们可以通过下面这些指令来指定使用哪种JIT编译器：-client：指定Java虚拟机运行在Client模式下，并使用C1编译器。C1编译器会对字节码进行简单和可靠的优化，耗时短，已达到更快的编译速度；-server：指定Java虚拟机运行在Server模式下，并使用C2编译器。C2编译器进行耗时较长的优化，以及激进优化，虽然编译耗时更长，但代码执行效率更高（64位JDK只支持Server模式）。参考文章：https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.htmlhttps://docs.oracle.com/en/java/javase/11/tools/java.htmlhttps://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.htmlhttp://www.atguigu.com/download_detail.shtml?v=279]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java BlockingQueue && BlockingDeque]]></title>
    <url>%2FJava-BlockingQueue.html</url>
    <content type="text"><![CDATA[BlockingQueue即阻塞队列，一个阻塞队列在数据结构中起到的作用大致如下图所示：上图中，线程1往阻塞队列中添加元素，线程2从阻塞队列中移出元素。当阻塞队列是空的时候，从队列中获取元素的操作将会被阻塞；当阻塞队列是满的时候，往队列中添加元素的操作将会被阻塞。使用BlockingQueue的好处是，我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，这些都由BlockingQueue自动完成。7大实现类BlockingQueue是一个接口类，主要有7种实现类型，UML类图如下所示：ArrayBlockingQueue：由数组机构组成的有界阻塞队列；LinkedBlockingQueue：由链表结构组成的有界（默认大小非常大，为Integer.MAX_VALUE）阻塞队列；PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列；DelayQueue：一个使用优先级队列实现的无界阻塞队列；SynchronousQueue：一个不存储元素的阻塞队列；LinkedTransferQueue：一个由链表结构组成的无界阻塞队列；LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。前六种都是单向队列，实现的是BlockingQueue接口，LinkedBlockingDeque是一个双向队列，实现的是BlockDeque接口，该接口继承了BlockingQueue接口。常用方法BlockingQueue的相关方法大致可以分为以下四种类型：方法描述抛出异常返回特殊的值一直阻塞超时退出插入数据add(e)offer(e)put(e)offer(e,time,unit)获取并移除队列的头remove()poll()take()poll(time,unit)获取但不移除队列的头element()peek()不可用不可用抛出异常：当阻塞队列满时，再往队列里add插入元素就会抛出IllegalStateException: Queue full；当阻塞队列空时，再往队列里remove移出元素就会抛出NoSuchElementException；返回特殊值：插入方法，成功时返回true，失败时返回false；移出方法，成功时候返回移出队列的元素，没有元素就返回null；一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到消费者取出数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用；超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。当阻塞队列为空时，队列会阻塞消费者线程一段时间，如果超过一定时间，消费者线程就会退出。BlockDeque也提供了这四种类型对应的方法，不过由于是双向队列，所以这些方法可以分为头部操作和尾部操作：头部操作：方法描述抛出异常返回特殊的值一直阻塞超时退出插入数据addFirst(e)offerFirst(e)putFirst(e)offerFirst(e, time, unit)获取并移除队列的头removeFirst()pollFirst()takeFirst()pollFirst(time, unit)获取但不移除队列的头getFirst()peekFirst()不适用不适用尾部操作：方法描述抛出异常返回特殊的值一直阻塞超时退出插入数据addLast(e)offerLast(e)putLast(e)offerLast(e, time, unit)获取并移除队列的头removeLast()pollLast()takeLast()pollLast(time, unit)获取但不移除队列的头getLast()peekLast()不适用不适用简单介绍ArrayBlockingQueueArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：1ArrayBlockingQueue&lt;String&gt; fairArrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(5, true);上面代码指定了一个初始大小为5的公平的ArrayBlockingQueue。访问者的公平性是使用可重入锁实现的，构造器源码如下：LinkedBlockingQueueLinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列按照先进先出的原则对元素进行排序。此队列的默认和最大长度为Integer.MAX_VALUE：所以推荐的做法是不要使用无参构造器，而是通过有参构造器指定容器的初始大小。PriorityBlockingQueuePriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。不指定排序时：1234567891011121314public class PriorityBlockingQueueTest &#123; public static void main(String[] args) &#123; PriorityBlockingQueue&lt;String&gt; queue = new PriorityBlockingQueue&lt;&gt;(3); IntStream.range(0, 3).forEach(i -&gt; queue.add(i + "hello")); queue.forEach(s -&gt; &#123; try &#123; System.out.println(queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125;输出：1230hello1hello2hello指定排序规则时：123456789101112131415public class PriorityBlockingQueueTest &#123; public static void main(String[] args) &#123; PriorityBlockingQueue&lt;String&gt; queue = new PriorityBlockingQueue&lt;&gt;(3, Comparator.comparingInt(String::hashCode).reversed()); IntStream.range(0, 3).forEach(i -&gt; queue.add(i + "hello")); queue.forEach(s -&gt; &#123; try &#123; System.out.println(queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125;输出：1232hello1hello0hello此外，因为PriorityBlockingQueue是一个无界队列，所以可以添加无数个元素：1234567891011121314public class PriorityBlockingQueueTest &#123; public static void main(String[] args) &#123; PriorityBlockingQueue&lt;String&gt; queue = new PriorityBlockingQueue&lt;&gt;(1); IntStream.range(0, 5).forEach(i -&gt; queue.add(i + "hello")); queue.forEach(s -&gt; &#123; try &#123; System.out.println(queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125;输出：123450hello1hello2hello3hello4hello因为是无界队列，所以上述例子并没有抛出java.lang.IllegalStateException: Queue full异常。DelayQueueDelayQueue也是一个无界阻塞队列，只有在延迟期满时才能从中提取元素。DelayQueue的所有方法只能操作“到期的元素“，例如，poll()、remove()、size()等方法，都会忽略掉未到期的元素。 我们可以将DelayQueue运用在以下应用场景：缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了；定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行。DelayQueue的实现是基于PriorityQueue，是一个优先级队列，是以延时时间的长短进行排序的。所以，DelayQueue需要知道每个元素的延时时间，而这个延时时间是由Delayed接口的getDelay()方法获取的。所以，DelayQueue的元素必须实现Delayed接口。举个例子，先创建一个队列元素类Item，实现Delayed接口：1234567891011121314151617181920212223242526272829303132public class Item implements Delayed &#123; private final String value; private final long expireTime; public Item(String value, long delayTime) &#123; this.value = value; this.expireTime = System.currentTimeMillis() + delayTime; &#125; @Override public long getDelay(TimeUnit unit) &#123; // 获取延迟时间 long diff = expireTime - System.currentTimeMillis(); return unit.convert(diff, TimeUnit.MILLISECONDS); &#125; @Override public int compareTo(@Nonnull Delayed o) &#123; Item item = (Item) o; // 按延迟时间从小到大排序 return Long.compare(this.expireTime, item.getExpireTime()); &#125; public String getValue() &#123; return value; &#125; public long getExpireTime() &#123; return expireTime; &#125;&#125;getDelay方法用于获取延迟时间，compareTo方法用于指定排序规则。DelayQueue内部使用PriorityBlockingQueue实现排序。创建一个测试用例：1234567891011121314151617181920public class DelayQueueTest &#123; private static Logger log = LoggerFactory.getLogger(DelayQueueTest.class); public static void main(String[] args) throws InterruptedException &#123; DelayQueue&lt;Item&gt; delayQueue = new DelayQueue&lt;&gt;(); Item item1 = new Item("item1 - 延迟1秒", 1000); Item item2 = new Item("item2 - 延迟4秒", 4000); Item item3 = new Item("item3 - 延迟2秒", 2000); delayQueue.add(item1); delayQueue.add(item2); delayQueue.add(item3); log.info("start"); while (delayQueue.size() &gt; 0) &#123; log.info(delayQueue.take().getValue()); &#125; &#125;&#125;程序运行结果如下：123414:11:32.488 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - start14:11:33.490 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - item1 - 延迟1秒14:11:34.488 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - item3 - 延迟2秒14:11:36.490 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - item2 - 延迟4秒可以看到，队列内元素是按延迟时间从小到大排序的，延迟1秒后take方法从队列里获取到了item1，延迟2秒后获取到了item3，延迟4秒后获取到了item2。如果我们将排序规则改为按延迟时间从大到小排列，会发生什么呢？1234567891011public class Item implements Delayed &#123; ...... @Override public int compareTo(@Nonnull Delayed o) &#123; Item item = (Item) o; // 按延迟时间从大到小排序 return Long.compare(item.getExpireTime(), this.expireTime); &#125;&#125;程序输出如下：123414:15:01.721 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - start14:15:05.722 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - item2 - 延迟4秒14:15:05.723 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - item3 - 延迟2秒14:15:05.723 [main] INFO cc.mrbird.wwj.blocking.DelayQueueTest - item1 - 延迟1秒可以看到，程序延迟4秒后，take方法从队列中获取到了item2，因为item3和item1的延迟时间小于4秒，所以4秒后，可以直接取出。SynchronousQueueSynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用。LinkedTransferQueueLinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列LinkedTransferQueue多了tryTransfer和transfer方法。transfer方法：如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。tryTransfer方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。我们也可以使用重载方法tryTransfer(E e, long timeout, TimeUnit unit)指定超时时间。LinkedBlockingDequeLinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了一些首尾元素的操作方法，具体可以参考上面的表格。参考文章http://ifeve.com/java-blocking-queue/https://www.cnblogs.com/jinggod/p/8495502.html]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fork/Join使用学习]]></title>
    <url>%2FJDK7-Fork-Join.html</url>
    <content type="text"><![CDATA[JDK7提供了一个将任务“分而治之”的框架 — Fork/Join。它把一个大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。分割的子任务分别放到双端队列里，然后启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。Fork/Join的思想如下所示： RecursiveTaskRecursiveTask适用于将任务分而治之，并且有返回值的情况，举个计算1到100和的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RecursiveTest &#123; // 定义最小区间为10 private final static int MAX_THRESHOLD = 10; public static void main(String[] args) &#123; final ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Integer&gt; future = forkJoinPool.submit(new CalculateRecursiveTask(1, 100)); try &#123; Integer result = future.get(); System.out.println(result); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; private static class CalculateRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123; // 起始 private int start; // 结束 private int end; public CalculateRecursiveTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; // 如果起始和结束范围小于我们定义的区间范围，则直接计算 if ((end - start) &lt;= MAX_THRESHOLD) &#123; return IntStream.rangeClosed(start, end).sum(); &#125; else &#123; // 否则，将范围一分为二，分成两个子任务 int middle = (start + end) / 2; CalculateRecursiveTask leftTask = new CalculateRecursiveTask(start, middle); CalculateRecursiveTask rightTask = new CalculateRecursiveTask(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 汇总子任务 return leftTask.join() + rightTask.join(); &#125; &#125; &#125;&#125;ForkJoinPool使用submit或invoke提交的区别：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行，只有在Future调用get的时候会阻塞。启动程序输出如下：其实这里执行子任务调用fork方法并不是最佳的选择，最佳的选择是invokeAll方法：123456// 执行子任务// leftTask.fork();// rightTask.fork();invokeAll(leftTask,rightTask);// 汇总子任务return leftTask.join() + rightTask.join();RecursiveAction使用方式和RecursiveTask类似，只不过没有返回值：12345678910111213141516171819202122232425262728293031323334353637383940public class RecursiveActionTest &#123; // 定义最小区间为10 private final static int MAX_THRESHOLD = 10; private final static AtomicInteger SUM = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException &#123; final ForkJoinPool forkJoinPool = new ForkJoinPool(); forkJoinPool.submit(new CalculateRecursiveAction(0, 100)); forkJoinPool.awaitTermination(2, TimeUnit.SECONDS); System.out.println(SUM); &#125; private static class CalculateRecursiveAction extends RecursiveAction &#123; // 起始 private final int start; // 结束 private final int end; private CalculateRecursiveAction(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected void compute() &#123; // 如果起始和结束范围小于我们定义的区间范围，则直接计算 if ((end - start) &lt;= MAX_THRESHOLD) &#123; SUM.addAndGet(IntStream.rangeClosed(start, end).sum()); &#125; else &#123; // 否则，将范围一分为二，分成两个子任务 int middle = (end + start) / 2; CalculateRecursiveAction leftAction = new CalculateRecursiveAction(start, middle); CalculateRecursiveAction rightAction = new CalculateRecursiveAction(middle + 1, end); // 执行子任务 invokeAll(leftAction, rightAction); // 没有汇总子任务结果过程，因为没有返回值。 &#125; &#125; &#125;&#125;输出结果也是5050。什么时候用上面只是为了演示Fork/Join的用法，实际是采用这种方式计算反而更加费时，因为切割任务，分配线程需要额外的开销。其实什么时候用不必太纠结，一个足够大的任务，如果采用Fork/Join来处理比传统处理方式快的话，那就毫不犹豫的选择它吧！参考文章：https://www.imooc.com/article/24822]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习Java线程池]]></title>
    <url>%2FJava-Thread-Pool.html</url>
    <content type="text"><![CDATA[在前面的例子中，我们都是通过new Thread来创建一个线程，由于线程的创建和销毁都需要消耗一定的CPU资源，所以在高并发下这种创建线程的方式将严重影响代码执行效率。而线程池的作用就是让一个线程执行结束后不马上销毁，继续执行新的任务，这样就节省了不断创建线程和销毁线程的开销。ThreadPoolExecutor创建Java线程池最为核心的类为ThreadPoolExecutor：它提供了四种构造函数来创建线程池，其中最为核心的构造函数如下所示：1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)这7个参数的含义如下：corePoolSize 线程池核心线程数。即线程池中保留的线程个数，即使这些线程是空闲的，也不会被销毁，除非通过ThreadPoolExecutor的allowCoreThreadTimeOut(true)方法开启了核心线程的超时策略；maximumPoolSize 线程池中允许的最大线程个数；keepAliveTime 用于设置那些超出核心线程数量的线程的最大等待时间，超过这个时间还没有新任务的话，超出的线程将被销毁；unit 超时时间单位；workQueue 线程队列。用于保存通过execute方法提交的，等待被执行的任务；threadFactory 线程创建工程，即指定怎样创建线程；handler 拒绝策略。即指定当线程提交的数量超出了maximumPoolSize后，该使用什么策略处理超出的线程。在通过这个构造方法创建线程池的时候，这几个参数必须满足以下条件，否则将抛出IllegalArgumentException异常：corePoolSize不能小于0；keepAliveTime不能小于0；maximumPoolSize 不能小于等于0；maximumPoolSize不能小于corePoolSize；此外，workQueue、threadFactory和handler不能为null，否则将抛出空指针异常。下面举些例子来深入理解这几个参数的含义。使用上面的构造方法创建一个线程池：123456789101112131415161718192021ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 2, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy());System.out.println("线程池创建完毕");int activeCount = -1;int queueSize = -1;while (true) &#123; if (activeCount != threadPoolExecutor.getActiveCount() || queueSize != threadPoolExecutor.getQueue().size()) &#123; System.out.println("活跃线程个数 " + threadPoolExecutor.getActiveCount()); System.out.println("核心线程个数 " + threadPoolExecutor.getCorePoolSize()); System.out.println("队列线程个数 " + threadPoolExecutor.getQueue().size()); System.out.println("最大线程数 " + threadPoolExecutor.getMaximumPoolSize()); System.out.println("------------------------------------"); activeCount = threadPoolExecutor.getActiveCount(); queueSize = threadPoolExecutor.getQueue().size(); &#125;&#125;上面的代码创建了一个核心线程数量为1，允许最大线程数量为2，最大活跃时间为10秒，线程队列长度为1的线程池。假如我们通过execute方法向线程池提交1个任务，看看结果如何：1234567891011121314151617181920212223ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 2, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy());System.out.println("线程池创建完毕");threadPoolExecutor.execute(() -&gt; sleep(100));int activeCount = -1;int queueSize = -1;while (true) &#123; if (activeCount != threadPoolExecutor.getActiveCount() || queueSize != threadPoolExecutor.getQueue().size()) &#123; System.out.println("活跃线程个数 " + threadPoolExecutor.getActiveCount()); System.out.println("核心线程个数 " + threadPoolExecutor.getCorePoolSize()); System.out.println("队列线程个数 " + threadPoolExecutor.getQueue().size()); System.out.println("最大线程数 " + threadPoolExecutor.getMaximumPoolSize()); System.out.println("------------------------------------"); activeCount = threadPoolExecutor.getActiveCount(); queueSize = threadPoolExecutor.getQueue().size(); &#125;&#125;ThreadPoolExecutor的execute和submit方法都可以向线程池提交任务，区别是，submit方法能够返回执行结果，返回值类型为Futuresleep方法代码：12345678private static void sleep(long value) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "线程执行sleep方法"); TimeUnit.SECONDS.sleep(value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;启动程序，控制台输出如下： 线程池核心线程数量为1，通过execute提交了一个任务后，由于核心线程是空闲的，所以任务被执行了。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。此外，因为提交的任务被核心线程执行了，所以并没有线程需要被放到线程队列里等待，线程队列长度为0。假如我们通过execute方法向线程池提交2个任务，看看结果如何：12threadPoolExecutor.execute(() -&gt; sleep(100));threadPoolExecutor.execute(() -&gt; sleep(100));线程池核心线程数量为1，通过execute提交了2个任务后，一开始核心线程是空闲的，Thread-0被执行。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。因为核心线程数量为1，所以另外一个任务在这100秒内不能被执行，于是被放到线程队列里等待，线程队列长度为1。假如我们通过execute方法向线程池提交3个任务，看看结果如何：123threadPoolExecutor.execute(() -&gt; sleep(100));threadPoolExecutor.execute(() -&gt; sleep(100));threadPoolExecutor.execute(() -&gt; sleep(100));这三个任务都是休眠100秒，所以核心线程池中第一个任务正在被执行，第二个任务被放入到了线程队列。而当第三个任务被提交进来时，线程队列满了（我们定义的长度为1），由于该线程池允许的最大线程数量为2，所以线程池还可以再创建一个线程来执行另外一个任务，于是乎之前在线程队列里的线程被取出执行（FIFO），第三个任务被放入到了线程队列。改变第二个和第三个任务的睡眠时间，观察输出：123threadPoolExecutor.execute(() -&gt; sleep(100));threadPoolExecutor.execute(() -&gt; sleep(5));threadPoolExecutor.execute(() -&gt; sleep(5));第二个任务提交5秒后，任务执行完毕，所以线程队列里的任务被执行，于是队列线程个数为0，活跃线程数量为2（第一个和第三个任务）。再过5秒后，第三个任务执行完毕，于是活跃线程数量为1（第一个100秒还没执行完毕）。在第三个任务结束的瞬间，我们观察线程快照:可以看到，线程池中有两个线程，Thread-0在执行第一个任务（休眠100秒，还没结束），Thread-1执行完第三个任务后并没有马上被销毁。过段时间后（10秒钟后）再观察线程快照:可以看到，Thread-1这个线程被销毁了，因为我们在创建线程池的时候，指定keepAliveTime 为10秒，10秒后，超出核心线程池线程外的那些线程将被销毁。假如一次性提交4个任务，看看会怎样：1234threadPoolExecutor.execute(() -&gt; sleep(100));threadPoolExecutor.execute(() -&gt; sleep(100));threadPoolExecutor.execute(() -&gt; sleep(100));threadPoolExecutor.execute(() -&gt; sleep(100));因为我们设置的拒绝策略为AbortPolicy，所以最后提交的那个任务直接被拒绝了。更多拒绝策略下面会介绍到。关闭线程池线程池包含以下几个状态：当线程池中所有任务都处理完毕后，线程并不会自己关闭。我们可以通过调用shutdown和shutdownNow方法来关闭线程池。两者的区别在于：shutdown方法将线程池置为shutdown状态，拒绝新的任务提交，但线程池并不会马上关闭，而是等待所有正在执行的和线程队列里的任务都执行完毕后，线程池才会被关闭。所以这个方法是平滑的关闭线程池。shutdownNow方法将线程池置为stop状态，拒绝新的任务提交，中断正在执行的那些任务，并且清除线程队列里的任务并返回。所以这个方法是比较“暴力”的。举两个例子观察下两者的区别：shutdown例子:123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 4, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(2), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy()); threadPoolExecutor.execute(new shortTask()); threadPoolExecutor.execute(new longTask()); threadPoolExecutor.execute(new longTask()); threadPoolExecutor.execute(new shortTask()); threadPoolExecutor.shutdown(); System.out.println("已经执行了线程池shutdown方法");&#125;static class shortTask implements Runnable &#123; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + "执行shortTask完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("shortTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;static class longTask implements Runnable &#123; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "执行longTask完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("longTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;启动程序，控制台输出如下：可以看到，虽然在任务都被提交后马上执行了shutdown方法，但是并不会马上关闭线程池，而是等待所有被提交的任务都执行完了才关闭。shutdownNow例子：1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 4, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(2), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy()); threadPoolExecutor.execute(new shortTask()); threadPoolExecutor.execute(new longTask()); threadPoolExecutor.execute(new longTask()); threadPoolExecutor.execute(new shortTask()); List&lt;Runnable&gt; runnables = threadPoolExecutor.shutdownNow(); // 马上关闭，并返回还未被执行的任务 System.out.println(runnables); System.out.println("已经执行了线程池shutdownNow方法");&#125;static class shortTask implements Runnable &#123; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + "执行shortTask完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("shortTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;static class longTask implements Runnable &#123; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "执行longTask完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("longTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;启动程序，控制台输出如下： 可以看到，在执行shutdownNow方法后，线程池马上就被关闭了，正在执行中的两个任务被打断，并且返回了线程队列中等待被执行的两个任务。通过上面两个例子我们还可以看到shutdown和shutdownNow方法都不是阻塞的。常与shutdown搭配的方法有awaitTermination。awaitTermination方法接收timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。该方法是阻塞的：123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 4, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(2), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy()); threadPoolExecutor.execute(new shortTask()); threadPoolExecutor.execute(new longTask()); threadPoolExecutor.execute(new longTask()); threadPoolExecutor.execute(new shortTask()); threadPoolExecutor.shutdown(); boolean isShutdown = threadPoolExecutor.awaitTermination(3, TimeUnit.SECONDS); if (isShutdown) &#123; System.out.println("线程池在3秒内成功关闭"); &#125; else &#123; System.out.println("等了3秒还没关闭，不等了╰（‵□′）╯"); &#125; System.out.println("------------");&#125;static class shortTask implements Runnable &#123; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + "执行shortTask完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("shortTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;static class longTask implements Runnable &#123; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "执行longTask完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("longTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;启动程序输出如下：4大拒绝策略当线程池无法再接收新的任务的时候，可采取如下四种策略： CallerRunsPolicyCallerRunsPolicy策略：由调用线程处理该任务：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 3, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.CallerRunsPolicy()); threadPoolExecutor.execute(new shortTask("任务1")); threadPoolExecutor.execute(new longTask("任务2")); threadPoolExecutor.execute(new longTask("任务3")); threadPoolExecutor.execute(new shortTask("任务4")); threadPoolExecutor.execute(new shortTask("任务5")); threadPoolExecutor.shutdown();&#125;static class shortTask implements Runnable &#123; private String name; public shortTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + "执行shortTask-name-" + name + "完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("shortTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;static class longTask implements Runnable &#123; private String name; public longTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "执行longTask-name-" + name + "完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("longTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;上面的线程池最多只能一次性提交4个任务，第5个任务提交后会被拒绝策略处理。启动程序输出如下：可以看到，第5个提交的任务由调用线程（即main线程）处理该任务。AbortPolicyAbortPolicy策略：丢弃任务，并抛出RejectedExecutionException异常。前面的例子就是使用该策略，所以不再演示。DiscardOldestPolicyDiscardOldestPolicy策略：丢弃最早被放入到线程队列的任务，将新提交的任务放入到线程队列末端：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 3, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.DiscardOldestPolicy()); threadPoolExecutor.execute(new shortTask("任务1")); threadPoolExecutor.execute(new longTask("任务2")); threadPoolExecutor.execute(new longTask("任务3")); threadPoolExecutor.execute(new shortTask("任务4")); threadPoolExecutor.execute(new shortTask("任务5")); threadPoolExecutor.shutdown();&#125;static class shortTask implements Runnable &#123; private String name; public shortTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + "执行shortTask-name-" + name + "完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("shortTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;static class longTask implements Runnable &#123; private String name; public longTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "执行longTask-name-" + name + "完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("longTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;启动程序输出如下：可以看到最后提交的任务被执行了，而第3个任务是第一个被放到线程队列的任务，被丢弃了。DiscardPolicyDiscardPolicy策略：直接丢弃新的任务，不抛异常：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 3, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.DiscardPolicy()); threadPoolExecutor.execute(new shortTask("任务1")); threadPoolExecutor.execute(new longTask("任务2")); threadPoolExecutor.execute(new longTask("任务3")); threadPoolExecutor.execute(new shortTask("任务4")); threadPoolExecutor.execute(new shortTask("任务5")); threadPoolExecutor.shutdown();&#125;static class shortTask implements Runnable &#123; private String name; public shortTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + "执行shortTask-name-" + name + "完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("shortTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;static class longTask implements Runnable &#123; private String name; public longTask(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "执行longTask-name-" + name + "完毕"); &#125; catch (InterruptedException e) &#123; System.err.println("longTask执行过程中被打断" + e.getMessage()); &#125; &#125;&#125;启动程序，输出如下： 第5个任务直接被拒绝丢弃了，而没有抛出任何异常。线程池工厂方法除了使用ThreadPoolExecutor的构造方法创建线程池外，我们也可以使用Executors提供的工厂方法来创建不同类型的线程池：newFixedThreadPool查看newFixedThreadPool方法源码：12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;可以看到，通过newFixedThreadPool创建的是一个固定大小的线程池，大小由nThreads参数指定，它具有如下几个特点:因为corePoolSize和maximumPoolSize的值都为nThreads，所以线程池中线程数量永远等于nThreads，不可能新建除了核心线程数的线程来处理任务，即keepAliveTime实际上在这里是无效的。LinkedBlockingQueue是一个无界队列（最大长度为Integer.MAX_VALUE），所以这个线程池理论是可以无限的接收新的任务，这就是为什么上面没有指定拒绝策略的原因。newCachedThreadPool查看newCachedThreadPool方法源码：12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;这是一个理论上无限大小的线程池：核心线程数为0，SynchronousQueue队列是没有长度的队列，所以当有新的任务提交，如果有空闲的还未超时的（最大空闲时间60秒）线程则执行该任务，否则新增一个线程来处理该任务。因为线程数量没有限制，理论上可以接收无限个新任务，所以这里也没有指定拒绝策略。newSingleThreadExecutor查看newSingleThreadExecutor源码：123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;核心线程数和最大线程数都为1，每次只能有一个线程处理任务。LinkedBlockingQueue队列可以接收无限个新任务。newScheduledThreadPool查看newScheduledThreadPool源码：123456789public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;......public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125;所以newScheduledThreadPool理论是也是可以接收无限个任务，DelayedWorkQueue也是一个无界队列。使用newScheduledThreadPool创建的线程池除了可以处理普通的Runnable任务外，它还具有调度的功能：1.延迟指定时间后执行：123ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);// 延迟5秒执行executorService.schedule(() -&gt; System.out.println("hello"), 5, TimeUnit.SECONDS);2.按指定的速率执行：12345ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);// 延迟1秒执行，然后每5秒执行一次executorService.scheduleAtFixedRate( () -&gt; System.out.println(LocalTime.now()), 1, 5, TimeUnit.SECONDS);3.按指定的时延执行：1234ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);executorService.scheduleWithFixedDelay( () -&gt; System.out.println(LocalTime.now()), 1, 5, TimeUnit.SECONDS);乍一看，scheduleAtFixedRate和scheduleWithFixedDelay没啥区别，实际它们还是有区别的：scheduleAtFixedRate按照固定速率执行任务，比如每5秒执行一个任务，即使上一个任务没有结束，5秒后也会开始处理新的任务；scheduleWithFixedDelay按照固定的时延处理任务，比如每延迟5秒执行一个任务，无论上一个任务处理了1秒，1分钟还是1小时，下一个任务总是在上一个任务执行完毕后5秒钟后开始执行。对于这些线程池工厂方法的使用，阿里巴巴编程规程指出：因为这几个线程池理论是都可以接收无限个任务，所以这就有内存溢出的风险。实际上只要我们掌握了ThreadPoolExecutor构造函数7个参数的含义，我们就可以根据不同的业务来创建出符合需求的线程池。一般线程池的创建可以参考如下规则：IO密集型任务：IO密集型任务线程并不是一直在执行任务，应该配置尽可能多的线程，线程池线程数量推荐设置为2 * CPU核心数；对弈IO密集型任务，网络上也有另一种线程池数量计算公式：CPU核心数/(1 - 阻塞系数)，阻塞系数取值0.8~0.9，至于这两种公式使用哪一个，可以根据实际环境测试比较得出；计算密集型任务：此类型需要CPU的大量运算，所以尽可能的去压榨CPU资源，线程池线程数量推荐设置为CPU核心数 + 1。CPU核心数可以使用Runtime获得：1Runtime.getRuntime().availableProcessors()一些API的用法ThreadPoolExecutor提供了几个判断线程池状态的方法：12345678910111213141516171819202122public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 2, 5, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy() ); threadPoolExecutor.execute(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); threadPoolExecutor.shutdown(); System.out.println("线程池为shutdown状态：" + threadPoolExecutor.isShutdown()); System.out.println("线程池正在关闭：" + threadPoolExecutor.isTerminating()); System.out.println("线程池已经关闭：" + threadPoolExecutor.isTerminated()); threadPoolExecutor.awaitTermination(6, TimeUnit.SECONDS); System.out.println("线程池已经关闭" + threadPoolExecutor.isTerminated());&#125;程序输出如下：前面我们提到，线程池核心线程即使是空闲状态也不会被销毁，除非使用allowCoreThreadTimeOut设置了允许核心线程超时：12345678910111213141516public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 2, 3, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy() ); threadPoolExecutor.allowCoreThreadTimeOut(true); threadPoolExecutor.execute(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println("任务执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;程序输出如下所示：5秒后任务执行完毕，核心线程处于空闲的状态。因为通过allowCoreThreadTimeOut方法设置了允许核心线程超时，所以3秒后（keepAliveTime设置为3秒），核心线程被销毁。核心线程被销毁后，线程池也就没有作用了，于是就自动关闭了。值得注意的是，如果一个线程池调用了allowCoreThreadTimeOut(true)方法，那么它的keepAliveTime不能为0。ThreadPoolExecutor提供了一remove方法，查看其源码：12345public boolean remove(Runnable task) &#123; boolean removed = workQueue.remove(task); tryTerminate(); // In case SHUTDOWN and now empty return removed;&#125;可看到，它删除的是线程队列中的任务，而非正在被执行的任务。举个例子：123456789101112131415161718192021public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 2, 3, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy() ); threadPoolExecutor.execute(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println("任务执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); Runnable r = () -&gt; System.out.println("看看我是否会被删除"); threadPoolExecutor.execute(r); threadPoolExecutor.remove(r); threadPoolExecutor.shutdown();&#125;执行程序，输出如下：可看到任务并没有被执行，已经被删除，因为唯一一个核心线程已经在执行任务了，所以后提交的这个任务被放到了线程队列里，然后通过remove方法删除。默认情况下，只有当往线程池里提交了任务后，线程池才会启动核心线程处理任务。我们可以通过调用prestartCoreThread方法，让核心线程即使没有任务提交，也处于等待执行任务的活跃状态：1234567891011121314public static void main(String[] args) throws InterruptedException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 2, 3, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy() ); System.out.println("活跃线程数: " + threadPoolExecutor.getActiveCount()); threadPoolExecutor.prestartCoreThread(); System.out.println("活跃线程数: " + threadPoolExecutor.getActiveCount()); threadPoolExecutor.prestartCoreThread(); System.out.println("活跃线程数: " + threadPoolExecutor.getActiveCount()); threadPoolExecutor.prestartCoreThread(); System.out.println("活跃线程数: " + threadPoolExecutor.getActiveCount());&#125;程序输出如下所示：该方法返回boolean类型值，如果所以核心线程都启动了，返回false，反之返回true。还有一个和它类似的prestartAllCoreThreads方法，它的作用是一次性启动所有核心线程，让其处于活跃地等待执行任务的状态。ThreadPoolExecutor的invokeAny方法用于随机执行任务集合中的某个任务，并返回执行结果，该方法是同步方法：123456789101112131415161718public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 5, 3, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy() ); // 任务集合 List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(0, 4).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123; TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5)); return i; &#125;).collect(Collectors.toList()); // 随机执行结果 Integer result = threadPoolExecutor.invokeAny(tasks); System.out.println("-------------------"); System.out.println(result); threadPoolExecutor.shutdownNow();&#125;启动程序，输出如下：ThreadPoolExecutor的invokeAll则是执行任务集合中的所有任务，返回Future集合：1234567891011121314151617181920212223public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 2, 5, 3, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1), (ThreadFactory) Thread::new, new ThreadPoolExecutor.AbortPolicy() ); List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(0, 4).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123; TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(5)); return i; &#125;).collect(Collectors.toList()); List&lt;Future&lt;Integer&gt;&gt; futureList = threadPoolExecutor.invokeAll(tasks); futureList.stream().map(f-&gt;&#123; try &#123; return f.get(); &#125; catch (InterruptedException | ExecutionException e) &#123; return null; &#125; &#125;).forEach(System.out::println); threadPoolExecutor.shutdownNow();&#125;输出如下： 总结下这些方法：方法描述allowCoreThreadTimeOut(boolean value)是否允许核心线程空闲后超时，是的话超时后核心线程将销毁，线程池自动关闭awaitTermination(long timeout, TimeUnit unit)阻塞当前线程，等待线程池关闭，timeout用于指定等待时间。execute(Runnable command)向线程池提交任务，没有返回值submit(Runnable task)向线程池提交任务，返回FutureisShutdown()判断线程池是否为shutdown状态isTerminating()判断线程池是否正在关闭isTerminated()判断线程池是否已经关闭remove(Runnable task)移除线程队列中的指定任务prestartCoreThread()提前让一个核心线程处于活跃状态，等待执行任务prestartAllCoreThreads()提前让所有核心线程处于活跃状态，等待执行任务getActiveCount()获取线程池活跃线程数getCorePoolSize()获取线程池核心线程数threadPoolExecutor.getQueue()获取线程池线程队列getMaximumPoolSize()获取线程池最大线程数shutdown()让线程池处于shutdown状态，不再接收任务，等待所有正在运行中的任务结束后，关闭线程池。shutdownNow()让线程池处于stop状态，不再接受任务，尝试打断正在运行中的任务，并关闭线程池，返回线程队列中的任务。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合线程安全问题]]></title>
    <url>%2F%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[常用的集合类型如ArrayList，HashMap，HashSet等，在并发环境下修改操作都是线程不安全的，会抛出java.util.ConcurrentModificationException异常，这节主要记录如何在并发环境下安全地修改集合数据。List举个ArrayList线程不安全的例子：12345678910public class CollectionTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; data = new ArrayList&lt;&gt;(); IntStream.range(0, 30).forEach( i -&gt; new Thread(() -&gt; data.add(String.valueOf(i)), String.valueOf(i)).start() ); System.out.println(data); &#125;&#125;上面例子中，有30个线程对data进行修改操纵，多运行几次上面的程序，控制台便会抛出如下异常：之所以会抛出java.util.ConcurrentModificationException异常，是因为多个线程并发争抢修改data导致，当一个线程正在写入但还未写完时，另一个线程抢夺写入，这便导致了数据异常。要解决这个问题，主要有以下三种方法：1. 使用Vector：12345678910public class CollectionTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; data = new Vector&lt;&gt;(); IntStream.range(0, 30).forEach( i -&gt; new Thread(() -&gt; data.add(String.valueOf(i)), String.valueOf(i)).start() ); System.out.println(data); &#125;&#125;Vector类的add方法是通过加同步锁来实现线程安全的，查看源码：2. 使用Collections工具类的synchronizedList方法：12345678910public class CollectionTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; data = Collections.synchronizedList(new ArrayList&lt;&gt;()); IntStream.range(0, 30).forEach( i -&gt; new Thread(() -&gt; data.add(String.valueOf(i)), String.valueOf(i)).start() ); System.out.println(data); &#125;&#125;其本质还是通过同步锁来解决线程安全问题：3. 使用CopyOnWriteArrayList：12345678910public class CollectionTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; data = new CopyOnWriteArrayList&lt;&gt;(); IntStream.range(0, 30).forEach( i -&gt; new Thread(() -&gt; data.add(String.valueOf(i)), String.valueOf(i)).start() ); System.out.println(data); &#125;&#125;查看CopyOnWriteArrayList类的add方法源码，会发现它是通过可重入锁来解决线程安全问题的：上面方法的源码使用了写时复制的思想（CopyOnWrite）：往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行复制，复制出一个新的容器Object[] newElements，然后往新的容器Object[] newElements里添加新的元素。添加完后，再将原容器的引用指向新的容器（即源码中的setArray(newElements)）。这种做法的好处是可以对CopyOnWrite的容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以这也是一种读写分离的思想，即读和写的容器是不同的容器。上面这三种解决办法中，更推荐使用CopyOnWriteArrayList。SetHashSet在并发下修改也会出现线程安全问题。解决办法同样可以通过Collections#synchronizedSet和CopyOnWriteArraySet解决，过程和上述类似，所以不再赘述。MapHashMap在并发环境下修改时的线程安全问题同样可以通过Collections.synchronizedMap解决。此外并没有所谓的CopyOnWriteHashMap，线程安全的HashMap可以使用ConcurrentHashMap：12345678910public class CollectionTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; data = new ConcurrentHashMap&lt;&gt;(); IntStream.range(0, 30).forEach( i -&gt; new Thread(() -&gt; data.put(String.valueOf(i), String.valueOf(i)), String.valueOf(i)).start() ); System.out.println(data); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Concurrency Lock]]></title>
    <url>%2FJava-Concurrency-Lock.html</url>
    <content type="text"><![CDATA[Lock锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。ReentrantLockReentrantLock字面上意思就是可重入锁（又称为递归锁），表示该锁能够支持一个线程对资源的重复加锁。定义一个ReentrantLock：1ReentrantLock lock = new ReentrantLock();默认无参构造函数创建的是非公平锁，构造函数重载方法ReentrantLock(boolean fair)支持传入true创建公平锁。公平锁的意思是多线程在获取锁的时候是公平的，也就是等待时间最长的线程最优先获取锁，类似FIFO。使用ReentrantLock可以实现和synchronized一样的功能：123456789101112131415161718public class ReentrantLockTest &#123; private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws InterruptedException &#123; IntStream.range(0, 2).forEach(i -&gt; new Thread(ReentrantLockTest::needLock).start()); &#125; public static void needLock() &#123; try &#123; lock.lock(); System.out.println(Thread.currentThread().getName() + "开始工作"); TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;确保在finally里释放锁，否则容易造成死锁。上面例子同一时刻只能有一个线程可以获得锁lock，别的线程必须等待锁被释放（unlock）才能开始竞争获取锁。程序运行结果如下所示：needLock方法和下面通过synchronized关键字实现锁方法效果是一样的：12345678910public static void needLockBySync() &#123; synchronized (ReentrantLockTest.class) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "开始工作"); TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;为什么ReentrantLock又称为递归锁呢？这是因为：一个线程如果获取了某个方法的锁，这个方法内部即使调用了别的需要获取锁的方法，那么这个线程不需要再次等待获取锁，可以直接进去。说着可能有点抽象，下面举个例子：1234567891011121314151617181920212223242526public class Test &#123; private static Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; IntStream.rangeClosed(0,1).forEach(i-&gt; new Thread(Test::method1, String.valueOf(i)).start()); &#125; public static void method1() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + " invoked method1"); method2(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void method2() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + " invoked method2"); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;程序运行结果：12340 invoked method10 invoked method21 invoked method11 invoked method2上面例子中，method1和method2都加了锁，线程0获取到了method1的锁后，内部可以直接调用method2，无需重新获取锁对象。synchronized也具有相同的特性。ReentrantLock可以对一个方法不限次的重复加锁，但解锁次数必须和加锁次数一致，否则锁永远不会被释放，别的线程将无法获取该方法的锁，比如：123456789101112131415161718192021222324public class Test &#123; private static Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; IntStream.rangeClosed(0,1).forEach(i-&gt; new Thread(Test::method1, String.valueOf(i)).start()); &#125; public static void method1() &#123; // 加锁4次 lock.lock(); lock.lock(); lock.lock(); lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + " invoked method1"); &#125; finally &#123; // 解锁3次 lock.unlock(); lock.unlock(); lock.unlock(); &#125; &#125;&#125;程序运行结果： 线程1一直处于WAITING状态，因为线程0加锁了4次，但只释放了3次锁，所以线程1一直无法获取到锁。lock方法是不可被打断的，即调用线程的interrupt方法不起作用：123456789101112131415161718192021222324public class ReentrantLockTest &#123; private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(ReentrantLockTest::testLockUnInterruptibly); thread1.start(); TimeUnit.SECONDS.sleep(1); Thread thread2 = new Thread(ReentrantLockTest::testLockUnInterruptibly); thread2.start(); TimeUnit.SECONDS.sleep(1); thread2.interrupt(); &#125; public static void testLockUnInterruptibly() &#123; try &#123; lock.lock(); // 不可以被打断 System.out.println(Thread.currentThread().getName() + "开始工作"); while (true) &#123; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;运行结果:thread2(Thread-1)依旧在继续等待获取锁，没有被打断。ReentrantLock提供了可打断获取锁的方法lockInterruptibly：12345678910111213141516171819202122232425262728public class ReentrantLockTest &#123; private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(ReentrantLockTest::testLockInterruptibly); thread1.start(); TimeUnit.SECONDS.sleep(1); Thread thread2 = new Thread(ReentrantLockTest::testLockInterruptibly); thread2.start(); TimeUnit.SECONDS.sleep(1); thread2.interrupt(); &#125; public static void testLockInterruptibly() &#123; try &#123; lock.lockInterruptibly(); // 可以被打断 System.out.println(Thread.currentThread().getName() + "开始工作"); while (true) &#123; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;thread2在等待获取锁时被打断，抛出InterruptedException异常。ReentrantLock的tryLock方法用于尝试获取锁，返回boolean类型，表示获取锁成功与否：123456789101112131415161718192021222324public class ReentrantLockTest &#123; private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(ReentrantLockTest::testTryLock, "thread1"); thread1.start(); TimeUnit.SECONDS.sleep(1); Thread thread2 = new Thread(ReentrantLockTest::testTryLock, "thread2"); thread2.start(); &#125; public static void testTryLock() &#123; if (lock.tryLock()) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "开始工作"); while (true) &#123; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; else &#123; System.out.println(Thread.currentThread().getName() + "没有获取到锁"); &#125; &#125;&#125;thread1抢到锁后进入死循环，一直不释放锁。thread2尝试获取锁失败后直接放弃。tryLock的重载方法tryLock(long timeout, TimeUnit unit)可以设置尝试获取锁的时间范围，超过这个时间没有获取到锁则返回false。ReentrantLock一些别的方法：方法含义getQueueLength()等待获取锁线程数量hasQueuedThreads()是否有在等待获取锁的线程hasQueuedThread(Thread thread)等待获取锁的线程队列里是包含指定的线程isLocked当前锁是否被任意一个线程获取到了Spin LockJUC中并没有自旋锁对应的类，而所谓的自旋锁就是：尝试获取锁的线程不会马上阻塞，而是采用循环的方式去尝试获取锁。这种方式的好处是可以减少线程上下文切换的消耗，缺点是循环会消耗CPU资源。一个经典的自旋锁例子就是unsafe类里的CAS思想：我们可以利用CAS实现一个自旋锁：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SpinLock &#123; AtomicReference&lt;Thread&gt; reference = new AtomicReference&lt;&gt;(); public void lock() &#123; Thread thread = Thread.currentThread(); System.out.println(thread.getName() + "尝试获取锁"); while (!reference.compareAndSet(null, thread)) &#123; // 自旋锁就是利用CAS思想制造循环，block住代码 &#125; System.out.println(thread.getName() + "获取到了锁"); &#125; public void unlock() &#123; Thread thread = Thread.currentThread(); reference.compareAndSet(thread, null); System.out.println(thread.getName() + "释放锁"); &#125; public static void main(String[] args) &#123; SpinLock lock = new SpinLock(); new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + "做某事..."); TimeUnit.SECONDS.sleep(5); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;, "线程1").start(); new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + "做某事..."); TimeUnit.SECONDS.sleep(5); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;, "线程2").start(); &#125;&#125;程序输出如下：12345678线程1尝试获取锁线程1获取到了锁线程1做某事...线程2尝试获取锁线程1释放锁线程2获取到了锁线程2做某事...线程2释放锁ReadWriteLockReadWriteLock为读写锁。ReentrantLock为排他锁，同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。简而言之，ReadWriteLock包含读写锁，遵循以下规则：写的时候不能读写的时候不能写读的时候不能写读的时候可以读ReadWriteLock为接口，我们使用它的实现类ReentrantReadWriteLock创建读写锁实例：123ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);ReentrantReadWriteLock.ReadLock readLock = lock.readLock();ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();使用读写锁创建一个读写的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ReadWriteLockTest &#123; private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true); // 读锁 private static ReentrantReadWriteLock.ReadLock readLock = lock.readLock(); // 写锁 private static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock(); // 存放数据 private static List&lt;Long&gt; data = new ArrayList&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; while (true) &#123; write(); &#125; &#125;, "writer").start(); new Thread(() -&gt; &#123; while (true) &#123; read(); &#125; &#125;, "reader").start(); &#125; public static void write() &#123; try &#123; writeLock.lock(); // 写锁 TimeUnit.SECONDS.sleep(1); long value = System.currentTimeMillis(); data.add(value); System.out.println(Thread.currentThread().getName() + " 写入value: " + value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; writeLock.unlock(); // 释放写锁 &#125; &#125; public static void read() &#123; try &#123; readLock.lock(); // 获取读锁 TimeUnit.SECONDS.sleep(1); String value = data.stream().map(String::valueOf).collect(Collectors.joining(",")); System.out.println(Thread.currentThread().getName() + "读取data: " + value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; readLock.unlock(); // 释放读锁 &#125; &#125;&#125;ReentrantReadWriteLock还包含了一些别的实用方法：功能和上面介绍的ReentrantLock差不多，方法名见名知其意，不再演示了。JDK8 StampedLockJDK8 新增了一个锁StampedLock，它是对ReadWriteLock的改进。使用ReadWriteLock的时候，当读线程数量远大于写线程数量的时候就会出现“写饥饿”现象。因为锁大概率都被读线程抢走了，写线程很难抢到锁，这将使得读写效率非常低下。JDK8的StampedLock就是为了解决这个问题而设计的，StampedLock包含乐观锁和悲观锁：乐观锁：每次去拿数据的时候，并不获取锁对象，而是判断标记位（stamp）是否有被修改，如果有修改就再去读一次。悲观锁：每次拿数据的时候都去获取锁。通过乐观锁，当写线程没有写数据的时候，标志位stamp并没有改变，所以即使有再多的读线程在读取数据，它们都可以直接去读数据，而无需获取锁，这就不会使得写线程抢不到锁了。stamp类似一个时间戳的作用，每次写的时候对其+1来改变被操作对象的stamp值。下面我们通过一个例子来模拟写饥饿的情况：创建20个线程，其中19个线程用于读数据，1个线程用于写数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class StampedLockTest &#123; private static StampedLock lock = new StampedLock(); private static List&lt;Long&gt; data = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(20); Runnable read = StampedLockTest::read; Runnable write = StampedLockTest::write; IntStream.range(0, 19).forEach(i -&gt; executorService.submit(read)); executorService.submit(write); executorService.shutdown(); &#125; private static void read() &#123; long stamped = -1; try &#123; stamped = lock.readLock(); // 获取悲观锁，阻塞写线程 TimeUnit.SECONDS.sleep(1); String collect = data.stream().map(String::valueOf).collect(Collectors.joining(",")); System.out.println(Thread.currentThread().getName() + " read value: " + collect); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlockRead(stamped); &#125; &#125; private static void write() &#123; long stamped = -1; try &#123; stamped = lock.writeLock(); TimeUnit.SECONDS.sleep(1); long value = System.currentTimeMillis(); data.add(value); System.out.println(Thread.currentThread().getName() + " write value: " + value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlockWrite(stamped); &#125; &#125;&#125;上面例子通过StampedLock调用writeLock、unlockWrite、readLock和unlockRead的时候都会导致StampedLock的stamp值的变化，即每次+1，直到加到最大值，然后从0重新开始。上面程序运行结果如下： 可以看到写线程最后才抢到锁并写入数据。我们通过乐观锁来改善这个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class StampedLockTest2 &#123; private static StampedLock lock = new StampedLock(); private static List&lt;Long&gt; data = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(20); Runnable read = StampedLockTest2::read; Runnable write = StampedLockTest2::write; IntStream.range(0, 19).forEach(i -&gt; executorService.submit(read)); executorService.submit(write); executorService.shutdown(); &#125; private static void read() &#123; long stamped = lock.tryOptimisticRead(); // 获取乐观锁 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 直接读取值 String collect = data.stream().map(String::valueOf).collect(Collectors.joining(",")); // 如果戳被改变，方法返回false，说明stamped被修改过了（被write方法修改过了，有新的数据写入）， // 那么重新获取锁并去读取值，否则直接使用上面读取的值。 if (!lock.validate(stamped)) &#123; try &#123; stamped = lock.readLock(); TimeUnit.SECONDS.sleep(1); collect = data.stream().map(String::valueOf).collect(Collectors.joining(",")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlockRead(stamped); &#125; &#125; System.out.println(Thread.currentThread().getName() + " read value: " + collect); &#125; private static void write() &#123; long stamped = -1; try &#123; stamped = lock.writeLock(); TimeUnit.SECONDS.sleep(1); long value = System.currentTimeMillis(); data.add(value); System.out.println(Thread.currentThread().getName() + " write value: " + value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlockWrite(stamped); &#125; &#125;&#125;我们重点关注read方法。read方法一开始通过调用StampedLock的tryOptimisticRead方法来获取标志位stamp，获取乐观锁并不会真正的去获取锁（所以不会阻塞写操作），然后直接去读数据。接着通过StampedLock的validate方法判断标志位stamp是否被修改了（write方法里会修改标志位的值），如果方法返回true，则说明数据没有被修改过，直接使用前面读取的数据即可；否则需要去获取锁重新去读数据，阻止写操作。上面例子运行结果如下：可以看到，写操作一开始就抢到了锁，并写入了数据。简而言之，StampedLock解决了在没有新数据写入时，由于过多读操作抢夺锁而使得写操作一直获取不到锁无法写入新数据的问题。ConditionCondition接口提供了类似Object的wait、notify和notifyAll方法，与Lock配合可以实现生产/消费模式，但是这两者在使用方式以及功能特性上还是有差别的。使用Codition实现一个生产消费的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ConditionTest &#123; private static ReentrantLock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); // 初始数据 private static int data = 0; // 是否被消费 private static volatile boolean consumed = false; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while (true) &#123; produceData(); &#125; &#125;,"producer").start(); new Thread(() -&gt; &#123; while (true) &#123; consumeData(); &#125; &#125;,"consumer").start(); &#125; public static void produceData() &#123; try &#123; lock.lock(); // 获取锁 while (!consumed) &#123; // 判断数据是否被消费 condition.await(); // 如果没有被消费则进入等待 &#125; TimeUnit.SECONDS.sleep(1); data++; System.out.println(Thread.currentThread().getName() + " produce data = " + data); consumed = false; // 生产完数据将消费标识置为false condition.signal(); // 解除await，用于通知消费者可以开始消费了 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; public static void consumeData() &#123; try &#123; lock.lock(); // 获取锁 while (consumed) &#123; // 判断数据是否被消费 condition.await(); // 如果被消费了则进入等待 &#125; TimeUnit.MICROSECONDS.sleep(500); System.out.println(Thread.currentThread().getName() + " consume data = " + data); consumed = true; // 消费完将消费标识置为true condition.signal(); // 解除await，用于通知生产者可以开始生产了 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125;&#125;上面例子中，通过consumed判断数据是否被消费。produceData方法在获取锁后，判断数据是否被消费，如果没有被消费，则调用Condition的await方法进入等待，直到Condition对象的signal方法被调用；consumeData方法逻辑和produceData一致。Condition核心用法就是通过await方法让线程进入阻塞等待状态，通过signal解除阻塞状态。上面的例子运行效果如下所示：对应上面的例子我们可以思考下面三个问题：是否可以只使用Lock而不使用Condition？生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？是否可以只使用Condition不使用Lock？对于第一个问题：是否可以只使用Lock而不使用Condition？虽然我们可以定义公平的ReentrantLock，但是实际上并不能确保100%公平，只是尽可能的公平。生产消费模型必须为生产者生成完了数据通知消费者消费，消费者消费完了通知生产者生产，这是环环相扣的，不允许出现别的情况。对于第二个问题：生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？假如一开始produceData方法先通过lock.lock()获取到了锁，consumed初始值为false，所以接着方法会调用condition.await()进入阻塞等待。await方法会使得当前线程释放锁对象，然后进入休眠状态，直到发生下面三种情况之一才会被解除休眠：Condition的signal方法被调用；Condition的signalAll方法被调用；其他线程调用了当前线程的interrupt方法。对于第三个问题：是否可以只使用Condition不使用Lock？既然await会使得线程进入阻塞等待状态，那么是否可以直接使用await，而不使用Lock呢？我们改造上面的例子，去掉获取和释放锁的相关代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class ConditionTest &#123; // 公平锁 private static ReentrantLock lock = new ReentrantLock(true); private static Condition condition = lock.newCondition(); // 初始数据 private static int data = 0; // 是否被消费 private static volatile boolean consumed = false; public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; while (true) &#123; produceData(); &#125; &#125;).start(); new Thread(() -&gt; &#123; while (true) &#123; consumeData(); &#125; &#125;).start(); &#125; public static void produceData() &#123; try &#123; while (!consumed) &#123; condition.await(); &#125; TimeUnit.SECONDS.sleep(1); data++; System.out.println(Thread.currentThread().getName() + " produce data = " + data); consumed = false; condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void consumeData() &#123; try &#123; while (consumed) &#123; condition.await(); &#125; TimeUnit.MICROSECONDS.sleep(500); System.out.println(Thread.currentThread().getName() + " consume data = " + data); consumed = true; condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;可以看到，程序抛出IllegalMonitorStateException异常，所以Condition必须配合Lock使用。正如前面说的，Condition的功能类似于Object对象的wait和notify方法，下面我们使用Object对象的wait和notify方法实现一个类似上面生产消费的功能：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class WaitNotifyExample &#123; private static int data = 0; private static volatile boolean used = false; private final static Object MONITOR = new Object(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while (true) &#123; produceData(); &#125; &#125;, "thread1").start(); new Thread(() -&gt; &#123; while (true) &#123; consumeData(); &#125; &#125;, "thread2").start(); &#125; public static void produceData() &#123; synchronized (MONITOR) &#123; while (!used) &#123; try &#123; MONITOR.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; data++; System.out.println(Thread.currentThread().getName() + " 生产data = " + data); used = false; MONITOR.notifyAll(); &#125; &#125; public static void consumeData() &#123; synchronized (MONITOR) &#123; while (used) &#123; try &#123; MONITOR.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " 消费data = " + data); used = true; MONITOR.notifyAll(); &#125; &#125;&#125;效果如下所示：Condition还可以绑定多个条件，并唤醒指定的线程，举个三个线程循环干活的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Loop &#123; private volatile String value = "a"; private Lock lock = new ReentrantLock(); // 条件1 private Condition condition1 = lock.newCondition(); // 条件2 private Condition condition2 = lock.newCondition(); // 条件3 private Condition condition3 = lock.newCondition(); public void printA() &#123; try &#123; lock.lock(); while (!value.equals("a")) &#123; condition1.await(); &#125; System.out.println(Thread.currentThread().getName() + " print a"); value = "b"; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printB() &#123; try &#123; lock.lock(); while (!value.equals("b")) &#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName() + " print b"); value = "c"; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void printC() &#123; try &#123; lock.lock(); while (!value.equals("c")) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName() + " print c"); value = "a"; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; Loop loop = new Loop(); IntStream.rangeClosed(0, 2).forEach(i -&gt; new Thread(loop::printA, "线程A").start()); IntStream.rangeClosed(0, 2).forEach(i -&gt; new Thread(loop::printB, "线程B").start()); IntStream.rangeClosed(0, 2).forEach(i -&gt; new Thread(loop::printC, "线程C").start()); &#125;&#125;程序输出如下：123456789线程A print a线程B print b线程C print c线程A print a线程B print b线程C print c线程A print a线程B print b线程C print csynchronized和Lock区别synchronized和Lock都是用于控制多个线程访问共享资源的方式，但他们还是有区别的，主要可以从下面几个方面比较：1.构成不一样synchronized是Java关键字，属于JVM层面，底层是由monitorenter和monitorexit指令完成（查看字节码证实）：而Lock是JUC下的Java接口类，是API层面的🔐。2.使用方式不同synchronized不需要我们手动释放锁，当synchronized代码执行完后，当前线程会自动释放锁；ReentrantLock需要手动释放锁，不然会造成死锁。3.可中断性synchronized是不可中断的，除非同步方法内抛出异常或者程序正常运行完成； ReentrantLock是可以中断的，比如lockInterruptibly()方法。4.公平否synchronized是非公平锁；ReentrantLock可以通过构造方法ReentrantLock(boolean fair)设置公平与否。5.灵活性synchronized不可以设置条件；ReentrantLock可以通过condition绑定多条件，精确唤醒指定线程。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal使用学习]]></title>
    <url>%2FThreadLocal.html</url>
    <content type="text"><![CDATA[ThreadLocal字面上的意思是局部线程变量，每个线程通过ThreadLocal的get和set方法来访问和修改线程自己独有的变量。简单地说，ThreadLocal的作用就是为每一个线程提供了一个独立的变量副本，每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。ThreadLocal的基本使用ThreadLocal是一个泛型类，在创建的时候需要指定变量的类型：1private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();ThreadLocal提供了set方法来设置变量的值，get方法获取变量的值，remove方法移除变量：1234567891011public class ThreadLocalTest &#123; private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; threadLocal.set("mrbird"); System.out.println(threadLocal.get()); threadLocal.remove(); System.out.println(threadLocal.get()); &#125;&#125;程序输出如下： 我们也可以给ThreadLocal设置初始值，设置初始值有两种方式：重写initialValue方法：1234567891011public class ThreadLocalTest &#123; private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;()&#123; @Override protected String initialValue() &#123; return "初始值"; &#125; &#125;; public static void main(String[] args) throws InterruptedException &#123; System.out.println(threadLocal.get()); // 初始值 &#125;&#125;使用ThreadLocal的withInitial方法：123456public class ThreadLocalTest &#123; private static ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; "初始值"); public static void main(String[] args) throws InterruptedException &#123; System.out.println(threadLocal.get()); // 初始值 &#125;&#125;值得注意的是remove无法移除初始值：1234567public class ThreadLocalTest &#123; private static ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; "初始值"); public static void main(String[] args) throws InterruptedException &#123; threadLocal.remove(); System.out.println(threadLocal.get()); // 初始值 &#125;&#125;演示多线程间独立在多个线程中使用ThreadLocal：12345678910111213141516171819202122232425262728293031323334public class ThreadLocalTest2 &#123; private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); private static Random random = new Random(System.currentTimeMillis()); public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set("thread t1"); try &#123; TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + " " + threadLocal.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "thread1"); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set("thread t2"); try &#123; TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + " " + threadLocal.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "thread2"); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(Thread.currentThread().getName() + " " + threadLocal.get()); &#125;&#125;程序输出如下：结果证明了ThreadLocal在每个线程间是相互独立的，threadLocal在thread1、thread2和main线程间都有一份独立拷贝。ThreadLocal基本原理在ThreadLocal类中有一个静态内部类ThreadLocalMap(概念上类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本。我们使用Map来代替ThreadLocalMap，创建一个简易的类ThreadLocal实现：123456789101112131415161718192021222324252627public class MyThreadLocal&lt;T&gt; &#123; private final Map&lt;Thread, T&gt; threadLocalMap = new HashMap&lt;&gt;(); public void set(T t) &#123; synchronized (this) &#123; Thread key = Thread.currentThread(); threadLocalMap.put(key, t); &#125; &#125; public T get() &#123; synchronized (this) &#123; Thread key = Thread.currentThread(); T t = threadLocalMap.get(key); if (t == null) &#123; return initalValue(); &#125; else &#123; return t; &#125; &#125; &#125; public T initalValue() &#123; return null; &#125;&#125;使用方式和之前的例子一致：123456789101112131415161718192021222324252627282930313233343536373839public class ThreadLocalTest3 &#123; private static MyThreadLocal&lt;String&gt; threadLocal = new MyThreadLocal&lt;String&gt;() &#123; @Override public String initalValue() &#123; return "initalValue"; &#125; &#125;; private static Random random = new Random(System.currentTimeMillis()); public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set("thread t1"); try &#123; TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + " " + threadLocal.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "thread1"); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set("thread t2"); try &#123; TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + " " + threadLocal.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "thread2"); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(Thread.currentThread().getName() + " " + threadLocal.get()); &#125;&#125;程序输出如下：使用建议将ThreadLocal变量指定为private static；使用完毕后显式地调用remove方法移除。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习CAS]]></title>
    <url>%2FCAS.html</url>
    <content type="text"><![CDATA[在深入理解volatile关键字一节中，我们提到volatile并不能确保线程安全性，要解决文章中提到的累加例子线程安全问题的话，可以使用同步锁（synchronized）和Atomic类型。但就那个例子来说，使用synchronized同步锁有点小题大作，我们可以选择更为轻量的AtomicInteger来解决。将前面的例子改写为：1234567891011121314public class AtomticIntegerTest &#123; private static AtomicInteger value = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; IntStream.range(0, 500).forEach(i -&gt; value.getAndIncrement())); Thread thread2 = new Thread(() -&gt; IntStream.range(0, 500).forEach(i -&gt; value.getAndIncrement())); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(value); &#125;&#125;我们将value类型从volatile修饰的int类型改为AtomicInteger类型，这个例子无论运行多少次，结果都是我们期望的1000：Atomic类型内部并没有通过锁来保证线程安全，那么它们是如何实现的呢？这就是本节要讨论的CAS。什么是CASCAS是Compare-And-Swap的缩写，意思为比较并交换。以AtomicInteger为例，其提供了compareAndSet(int expect, int update)方法，expect为期望值（被修改的值在主内存中的期望值），update为修改后的值。compareAndSet方法返回值类型为布尔类型，修改成功则返回true，修改失败返回false。举个compareAndSet方法的例子：123456789public class AtomticIntegerTest &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(0); boolean result = atomicInteger.compareAndSet(0, 1); System.out.println(result); System.out.println(atomicInteger.get()); &#125;&#125;上面例子中，通过AtomicInteger(int initialValue)构造方法指定了AtomicInteger类成员变量value的初始值为0：123456789101112131415public class AtomicInteger extends Number implements java.io.Serializable &#123; ...... private volatile int value; /** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */ public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; ......&#125;接着执行compareAndSet方法，main线程从主内存中拷贝了value的副本到工作线程，值为0，并将这个值修改为1。如果此时主内存中value的值还是为0的话（言外之意就是没有被其他线程修改过），则将修改后的副本值刷回主内存更新value的值。所以上面的例子运行结果应该是true和1：将上面的例子修改为：1234567891011public class AtomticIntegerTest &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(0); boolean firstResult = atomicInteger.compareAndSet(0, 1); boolean secondResult = atomicInteger.compareAndSet(0, 1); System.out.println(firstResult); System.out.println(secondResult); System.out.println(atomicInteger.get()); &#125;&#125;上面例子中，main线程第二次调用compareAndSet方法的时候，value的值已经被修改为1了，不符合其expect的值，所以修改将失败。上面例子输出如下：CAS底层原理查看compareAndSet方法源码：该方法通过调用unsafe类的compareAndSwapInt方法实现相关功能。compareAndSwapInt方法包含四个参数：this，当前对象；valueOffset，value成员变量的内存偏移量（也就是内存地址）：12345678private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;expect，期待值；update，更新值。所以这个方法的含义为：获取当前对象value成员变量在主内存中的值，和传入的期待值相比，如果相等则说明这个值没有被别的线程修改过，然后将其修改为更新值。那么unsafe又是什么？它的compareAndSwapInt方法是原子性的么？查看该方法的源码：该方法并没有具体Java代码实现，方法通过native关键字修饰。由于Java方法无法直接访问底层系统，Unsafe类相当于一个后门，可以通过该类的方法直接操作特定内存的数据。Unsafe类存在于sun.msic包中，JVM会帮我们实现出相应的汇编指令。Unsafe类中的CAS方法是一条CPU并发原语，由若干条指令组成，用于完成某个功能的一个过程。原语的执行必须是连续的，在执行过程中不允许被中断，不会存在数据不一致的问题。getAndIncrement方法剖析了解了CAS原理后，我们回头看下AtomicInteger的getAndIncrement方法源码：该方法通过调用unsafe类的getAndAddInt方法实现相关功能。继续查看getAndAddInt方法的源码：结合这两张图，我们便可以很直观地看出为什么AtomicInteger的getAndIncrement方法是线程安全的了：上图中，var1是AtomicInteger对象本身；var2是AtomicInteger对象的成员变量value的内存地址；var4是需要变更的数量；var5是通过unsafe的getIntVolatile方法获得AtomicInteger对象的成员变量value在主内存中的值。do while循环中的逻辑为：用当前对象的值和var5比较，如果相同，说明该值没有被别的线程修改过，更新为var5+var4，并返回true（CAS）；否则继续获取值并比较，直到更新完成。CAS的缺点CAS并不是完美的，其存在以下这些缺点：如果刚好while里的CAS操作一直不成功，那么对CPU的开销大；只能确保一个共享变量的原子操作；存在ABA问题。CAS实现的一个重要前提是需要取出某一时刻的数据并在当下时刻比较交换，这之间的时间差会导致数据的变化。比如：thread1线程从主内存中取出了变量a的值为A，thread2页从主内存中取出了变量a的值为A。由于线程调度的不确定性，这时候thread1可能被短暂挂起了，thread2进行了一些操作将值修改为了B，然后又进行了一些操作将值修改回了A，这时候当thread1重新获取CPU时间片重新执行CAS操作时，会发现变量a在主内存中的值仍然是A，所以CAS操作成功。解决ABA问题那么如何解决CAS的ABA问题呢？由上面的阐述课件，光通过判断值是否相等并不能确保在一定时间差内值没有变更过，所以我们需要一个额外的指标来辅助判断，类似于时间戳，版本号等。JUC为我们提供了一个AtomicStampedReference类，通过查看它的构造方法就可以看出，除了指定初始值外，还需指定一个版本号（戳）：我们就用这个类来解决ABA问题，首先模拟一个ABA问题场景：1234567891011121314151617181920212223242526public class AtomticIntegerTest &#123; public static void main(String[] args) &#123; AtomicReference&lt;String&gt; atomicReference = new AtomicReference&lt;&gt;("A"); new Thread(() -&gt; &#123; // 模拟一次ABA操作 atomicReference.compareAndSet("A", "B"); atomicReference.compareAndSet("B", "A"); System.out.println(Thread.currentThread().getName() + "线程完成了一次ABA操作"); &#125;, "thread1").start(); new Thread(() -&gt; &#123; // 让thread2先睡眠2秒钟，确保thread1的ABA操作完成 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean result = atomicReference.compareAndSet("A", "B"); if (result) &#123; System.out.println(Thread.currentThread().getName() + "线程修改值成功，当前值为：" + atomicReference.get()); &#125; &#125;, "thread2").start(); &#125;&#125;运行程序，输出如下：使用AtomicStampedReference解决ABA问题：123456789101112131415161718192021222324252627282930313233343536373839public class AtomticIntegerTest &#123; public static void main(String[] args) &#123; // 初始值为A，版本号为1 AtomicStampedReference&lt;String&gt; reference = new AtomicStampedReference&lt;&gt;("A", 1); new Thread(() -&gt; &#123; int stamp = reference.getStamp(); System.out.println(Thread.currentThread().getName() + "当前版本号为：" + stamp); // 休眠1秒，让thread2也拿到初始的版本号 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 模拟一次ABA操作 reference.compareAndSet("A", "B", reference.getStamp(), reference.getStamp() + 1); reference.compareAndSet("B", "A", reference.getStamp(), reference.getStamp() + 1); System.out.println(Thread.currentThread().getName() + "线程完成了一次ABA操作"); &#125;, "thread1").start(); new Thread(() -&gt; &#123; int stamp = reference.getStamp(); System.out.println(Thread.currentThread().getName() + "当前版本号为：" + stamp); // 让thread2先睡眠2秒钟，确保thread1的ABA操作完成 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean result = reference.compareAndSet("A", "B", stamp, stamp + 1); if (result) &#123; System.out.println(Thread.currentThread().getName() + "线程修改值成功，当前值为：" + reference.getReference()); &#125; else &#123; System.out.println(Thread.currentThread().getName() + "线程修改值失败，当前值为：" + reference.getReference() + "，版本号为：" + reference.getStamp()); &#125; &#125;, "thread2").start(); &#125;&#125;程序输出如下：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC之Semaphore]]></title>
    <url>%2FJUC-Semaphore.html</url>
    <content type="text"><![CDATA[JUC的Semaphore俗称信号量，可用来控制同时访问特定资源的线程数量。通过它的构造函数我们可以指定信号量（称为许可证permits可能更为明确）的数量，线程可以调用Semaphore对象的acquire方法获取一个许可证，调用release来归还一个许可证。下面举个Semaphore的基本使用示例。Semaphore示例123456789101112131415161718192021222324public class SemaphoreTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 定义许可证数量 final Semaphore semaphore = new Semaphore(2); IntStream.range(0, 4).forEach(i -&gt; &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "开始"); try &#123; semaphore.acquire(); // 一次拿一个许可证 System.out.println(Thread.currentThread().getName() + "获取许可证"); TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + "释放许可证"); semaphore.release(); &#125; System.out.println(Thread.currentThread().getName() + "结束"); &#125;, "thread" + (i + 1)).start(); &#125;); &#125;&#125;上面的例子中，我们定义许可证的数量为2个，然后4个线程通过acquire方法去获取许可证，结束行通过release方法释放许可证。acquire方法默认一次只拿一个许可证，所以上面的例子中，同一时刻最多只有两个线程同时执行。程序输出如下所示： acquire的重载方法acquire(int permits)允许线程一次性获取N个许可证；同样的release的重载方法release(int permits)允许线程一次性释放N个许可证。Semaphore还有一个tryAcquire，它允许线程尝试去获取1个许可证，如果许可证不足没有获取到的话，线程也会继续执行，而非阻塞等待。tryAcquire方法的重载方法tryAcquire(long timeout, TimeUnit unit)可以指定尝试获取许可证的超时时间。acquireUninterruptibly从上面的例子我们会发现acquire方法会抛出InterruptedException异常，说明这个方法是可以被打断的：123456789101112131415161718public class SemaphoreTest &#123; public static void main(String[] args) throws InterruptedException &#123; final Semaphore semaphore = new Semaphore(1); Thread thread1 = new Thread(() -&gt; &#123; try &#123; semaphore.acquire(2); &#125; catch (InterruptedException e) &#123; System.err.println("semaphore InterruptedException"); e.printStackTrace(); &#125; &#125;); thread1.start(); TimeUnit.MICROSECONDS.sleep(500); thread1.interrupt(); &#125;&#125;上面例子thread1线程获取2个许可证，但许可证总数只有1个，所以会阻塞等待。main线程通过调用thread1的interrupt方法去打断thread1线程，结果如下：而通过acquireUninterruptibly方法去获取许可证是不可被打断的：123456789101112public class SemaphoreTest &#123; public static void main(String[] args) throws InterruptedException &#123; final Semaphore semaphore = new Semaphore(1); Thread thread1 = new Thread(() -&gt; &#123; semaphore.acquireUninterruptibly(2); &#125;); thread1.start(); TimeUnit.MICROSECONDS.sleep(500); thread1.interrupt(); &#125;&#125;上面程序并不会抛出InterruptedException，thread1会一直处于阻塞状态。drainPermitsdrainPermits方法一次性获取所有许可证（drain抽干榨干😮）：12345678910111213141516171819public class SemaphoreTest &#123; public static void main(String[] args) throws InterruptedException &#123; final Semaphore semaphore = new Semaphore(5); new Thread(() -&gt; &#123; System.out.println("availablePermits: " + semaphore.availablePermits()); semaphore.drainPermits(); // 获取所有许可证，抽干 System.out.println("availablePermits: " + semaphore.availablePermits()); try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; semaphore.release(5); System.out.println(Thread.currentThread().getName() + "结束"); &#125;, "thread1").start(); &#125;&#125;availablePermits方法用于获取当前可用许可证数量的预估值。程序输出如下：别的APIhasQueuedThreads方法用于判断是否有处于等待获取许可证状态的线程；getQueueLength用于获取处于等待获取许可证状态的线程的数量；getQueuedThreads用于获取处于等待获取许可证状态的线程集合。getQueuedThreads是protected的，所以要使用它，我们得自定义一个Semaphore的子类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SemaphoreTest &#123; public static void main(String[] args) &#123; // 定义许可证数量 final MySemaphore semaphore = new MySemaphore(1); IntStream.range(0, 4).forEach(i -&gt; &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "开始"); try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + "获取许可证"); TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + "释放许可证"); semaphore.release(); &#125; System.out.println(Thread.currentThread().getName() + "结束"); &#125;, "thread" + (i + 1)).start(); &#125;); while (true) &#123; if (semaphore.hasQueuedThreads()) &#123; System.out.println("等待线程数量：" + semaphore.getQueueLength()); Collection&lt;Thread&gt; queuedThreads = semaphore.getQueuedThreads(); System.out.println("等待线程：" + queuedThreads.stream().map(Thread::getName).collect(Collectors.joining(","))); &#125; &#125; &#125; static class MySemaphore extends Semaphore &#123; private static final long serialVersionUID = -2595494765642942297L; public MySemaphore(int permits) &#123; super(permits); &#125; public MySemaphore(int permits, boolean fair) &#123; super(permits, fair); &#125; public Collection&lt;Thread&gt; getQueuedThreads() &#123; return super.getQueuedThreads(); &#125; &#125;&#125;程序输出如下所示（截取一部分）： Api总结总结下Semaphore常用的方法：方法描述acquire()获取一个许可证，可以被打断，没有足够的许可证时阻塞等待acquire(int permits)获取指定数量的许可证，可以被打断，没有足够的许可证时阻塞等待acquireUninterruptibly()获取一个许可证，不可被打断，没有足够的许可证时阻塞等待acquireUninterruptibly(int permits)获取指定数量的许可证，不可被打断，没有足够的许可证时阻塞等待tryAcquire()尝试获取一个许可证，没有足够的许可证时程序继续执行，不会被阻塞tryAcquire(int permits)尝试获取指定数量的许可证，没有足够的许可证时程序继续执行，不会被阻塞tryAcquire(long timeout, TimeUnit unit)在指定的时间范围内尝试获取1个许可证，没有足够的许可证时程序继续执行，不会被阻塞，在该时间方位内可以被打断tryAcquire(int permits, long timeout, TimeUnit unit)在指定的时间范围内尝试获取指定数量的许可证，没有足够的许可证时程序继续执行，不会被阻塞，在该时间方位内可以被打断release()释放一个许可证drainPermits()一次性获取所有可用的许可证availablePermits()获取当前可用许可证数量的预估值hasQueuedThreads()判断是否有处于等待获取许可证状态的线程getQueueLength()获取处于等待获取许可证状态的线程的数量的预估值getQueuedThreads()获取处于等待获取许可证状态的线程集合]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解volatile关键字]]></title>
    <url>%2Fvolatile.html</url>
    <content type="text"><![CDATA[volatile关键字修饰的成员变量具有两大特性：保证了该成员变量在不同线程之间的可见性；禁止对该成员变量进行重排序，也就保证了其有序性。但是volatile修饰的成员变量并不具有原子性，在并发下对它的修改是线程不安全的。下面分别举例来演示这两个特性，并且分析为什么volatile不是线程安全的。可见性通过对JMM的学习，我们都知道线程对主内存中共享变量的修改首先会从主内存获取值的拷贝，然后保存到线程的工作内存中。接着在工作内存中对值进行修改，最终刷回主内存。由于不同线程拥有各自的工作内存，所以它们对某个共享变量值的修改在没有刷回主内存的时候只对自己可见。举个例子，假如有两个线程，其中一个线程用于修改共享变量value，另一个线程用于获取修改后的value：1234567891011121314151617181920212223242526272829public class VolatileTest &#123; private static int INIT_VALUE = 0; private final static int LIMIT = 5; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; int value = INIT_VALUE; while (value &lt; LIMIT) &#123; if (value != INIT_VALUE) &#123; System.out.println("获取更新后的值：" + INIT_VALUE); value = INIT_VALUE; &#125; &#125; &#125;, "reader").start(); new Thread(() -&gt; &#123; int value = INIT_VALUE; while (INIT_VALUE &lt; LIMIT) &#123; System.out.println("将值更新为：" + ++value); INIT_VALUE = value; try &#123; TimeUnit.MILLISECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "writer").start(); &#125;&#125;writer线程每隔0.5秒将INIT_VALUE值递增，直到INIT_VALUE大于等于5。而reader线程则是不停的去获取INIT_VALUE的值，直到INIT_VALUE的值大于等于5。程序执行结果如下：多执行几次可能每次结果都不一样，但是可以确定的是，writer对值的修改reader并不能感知到（如果能感知到的话，reader线程就不会停不下来了）。为什么会出现上面的结果呢？因为writer线程在工作内存中修改了INIT_VALUE的值，即使它刷回主内存了，但是reader线程在此之前已经从主内存获取了INIT_VALUE的值（因为线程获取CPU时间片不确定性，这个值可能是0，也可能是被writer修改后的值，但writer线程是每隔0.5毫秒才会去修改值，所以reader获取到的INIT_VALUE的值一般不会是writer修改的最终值5），并保存到了reader线程的工作内存中。reader线程通过while不断的轮询判断value和INIT_VALUE的值是否相等，但是由于reader线程工作内存中已经有INIT_VALUE的值的拷贝了，所以reader并不会重新从主内存中获取被writer修改后的INIT_VALUE的值，reader线程里while条件一直成立，这就是为什么reader线程不会正常停止并且没有输出修改后的值的原因。修改上面的例子，将INIT_VALUE成员变量使用volatile关键字修饰：1234567891011121314151617181920212223242526272829public class VolatileTest &#123; private volatile static int INIT_VALUE = 0; private final static int LIMIT = 5; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; int value = INIT_VALUE; while (value &lt; LIMIT) &#123; if (value != INIT_VALUE) &#123; System.out.println("获取更新后的值：" + INIT_VALUE); value = INIT_VALUE; &#125; &#125; &#125;, "reader").start(); new Thread(() -&gt; &#123; int value = INIT_VALUE; while (INIT_VALUE &lt; LIMIT) &#123; System.out.println("将值更新为：" + ++value); INIT_VALUE = value; try &#123; TimeUnit.MICROSECONDS.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, "writer").start(); &#125;&#125;可以看到，reader线程已经可以正常停止了，因为最终INIT_VALUE的值肯定是5，并且reader可以感知到这个值被修改为5了。为什么volatile修饰的成员变量在线程间具有可见性呢？因为通过volatile修饰，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，加了这个指令后，会引发两件事情：将当前处理器缓存行的内容写回到系统内存，也就是强制将工作内存中的值刷回主内存；这个写回到内存的操作会使得在其他CPU里缓存了该内存地址的数据失效。其他CPU缓存数据失效，则会重新去内存中读取值，也就是被修改的数据。通过上面这两个特性，我们可以确定的是，writer对值进行修改并刷回主内存后，reader里INIT_VALUE值的拷贝就失效了，所以reader线程会再次从主内存中获取INIT_VALUE的值，这时候这个值已经是被writer线程修改刷新后的值了。有序性来看一个线程不安全的单例实现（双重同步锁单例模式，更多关于单例的介绍可以参考单例的几种写法和对比）:123456789101112131415161718public class SingletonTest &#123; // 私有化构造函数，让外部没办法直接通过new来创建 private SingletonTest() &#123; &#125; // 单例对象 private static SingletonTest instance = null; // 静态工厂方法 public static SingletonTest getInstance() &#123; if (instance == null) &#123; // 双重检测 synchronized (SingletonTest.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; &#125; return instance; &#125;&#125;上面的例子虽然加了同步锁，但是在多线程下并不是线程安全的。第12行instance = new SingletonTest()在实际执行的时候会被拆分为以下三个步骤:分配存储SingletonTest对象的内存空间；初始化SingletonTest对象；将instance指向刚刚分配的内存空间。通过JMM的学习我们都知道，在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，因为第2步和第3步并没有依赖关系，所以可能发生重排序，排序后的步骤为：分配存储SingletonTest对象的内存空间；将instance指向刚刚分配的内存空间；初始化SingletonTest对象。经过重排序后，上面的例子在多线程下就会出现问题。假如现在有两个线程A和B同时调用SingletonTest#getInstance，线程A执行到了代码的第12行instance = new SingletonTest()，已经完成了对象内存空间的分配并将instance指向了该内存空间，线程B执行到了第9行，发现instance并不是null（因为已经指向了内存空间），所以就直接返回instance了。但是线程A并还没有执行初始化SingletonTest操作，所以实际线程B拿到的SingletonTest实例是空的，那么线程B后续对SingletonTest操控将抛出空指针异常。要让上面的例子是线程安全的，只需要用volatile修饰单例对象即可：123456789101112131415161718public class SingletonTest &#123; // 私有化构造函数，让外部没办法直接通过new来创建 private SingletonTest() &#123; &#125; // 单例对象 private volatile static SingletonTest instance = null; // 静态工厂方法 public static SingletonTest getInstance() &#123; if (instance == null) &#123; // 双重检测 synchronized (SingletonTest.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; &#125; return instance; &#125;&#125;因为通过volatile修饰的成员变量会添加内存屏障来阻止JVM进行指令重排优化。线程不安全举个递增的例子：1234567891011121314public class VolatileTest2 &#123; private volatile static int value; public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; IntStream.range(0, 500).forEach(i -&gt; value += 1)); Thread thread2 = new Thread(() -&gt; IntStream.range(0, 500).forEach(i -&gt; value += 1)); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(value); &#125;&#125;多次运行上面的例子：可以看到最终的值有可能小于1000。volatile可以保证修改的值能够马上更新到主内存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？因为在Java中，只有对基本类型的赋值和修改才是原子性的，而对共享变量的修改并不是原子性的。通过JMM内存交互协议我们可以知道，一个线程修改共享变量的值需要经过下面这些步骤：线程从主内存中读取（read）共享变量的值，然后载入（load）到线程的工作内存中的变量；使用（use）工作内存变量的值，执行加减操作，然后将修改后的值赋值（assign）给工作内存中的变量；将工作内存中修改后的变量的值存储（store）到主内存中，并执行写入（write）操作。所以上面的例子中，可能出现下面这种情况：thread1和thread2同时获取了value的值，比如为100。thread1执行了+1操作，然后写回主内存，这个时候thread2刚好执行完use操作（+1），准备执行assign（将+1后的值写回工作内存对应的变量中）操作。虽然这时候thread2工作内存中value值的拷贝无效了（因为volatile的特性），但是thread2已经执行完+1操作了，它并不需要再从主内存中获取value的值，所以thread2可以顺利地将+1后的值赋值给工作内存中的变量，然后刷回主存。这就是为什么上面的累加结果可能会小于1000的原因。要让上面的例子是线程安全的话可以加同步锁，或者使用atomic类，后续会介绍到。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC之Exchanger]]></title>
    <url>%2FJUC-Exchanger.html</url>
    <content type="text"><![CDATA[JUC中的Exchanger允许成对的线程在指定的同步点上通过exchange方法来交换数据。如果第一个线程先执行exchange方法，它会一直等待第二个线程也 执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将当前线程生产 出来的数据传递给对方。Exchanger示例两个线程通过Exchanger交换数据的简单示例：123456789101112131415161718192021222324252627public class ExchangerTest &#123; public static void main(String[] args) &#123; final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); new Thread(() -&gt; &#123; System.out.println("thread1开始"); try &#123; String exchange = exchanger.exchange("来自thread1的数据"); System.out.println("接收thread2发送的数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread1结束"); &#125;, "thread1").start(); new Thread(() -&gt; &#123; System.out.println("thread2开始"); try &#123; String exchange = exchanger.exchange("来自thread2的数据"); System.out.println("接收thread1发送的数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread2结束"); &#125;, "thread2").start(); &#125;&#125;在定义Exchanger的时候需要指定交换的数据类型，这里为String类型。exchange方法用于向另一个线程发送数据，方法的返回值为另一个线程发送过来的数据。上面例子输出如下：123456thread1开始thread2开始接收thread2发送的数据：来自thread2的数据thread1结束接收thread1发送的数据：来自thread1的数据thread2结束上面说过，只有当成对的线程都到达同步点的时候，才会执行数据交换操作。现在我们让thread2休眠一会儿，看看thread1是否会进入等待：12345678910111213141516171819202122232425262728public class ExchangerTest &#123; public static void main(String[] args) &#123; final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); new Thread(() -&gt; &#123; System.out.println("thread1开始"); try &#123; String exchange = exchanger.exchange("来自thread1的数据"); System.out.println("接收thread2发送的数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread1结束"); &#125;, "thread1").start(); new Thread(() -&gt; &#123; System.out.println("thread2开始"); try &#123; TimeUnit.SECONDS.sleep(3); // thread1也会进入等待，直到双方都准备好交换数据。 String exchange = exchanger.exchange("来自thread2的数据"); System.out.println("接收thread1发送的数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread2结束"); &#125;, "thread2").start(); &#125;&#125;程序输出如下所示：那么如果线程不成对会出现什么情况呢？我们添加thread3线程：1234567891011121314151617181920212223242526272829303132333435363738public class ExchangerTest &#123; public static void main(String[] args) &#123; final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); new Thread(() -&gt; &#123; System.out.println("thread1开始"); try &#123; String exchange = exchanger.exchange("发送数据-thread1"); System.out.println("接收数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread1结束"); &#125;, "thread1").start(); new Thread(() -&gt; &#123; System.out.println("thread2开始"); try &#123; String exchange = exchanger.exchange("发送数据-thread2"); System.out.println("接收数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread2结束"); &#125;, "thread2").start(); new Thread(() -&gt; &#123; System.out.println("thread3开始"); try &#123; String exchange = exchanger.exchange("发送数据-thread3"); System.out.println("接收数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread3结束"); &#125;, "thread3").start(); &#125;&#125;程序输出如下所示：1234567thread1开始thread3开始接收数据：发送数据-thread1thread3结束thread2开始接收数据：发送数据-thread3thread1结束可看到thread1和thread3交换了数据然后正常停止了，而thread2由于没有线程和它交换数据而苦苦等待，线程永远不会停止。查看线程快照可以证明这点：线程匹配是随机的，所以也有可能thread1和thread2匹配，thread3进入无休止的等待，这就类似于…另一个值得一提的点就是通过Exchanger交换的是同一个对象，而不是对象的拷贝：12345678910111213141516171819202122232425262728293031public class ExchangerTest &#123; public static void main(String[] args) &#123; final Exchanger&lt;Object&gt; exchanger = new Exchanger&lt;&gt;(); new Thread(() -&gt; &#123; System.out.println("thread1开始"); Object object = new Object(); System.out.println("thread1发送数据：" + object); try &#123; Object exchange = exchanger.exchange(object); System.out.println("接收thread2发送的数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread1结束"); &#125;, "thread1").start(); new Thread(() -&gt; &#123; System.out.println("thread2开始"); Object object = new Object(); System.out.println("thread2发送数据：" + object); try &#123; Object exchange = exchanger.exchange(object); System.out.println("接收thread1发送的数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread2结束"); &#125;, "thread2").start(); &#125;&#125;程序输出如下：12345678thread1开始thread2开始thread2发送数据：java.lang.Object@6d559005thread1发送数据：java.lang.Object@7702c19接收thread2发送的数据：java.lang.Object@6d559005接收thread1发送的数据：java.lang.Object@7702c19thread2结束thread1结束可以看到thread1发送的对象和thread2接收的对象句柄是一致的。设置超时时间如果不想线程在交换数据的时候等待过长的时间，我们可以使用exchanger的重载方法exchange(V x, long timeout, TimeUnit unit)来指定超时时间：12345678910111213141516171819202122232425262728public class ExchangerTest &#123; public static void main(String[] args) &#123; final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); new Thread(() -&gt; &#123; System.out.println("thread1开始"); try &#123; String exchange = exchanger.exchange("来自thread1的数据", 5, TimeUnit.SECONDS); System.out.println("接收thread2发送的数据：" + exchange); &#125; catch (InterruptedException | TimeoutException e) &#123; e.printStackTrace(); &#125; System.out.println("thread1结束"); &#125;, "thread1").start(); new Thread(() -&gt; &#123; System.out.println("thread2开始"); try &#123; TimeUnit.SECONDS.sleep(10); String exchange = exchanger.exchange("来自thread2的数据"); System.out.println("接收thread1发送的数据：" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("thread2结束"); &#125;, "thread2").start(); &#125;&#125;上面例子中，thread2休眠10秒后才开始交换数据，而thread1在等待5秒后没能成功交换数据就抛出TimeoutException异常了。10秒后由于没有线程再和thread2交换数据，所以thread2会一直等待：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC之CyclicBarrier]]></title>
    <url>%2FJUC-CyclicBarrier.html</url>
    <content type="text"><![CDATA[CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。CyclicBarrier示例使用“人满发车”的例子来演示CyclicBarrier：12345678910111213141516171819202122232425262728public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; CyclicBarrier barrier = new CyclicBarrier(2); System.out.println("快上车来不及解释了"); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread() + "已上车"); barrier.await(); System.out.println("所有人已上车，发车"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "Jane").start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread() + "已上车"); barrier.await(); System.out.println("所有人已上车，发车"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "Mike").start(); &#125;&#125;上面例子中我们定义了一个等待2个线程完成的CyclicBarrier，在两个线程内部调用了await方法，让其阻塞等待，并告知CyclicBarrier我已经到达屏障了。只有当两个线程都执行到barrier.await()这一行时，屏障开启，线程才会继续往下执行。程序输出如下所示：12345快上车来不及解释了Thread[Mike,5,main]已上车Thread[Jane,5,main]已上车所有人已上车，发车所有人已上车，发车CyclicBarrier的构造函数支持传入一个回调方法：123CyclicBarrier barrier = new CyclicBarrier(n, () -&gt; &#123; System.out.println("当所有线程到达屏障时，执行该回调");&#125;);改造上面的例子：12345678910111213141516171819202122232425262728293031public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; CyclicBarrier barrier = new CyclicBarrier(2, new Thread(() -&gt; &#123; System.out.println("发车，嘟嘟嘟"); &#125;)); System.out.println("快上车来不及解释了"); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread() + "已上车"); barrier.await(); System.out.println("所有人已上车"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "Jane").start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(3); System.out.println(Thread.currentThread() + "已上车"); barrier.await(); System.out.println("所有人已上车"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "Mike").start(); &#125;&#125;输出如下所示：123456快上车来不及解释了Thread[Mike,5,main]已上车Thread[Jane,5,main]已上车发车，嘟嘟嘟所有人已上车，发车所有人已上车，发车设置超时时间await的重载方法：await(long timeout, TimeUnit unit)可以设置最大等待时长，超出这个时间屏障还没有开启的话则抛出TimeoutException：1234567891011121314151617181920212223242526public class CyclicBarrierTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; CyclicBarrier barrier = new CyclicBarrier(2); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(3); barrier.await(); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "thread1").start(); new Thread(() -&gt; &#123; try &#123; barrier.await(1, TimeUnit.SECONDS); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; &#125;, "thread2").start(); &#125;&#125;BrokenBarrierException抛出BrokenBarrierException异常时表示屏障破损，此时标志位broken=true。抛出BrokenBarrierException异常的情况主要有：其他等待的线程被中断，则当前线程抛出BrokenBarrierException异常；其他等待的线程超时，则当前线程抛出BrokenBarrierException异常；当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常。模拟第1种情况，其他等待的线程被中断，则当前线程抛出BrokenBarrierException异常：12345678910111213141516171819202122232425262728293031public class CyclicBarrierTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; CyclicBarrier barrier = new CyclicBarrier(2); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread() + "开始执行"); TimeUnit.SECONDS.sleep(3); barrier.await(); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "thread1").start(); Thread thread2 = new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread() + "开始执行"); TimeUnit.SECONDS.sleep(1); barrier.await(); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "thread2"); thread2.start(); TimeUnit.SECONDS.sleep(2); thread2.interrupt(); &#125;&#125;输出：上面例子中thread2线程睡眠1秒后先到达屏障点，然后进入等待状态。2秒后main线程执行thread2.interrupt()中断等待中的thread2线程，所以程序抛出BrokenBarrierException异常。3秒后thread1线程到达屏障点，此时屏障已经被破坏了，所以也抛出BrokenBarrierException异常。模拟第2种情况：其他等待的线程超时，则当前线程抛出BrokenBarrierException异常：123456789101112131415161718192021222324252627public class CyclicBarrierTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; CyclicBarrier barrier = new CyclicBarrier(2); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread() + "开始执行"); TimeUnit.SECONDS.sleep(3); barrier.await(); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "thread1").start(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread() + "开始执行"); TimeUnit.SECONDS.sleep(1); barrier.await(1, TimeUnit.SECONDS); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException | TimeoutException e) &#123; e.printStackTrace(); &#125; &#125;, "thread2").start(); &#125;&#125;输出：上面例子中thread2睡眠1秒后到达屏障点，然后进入等待状态（最多等待1秒），然而因为thread1要3秒后才能到达屏障点，所以thread2将抛出TimeoutException。3秒后，thread1到达屏障点，但这时候由于thread2的await方法抛出的异常破坏了屏障，所以thread1将抛出BrokenBarrierException异常。模拟第3中情况：当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常：1234567891011121314151617181920212223242526272829303132public class CyclicBarrierTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; CyclicBarrier barrier = new CyclicBarrier(2); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread() + "开始执行"); TimeUnit.SECONDS.sleep(3); barrier.await(); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "thread1").start(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread() + "开始执行"); TimeUnit.SECONDS.sleep(1); barrier.await(); System.out.println(Thread.currentThread() + "继续执行"); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "thread2").start(); TimeUnit.SECONDS.sleep(2); System.out.println(barrier.getNumberWaiting()); barrier.reset(); &#125;&#125;输出：上面例子中，thread2睡眠1秒后到达屏障点，然后进入等待状态。2秒后main线程调用reset方法重置了屏障，所以在等待状态中的thread2抛出BrokenBarrierException异常。3秒后，thread1到达屏障点，由于reset方法重置了屏障，所以thread1并不会抛出BrokenBarrierException异常，而是一直在屏障点进行等待别的线程到达屏障点。从上面的三个例子中可以看到，无论是哪种情况导致屏障破坏，屏障点后面的代码都没有被执行，main方法也没有退出。和CountDownLatch区别CountDownLatch：一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行；CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。CountDownLatch：一次性的；CyclicBarrier：可以重复使用。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC之CountDownLatch]]></title>
    <url>%2FJUC-CountDownLatch.html</url>
    <content type="text"><![CDATA[CountDownLatch允许一个或多个线程等待其他线程完成操作。定义CountDownLatch的时候，需要传入一个正数来初始化计数器（虽然传入0也可以，但这样的话CountDownLatch没什么实际意义）。其countDown方法用于递减计数器，await方法会使当前线程阻塞，直到计数器递减为0。所以CountDownLatch常用于多个线程之间的协调工作。CountDownLatch示例假设我们现在有这样一个需求：从数据库获取数据对这批数据进行处理保存这批数据为了让程序执行效率更高，第2步中我们可以使用多线程来并行处理这批数据，大致过程如下所示：123456789101112131415161718192021222324252627282930313233public class CountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 1. 模拟从数据库获取数据 int[] data = query(); System.out.println("获取数据完毕"); // 2. 数据处理 IntStream.range(0, data.length).forEach(i -&gt; &#123; ExecutorService.execute(() -&gt; &#123; System.out.println(Thread.currentThread() + "处理第" + (i + 1) + "条数据"); int value = data[i]; if (value % 2 == 0) &#123; data[i] = value * 2; &#125; else &#123; data[i] = value * 10; &#125; &#125;); &#125;); System.out.println("所有数据都处理完了"); // 关闭线程池 ExecutorService.shutdown(); // 3. 保存数据 save(data); &#125; private static int[] query() &#123; return new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; &#125; private static void save(int[] data) &#123; System.out.println("保存数据 - " + Arrays.toString(data)); &#125;&#125;由于线程获取CPU时间片的不确定性，所以有可能数据还没有处理完毕，第3步就执行完了：12345678910111213获取数据完毕所有数据都处理完了保存数据 - [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]Thread[pool-1-thread-2,5,main]处理第2条数据Thread[pool-1-thread-1,5,main]处理第1条数据Thread[pool-1-thread-2,5,main]处理第3条数据Thread[pool-1-thread-1,5,main]处理第4条数据Thread[pool-1-thread-1,5,main]处理第6条数据Thread[pool-1-thread-2,5,main]处理第5条数据Thread[pool-1-thread-1,5,main]处理第7条数据Thread[pool-1-thread-1,5,main]处理第9条数据Thread[pool-1-thread-2,5,main]处理第8条数据Thread[pool-1-thread-1,5,main]处理第10条数据我们可以借助CountDownLatch解决这个问题：12345678910111213141516171819202122232425262728293031323334353637public class CountDownLatchTest &#123; private static ExecutorService ExecutorService = Executors.newFixedThreadPool(2); private static CountDownLatch latch = new CountDownLatch(10); public static void main(String[] args) throws InterruptedException &#123; // 1. 模拟从数据库获取数据 int[] data = query(); System.out.println("获取数据完毕"); // 2. 数据处理 IntStream.range(0, data.length).forEach(i -&gt; &#123; ExecutorService.execute(() -&gt; &#123; System.out.println(Thread.currentThread() + "处理第" + (i + 1) + "条数据"); int value = data[i]; if (value % 2 == 0) &#123; data[i] = value * 2; &#125; else &#123; data[i] = value * 10; &#125; latch.countDown(); &#125;); &#125;); latch.await(); System.out.println("所有数据都处理完了"); // 关闭线程池 ExecutorService.shutdown(); // 3. 保存数据 save(data); &#125; private static int[] query() &#123; return new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; &#125; private static void save(int[] data) &#123; System.out.println("保存数据 - " + Arrays.toString(data)); &#125;&#125;我们定义了一个CountDownLatch，计数器值为10，和数据量一致。然后在第2步中，当每个线程执行完毕的时候调用countDown方法，让计数器减1。在第3步前调用await方法让main线程阻塞等待，直到计数器被减为0。所以这就保证了只有当所有数据加工完毕才执行保存数据操作。执行方法，程序输出如下所示：12345678910111213获取数据完毕Thread[pool-1-thread-1,5,main]处理第1条数据Thread[pool-1-thread-1,5,main]处理第3条数据Thread[pool-1-thread-1,5,main]处理第4条数据Thread[pool-1-thread-1,5,main]处理第5条数据Thread[pool-1-thread-1,5,main]处理第6条数据Thread[pool-1-thread-1,5,main]处理第7条数据Thread[pool-1-thread-1,5,main]处理第8条数据Thread[pool-1-thread-1,5,main]处理第9条数据Thread[pool-1-thread-1,5,main]处理第10条数据Thread[pool-1-thread-2,5,main]处理第2条数据所有数据都处理完了保存数据 - [10, 4, 30, 8, 50, 12, 70, 16, 90, 20]await有重载方法：await(long timeout, TimeUnit unit)，设置最大等待时间，超过这个时间程序将继续执行不再被阻塞：123456789101112131415161718public class CountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; final CountDownLatch latch = new CountDownLatch(1); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(4); System.out.println(Thread.currentThread() + "线程执行完毕"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; latch.countDown(); &#125; &#125;, "thread1").start(); latch.await(3, TimeUnit.SECONDS); // 最多等待 3秒 System.out.println("main线程执行完毕"); &#125;&#125;输出如下：12main线程执行完毕Thread[thread1,5,main]线程执行完毕]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 内存模型]]></title>
    <url>%2FJava-Memory-model.html</url>
    <content type="text"><![CDATA[理解Java内存模型是深入学习Java并发不可或缺的部分。Java内存模型即Java Memory Model，简称为JMM，定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。JMM规定Java线程间的通信采用共享内存的方式。在Java中，所有成员变量、静态变量和数组元素都存储在堆内存中，堆内存在线程之间共享，所以它们通常也称为共享变量。JMM定义了线程和主内存之间的抽 象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory，或者也可以称为工作内存 Work Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。JMM抽象JMM的抽象示意图如下所示：多个线程同时对同一个共享变量进行读写的时候会产生线程安全问题。那为什么CPU不直接操作内存，而要在CPU和内存间加上各种缓存和寄存器等缓冲区呢？因为CPU的运算速度要比内存的读写速度快得多，如果CPU直接操作内存的话势必会花费很长时间等待数据到来，所以缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾。内存间交互协议JMM规定了主内存和工作内存间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，这主要包含了下面8个步骤：lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。lock，unlock需要代码中用锁实现。这8个步骤必须符合下述规则：不允许read和load，store和write操作之一单独出现。不允许一个线程丢弃它最近的assign操作。即变量在工作内存中改变了账号必须把变化同步回主内存一个新的变量只允许在主内存中诞生，不允许工作内存直接使用未初始化的变量。一个变量同一时刻只允许一条线程进行lock操作，但同一线程可以lock多次，lock多次之后必须执行同样次数的unlock操作如果对一个变量进行lock操作，那么将会清空工作内存中此变量的值。不允许对未lock的变量进行unlock操作，也不允许unlock一个被其它线程lock的变量如果一个变量执行unlock操作，必须先把此变量同步回主内存中。指令重排在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序：编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。 编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。内存屏障通过插入内存屏障（Memory Barrier）可以阻止特定类型的指令重排。JMM将内存屏障划分为四种：屏障类型示例描述LoadLoad BarriersLoad1-LoadLoad-Load2Load1数据装载过程要先于Load2及所有后续的数据装载过程StoreStore BarriersStore1-StoreStore-Store2Store1刷新数据到内存的过程要先于Strore2及后续所有刷新数据到内存的过程LoadStore BarriersLoad1-LoadStore-Store2Load1数据装载要先于Strore2及后续所有刷新数据到内存的过程StoreLoad BarriersStore1-StoreLoad-Load2Store1刷新数据到内存的过程要先于Load2及所有后续的数据装载过程Java中volatile关键字的实现就是通过内存屏障来完成的。happens-before从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。与程序员密切相关的happens-before规则如下：程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。参考自：Java并发编程的艺术]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava 杂项笔记]]></title>
    <url>%2FGuava-Miscellaneous-notes.html</url>
    <content type="text"><![CDATA[这里主要记录Guava提供的一些工具类的用法。Strings空和null相互转换：1234String s1 = Strings.emptyToNull("");System.out.println(s1); // nullString s2 = Strings.nullToEmpty(null);System.out.println(s2); //获取相同的前缀和后缀：1234String s3 = Strings.commonPrefix("mrbird", "mr.right");System.out.println(s3); // mrString s4 = Strings.commonSuffix("mrbird", "third");System.out.println(s4); // irdrepeat重复操作：12String s5 = Strings.repeat("mrbird", 3);System.out.println(s5); // mrbirdmrbirdmrbird判断字符串是否为空或null：12boolean nullOrEmpty = Strings.isNullOrEmpty(null);System.out.println(nullOrEmpty); // true左侧填充和右侧填充：1234String s6 = Strings.padStart("01", 5, '0');System.out.println(s6); // 00001String s7 = Strings.padEnd("1.0", 5, '0');System.out.println(s7); // 1.000StopWatcherStopWatcher用于监测一段程序的执行耗时。我们之前通常的做法是：1234System.out.println("程序开始处理");long start = System.currentTimeMillis();TimeUnit.SECONDS.sleep(2);System.out.println("程序处理结束，耗时" + (System.currentTimeMillis() - start) + "毫秒"); // 程序处理结束，耗时2.002 s使用StopWatcher方便之处在于它会帮我们选取合适的时间单位：1234System.out.println("程序开始处理");Stopwatch stopwatch = Stopwatch.createStarted();TimeUnit.SECONDS.sleep(2);System.out.println("程序处理结束，耗时" + stopwatch.stop()); // 程序处理结束，耗时2.002 sPreconditions断言断言常用于类库设计中方法参数的判断，当参数不符合要求时，让程序提前抛异常结束。Preconditions是Guava提供的断言类。非空校验判断是否为空，为空的话抛出NullPointerException：12List&lt;String&gt; list = null;Preconditions.checkNotNull(list);自定义描述：12List&lt;String&gt; list = null;Preconditions.checkNotNull(list, "list不能为空");自定义描述 + 长度校验：12List&lt;String&gt; list = null;Preconditions.checkNotNull(list, "list长度必须为%s", 2);参数校验校验不通过时，抛出IllegalArgumentException：12String value = "hello";Preconditions.checkArgument("world".equals(value), "参数内容必须为world");状态校验校验不通过时，抛出IllegalStateException：12String state = "on";Preconditions.checkState("off".equals(state), "状态必须为off");校验元素个数校验不通过，抛出IndexOutOfBoundsException：12List&lt;String&gt; list = ImmutableList.of();Preconditions.checkElementIndex(10, list.size(), "下标越界，不存在第10个元素");IO操作演示之前先创建一个source.txt文件：12Guava I/O operationGuava I/O 操作相关常量：12private static final String SOURCE_FILE = "C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird\\resources\\source.txt";private static final String TARGET_FILE = "C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird\\resources\\target.txt";文件拷贝123File targetFile = new File(TARGET_FILE);Files.copy(new File(SOURCE_FILE), targetFile);System.out.println(targetFile.exists()); // true文件移动1Files.move(new File(SOURCE_FILE), new File(TARGET_FILE));文件移动和文件拷贝的区别是，文件移动会删除源文件：读取文件内容将文件内容读取到String集合中：12List&lt;String&gt; list = Files.readLines(new File(SOURCE_FILE), Charsets.UTF_8);list.forEach(System.out::println);读的过程中进行一些加工：12345678910111213141516LineProcessor&lt;List&lt;String&gt;&gt; lineProcessor = new LineProcessor&lt;List&lt;String&gt;&gt;() &#123; List&lt;String&gt; result = Lists.newArrayList(); @Override public boolean processLine(String line) &#123; if (line.length() != 0) &#123; result.add(line + "。"); &#125; return true; &#125; @Override public List&lt;String&gt; getResult() &#123; return result; &#125;&#125;;List&lt;String&gt; result = Files.asCharSource(new File(SOURCE_FILE), Charsets.UTF_8).readLines(lineProcessor);System.out.println(result); // [Guava I/O operation。, Guava I/O 操作。]写操作追加操作：1234567File file = new File(SOURCE_FILE);String value = "添加一些内容";CharSink charSink = Files.asCharSink(file, Charsets.UTF_8, FileWriteMode.APPEND); // 追加charSink.write(value);String read = Files.asCharSource(file, Charsets.UTF_8).read();System.out.println(read);覆盖操作：1234567File file = new File(SOURCE_FILE);String value = "添加一些内容";CharSink charSink = Files.asCharSink(file, Charsets.UTF_8); // 覆盖charSink.write(value);String read = Files.asCharSource(file, Charsets.UTF_8).read();System.out.println(read);文件转为哈希码123File file = new File(SOURCE_FILE);HashCode hash = Files.asByteSource(file).hash(Hashing.sha256());System.out.println(hash); // c46982603d4b2ba5032d73dc1fffbe1aea1f11d75921b2839632c56636673d31文件创建12345String TOUCH_FILE = "C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird\\resources\\new.txt";File file = new File(TOUCH_FILE);Files.touch(file);boolean exists = file.exists();System.out.println(exists); // true递归操作由浅入深：12345678910File file = new File("C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird");// depthFirstPreOrder 由浅入深Iterable&lt;File&gt; files = Files.fileTraverser().depthFirstPreOrder(file);files.forEach(f -&gt; &#123; if (f.isDirectory()) &#123; System.out.println("directory: " + f); &#125; else &#123; System.out.println("file: " + f); &#125;&#125;);由深入浅：12345678910File file = new File("C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird");// depthFirstPostOrder 由深入浅Iterable&lt;File&gt; files = Files.fileTraverser().depthFirstPostOrder(file);files.forEach(f -&gt; &#123; if (f.isDirectory()) &#123; System.out.println("directory: " + f); &#125; else &#123; System.out.println("file: " + f); &#125;&#125;);]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO2接口方法]]></title>
    <url>%2FNIO2%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[JDK7对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。Path 与 Pathsjava.nio.file.Path接口代表一个平台无关的平台路径，描述了目录结构中文件的位置。Paths提供的get()方法用来获取Path对象：Path get(String first, String … more)：用于将多个字符串串连成路径。Path常用方法：boolean endsWith(String path)： 判断是否以 path 路径结束；boolean startsWith(String path)：判断是否以 path 路径开始；boolean isAbsolute()： 判断是否是绝对路径；Path getFileName()： 返回与调用 Path 对象关联的文件名；Path getName(int idx)：返回的指定索引位置 idx 的路径名称；int getNameCount()：返回Path 根目录后面元素的数量；Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径；Path getRoot() ：返回调用 Path 对象的根路径；Path resolve(Path p) ：将相对路径解析为绝对路径；Path toAbsolutePath()：作为绝对路径返回调用 Path 对象；String toString()：返回调用 Path 对象的字符串表示形式。Files 类java.nio.file.Files 用于操作文件或目录的工具类。Files常用方法（增删改）：Path copy(Path src, Path dest, CopyOption … how)：文件的复制；Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr)：创建一个目录；Path createFile(Path path, FileAttribute&lt;?&gt; … arr)：创建一个文件；void delete(Path path)：删除一个文件；Path move(Path src, Path dest, CopyOption…how)：将 src 移动到 dest 位置；long size(Path path)：返回 path 指定文件的大小。Files常用方法（判断类）：boolean exists(Path path, LinkOption … opts)：判断文件是否存在；boolean isDirectory(Path path, LinkOption … opts)：判断是否是目录；boolean isExecutable(Path path)：判断是否是可执行文件；boolean isHidden(Path path)：判断是否是隐藏文件；boolean isReadable(Path path)：判断文件是否可读；boolean isWritable(Path path)：判断文件是否可写；boolean notExists(Path path, LinkOption … opts)：判断文件是否不存在；public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,Class&lt;A&gt; type,LinkOption... options)：获取与 path 指定的文件相关联的属性。Files常用方法（内容操作）：SeekableByteChannel newByteChannel(Path path, OpenOption…how)：获取与指定文件的连接，how 指定打开方式。DirectoryStream newDirectoryStream(Path path)：打开 path 指定的目录InputStream newInputStream(Path path, OpenOption…how)：获取 InputStream 对象OutputStream newOutputStream(Path path, OpenOption…how)：获取 OutputStream 对象]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava RateLimiter]]></title>
    <url>%2FGuava-RateLimiter.html</url>
    <content type="text"><![CDATA[Google Guava提供的RateLimiter使用的是令牌桶算法。令牌桶算法的基本思想是以固定的速率生成令牌，在执行请求之前都需要从令牌桶里获取足够的令牌。当令牌数量不足的时候，请求将被阻塞进入等待状态或者直接返回失败。RateLimiter常用于限制访问资源的速率。RateLimiter使用示例下面是一个RateLimiter的简单使用示例：1234567891011121314public class RateLimiterTest &#123; // 1秒钟产生0.5张令牌 private final static RateLimiter limiter = RateLimiter.create(0.5); public static void main(String[] args) &#123; ExecutorService service = Executors.newFixedThreadPool(5); IntStream.range(0, 5).forEach(i -&gt; service.submit(RateLimiterTest::testLimiter)); service.shutdown(); &#125; private static void testLimiter() &#123; System.out.println(Thread.currentThread() + " waiting " + limiter.acquire()); &#125;&#125;我们定义了一个RateLimiter实例，每秒钟产生0.5张令牌，即每2秒钟产生1张令牌。testLimiter方法中通过limiter.acquire()方法获取令牌（不带参数时默认获取1张令牌）。Executors.newFixedThreadPool(5)生成五个线程，并发调用testLimiter方法，执行代码，控制台输出如下所示：12345Thread[pool-1-thread-1,5,main] waiting 0.0Thread[pool-1-thread-5,5,main] waiting 1.908947Thread[pool-1-thread-4,5,main] waiting 3.908935Thread[pool-1-thread-3,5,main] waiting 5.908919Thread[pool-1-thread-2,5,main] waiting 7.908808可以看到每个线程调用时间相隔大约为2秒钟。可能你会问，为什么第一个线程没有等待2秒，直接就获取到了令牌然后执行了呢？Guava RateLimiter允许某次请求获取超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上。再来看一个RateLimiter的例子：123456789public class RateLimiterTest &#123; public static void main(String[] args) &#123; RateLimiter limiter = RateLimiter.create(1); System.out.println(limiter.acquire(4)); System.out.println(limiter.acquire(3)); System.out.println(limiter.acquire(2)); System.out.println(limiter.acquire(1)); &#125;&#125;程序输出如下：12340.03.9966022.9974482.000229上面例子钟，一秒钟产生一张令牌，第一次请求直接取出4张令牌，所以第二次请求需要等待4/1秒才能取到令牌。经过大约4秒后，第二次请求直接取出3张令牌，所以第三次请求需要等待3/1秒后才能取到令牌，依此类推。设置超时时间我们可以设置等待令牌的超时时间，如果等待令牌的时间大于超时时间，将直接返回false，不再等待：1234567public class RateLimiterTest &#123; public static void main(String[] args) &#123; RateLimiter limiter = RateLimiter.create(1); System.out.println(limiter.acquire(3)); System.out.println(limiter.tryAcquire(1, 2, TimeUnit.SECONDS)); &#125;&#125;上面例子limiter.tryAcquire设置了超时时间为2秒，由于第一次请求一次性获取了3张令牌，所以这里需要等待大约3秒钟，超出了2秒的超时时间，所以limiter.tryAcquire不会等待3秒，而是直接返回false。]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava 缓存]]></title>
    <url>%2FGuava-Cache.html</url>
    <content type="text"><![CDATA[Guava缓存是轻量级的，它将内容缓存到运行内存中。如果系统中某些值（比如一些配置表）被频繁查询使用，并且我们愿意消耗一些内存空间来提升应用的速度，减轻数据库压力的话，Guava缓存将会是一个不错的选择。由于缓存是存储在运行内存中的，所以我们需要确保缓存的大小不超出内存的容量。创建缓存我们可以直接创建Guava缓存对象，而不使用任何的CacheLoader：1234Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();cache.put("hello", "world");System.out.println(cache.getIfPresent("hello")); // worldkey值是大小写敏感的，所以使用cache.getIfPresent(&quot;HELLO&quot;)将返回null值。接下来看看如何使用CacheLoader创建缓存对象：123456789101112131415CacheLoader&lt;String, String&gt; loader = new CacheLoader&lt;String, String&gt;() &#123; @Override public String load(String key) &#123; return sayHello(key); &#125;&#125;;LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(loader);String mrbird = cache.getUnchecked("mrbird");System.out.println(mrbird); // hello mrbird...private String sayHello(String key) &#123; return String.format("hello %s", key);&#125;方法getUnchecked作用为：当值不存在时，会通过CacheLoader计算出值，然后存到缓存中。驱逐机制我们可以定义一些驱逐缓存的机制来限制缓存的大小。限制缓存数目我们可以通过maximumSize来限制缓存的条目：12345678910Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(3).build();cache.put("k1", "v1");cache.put("k2", "v2");cache.put("k3", "v3");cache.put("k4", "v4");System.out.println(cache.size()); // 3System.out.println(cache.getIfPresent("k1")); // nullSystem.out.println(cache.asMap()); // &#123;k3=v3, k4=v4, k2=v2&#125;我们限制最多只能存储3个值，所以k4的存入把最早的k1给驱逐出去了，类似于FIFO。限制缓存大小我们可以自定义权重函数来限制缓存的大小：123456789101112Weigher&lt;String, String&gt; weigher = (key, value) -&gt; value.length();Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumWeight(15).weigher(weigher).build();cache.put("k1", "11111");cache.put("k2", "22222");cache.put("k3", "33333");cache.put("k4", "4444");cache.put("k5", "5555");System.out.println(cache.size()); // 3System.out.println(cache.getIfPresent("k1")); // nullSystem.out.println(cache.asMap()); // &#123;k3=33333, k5=5555, k4=4444&#125;上面例子中，我们通过maximumWeight(15)指定了缓存的最大容量，权重规则为value的长度。k3，k4和k5的value长度加起来为13，所以k1和k2的值存不下了，被驱逐。设置缓存时间我们可以设置缓存的有效时间和缓存的活跃时间。设置缓存的活跃时间为2s：1234567891011121314Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterAccess(2, TimeUnit.SECONDS).build();cache.put("k1", "v1");cache.put("k2", "v2");cache.getIfPresent("k1");TimeUnit.SECONDS.sleep(1);cache.getIfPresent("k1");TimeUnit.SECONDS.sleep(1);System.out.println(cache.getIfPresent("k1")); // v1System.out.println(cache.getIfPresent("k2")); // nullSystem.out.println(cache.size()); // 1System.out.println(cache.asMap()); // &#123;k1=v1&#125;上面代码中，我们通过cache.getIfPresent(&quot;k1&quot;)获取了k1的值，然后让线程阻塞1秒，这时候k1和k2的有效时间大约为1秒左右。接着又获取了k1的值，所以k1的有效时间还是2秒，k2为1秒，再次让线程阻塞1秒后，k1的有效时间为1秒，k2已经失效了。打印输出的结果和我们预期的一致。设置缓存的有效时间为2s：1234567891011121314 Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(2, TimeUnit.SECONDS).build();cache.put("k1", "v1");cache.put("k2", "v2");cache.getIfPresent("k1");TimeUnit.SECONDS.sleep(1);cache.getIfPresent("k1");TimeUnit.SECONDS.sleep(1);System.out.println(cache.getIfPresent("k1")); // nullSystem.out.println(cache.getIfPresent("k2")); // nullSystem.out.println(cache.size()); // 0System.out.println(cache.asMap()); // &#123;&#125;因为我们设置缓存有效时间为2秒，所以2秒后所有缓存都过期失效了，无论期间获取过多少次缓存。weakKeys&amp;softValues默认情况下，Guava缓存键值都有强引用，我们可以使用weakKeys和softValues来让键值变为弱引用，这样垃圾收集器在必要的情况下将会工作：1Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().weakKeys().softValues().build();刷新缓存可以通过refreshAfterWrite设置缓存自动刷新间隔，或者可以直接调用refresh方法来手动刷新缓存：1Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().refreshAfterWrite(1,TimeUnit.SECONDS).build();添加多个缓存可以通过putAll来一次性添加多个缓存：12345678910Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();Map&lt;String, String&gt; map = Maps.newHashMap();map.put("k1", "v1");map.put("k2", "v2");map.put("k3", "v3");cache.putAll(map);System.out.println(cache.size()); // 3System.out.println(cache.asMap()); // &#123;k3=v3, k1=v1, k2=v2&#125;删除缓存Cache.invalidate(key)方法通过key来删除缓存：123456789Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();Map&lt;String, String&gt; map = Maps.newHashMap();map.put("k1", "v1");cache.putAll(map);System.out.println(cache.asMap()); // &#123;k1=v1&#125;cache.invalidate("k1");System.out.println(cache.asMap()); // &#123;&#125;除此之外，我们也可以通过Cache.invalidateAll(keys)一次性删除多个缓存或者Cache.invalidateAll()删除全部缓存。我们还可以给删除事件添加监听器：1234567RemovalListener&lt;String, String&gt; listener = notification -&gt; System.out.println("监听到删除事件，key=" + notification.getKey() + "，value=" + notification.getValue());Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().removalListener(listener).build();cache.put("k1", "v1");cache.invalidate("k1"); // 监听到删除事件，key=k1，value=v1增删改查简单封装一个Guava缓存工具类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class GuavaCacheUtil &#123; private static Logger logger = LoggerFactory.getLogger(GuavaCacheUtil.class); private static Cache&lt;String, String&gt; cache; static &#123; RemovalListener&lt;String, String&gt; listener = n -&gt; logger.info("监听到删除事件，key=&#123;&#125;，value=&#123;&#125;", n.getKey(), n.getValue()); cache = CacheBuilder.newBuilder() .removalListener(listener).build(); &#125; /** * 添加缓存 * * @param key 键 * @param value 值 */ public void put(String key, String value) &#123; if (StringUtils.isNotBlank(key) &amp;&amp; StringUtils.isNotBlank(value)) &#123; cache.put(key, value); &#125; &#125; /** * 批量添加缓存 * * @param map key,value集合 */ public void putAll(Map&lt;String, String&gt; map) &#123; cache.putAll(map); &#125; /** * 删除缓存 * * @param key 键 */ public void remove(String key) &#123; if (StringUtils.isNotBlank(key)) &#123; cache.invalidate(key); &#125; &#125; /** * 批量删除缓存 * * @param keys key集合 */ public void remove(List&lt;String&gt; keys) &#123; if (CollectionUtils.isNotEmpty(keys)) &#123; cache.invalidateAll(keys); &#125; &#125; /** * 清空缓存 */ public void removeAll() &#123; cache.invalidateAll(); &#125; /** * 获取缓存 * * @param key 键 * @return 值 */ public String get(String key) &#123; return StringUtils.isNotBlank(key) ? cache.getIfPresent(key) : null; &#125; /** * 批量获取缓存 * * @param keys 键集合 * @return 值集合 */ public ImmutableMap&lt;String, String&gt; get(List&lt;String&gt; keys) &#123; return CollectionUtils.isNotEmpty(keys) ? cache.getAllPresent(keys) : null; &#125;&#125;]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava 集合操作]]></title>
    <url>%2FGuava-Collection.html</url>
    <content type="text"><![CDATA[不可变集合不可变集合例子：12ImmutableSet&lt;String&gt; FRUITS = ImmutableSet.of("apple", "watermelon", "cherry", "mango");FRUITS.remove("apple");将抛出java.lang.UnsupportedOperationException异常： 创建不可变集合of12ImmutableList&lt;String&gt; immutableList = ImmutableList.of("a", "b", "c");ImmutableMap&lt;Integer, String&gt; immutableMap = ImmutableMap.of(1, "v1", 2, "v2", 3, "v3")copyOf12Map&lt;String, String&gt; map = Maps.newHashMap();ImmutableMap&lt;String, String&gt; immutableMap = ImmutableMap.copyOf(map);builder12345678910Map&lt;String, String&gt; map = Maps.newHashMap();ImmutableMap&lt;String, String&gt; immutableMap = ImmutableMap.&lt;String, String&gt;builder() .putAll(map) .put("k1", "v1") .build();List&lt;String&gt; list = Lists.newArrayList();ImmutableList&lt;String&gt; immutableList = ImmutableList.&lt;String&gt;builder() .addAll(list) .build();除此之外，我们也可以从Java 8 Stream中创建不可变集合：12345678import static java.util.stream.Collectors.*;...List&lt;String&gt; list = Arrays.asList("a", "b", "c");List&lt;String&gt; immutableList = list.stream() .collect(collectingAndThen(toList(), ImmutableList::copyOf));System.out.println(immutableList.getClass()); // class com.google.common.collect.RegularImmutableList上面的例子我们也可以使用Guava提供的收集器：12345List&lt;String&gt; list = Arrays.asList("a", "b", "c");List&lt;String&gt; immutableList = list.stream() .collect(ImmutableList.toImmutableList());System.out.println(immutableList.getClass()); // class com.google.common.collect.RegularImmutableList不可变集合优点当对象被不可信的库调用时，不可变形式是安全的；不可变对象被多个线程调用时，不存在竞态条件问题不可变集合不需要考虑变化，因此可以节省时间和空间。所有不可变的集合都比它们的可变形式有更好的内存利用率（分析和测试细节）；不可变对象因为有固定不变，可以作为常量来安全使用。新集合类型Guava提供了许多JDK没有的集合类型。RangeSetRangeSet一组不相连的、非空的区间，基本实现为TreeRangeSet，看个RangeSet的例子：123456789101112131415RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();rangeSet.add(Range.closed(1, 10));System.out.println(rangeSet); // [[1..10]]rangeSet.add(Range.closedOpen(11, 15));System.out.println(rangeSet); // 不相连区间 [[1..10], [11..15)]rangeSet.add(Range.closedOpen(15, 20));System.out.println(rangeSet); // 相连区间 [[1..10], [11..20)]rangeSet.add(Range.openClosed(0, 0));System.out.println(rangeSet); // 空区间 [[1..10], [11..20)]rangeSet.remove(Range.open(5, 10)); System.out.println(rangeSet); // 区间分割 [[1..5], [10..10], [11..20)]查看RangeSet的范围跨度：1234567RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();rangeSet.add(Range.closed(1, 10));rangeSet.add(Range.closedOpen(11, 15));Range&lt;Integer&gt; span = rangeSet.span();System.out.println(span.lowerEndpoint().intValue()); // 1System.out.println(span.upperEndpoint().intValue()); // 15从已有的RangeSet获取一个子范围RangeSet：123456789RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();numberRangeSet.add(Range.closed(0, 2));numberRangeSet.add(Range.closed(3, 5));numberRangeSet.add(Range.closed(5, 8));RangeSet&lt;Integer&gt; numberSubRangeSet = numberRangeSet.subRangeSet(Range.closed(4, 14));System.out.println(numberRangeSet); // [[0..2], [3..8]]System.out.println(numberSubRangeSet); // [[4..8]]获取除了RangeSet范围外的RangeSet：123456789RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();numberRangeSet.add(Range.closed(0, 2));numberRangeSet.add(Range.closed(3, 5));numberRangeSet.add(Range.closed(6, 8));RangeSet&lt;Integer&gt; numberRangeComplementSet = numberRangeSet.complement();System.out.println(numberRangeSet); // [[0..2], [3..5], [6..8]]System.out.println(numberRangeComplementSet); // [(-∞..0), (2..3), (5..6), (8..+∞)]判断一个RangeSet是否和另一个范围有交集：12345678RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();numberRangeSet.add(Range.closed(0, 2));numberRangeSet.add(Range.closed(3, 10));numberRangeSet.add(Range.closed(15, 18));System.out.println(numberRangeSet); // [[0..2], [3..10], [15..18]]System.out.println(numberRangeSet.intersects(Range.closed(4, 17))); // true遍历RangeSet的范围区间：12345678RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();numberRangeSet.add(Range.closed(0, 2));numberRangeSet.add(Range.closed(3, 10));numberRangeSet.add(Range.closed(15, 18));Set&lt;Range&lt;Integer&gt;&gt; ranges = numberRangeSet.asRanges();ranges.forEach(System.out::print); // [0..2][3..10][15..18]从RangeSet中获取包含某个值的访问区间：1234567RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();numberRangeSet.add(Range.closed(0, 2));numberRangeSet.add(Range.closed(3, 10));numberRangeSet.add(Range.closed(15, 18));System.out.println(numberRangeSet.rangeContaining(7)); // [3..10]RangeMapRangeMap是一组不相连的、非空的区间与指定值的映射，基本实现为TreeRangeMap光这样说有点抽象，看些例子:123456789101112RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create();rangeMap.put(Range.closed(1, 10), "foo");System.out.println(rangeMap); // [[1..10]=foo]rangeMap.put(Range.open(3, 6), "bar");System.out.println(rangeMap); // [[1..3]=foo, (3..6)=bar, [6..10]=foo]rangeMap.put(Range.open(10, 20), "eoo");System.out.println(rangeMap); // [[1..3]=foo, (3..6)=bar, [6..10]=foo, (10..20)=eoo]rangeMap.remove(Range.closed(5, 11));System.out.println(rangeMap); // [[1..3]=foo, (3..5)=bar, (11..20)=eoo]从RangeMap中获取一个Entry：123456789RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create();rangeMap.put(Range.closed(0, 2), "foo");rangeMap.put(Range.closed(3, 5), "bar");rangeMap.put(Range.closed(6, 8), "eoo");Map.Entry&lt;Range&lt;Integer&gt;, String&gt; entry = rangeMap.getEntry(7);System.out.println(entry.getKey()); // [6..8]System.out.println(entry.getValue()); // eoo剩下的操作和RangeSet差不多。BiMapBiMap是一种特殊的，双向映射的Map，可以确保不会出现重复的值并且我们总是可以安全地通过key获取到value。BiMap的基本实现为HashBiMap。看看例子：12345678BiMap&lt;String, String&gt; biMap = HashBiMap.create();biMap.put("k1", "v1");biMap.put("k2", "v2");biMap.put("k3", "v3");System.out.println(biMap); // &#123;k1=v1, k2=v2, k3=v3&#125;BiMap&lt;String, String&gt; inverse = biMap.inverse();System.out.println(inverse); // &#123;v1=k1, v2=k2, v3=k3&#125;通过inverse可以得到值，键映射的BiMap。往BiMap里添加重复的值将会报错：1234BiMap&lt;String, String&gt; biMap = HashBiMap.create();biMap.put("k1", "v1");biMap.put("k2", "v2");biMap.put("k3", "v1");如果非要添加重复的值的话，可以用forcePut方法：12345BiMap&lt;String, String&gt; biMap = HashBiMap.create();biMap.put("k1", "v1");biMap.put("k2", "v2");biMap.forcePut("k3", "v1");System.out.println(biMap); // &#123;k2=v2, k3=v1&#125;TableTable是一个包含行，列和单元格的集合类型，行和列组成有序键对。创建一个HashBasedTable（内部使用LinkedHashMap）：1Table&lt;String, String, Integer&gt; hashBasedTable = HashBasedTable.create();如果需要对table的行和列按照自然顺序或者提供的排序规则进行排序的话，可以创建一个TreeBasedTable：1Table&lt;String, String, Integer&gt; treeBasedTable = TreeBasedTable.create();如果事先知道行和列的值，并且table大小是固定的话，可以使用ArrayTable：1234List&lt;String&gt; row = Lists.newArrayList("r1", "r2");List&lt;String&gt; column = Lists.newArrayList("c1", "c2", "c3");Table&lt;String, String, Integer&gt; arrayTable = ArrayTable.create(row, column);System.out.println(arrayTable); // &#123;r1=&#123;c1=null, c2=null, c3=null&#125;, r2=&#123;c1=null, c2=null, c3=null&#125;&#125;上面例子创建了一个两行三列的table。创建不可变table：123Table&lt;String, String, String&gt; immutableTable = ImmutableTable.&lt;String, String, String&gt; builder() .put("r1", "c1", "hello") .build();通过行和列获取单元格的值：12345678910111213Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();hashBasedTable.put("r1", "c1", "hello");hashBasedTable.put("r1", "c2", "world");hashBasedTable.put("r2", "c1", "good");hashBasedTable.put("r2", "c2", "bye");System.out.println(hashBasedTable); // &#123;r1=&#123;c1=hello, c2=world&#125;, r2=&#123;c1=good, c2=bye&#125;&#125;String v1 = hashBasedTable.get("r1", "c1");String v2 = hashBasedTable.get("r2", "c3");System.out.println(v1); // helloSystem.out.println(v2); // null我们可以检测table是否包含某个行键，某个列键，某个值和某个行和列组合的键：12345678910Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();hashBasedTable.put("r1", "c1", "hello");hashBasedTable.put("r1", "c2", "world");hashBasedTable.put("r2", "c1", "good");hashBasedTable.put("r2", "c2", "bye");boolean b1 = hashBasedTable.contains("r1", "c2"); // trueboolean b2 = hashBasedTable.containsColumn("c3"); // falseboolean b3 = hashBasedTable.containsRow("r2"); // trueboolean b4 = hashBasedTable.containsValue("world"); // true通过行和列删除单元格，返回被删除的值：12345678910Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();hashBasedTable.put("r1", "c1", "hello");hashBasedTable.put("r1", "c2", "world");hashBasedTable.put("r2", "c1", "good");hashBasedTable.put("r2", "c2", "bye");String removeValue = hashBasedTable.remove("r1", "c1");System.out.println(removeValue); // helloSystem.out.println(hashBasedTable); // &#123;r1=&#123;c2=world&#125;, r2=&#123;c1=good, c2=bye&#125;&#125;我们可以通过行或列得到一个Map，如果通过行得到Map，那么Map的键为列值，Map的值为对应单元格的值，光说有点抽象，看个例子：123456789101112Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();hashBasedTable.put("r1", "c1", "hello");hashBasedTable.put("r1", "c2", "world");hashBasedTable.put("r2", "c1", "good");hashBasedTable.put("r2", "c2", "bye");Map&lt;String, String&gt; c2Map = hashBasedTable.column("c2");Map&lt;String, String&gt; r1Map = hashBasedTable.row("r1");System.out.println(c2Map); // &#123;r1=world, r2=bye&#125;System.out.println(r1Map); // &#123;c1=hello, c2=world&#125;System.out.println(c2Map.get("r1")); // world我们还可以单独获取所有行或者所有列组成的Map：1234567891011Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();hashBasedTable.put("r1", "c1", "hello");hashBasedTable.put("r1", "c2", "world");hashBasedTable.put("r2", "c1", "good");hashBasedTable.put("r2", "c2", "bye");Map&lt;String, Map&lt;String, String&gt;&gt; columnMap = hashBasedTable.columnMap();Map&lt;String, Map&lt;String, String&gt;&gt; rowMap = hashBasedTable.rowMap();System.out.println(columnMap); // &#123;c1=&#123;r1=hello, r2=good&#125;, c2=&#123;r1=world, r2=bye&#125;&#125;System.out.println(rowMap); // &#123;r1=&#123;c1=hello, c2=world&#125;, r2=&#123;c1=good, c2=bye&#125;&#125;获取所有行键、列键或者值的集合：12345678910111213Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();hashBasedTable.put("r1", "c1", "hello");hashBasedTable.put("r1", "c2", "world");hashBasedTable.put("r2", "c1", "good");hashBasedTable.put("r2", "c2", "bye");Set&lt;String&gt; rowKeySet = hashBasedTable.rowKeySet();Set&lt;String&gt; columnKeySet = hashBasedTable.columnKeySet();Set&lt;Table.Cell&lt;String, String, String&gt;&gt; cells = hashBasedTable.cellSet();System.out.println(rowKeySet); // [r1, r2]System.out.println(columnKeySet); // [c1, c2]System.out.println(cells); // [(r1,c1)=hello, (r1,c2)=world, (r2,c1)=good, (r2,c2)=bye]MultisetMultiset和java.util.set类似，不过Mutiset可以添加重复的值：123456789101112HashMultiset&lt;String&gt; hashMultiset = HashMultiset.create();hashMultiset.add("are you ok?");hashMultiset.add("are you ok?");hashMultiset.add("are you ok?");System.out.println(hashMultiset); // [are you ok? x 3]hashMultiset.remove("are you ok?");System.out.println(hashMultiset); // [are you ok? x 2]hashMultiset.setCount("are you ok?", 10); // 直接设置元素个数System.out.println(hashMultiset); // [are you ok? x 10]在并发环境下，我们可以使用ConcurrentHashMultiset，它的add和remove方法是线程安全的。唯一值得注意的是，在并发环境下使用setCount方法时候，需使用下面这种方式：12345HashMultiset&lt;String&gt; hashMultiset = HashMultiset.create();hashMultiset.setCount("are you ok?", 0, 5);hashMultiset.setCount("are you ok?", 10, 5);System.out.println(hashMultiset); // [are you ok? x 5]第一个参数为需要添加的值，第二个参数为当前Multiset里元素个数，第三个参数为需要添加的元素个数。只有第二个参数的值正确的时候，setCount才有效，所以hashMultiset.setCount(&quot;are you ok?&quot;, 10, 5)实际上是不生效的。MultimapMultimap可以通过一个键映射多个值：1234567String key = "hello";ArrayListMultimap&lt;String, String&gt; multimap = ArrayListMultimap.create();multimap.put(key, "world");multimap.put(key, "java");System.out.println(multimap); // &#123;hello=[world, java]&#125;System.out.println(multimap.get(key)); // [world, java]ClassToInstanceMap使用类型作为键：1234567MutableClassToInstanceMap&lt;Object&gt; classToInstanceMap = MutableClassToInstanceMap.create();classToInstanceMap.put(String.class, "hello");classToInstanceMap.put(Integer.class, 777);classToInstanceMap.put(Double.class, 43.96);System.out.println(classToInstanceMap); // &#123;class java.lang.Double=43.96, class java.lang.String=hello, class java.lang.Integer=777&#125;System.out.println(classToInstanceMap.get(Double.class)); // 43.96Lists、Maps&amp;SetsLists创建一个List：1ArrayList&lt;String&gt; list = Lists.newArrayList("a", "b", "c");反转List：1234ArrayList&lt;String&gt; list = Lists.newArrayList("a", "b", "c");List&lt;String&gt; reverse = Lists.reverse(list);System.out.println(reverse); // [c, b, a]通过字符串生成字符集合：12List&lt;Character&gt; characters = Lists.charactersOf("mrbird");System.out.println(characters); // [m, r, b, i, r, d]将集合按照指定区块大小分区：1234List&lt;String&gt; list = Lists.newArrayList("java", "php", "go", "python", "c#", "javascript");List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, 2);System.out.println(partition); // [[java, php], [go, python], [c#, javascript]]一个删除List中重复项的技巧：1234List&lt;String&gt; list = Lists.newArrayList("a", "p", "p", "l", "e");ImmutableList&lt;String&gt; newList = ImmutableSet.copyOf(list).asList();System.out.println(newList); // [a, p, l, e]从集合中删除null值：1234List&lt;String&gt; list = Lists.newArrayList("java", null," python");Iterables.removeIf(list, Objects::isNull);System.out.println(list); // [java, python]Sets通过Sets创建set：1Set&lt;Object&gt; hashSet = Sets.newHashSet();合并两个Set：12345Set&lt;String&gt; set1 = ImmutableSet.of("a", "b", "c");Set&lt;String&gt; set2 = ImmutableSet.of("b", "c", "d");Set&lt;String&gt; union = Sets.union(set1, set2);System.out.println(union); // [a, b, c, d]可以通过Sets.cartesianProduct()获取两个Set的笛卡尔积：12345Set&lt;Character&gt; first = ImmutableSet.of('a', 'b');Set&lt;Character&gt; second = ImmutableSet.of('c', 'd');Set&lt;List&lt;Character&gt;&gt; result = Sets.cartesianProduct(first, second);System.out.println(result); // [[a, c], [a, d], [b, c], [b, d]]获取两个Set的交集：12345Set&lt;Character&gt; first = ImmutableSet.of('a', 'b', 'c');Set&lt;Character&gt; second = ImmutableSet.of('c', 'd', 'e');Set&lt;Character&gt; intersection = Sets.intersection(first, second);System.out.println(intersection); // [c]获取两个Set的差集：12345Set&lt;Character&gt; first = ImmutableSet.of('a', 'b', 'c');Set&lt;Character&gt; second = ImmutableSet.of('c', 'd', 'e');Set&lt;Character&gt; difference = Sets.symmetricDifference(first, second);System.out.println(difference); // [a, b, d, e]Maps通过Maps创建Map：1HashMap&lt;Object, Object&gt; map = Maps.newHashMap();创建期望大小的Map：1HashMap&lt;Object, Object&gt; map = Maps.newHashMapWithExpectedSize(5);Joiner与SplitterJoinerJoiner用于连接操作。比如将List里的元素通过“,”连接成一个字符串：1234List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");String join = Joiner.on(",").join(list);System.out.println(join); // a,b,c使用Joiner将Map转换为String：123456HashMap&lt;String, Integer&gt; map = Maps.newHashMap();map.put("mrbird", 18);map.put("scott", 28);String join = Joiner.on(",").withKeyValueSeparator("~").join(map);System.out.println(join); // mrbird~18,scott~28在使用Joiner的时候，如果集合中含有null值，我们可以选择跳过它：1234List&lt;String&gt; list = Lists.newArrayList("a", null, "b", "c", "d");String result = Joiner.on(",").skipNulls().join(list);System.out.println(result); // a,b,c,d或者使用指定值替代null：1234List&lt;String&gt; list = Lists.newArrayList("a", null, "b", "c", "d");String result = Joiner.on(",").useForNull("空").join(list);System.out.println(result); // a,空,b,c,dSplitterSplitter用于将String拆分为集合类型，看个例子:1234String value = "a,b,c,d ";List&lt;String&gt; list = Splitter.on(",").trimResults().splitToList(value);System.out.println(list); // [a, b, c, d]使用Splitter将String拆分为Map：1234 String value = "mrbird=18,scott=28";Map&lt;String, String&gt; map = Splitter.on(",").withKeyValueSeparator("=").split(value);System.out.println(map); // &#123;mrbird=18, scott=28&#125;分割具有多种分隔符的String：1234String value = "a.b,,c,,..";List&lt;String&gt; result = Splitter.onPattern("[.,]").omitEmptyStrings().splitToList(value);System.out.println(result); // [a, b, c]omitEmptyStrings用于忽略空字符串。我们还可以通过指定长度来拆分字符串：1234String value = "人们都说：“桂林山水甲天下”，我们乘着木船荡漾在漓江上，来观赏桂林的山水。";List&lt;String&gt; list = Splitter.fixedLength(3).splitToList(value);System.out.println(list); // [人们都, 说：“, 桂林山, 水甲天, 下”，, 我们乘, 着木船, 荡漾在, 漓江上, ，来观, 赏桂林, 的山水, 。]也可以指定拆分项的长度：1234String value = "a-b-c-d-e";List&lt;String&gt; result = Splitter.on("-").limit(4).splitToList(value);System.out.println(result); // [a, b, c, d-e]可以看到d-e没有被拆分。Filter&amp;TransformFilter可以通过Guava提供的Predicates来实现各种集合过滤操作。比如找出集合中包含a的元素：1234List&lt;String&gt; list = Lists.newArrayList("java", "javascript", "c#", "golang");Iterable&lt;String&gt; result = Iterables.filter(list, Predicates.containsPattern("a"));System.out.println(result); // [java, javascript, golang]上面的例子也可以通过Collections2.filter来实现：1234List&lt;String&gt; list = Lists.newArrayList("java", "javascript", "c#", "golang");Collection&lt;String&gt; result = Collections2.filter(list, Predicates.containsPattern("a"));System.out.println(result);我们也可以编写自定义的过滤规则：1234567891011121314 Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123; @Override public boolean apply(@Nullable String input) &#123; return input.endsWith("a") || input.contains("#"); &#125; @Override public boolean test(String input) &#123; return this.apply(input); &#125;&#125;;List&lt;String&gt; list = Lists.newArrayList("java", "javascript", "c#", "golang");Collection&lt;String&gt; result = Collections2.filter(list, predicate);System.out.println(result); // [java, c#]组合多个过滤条件：1234567List&lt;String&gt; list = Lists.newArrayList("java", "javascript", "c#", "golang");Collection&lt;String&gt; result = Collections2.filter(list, Predicates.or( Predicates.containsPattern("a"), Predicates.containsPattern("#") ));System.out.println(result); // [java, javascript, c#, golang]过滤掉集合中的null：1234List&lt;String&gt; list = Lists.newArrayList("java", null," python");Collection&lt;String&gt; result = Collections2.filter(list, Predicates.&lt;String&gt;notNull());System.out.println(result); // [java, python]检测集合中是否有包含a字符的元素：1234List&lt;String&gt; list = Lists.newArrayList("java", "c#"," python");boolean result = Iterables.any(list, Predicates.containsPattern("a"));System.out.println(result); // trueTransform将集合转换为元素长度的集合：1234567891011Function&lt;String, Integer&gt; function = new Function&lt;String, Integer&gt;() &#123; @Nullable @Override public Integer apply(@Nullable String s) &#123; return s.length(); &#125;&#125;;List&lt;String&gt; list = Lists.newArrayList("java", "c#", " python");Iterable&lt;Integer&gt; result = Iterables.transform(list, function);System.out.println(result); // [4, 2, 7]上面的例子同样可以使用Collections2.transform来代替Iterables.transform。我们也可以通过Functions.forPredicate来创建简单的转换函数Function：1234List&lt;String&gt; list = Lists.newArrayList("java", "c#", " python");Iterable&lt;Boolean&gt; result = Iterables.transform(list, Functions.forPredicate(Predicates.containsPattern("#")));System.out.println(result); // [false, true, false]组合多个转换函数：1234567891011121314151617Function&lt;String, String&gt; f1 = new Function&lt;String, String&gt;() &#123; @Override public String apply(String input) &#123; return "i like " + input; &#125;&#125;;Function&lt;String, String&gt; f2 = new Function&lt;String, String&gt;() &#123; @Override public String apply(String input) &#123; return input.toUpperCase(); &#125;&#125;;List&lt;String&gt; list = Lists.newArrayList("java", "c#", " python");Iterable&lt;String&gt; result = Iterables.transform(list, Functions.compose(f2, f1));System.out.println(result); // [I LIKE JAVA, I LIKE C#, I LIKE PYTHON]我们也可以将过滤和转换组合在一起使用：12345678910111213141516171819202122232425Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123; @Override public boolean apply(String input) &#123; return input.startsWith("j"); &#125; @Override public boolean test(String input) &#123; return this.apply(input); &#125;&#125;;Function&lt;String, String&gt; function = new Function&lt;String,String&gt;()&#123; @Override public String apply(String input) &#123; return input.toUpperCase(); &#125;&#125;;List&lt;String&gt; list = Lists.newArrayList("java", "c#", "javascript", "python");ImmutableList&lt;String&gt; result = FluentIterable.from(list) .filter(predicate) .transform(function) .toList();System.out.println(result); // [JAVA, JAVASCRIPT]Iterables除了上面涉及的Iterables的用法外，其还提供了许多别的好用的方法。removeAll该方法用于从特定集合中删除给定集合中的元素：123456List&lt;String&gt; removeFrom = Lists.newArrayList("a", "b", "c");List&lt;String&gt; elementsToRemove = Lists.newArrayList("b", "c");boolean result = Iterables.removeAll(removeFrom, elementsToRemove);System.out.println(result); // trueSystem.out.println(removeFrom); // [a]retainAllretainAll的功能和removeAll相反：123456List&lt;String&gt; removeFrom = Lists.newArrayList("a", "b", "c");List&lt;String&gt; elementsToRetain = Lists.newArrayList("b", "c");boolean result = Iterables.retainAll(removeFrom, elementsToRetain);System.out.println(result); // trueSystem.out.println(removeFrom); // [b, c]addAlladdAll用于将给定集合添加到现有集合中：12345List&lt;String&gt; list1 = Lists.newArrayList("a", "b", "c");List&lt;String&gt; list2 = Lists.newArrayList("b", "c");boolean b = Iterables.addAll(list1, list2); // trueSystem.out.println(list1); // [a, b, c, b, c]concatconcat用于合并集合，组成一个新的集合对象：12345List&lt;String&gt; list1 = Lists.newArrayList("a", "b", "c");List&lt;String&gt; list2 = Lists.newArrayList("b", "c");Iterable&lt;String&gt; result = Iterables.concat(list1,list2);System.out.println(result); // [a, b, c, b, c]Iterables还包含许多别的实用方法：这里就不一一演示了，溜了。更详细的内容可以参考guava官方wiki：https://github.com/google/guava/wiki]]></content>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FEBS-Vue文档]]></title>
    <url>%2FFEBS-Vue-Document.html</url>
    <content type="text"><![CDATA[FEBS-Vue为FEBS-Shiro的前后端分离版本，前端使用Vue全家桶，组件库采用Ant-Design-Vue。文档里介绍的示例是在Windows10操作系统下完成的，后端编辑器使用IDEA，前端编辑器使用WebStorm。项目导入为了方便，我直接在桌面上通过git bash克隆项目：1git clone https://github.com/wuyouzhuguli/FEBS-Vue.git克隆后，桌面上多出一个FEBS-Vue文件夹：backend为后端项目源码，frontend为前端项目源码，sql为数据库初始化脚本。JDK因为项目用到了JDK 8的一些特性，所以JDK最低版本不能低于8。JDK 8官方下载地址：https://www.oracle.com/technetwork/java/javase/downloads。安装Node.jsNode.js下载地址：http://nodejs.cn/download/，直接安装即可，安装后查看其版本：Node.js集成了npm，所以安装好Node.js后npm就可以使用了：安装yarn在CMD中执行npm install -g yarn：因为我之前已经安装过了，所以这里就相当于更新操作了。安装Redis项目缓存数据库使用的是Redis，所以在导入项目前需先安装Redis。Redis Windows版本下载地址：https://github.com/MicrosoftArchive/redis/releases。直接下载zip版本解压到任意目录即可。下载后，使用cmd命令切换到Redis根目录，然后运行redis-server.exe redis.windows.conf启动即可：安装MySQL项目数据库采用MySQL社区版，版本为5.7.x。下载地址：https://dev.mysql.com/downloads/windows/installer/5.7.html导入SQL使用Navicat新建一个数据库：然后导入SQL脚本即可。导入后端项目IDEA选择backend： 导入项目后安装lombok插件（不懂lombok可以自行百度）：安装完重启IDEA才能生效。接着修改application.yml中的数据库和Redis配置，修改完后通过Spring Boot入口类FebsApplication启动即可：接着开始导入前端项目。导入前端项目使用WebStorm打开frontend：在终端输入yarn install命令安装依赖：稍等片刻，坐与放宽。依赖下载完毕后，输入yarn start启动前端项目：浏览器访问http://localhost:8081：项目部署下面演示如何在Linux上部署项目（例子采用CentOS7）。Vagrant创建CentOS如果没有CentOS7环境可以使用Vagrant快速构建一个CentOS虚拟机，具体可以参考：https://mrbird.cc/Create-Virtual-Machine-By-Vagrant.html。我的CentOS虚拟机IP为：192.168.33.11。使用命令timedatectl set-timezone Asia/Shanghai设置CentOS的时区，以避免因时区带来的BUG。Java环境配置下载JDK8：下载后通过Vagrant共享到CentOS上（我的Vagrantfile共享配置为config.vm.synced_folder &quot;./sync&quot;, &quot;/vagrant&quot;, create:true, owner: &quot;root&quot;, group: &quot;root&quot;）：安装JDK8：1rpm -ivh jdk-8u201-linux-x64.rpm配置环境变量1vim /etc/profile输入以下内容：12345JAVA_HOME=/usr/java/jdk1.8.0_201JRE_HOME=/usr/java/jdk1.8.0_201/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH然后执行以下命令生效：1source /etc/profile安装Docker官方安装教程：https://docs.docker.com/install/linux/docker-ce/centos/安装好后：Docker安装MySQL拉取MySQL镜像：创建目录/home/febs/mysql，用于挂载MySQL volume:创建MySQL容器：12docker run -d --name mysql -p 3306:3306 \ -v $(pwd):/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.25使用Navicat连接MySQL，创建数据库并导入数据：连接：新增数据库：导入SQL：Docker安装Redis拉取Redis镜像:创建文件/home/febs/redis/conf/redis.conf，用于挂载Redis配置文件：创建Redis容器：123docker run -d -p 6379:6379 \ -v /home/febs/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf \ --name redis redis:4.0.14测试连接：Docker安装Nginx拉取Nginx镜像:创建目录/home/febs/nginx/html、/home/febs/nginx/logs和文件/home/febs/nginx/conf/nginx.conf，分别用于挂载Nginx html,logs和配置文件： 修改Nginx配置：1vim /home/febs/nginx/conf/nginx.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; server_names_hash_bucket_size 512; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 50m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 256k; fastcgi_intercept_errors on; gzip on; gzip_min_length 1k; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_comp_level 6; gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable "MSIE [1-6]\."; limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server_tokens off; access_log off; server &#123; listen 80; server_name localhost; charset utf-8; location / &#123; root html; index index.html index.htm; &#125; location = /50x.html &#123; root html; &#125; &#125;&#125;创建Nginx容器：1234docker run --name nginx -d -p 80:80 \-v /home/febs/nginx/conf/nginx.conf:/etc/ng inx/nginx.conf \-v /home/febs/nginx/html:/etc/nginx/html \-v /home/febs/nginx/logs:/var/log/nginx nginx:1.14.2后端部署修改application.yml中数据库和redis的连接配置，然后将项目打包成jar文件：将其上传到CentOS虚拟机的/home/febs/backend目录下：编写一个启动项目的shell脚本：1vim start.sh内容：1nohup java -jar febs_shiro_jwt-1.0.0-release.jar &amp;编写一个关停项目的shell脚本：1vim stop.sh内容：12345678PID=`ps -ef | grep febs_shiro_jwt-1.0.0-release.jar | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`if [ -z &quot;$PID&quot; ]then echo Application is already stoppedelse echo kill $PID kill -9 $PIDfi授权，让其可执行：启动项目：123./start.shtail -f nohup.out看到如下输出的时候说明后端项目启动成功：前端部署点击build：build成功后，项目目录下会多出个dist文件夹：将这个目录下的文件上传到CentOS虚拟机的/home/febs/nginx/html目录下：浏览器访问http://192.168.33.11/#/login：部署成功。后端项目介绍项目结构后端项目目录含义如下图所示：Common模块文件含义如下图所示：其他模块文件较为简单，略。项目配置application.yml中除了各个插件的配置外，下面这段配置为系统配置：123456789febs: openAopLog: true max: batch: insert: num: 1000 shiro: anonUrl: /login,/logout/**,/regist,/user/check/** jwtTimeOut: 3600febs.opAopLog：Boolean类型，取值true或者false，为true时表示开启Aop记录用户的操作日志，需和@Log注解搭配使用。febs.max.batch.insert.num：大于0的Integer类型，表示Excel导入数据当次最大入库数据量。比如配置为1000时表示入库数据为0 - 1000 时只会执行一次数据库commit操作。febs.shiro.anonUrl：逗号分隔的字符串，表示无需认证的资源路径。febs.shiro.jwtTimeOut：定义token的有效时间，单位为秒，比如配置为3600表示token一个小时内有效，超过一个小时后需要重新认证。RESTful风格系统Controller暴露的接口风格为RESTful，通过HTTP请求method对应增删改查类型，响应以HTTP Code为判断依据。以UserController为例子：描述请求URIHTTP Method对应注解查询所有用户/userGET@GetMapping通过用户名查找用户/user/{username}GET@GetMapping新增用户/userPOST@PostMapping修改用户/userPUT@PutMapping删除用户/user/{userIds}DELETE@DeleteMappingController方法默认返回200状态码，当Controller抛出异常时，将被GlobalExceptionHandler捕获，根据异常类型，返回不同的HTTP状态码：异常类型异常描述状态码对应常量UnauthorizedException未授权异常，权限不足异常403HttpStatus.FORBIDDENLimitAccessException限制访问异常，访问接口频率超限429HttpStatus.TOO_MANY_REQUESTSConstraintViolationException参数校验异常（普通传参）400HttpStatus.BAD_REQUESTBindException参数校验异常（实体对象传参）400HttpStatus.BAD_REQUESTFebsExceptionFebs系统异常500HttpStatus.INTERNAL_SERVER_ERRORException剩下的别的异常500HttpStatus.INTERNAL_SERVER_ERROR数据层介绍首先看看表结构，数据表分为两大类：定时任务表和系统表。以qrtz_开头的为定时任务表，定时任务有基于内存和基于数据库的，本项目使用的是基于数据库持久化的方案。要详细了解这些表可以参考文章：http://www.ibloger.net/article/2650.html。以t_开头的为系统表，他们的关系如下所示:其中用户，角色和权限之间的关系使用的是经典的RBAC（Role-Based Access Control，基于角色的访问控制）模型。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。如下图所示：比如获取用户名为mrbrid的用户权限过程为：通过mrbrid的user_id从t_user_role表获取对应的role_id；通过第1步获取的role_id从t_role_menu表获取对应的menu_id；通过第2步获取的menu_id从t_menu获取menu相关信息（t_menu表的permission为权限信息）。数据层框架采用的是MybatisPlus，具体可以参考其官方文档。登录逻辑登录逻辑如下图所示：这里详细说明下登录成功后的第2步、第3步和第4步过程：登录成功后，构建一个ActiveUser对象，对应LoginController的saveTokenToRedis方法：123456789// 构建在线用户ActiveUser activeUser = new ActiveUser();activeUser.setUsername(user.getUsername());activeUser.setIp(ip);activeUser.setToken(token.getToken());activeUser.setLoginAddress(AddressUtil.getCityInfo(DbSearcher.BTREE_ALGORITHM, ip));// zset 存储登录用户，score 为过期时间戳this.redisService.zadd(FebsConstant.ACTIVE_USERS_ZSET_PREFIX, Double.valueOf(token.getExipreAt()), mapper.writeValueAsString(activeUser));然后将activeUser通过ObjectMapper序列化，存储到Redis的Zset结构中，key为FebsConstant.ACTIVE_USERS_ZSET_PREFIX（即febs.user.active），score为该用户的登录过期时间点（即Tokean失效时间），value为activeUser序列化值。Zset它在set的基础上增加了一个顺序属性(score)，这一属性在添加修改元素时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以理解为有两列字段的数据表，一列存value,一列存顺序编号。Zset相关Redis命令：比如当用户mrbird和scott登录成功后，查看Redis中key为febs.user.active的值:将Token存储到Redis中：key为febs.cache.token.token值.IP地址，value为token值，有效期为token的有效时长，对应的源码为：1this.redisService.set(FebsConstant.TOKEN_CACHE_PREFIX + token.getToken() + StringPool.DOT + ip, token.getToken(), properties.getShiro().getJwtTimeOut() * 1000);返回前端数据包括:1.token：token；2.exipreTime：token过期时间；3.roles：用户角色；4.permissions：用户权限；5.config：用户前端系统的个性化配置；6.user：用户信息（不包括密码）。比如，当scott登录成功后，接口返回数据如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123; "data": &#123; "permissions": [ "user:view", "dept:add", "job:export", "role:add", "weather:view", "dict:add", "role:export", "menu:export", "dict:view", "dept:export", "menu:view", "role:view", "user:export", "job:add", "dept:view", "article:view", "log:view", "jobLog:view", "job:view", "menu:add", "redis:view", "log:export", "movie:coming", "movie:hot", "dict:export", "jobLog:export", "user:online" ], "roles": [ "注册用户" ], "exipreTime": "20190408164521", "config": &#123; "userId": 2, "theme": "light", "layout": "side", "multiPage": "0", "fixSiderbar": "1", "fixHeader": "1", "color": "rgb(24, 144, 255)" &#125;, "user": &#123; "userId": 2, "username": "scott", "password": "it's a secret", "deptId": 6, "deptName": null, "email": "scott@qq.com", "mobile": "15134627380", "status": "1", "createTime": "2017-12-30 00:16:39", "modifyTime": "2019-01-18 08:59:09", "lastLoginTime": "2019-01-23 15:34:28", "ssex": "0", "description": "我是scott，嗯嗯", "avatar": "gaOngJwsRYRaVAuXXcmB.png", "roleId": null, "roleName": null, "sortField": null, "sortOrder": null, "createTimeFrom": null, "createTimeTo": null, "id": "YBeNsMJ0ZJm9GLJP1rlO", "authCacheKey": 2 &#125;, "token": "b25e39b47e774b4a05b3cb1555fc377f209457c3fd339d373d3fca7b1ea8be56fdc6ed05b7ffb0700e7300d242fb83b57b35f45ee1b155b380 50a0671bc7ec54c2f2c5bb1aee0651db69ce657e8ab4cb79c7806209103eda8a3bc96aa043a0144ae3c06a5c549ac168183c37384cf4347e450bf11644d0 62c31ffc3059e63722f849a5de4540b0d1" &#125;, "message": "认证成功"&#125;Redis缓存使用在系统启动过程中，会执行缓存初始化操作，对应CacheInitRunner：123456789101112131415161718192021@Slf4j@Componentpublic class CacheInitRunner implements ApplicationRunner &#123; @Autowired private UserService userService; @Autowired private UserManager userManager; @Override public void run(ApplicationArguments args) &#123; try &#123; ... List&lt;User&gt; list = this.userService.list(); for (User user : list) &#123; userManager.loadUserRedisCache(user); &#125; &#125; catch (Exception e) &#123; ... &#125; &#125;&#125;loadUserRedisCache方法源码：123456789101112131415/** * 将用户相关信息添加到 Redis缓存中 * * @param user user */public void loadUserRedisCache(User user) throws Exception &#123; // 缓存用户 cacheService.saveUser(user.getUsername()); // 缓存用户角色 cacheService.saveRoles(user.getUsername()); // 缓存用户权限 cacheService.savePermissions(user.getUsername()); // 缓存用户个性化配置 cacheService.saveUserConfigs(String.valueOf(user.getUserId()));&#125;可以看到，这一过程缓存了用户信息，用户角色信息，用户权限信息，用户的个性化配置信息，缓存的具体key，value可以查看上述方法的源码。通过这些缓存，可以一定程度减轻数据库压力。为了确保缓存数据和数据库数据的一致性，我们必须在相应的增删改方法中对缓存进行相应的操作。比如在更新用户后，我们必须更新相应的缓存：12345678910@Override@Transactionalpublic void updateUser(User user) throws Exception &#123; ... // 重新将用户信息，用户角色信息，用户权限信息 加载到 redis中 cacheService.saveUser(user.getUsername()); cacheService.saveRoles(user.getUsername()); cacheService.savePermissions(user.getUsername());&#125;总而言之，由于我们在启动系统的时候缓存了用户信息，用户角色信息，用户权限信息，用户的个性化配置信息，之后凡是涉及到用户，用户角色，用户权限和用户个性化配置的相关增删改操作都应该及时更新相应的缓存。动态路由构建不同的用户拥有不同的角色，不同的角色对应不同的菜单权限，所以我们需要通过用户查询出对应的菜单列表，然后将列表构建成前端需要的路由（前端根据路由信息构建相应的菜单）。获取用户路由的方法为UserManage#getUserRouters：12345678910111213141516171819202122/** * 通过用户名构建 Vue路由 * * @param username 用户名 * @return 路由集合 */public ArrayList&lt;VueRouter&lt;Menu&gt;&gt; getUserRouters(String username) &#123; List&lt;VueRouter&lt;Menu&gt;&gt; routes = new ArrayList&lt;&gt;(); List&lt;Menu&gt; menus = this.menuService.findUserMenus(username); menus.forEach(menu -&gt; &#123; VueRouter&lt;Menu&gt; route = new VueRouter&lt;&gt;(); route.setId(menu.getMenuId().toString()); route.setParentId(menu.getParentId().toString()); route.setIcon(menu.getIcon()); route.setPath(menu.getPath()); route.setComponent(menu.getComponent()); route.setName(menu.getMenuName()); route.setMeta(new RouterMeta(true, null)); routes.add(route); &#125;); return TreeUtil.buildVueRouter(routes);&#125;比如用户mrbird对应的前端路由为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277[ &#123; "path": "/", "name": "主页", "component": "MenuView", "icon": "none", "redirect": "/home", "children": [ &#123; "path": "/home", "name": "系统主页", "component": "HomePageView", "icon": "home", "meta": &#123; "closeable": false, "isShow": true &#125; &#125;, &#123; "path": "/system", "name": "系统管理", "component": "PageView", "icon": "appstore-o", "meta": &#123; "closeable": true &#125;, "children": [ &#123; "path": "/system/user", "name": "用户管理", "component": "system/user/User", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/system/role", "name": "角色管理", "component": "system/role/Role", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/system/menu", "name": "菜单管理", "component": "system/menu/Menu", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/system/dept", "name": "部门管理", "component": "system/dept/Dept", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/system/dict", "name": "字典管理", "component": "system/dict/Dict", "icon": "", "meta": &#123; "closeable": true &#125; &#125; ] &#125;, &#123; "path": "/monitor", "name": "系统监控", "component": "PageView", "icon": "dashboard", "meta": &#123; "closeable": true &#125;, "children": [ &#123; "path": "/monitor/online", "name": "在线用户", "component": "monitor/Online", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/monitor/systemlog", "name": "系统日志", "component": "monitor/SystemLog", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/monitor/redis/info", "name": "Redis监控", "component": "monitor/RedisInfo", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/monitor/httptrace", "name": "请求追踪", "component": "monitor/Httptrace", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/monitor/system", "name": "系统信息", "component": "EmptyPageView", "meta": &#123; "closeable": true &#125;, "children": [ &#123; "path": "/monitor/system/jvminfo", "name": "JVM信息", "component": "monitor/JvmInfo", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/monitor/system/tomcatinfo", "name": "Tomcat信息", "component": "monitor/TomcatInfo", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/monitor/system/info", "name": "服务器信息", "component": "monitor/SystemInfo", "meta": &#123; "closeable": true &#125; &#125; ] &#125; ] &#125;, &#123; "path": "/job", "name": "任务调度", "component": "PageView", "icon": "clock-circle-o", "meta": &#123; "closeable": true &#125;, "children": [ &#123; "path": "/job/job", "name": "定时任务", "component": "quartz/job/Job", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/job/log", "name": "调度日志", "component": "quartz/log/JobLog", "icon": "", "meta": &#123; "closeable": true &#125; &#125; ] &#125;, &#123; "path": "/web", "name": "网络资源", "component": "PageView", "icon": "compass", "meta": &#123; "closeable": true &#125;, "children": [ &#123; "path": "/web/weather", "name": "天气查询", "component": "web/Weather", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/web/dailyArticle", "name": "每日一文", "component": "web/DailyArticle", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/web/movie", "name": "影视资讯", "component": "EmptyPageView", "meta": &#123; "closeable": true &#125;, "children": [ &#123; "path": "/web/movie/hot", "name": "正在热映", "component": "web/MovieHot", "icon": "", "meta": &#123; "closeable": true &#125; &#125;, &#123; "path": "/web/movie/coming", "name": "即将上映", "component": "web/MovieComing", "icon": "", "meta": &#123; "closeable": true &#125; &#125; ] &#125; ] &#125;, &#123; "path": "/others", "name": "其他模块", "component": "PageView", "icon": "coffee", "meta": &#123; "closeable": true &#125;, "children": [ &#123; "path": "/others/excel", "name": "导入导出", "component": "others/Excel", "meta": &#123; "closeable": true &#125; &#125; ] &#125;, &#123; "path": "/profile", "name": "个人中心", "component": "personal/Profile", "icon": "none", "meta": &#123; "closeable": true, "isShow": false &#125; &#125; ] &#125;, &#123; "path": "*", "name": "404", "component": "error/404" &#125;]关于Vue Router可以参考：https://router.vuejs.org/zh/。权限控制我们可以在Controller的方法上通过Shiro相关的权限注解进行权限控制，比如下面这个方法只有当用户拥有user:add权限才能访问：12345@PostMapping("/user")@RequiresPermissions("user:add")public void addUser(@Valid User user) &#123; ...&#125;当用户没有user:add权限时，系统将抛出UnauthorizedException异常，由GlobalExceptionHandler捕获，返回403状态码。更多Shiro提供的权限注解可以参考：1234567891011121314// 表示当前Subject已经通过login进行了身份验证；即Subject.isAuthenticated()返回true。@RequiresAuthentication // 表示当前Subject已经身份验证或者通过记住我登录的。@RequiresUser // 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。@RequiresGuest // 表示当前Subject需要角色admin和user。 @RequiresRoles(value=&#123;"admin", "user"&#125;, logical= Logical.AND) // 表示当前Subject需要权限user:a或user:b。@RequiresPermissions (value=&#123;"user:a", "user:b"&#125;, logical= Logical.OR)多数据源多数据源采用的是MyBatis Plus提供的方案：https://mp.baomidou.com/guide/dynamic-datasource.html代码生成目前只有后端代码生成器，采用的是MyBatis Plus提供的方案，对应源码cc.mrbird.febs.common.generator.CodeGenerator，执行其main方法，然后输入表名，就可以生成相应的domain、dao、service、controller、mapper.xml。Excel导入导出Excel导入导出使用的插件为：https://gitee.com/wuwenze/ExcelKit，具体操作规则可以仔细阅读这个项目的Readme.md统一参数校验统一参数校验可以参考我的博客：Spring Boot配合Hibernate Validator参数校验。SQL打印SQL打印采用的插件为p6spy，要开启p6spy的SQL打印功能，只需将配置文件application.yml中的spring.datasource.dynamic.p6spy改为true即可。在p6spy.properties文件中可以配置打印规则：123456789101112# 使用日志系统记录 sqlappender=com.p6spy.engine.spy.appender.Slf4JLogger# 自定义日志打印logMessageFormat=cc.mrbird.febs.common.config.P6spySqlFormatConfig# 是否开启慢 SQL记录outagedetection=true# 慢 SQL记录标准 2 秒outagedetectioninterval=2# 开启过滤filter=true# 包含 QRTZ的不打印exclude=QRTZSQL打印效果如下所示：1234567891011122019-04-08 15:29:50 | INFO | http-nio-9527-exec-1 | p6spy | 2019-04-08 15:29:50 | 耗时 73 ms | SQL 语句：UPDATE t_user SET last_login_time=&apos;2019-04-08T15:29:50.724+0800&apos; WHERE username = &apos;mrbird&apos;;2019-04-08 15:29:50 | INFO | http-nio-9527-exec-1 | p6spy | 2019-04-08 15:29:50 | 耗时 0 ms | SQL 语句：SELECT USER_ID,username,password,dept_id,email,mobile,status,create_time,modify_time,last_login_time,ssex,description,avatar FROM t_user WHERE username = &apos;mrbird&apos;;2019-04-08 15:29:52 | INFO | http-nio-9527-exec-1 | p6spy | 2019-04-08 15:29:52 | 耗时 489 ms | SQL 语句：INSERT INTO t_login_log ( username, login_time, location, ip ) VALUES ( &apos;mrbird&apos;, &apos;2019-04-08T15:29:50.874+0800&apos;, &apos;&apos;, &apos;127.0.0.1&apos; );2019-04-08 15:45:20 | INFO | http-nio-9527-exec-7 | p6spy | 2019-04-08 15:45:20 | 耗时 1 ms | SQL 语句：UPDATE t_user SET last_login_time=&apos;2019-04-08T15:45:20.193+0800&apos; WHERE username = &apos;scott&apos;;2019-04-08 15:45:20 | INFO | http-nio-9527-exec-7 | p6spy | 2019-04-08 15:45:20 | 耗时 0 ms | SQL 语句：SELECT USER_ID,username,password,dept_id,email,mobile,status,create_time,modify_time,last_login_time,ssex,description,avatar FROM t_user WHERE username = &apos;scott&apos;;2019-04-08 15:45:21 | INFO | http-nio-9527-exec-7 | p6spy | 2019-04-08 15:45:21 | 耗时 89 ms | SQL 语句：INSERT INTO t_login_log ( username, login_time, location, ip ) VALUES ( &apos;scott&apos;, &apos;2019-04-08T15:45:20.466+0800&apos;, &apos;&apos;, &apos;127.0.0.1&apos; );开启这个功能方便我们开发调试，生产环境最好关闭这个功能，因为它在一定程度上会造成性能耗损。更多p6psy的配置可以参考：https://p6spy.readthedocs.io/en/latest/configandusage.htmlAOP记录操作日志具体可以参考我的博客：Spring Boot AOP记录用户操作日志。记录操作日志的过程可以改为异步的方式，这样不会造成接口性能损耗，可以参考我的博客：Spring Boot 中的异步调用。接口限流项目中@Limit注解可以实现接口的限流。即规定一段时间内最多可以访问该接口的次数，超过这个次数则抛出LimitAccessException异常。@Limit注解如下所示：12345678910111213141516171819import cc.mrbird.common.domain.LimitType;import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Limit &#123; // 资源名称，用于描述接口功能 String name() default ""; // 资源 key String key() default ""; // key prefix String prefix() default ""; // 时间的，单位秒 int period(); // 限制访问次数 int count(); // 限制类型 LimitType limitType() default LimitType.CUSTOMER;&#125;其中，limitType包含传统类型限流和根据IP限流，其为枚举类型：123456public enum LimitType &#123; // 传统类型 CUSTOMER, // 根据 IP 限制 IP;&#125;下面举个使用示例：1234567891011121314151617import cc.mrbird.common.annotation.Limit;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.atomic.AtomicInteger;@RestControllerpublic class TestController &#123; private static final AtomicInteger ATOMIC_INTEGER = new AtomicInteger(); @Limit(key = "test", period = 600, count = 10, name = "resource", prefix = "limit") @GetMapping("/test") public int testLimiter() &#123; return ATOMIC_INTEGER.incrementAndGet(); &#125;&#125;上面配置表示使用传统限流的方式，testLimiter方法在600秒内最多只能访问10次。当600秒内第11次访问该接口时，接口将抛出LimitAccessException异常。Shiro教程Apache Shiro简介Spring Boot Shiro用户认证Spring Boot Shiro 添加记住我功能Spring Boot Shiro权限控制Spring Boot Shiro中使用缓存Spring Boot Thymeleaf中使用Shiro标签Spring Boot Shiro在线会话管理Shiro如何整合JWTShiro如何整合JWT可以参考：https://gitlab.com/wuyouzhuguli/shiro_jwt为了简化过程，例子没有使用数据库和Redis，在内存中模拟了两个用户：12345678910111213141516171819202122/** * 模拟两个用户 * * @return List&lt;User&gt; */private static List&lt;User&gt; users() &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 模拟两个用户： // 1. 用户名 admin，密码 123456，角色 admin（管理员），权限 "user:add"，"user:view" // 1. 用户名 scott，密码 123456，角色 regist（注册用户），权限 "user:view" users.add(new User( "admin", "bfc62b3f67a4c3e57df84dad8cc48a3b", new HashSet&lt;&gt;(Collections.singletonList("admin")), new HashSet&lt;&gt;(Arrays.asList("user:add", "user:view")))); users.add(new User( "scott", "11bd73355c7bbbac151e4e4f943e59be", new HashSet&lt;&gt;(Collections.singletonList("regist")), new HashSet&lt;&gt;(Collections.singletonList("user:view")))); return users;&#125;可以使用PostMan进行接口测试。前端项目介绍项目结构项目机构如下图所示：数据存储在用户登录成功后，项目会通过Vuex和localstorage存储一些数据供项目全局使用。正如前面所说，当用户登录成功后，后端会返回如下数据：token：token；exipreTime：token过期时间；roles：用户角色；permissions：用户权限；config：用户前端系统的个性化配置；user：用户信息（不包括密码）。在src/views/login/Login.vue文件中你会看到如下代码：1234567891011121314151617181920212223242526...mapMutations(&#123; setToken: 'account/setToken', setExpireTime: 'account/setExpireTime', setPermissions: 'account/setPermissions', setRoles: 'account/setRoles', setUser: 'account/setUser', setTheme: 'setting/setTheme', setLayout: 'setting/setLayout', setMultipage: 'setting/setMultipage', fixSiderbar: 'setting/fixSiderbar', fixHeader: 'setting/fixHeader', setColor: 'setting/setColor'&#125;),saveLoginData (data) &#123; this.setToken(data.token) this.setExpireTime(data.exipreTime) this.setUser(data.user) this.setPermissions(data.permissions) this.setRoles(data.roles) this.setTheme(data.config.theme) this.setLayout(data.config.layout) this.setMultipage(data.config.multiPage === '1') this.fixSiderbar(data.config.fixSiderbar === '1') this.fixHeader(data.config.fixHeader === '1') this.setColor(data.config.color)&#125;这将把登录接口返回的数据存储到Vuex和浏览器的localstorage中。存储Token的原因是，后续需要认证的请求，都会在请求头中携带这个Token；存储ExpireTime的原因是为了优化认证过期时的用户体验；存储用户信息的原因是为了供个人中心和系统主页使用；存储角色和权限是为了判断页面按钮渲染与否；存储用户个性化配置的原因是为了通过这些配置渲染不同的系统界面。路由导航守卫路由导航守卫代码位置：frontend/src/router/index.js：12345678910111213141516171819202122232425262728293031323334353637383940...const whiteList = ['/login']let asyncRouter// 导航守卫，渲染动态路由router.beforeEach((to, from, next) =&gt; &#123; if (whiteList.indexOf(to.path) !== -1) &#123; next() &#125; let token = db.get('USER_TOKEN') let user = db.get('USER') let userRouter = get('USER_ROUTER') if (token.length &amp;&amp; user) &#123; if (!asyncRouter) &#123; if (!userRouter) &#123; request.get(`menu/$&#123;user.username&#125;`).then((res) =&gt; &#123; asyncRouter = res.data save('USER_ROUTER', asyncRouter) go(to, next) &#125;) &#125; else &#123; asyncRouter = userRouter go(to, next) &#125; &#125; else &#123; next() &#125; &#125; else &#123; next('/login') &#125;&#125;)function go (to, next) &#123; asyncRouter = filterAsyncRouter(asyncRouter) router.addRoutes(asyncRouter) next(&#123;...to, replace: true&#125;)&#125;...主要逻辑分为下面几步：判断要跳转的路由地址是否在路由白名单内，是的话放行，不是的话进行第2步；从内存中获取token和用户信息，如果存在则进行第3步，不存在跳转到登录页；判断动态路由信息是否存在，存在则放行，不存在则进行第4步；判断用户路由是否已经加载，是的话将用户路由赋值给动态路由，并执行路由添加操作，然后跳转；如果用户路由不存在，则执行第5步；根据用户名从后台获取用户路由信息，并将其保存到内存中，再执行路由添加操作，然后跳转。权限控制在前端页面中，我们已经实现了通过不同用户获取不同的路由，以此渲染出不同的菜单列表功能，此外页面上的操作按钮也必须进行权限控制。正如前面所述，在登录成功后，系统会把用户的角色和权限信息存储到了内存中，所以我们可以通过这些信息结合 自定义Vue指令 的方式来实现按钮的权限控制。目前支持的和权限相关的Vue指令有：指令含义示例v-hasPermission当用户拥有列出的权限的时候，渲染该元素&lt;template v-hasPermission=&quot;&#39;user:add&#39;,&#39;user:update&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;v-hasAnyPermission当用户拥有列出的任意一项权限的时候，渲染该元素&lt;template v-hasAnyPermission=&quot;&#39;user:add&#39;,&#39;user:update&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;v-hasRole当用户拥有列出的角色的时候，渲染该元素&lt;template v-hasRole=&quot;&#39;admin&#39;,&#39;register&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;v-hasAnyRole当用户拥有列出的任意一个角色的时候，渲染该元素&lt;template v-hasAnyRole=&quot;&#39;admin&#39;,&#39;register&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;hasNoPermission当用户没有列出的权限的时候，渲染该元素&lt;template v-hasNoPermission=&quot;&#39;user:add&#39;,&#39;register&#39;&quot;&gt;&lt;span&gt;无操作权限&lt;/span&gt;&lt;/template&gt;以v-hasPermission=&quot;user:add&quot;为例，详细介绍下自定义权限Vue指令的实现过程：在src/utils/permissionDirect.js中定义如下代码：1234567891011121314151617181920212223 export const hasPermission = &#123; install (Vue) &#123; Vue.directive('hasPermission', &#123; bind (el, binding, vnode) &#123; let permissions = vnode.context.$store.state.account.permissions let value = binding.value.split(',') let flag = true for (let v of value) &#123; if (!permissions.includes(v)) &#123; flag = false &#125; &#125; if (!flag) &#123; if (!el.parentNode) &#123; el.style.display = 'none' &#125; else &#123; el.parentNode.removeChild(el) &#125; &#125; &#125; &#125;) &#125;&#125;上面代码中，我们从Vuex中获取了用户所拥有的权限，然后判断这些权限中是否包含user:add，如果不包含，则将对应的元素（el）移除或者隐藏。所以当用户没有user:add权限时，下面的按钮将不会被渲染在页面上：1&lt;template v-hasPermission="'user:add'"&gt;&lt;button&gt;新增用户&lt;/button&gt;&lt;/template&gt;要让自定义Vue指令生效，还需要在src/utils/install.js中将其添加到Plugins列表。Axios封装项目使用Axios插件来发送HTTP请求，并对它进行了封装（frontend/src/utils/request.js），这里主要讲述下request.js中主要逻辑。123456789// 统一配置let FEBS_REQUEST = axios.create(&#123; baseURL: 'http://127.0.0.1:9527/', responseType: 'json', validateStatus (status) &#123; // 200 外的状态码都认定为失败 return status === 200 &#125;&#125;)上面这段代码对请求进行了统一配置，baseURL定义了后端地址的基础路径，responseType定义了响应数据类型为JSON，只有状态码为200时才认定请求成功。1234567891011121314151617181920212223242526272829// 拦截请求FEBS_REQUEST.interceptors.request.use((config) =&gt; &#123; let expireTime = store.state.account.expireTime let now = moment().format('YYYYMMDDHHmmss') // 让token早10秒种过期，提升“请重新登录”弹窗体验 if (now - expireTime &gt;= -10) &#123; Modal.error(&#123; title: '登录已过期', content: '很抱歉，登录已过期，请重新登录', okText: '重新登录', mask: false, onOk: () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 为什么不直接跳转到登录页呢？那是因为Vue没有提供清空路由的方法，只能通过刷新页面的方式 // 来清除之前动态添加的路由信息。 db.clear() location.reload() &#125;) &#125; &#125;) &#125; // 有 token就带上 if (store.state.account.token) &#123; config.headers.Authentication = store.state.account.token &#125; return config&#125;, (error) =&gt; &#123; return Promise.reject(error)&#125;)在Axios的前置拦截中，我们首先判断了token是否已经过期，如果过期了则清空在登录时保存的数据，并且刷新页面。这时候通过路由导航守卫，页面会被重定向到登录页面，引导用户重新登录。如果token没有过期，则在请求头上带上token信息。headers.Authentication和后端代码中的TOKEN名称相对应：123456789101112131415161718192021222324252627282930313233// 拦截响应FEBS_REQUEST.interceptors.response.use((config) =&gt; &#123; return config&#125;, (error) =&gt; &#123; if (error.response) &#123; let errorMessage = error.response.data === null ? '系统内部异常，请联系网站管理员' : error.response.data.message switch (error.response.status) &#123; case 404: notification.error(&#123; message: '系统提示', description: '很抱歉，资源未找到', duration: 4 &#125;) break case 403: case 401: notification.warn(&#123; message: '系统提示', description: '很抱歉，您无法访问该资源，可能是因为没有相应权限或者登录已失效', duration: 4 &#125;) break default: notification.error(&#123; message: '系统提示', description: errorMessage, duration: 4 &#125;) break &#125; &#125; return Promise.reject(error)&#125;)上面代码中我们实现了异常响应的统一处理，根据不同的状态码给予不同的提示信息。此外，项目还对各种HTTP请求进行了封装，下面一一列举出它们的用法：GET请求方式一：12345this.$get('user', &#123; ...params&#125;).then((r) =&gt; &#123; console.log(r)&#125;)因为我们在前面已经定义了后端地址的基础路径，所以上面这个请求的实际地址为：http://127.0.0.1:9527/user。在前面我们已经对异常响应进行统一处理，当然你也可以通过catch来覆盖：1234567this.$get('user', &#123; ...params&#125;).then((r) =&gt; &#123; console.log(r)&#125;).catch((error) =&gt; &#123; alert('出错啦')&#125;)方式二（路径传参）：123this.$get(`menu/$&#123;user.username&#125;`).then((r) =&gt; &#123; console.log(r)&#125;)方式三：123this.$get(`user?username=$&#123;user.username&#125;`).then((r) =&gt; &#123; console.log(r)&#125;)POST请求12345this.$post('user', &#123; ...params&#125;).then((r) =&gt; &#123; console.log(r)&#125;)PUT请求12345this.$put('user', &#123; ...params&#125;).then((r) =&gt; &#123; console.log(r)&#125;)DELETE请求123this.$delete('user/$&#123;user.userId&#125;').then((r) =&gt; &#123; console.log(r)&#125;)下载文件1this.$download('file', &#123; ...params &#125;, 'xxx.xx')xxx.xx为下载的文件名，比如下载xlsx文件的话为 Excel文件.xlsx，后端接口返回数据流即可。上传文件1234let formData = new FormData($("#form")[0]);this.$upload('upload', formData).then((r) =&gt; &#123; console.log(r)&#125;)后端以MultipartFile接收文件即可。路径配置在build/webpack.base.conf.js中，我们定义了一些路径变量：12345678910111213module.exports = &#123; ... resolve: &#123; ... alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), '~': resolve('src/components'), 'utils': resolve('src/utils') &#125; &#125;, ...&#125;比如~代表src/components路径，在项目中，如果要引入src/components/test.vue只需要这样做即可：1import ~/test.vue当然，你也可以使用相对路径和绝对路径，而不使用这些变量。第三方组件介绍Ant Design Vue已经提供了非常丰富的组件，除此之外，项目里使用的图表插件为：apexcharts.js，其官方文档提供了很多示例，这里就不赘述了。开发建议相信正在阅读文档的你十有八九是一名后端开发者，可能对前端特别是对Vue不太熟悉，这里给出几点改造frontend的建议：要有一定的ES6语法基础，可以参考 ES6学习笔记 ，如果要系统学习ES6，推荐阮一峰的： ECMAScript 6 入门 。Vue的官方文档还是挺详细的，建议仔细阅读，我在学习Vue的时候也做了一些笔记，可以参考：https://mrbird.cc/Vue-Learn-Note.html。Vue的学习路线：Vue基础语法 -&gt; Vuex -&gt; Vue Router。前端组件用的是Ant Design Vue，所以在使用它提供的组件的时候，多阅读它的使用文档。开发示例新建一个页面在frontend工程的src/views下新建一个test目录，在该目录下新建一个test.vue文件： 内容如下所示：1234567891011121314151617181920&lt;template&gt; &lt;div class="test"&gt;&#123;&#123;hello&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'test', data () &#123; return &#123; hello: 'hello world' &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="less" scoped&gt; .test &#123; color: #42b984; font-size: 1.1rem; font-weight: 600; &#125;&lt;/style&gt;启动项目，使用管理员账号登录，然后在菜单管理中新建一个菜单：菜单URL：这里填写/test的话，在访问这个页面的时候，浏览器地址栏为http://localhost:8081/#/test，只要确保这个值不重复即可；组件地址：对应要渲染的Vue组件地址，在路由导航守卫中有如下一段代码：所以这里填test/test，对应@/views/test/test.vue组件。相关权限：访问这个页面需要test:view权限。点击确定后，这个菜单就被建好了：接着修改管理员角色，将刚刚新建的菜单授权给管理员：点击确定修改后，重新登录系统：如何新建一个多级菜单在新增多级菜单前，先了解下系统中的一个约定：在一个多级菜单中，顶级菜单对应的组件为PageView，末级菜单对应的组件为需要渲染的页面组件，剩下的（非顶级，非末级的中间菜单对应的组件为EmptyPageView）。我们来建一个四级菜单，首先新增一个顶级菜单：因为是顶级菜单，所以对应组件填PageView。接着新增第二级菜单：因为它数据中间菜单（非顶级非末级）所以对应组件填EmptyPageView，上级菜单勾选刚刚新建的一级菜单。继续新增三级菜单：因为它也是一个中间菜单，所以对应组件填EmptyPageView，上级菜单勾选刚刚新建的二级菜单。最后将我们前面建好的测试页面作为末级，点击测试页面后面的小齿轮按钮，进行修改：点击确定后一个四级菜单就建好了：最后一步授权！修改管理员角色：修改后，重新登录系统：因为我没有设置排序，所以默认排在最前面了。如何隐藏路由有的时候，一些路由并不需要渲染成菜单，比如个人中心这类页面。而这些页面一般都是所有用户共有的，所以在后台系统里构建路由的时候写死即可。要隐藏路由只需要将路由meta的isShow属性设置为false即可：参考后台代码cc.mrbird.febs.common.utils.TreeUtil：如何分配权限权限是和角色绑定的，所以要分配权限实际就是对角色的增删改。假如现在要配置一个角色 ——— 系统监控管理员，负责系统监控模块的查看：然后新增一个用户 ——— yuuki，角色为系统监控管理员：新建好后，使用yuuki的账号登录：可以看到，yuuki只有系统监控模块的权限。前端如何添加依赖在https://www.npmjs.com/搜索需要安装的依赖，比如jQuery：比如我需要安装jQuery 3.3.1版本，只需要在终端输入如下命令即可：安装好后，在package.json的依赖列表里会多出一个jquery 3.3.1：如何处理排序对于前端来说，需要上送两个参数：sortField：需要排序的字段；sortOrder：排序规则，ascend或者descend。对于后端来说，排序主要分为四种情况：结果需要分页的，并且是通过xml定义的SQL查询出来的结果：1SortUtil.handlePageSort(request, page, "userId", FebsConstant.ORDER_ASC, false);userId和FebsConstant.ORDER_ASC指定了默认的排序规则，即默认按照userId字段升序排序。最后一个参数表示是否需要开启驼峰转下划线，这种情况下不需要，false即可。具体可以参考cc.mrbird.febs.system.service.impl.UserServiceImpl#findUserDetail。如果不需要指定默认排序规则，使用handlePageSort的重载方法即可：1SortUtil.handlePageSort(request, page, false);结果需要分页的，并且是通过Mybatis Plus插件查询出来的结果：1SortUtil.handlePageSort(request, page, true);这种情况下，最后一个参数值必须为true。具体可以参考cc.mrbird.febs.system.service.impl.DictServiceImpl#findDicts。1和2主要区别就是是否需要开启驼峰转下划线。结果不需要分页，并且是通过xml定义的SQL查询出来的结果：1SortUtil.handleWrapperSort(request, queryWrapper, "orderNum", FebsConstant.ORDER_ASC, false);具体可以参考：cc.mrbird.febs.system.service.impl.DeptServiceImpl#findDepts结果不需要分页，并且是通过Mybatis Plus插件查询出来的结果：1SortUtil.handleWrapperSort(request, queryWrapper, "orderNum", FebsConstant.ORDER_ASC, true);总之，对于处理排序的方法，第一个参数一定是cc.mrbird.febs.common.domain.QueryRequest。第二个参数如果需要分页，则传递com.baomidou.mybatisplus.extension.plugins.pagination.Page，不需要分页则传递com.baomidou.mybatisplus.core.conditions.query.QueryWrapper。最后一个参数如果查询结果是Mybatis Plus查询出来的结果，则需设置为true，否则为false。后端接口测试由于后端接口为RESTful接口，所以不能使用浏览器来测试，可以使用PostMan或者Chrome插件RestLet来测试后端接口。文档以PostMan为例。因为后台接口大部分都需要用户认证后才能访问，所以在测试之前需要通过登录接口获取一个可用的token。成功获取到了token。测试获取mrbird的前端路由信息：在Headers设置一个键值对，key为Authentication，value为刚刚获取到的token，发送请求便可以获取到mrbird的路由信息。其他接口测试以此类推。如果token填错或者不填：后端将返回401。常见问题导入项目编译出错，代码是否不全？编辑器安装lombok插件即可。导入SQL为何出错？MySQL数据库请使用5.7.x版本，不同版本SQL语法有差异。如果你SQL技术过硬可以通过错误信息去修改出错的SQL，更推荐的做法是安装推荐版本的MySQL数据库。ip2region是啥玩意，打开怎么乱码？通过ip获取地址的开源软件数据库文件，不要直接打开。ip2region地址：https://github.com/lionsoul2014/ip2region。项目缺陷前端页面不支持移动端（不能自适应）；前端打包后vendor.js较大，通过nginx压缩后在591kb左右，在我的渣渣服务器（1核1G1M）下，访问时间大约为7 - 8秒左右：如果你的服务器带宽够大，或者是部署在公司局域网内的话，这个问题可以忽略。如果要在根源上解决这个问题个人觉得可以从这几个地方入手：Ant Design采用SVG格式的图标后，导致项目打包体积过大，可以参考官方issue的讨论：https://github.com/vueComponent/ant-design-vue/issues/325和https://github.com/ant-design/ant-design/issues/12011；可以将依赖通过CDN来加载，参考连接：https://blog.csdn.net/qq_35844177/article/details/78599064；webpack打包配置可能存在可优化的地方。由于我才疏学浅，前端技能薄弱，所以没能够很好地解决这个问题。欢迎来自五湖四海的能人志士pull request来改善这个问题，感激不尽。]]></content>
      <tags>
        <tag>FEBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot WebFlux增删改查样例]]></title>
    <url>%2FSpring-Boot-WebFlux-CRUD.html</url>
    <content type="text"><![CDATA[在 Spring Boot 2.0 WebFlux编程 一节我们大致了解了WebFlux的用法，这节我们将结合Mongo DB在WebFlux的架构下实现增删改查样例。和 Spring Boot整合Mongo DB 不同的是，我们使用的是Reactive Mongo DB依赖，所有增删改查方法返回值类型为Flux或者Mono。项目准备新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入webflux和reactive mongodb依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;&lt;/dependency&gt;要开启Reactive Mongo DB的相关配置，需要在Spring Boot启动类上添加@EnableReactiveMongoRepositories注解：1234567@SpringBootApplication@EnableReactiveMongoRepositoriespublic class WebfluxApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebfluxApplication.class, args); &#125;&#125;接着在配置文件application.yml里配置Mongo DB连接：123456spring: data: mongodb: host: localhost port: 27017 database: webflux使用的是webflux数据库，所以需要在Mongo DB里新建一个webflux数据库（并创建user文档/表，以供待会使用）：创建User实体类:1234567891011@Document(collection = "user")public class User &#123; @Id private String id; private String name; private Integer age; private String description; // get set 略&#125;简单增删改查创建UserDao接口，继承自ReactiveMongoRepository：123@Repositorypublic interface UserDao extends ReactiveMongoRepository&lt;User, String&gt; &#123;&#125;和 Spring Boot整合Mongo DB 不同的是，我们继承的是ReactiveMongoRepository而非MongoRepository，它所提供的方法都是响应式的：在UserService里通过UserDao定义简单增删改查方法：123456789101112131415161718192021222324252627282930313233@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public Flux&lt;User&gt; getUsers() &#123; return userDao.findAll(); &#125; public Mono&lt;User&gt; getUser(String id) &#123; return this.userDao.findById(id); &#125; public Mono&lt;User&gt; createUser(User user) &#123; return userDao.save(user); &#125; public Mono&lt;Void&gt; deleteUser(String id) &#123; return this.userDao.findById(id) .flatMap(user -&gt; this.userDao.delete(user)); &#125; public Mono&lt;User&gt; updateUser(String id, User user) &#123; return this.userDao.findById(id) .flatMap(u -&gt; &#123; u.setName(user.getName()); u.setAge(user.getAge()); u.setDescription(user.getDescription()); return this.userDao.save(u); &#125;); &#125;&#125;大致上和 Spring Boot整合Mongo DB 中的UserService差不多，不同的是返回值类型为Flux或者Mono，即它们是响应式非阻塞的方法。编写RESTfulUserController：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; /** * 以数组的形式一次性返回所有数据 */ @GetMapping public Flux&lt;User&gt; getUsers() &#123; return userService.getUsers(); &#125; /** * 以 Server sent events形式多次返回数据 */ @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux&lt;User&gt; getUsersStream() &#123; return userService.getUsers(); &#125; @PostMapping public Mono&lt;User&gt; createUser(User user) &#123; return userService.createUser(user); &#125; /** * 存在返回 200，不存在返回 404 */ @DeleteMapping("/&#123;id&#125;") public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(@PathVariable String id) &#123; return userService.deleteUser(id) .then(Mono.just(new ResponseEntity&lt;Void&gt;(HttpStatus.OK))) .defaultIfEmpty(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND)); &#125; /** * 存在返回修改后的 User * 不存在返回 404 */ @PutMapping("/&#123;id&#125;") public Mono&lt;ResponseEntity&lt;User&gt;&gt; updateUser(@PathVariable String id, User user) &#123; return userService.updateUser(id, user) .map(u -&gt; new ResponseEntity&lt;&gt;(u, HttpStatus.OK)) .defaultIfEmpty(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND)); &#125; /** * 根据用户 id查找 * 存在返回，不存在返回 404 */ @GetMapping("/&#123;id&#125;") public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUser(@PathVariable String id) &#123; return userService.getUser(id) .map(user -&gt; new ResponseEntity&lt;&gt;(user, HttpStatus.OK)) .defaultIfEmpty(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND)); &#125;&#125;对于返回值为Flux&lt;T&gt;类型的方法，推荐定义两个一样的方法，一个以普通形式返回，一个以Server Sent Event的形式返回。对于修改和删除，如果需要修改和删除的用户不存在，我们返回404。对于Flux和Mono的操作，在 Spring Boot 2.0 WebFlux编程 一节中已经介绍过了，这里就不再赘述了。排序与分页在 Spring Boot整合Mongo DB 一节中，我们通过MongoTemplate实现了排序与分页。与MongoTemplate对于的响应式的对象为ReactiveMongoTemplate，所以我们照葫芦画瓢，仿照MongoTemplate的写法来实现：123456789101112131415161718192021222324252627282930313233/** * 分页查询，只返回分页后的数据，count值需要通过 getUserByConditionCount * 方法获取 */public Flux&lt;User&gt; getUserByCondition(int size, int page, User user) &#123; Query query = getQuery(user); Sort sort = new Sort(Sort.Direction.DESC, "age"); Pageable pageable = PageRequest.of(page, size, sort); return template.find(query.with(pageable), User.class);&#125;/** * 返回 count，配合 getUserByCondition使用 */public Mono&lt;Long&gt; getUserByConditionCount(User user) &#123; Query query = getQuery(user); return template.count(query, User.class);&#125;private Query getQuery(User user) &#123; Query query = new Query(); Criteria criteria = new Criteria(); if (!StringUtils.isEmpty(user.getName())) &#123; criteria.and("name").is(user.getName()); &#125; if (!StringUtils.isEmpty(user.getDescription())) &#123; criteria.and("description").regex(user.getDescription()); &#125; query.addCriteria(criteria); return query;&#125;之所以拆分是因为没找到与PageableExecutionUtils类的getPage方法类似的方法，如果是响应式的话，返回值类型应该是Mono&lt;Page&lt;User&gt;&gt;，不懂大家有没别的更好的实现方法？源码和PostMan测试样例链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/58.Spring-Boot-WebFlux-crud]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>MongoDB</tag>
        <tag>WebFlux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Consul服务治理]]></title>
    <url>%2FSpring-Cloud-Consul.html</url>
    <content type="text"><![CDATA[Consul是一款由HashiCorp公司开源的，用于服务治理的软件，Spring Cloud Consul对其进行了封装。Consul具有如下特点:服务注册 - 自动注册和取消注册服务实例的网络位置运行状况检查 - 检测服务实例何时启动并运行分布式配置 - 确保所有服务实例使用相同的配置Consul agent有两种运行模式：Server和Client。这里的Server和Client只是Consul集群层面的区分，与搭建在Cluster之上 的应用服务无关。 以Server模式运行的Consul agent节点用于维护Consul集群的状态，官方建议每个Consul Cluster至少有3个或以上的运行在Server mode的Agent，Client节点不限。安装ConsulConsul下载地址：https://www.consul.io/downloads.html，本文选择Linux 64bit 版本进行演示。下载后解压，然后在解压目录下运行./consul命令：可以看到Consul所包含的命令，使用consul [命令] --help可以查看某个命令的具体用法。执行下面这条命令来启动一个Consul agent：1./consul agent -dev -client 192.168.140.215-dev表示创建一个开发环境下的server节点，在该模式下不会有任何持久化操作，即不会有任何数据写入到磁盘，所以这个模式适合用于开发过程，而不适用于生产环境。-client 192.168.140.215表示运行客户端使用ip地址192.168.140.215（本文Linux环境IP地址）去访问。启动后，默认的端口号为8500，访问http://192.168.140.215:8500当前就一个consul服务。接下来我们开始创建服务提供者和服务消费者。Server-Provider创建一个Spring Boot项目，版本为2.0.2.RELEASE，artifactId为server-provider，Spring Cloud版本为Finchley.RELEASE：123456789101112131415161718192021222324252627&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;然后在配置文件里添加如下配置：1234567891011121314server: port: 9000spring: application: name: server-provider cloud: consul: host: 192.168.140.215 port: 8500 discovery: health-check-interval: 10s service-name: $&#123;spring.application.name&#125; register-health-check: true health-check-path: /checkspring.cloud.consul.host和spring.cloud.consul.port配置了consul的ip和端口；spring.cloud.consul.discovery.service-name配置了该服务在consul里注册的服务名称；spring.cloud.consul.discovery.register-health-check用于开启健康检查，spring.cloud.consul.discovery.health-check-interval配置了健康检查的周期为10秒，spring.cloud.consul.discovery.health-check-path配置了健康检查路径。接着新建TestController：12345678910111213141516@RestControllerpublic class TestController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @GetMapping("check") private String check() &#123; logger.info("health check"); return "ok"; &#125; @GetMapping("hello") public String hello() &#123; logger.info("hello"); return "hello from server provider"; &#125;&#125;check方法用于监控检查，TestController还提供了一个hello方法，以供后续服务消费者调用。spring.cloud.consul.discovery.health-check-path的默认值为/actuator/health，如果采用该默认值的话，还需要导入spring-boot-starter-actuator依赖。最后，要开启服务注册与发行，需要在Spring Boot入口类上添加@EnableDiscoveryClient注解：1234567@EnableDiscoveryClient@SpringBootApplicationpublic class ServerProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServerProviderApplication.class, args); &#125;&#125;准备完毕后，打包项目，然后启动两个实例，端口号分别为9000和9001，启动后，再次访问consul管理界面：服务提供者注册成功，接下来开始搭建服务消费者。Server-Consumer创建一个Spring Boot项目，版本为2.0.2.RELEASE，artifactId为server-provider，Spring Cloud版本为Finchley.RELEASE：12345678910111213141516171819202122232425262728293031&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;引入spring-boot-starter-actuator用于默认的健康检查。配置application.yml：12345678910111213server: port: 9002spring: application: name: server-consumer cloud: consul: host: 192.168.140.215 port: 8500 discovery: service-name: $&#123;spring.application.name&#125;同样的，需要开启服务注册与发现需要在入口类上添加@EnableDiscoveryClient注解。接着创建TestController来消费Server-Provider提供的hello服务：1234567891011121314151617181920212223242526272829@RestControllerpublic class TestController &#123; private Logger loggr = LoggerFactory.getLogger(this.getClass()); @Autowired private DiscoveryClient discoveryClient; @Autowired private LoadBalancerClient loadBalancerClient; private final RestTemplate restTemplate = new RestTemplate(); private static final String SERVER_ID = "server-provider"; @GetMapping("uri") public List&lt;URI&gt; getServerUris() &#123; return this.discoveryClient.getInstances(SERVER_ID) .stream() .map(ServiceInstance::getUri).collect(Collectors.toList()); &#125; @GetMapping("hello") public String hello() &#123; ServiceInstance instance = loadBalancerClient.choose(SERVER_ID); String url = instance.getUri().toString() + "/hello"; loggr.info("remote server url：&#123;&#125;", url); return restTemplate.getForObject(url, String.class); &#125;&#125;SERVER_ID的值为服务提供者在consul注册中心的实例名称，即server-provider。通过DiscoveryClient我们可以获取到所有名称为server-provider的服务实例信息。通过LoadBalancerClient我们可以实现负载均衡地去获取服务实例，并通过RestTemplate去调用服务。打包部署项目，然后查看consul控制台：访问：http://192.168.140.215:9002/uri：可以看到我们成功获取到了服务名称为server-provider的两个具体实例。多次调用http://192.168.140.215:9002/hello：控制台输出如下：服务调用是均衡的。除此之外，consul内置了Ribbon，所以我们还可以通过@LoadBalanced标注的RestTemplate来实现负载均衡服务调用：12345678910111213141516@Autowiredprivate RestTemplate restTemplate;private static final String SERVER_ID = "server-provider";@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125;@GetMapping("hello")public String hello() &#123; String url = "http://" + SERVER_ID + "/hello"; return restTemplate.getForObject(url, String.class);&#125;效果是一样的。consul集群上面我们只是以-dev模式开启了一个单节点consul agent，生产环境下需要搭建consul集群来确保高可用。搭建consul集群时常用的命令有:命令解释示例agent运行一个consul agentconsul agent -devjoin将agent加入到consul集群consul join IPmembers列出consul cluster集群中的membersconsul membersleave将节点移除所在集群consul leave准备了三台Linux服务器，配置如下：序号节点ip节点名称角色1192.168.140.215consul-server-215server2192.168.140.213consul-server-213server3192.168.140.216consul-server-216server &amp; web ui在这三台服务器上下载并解压consul，然后在解压的根目录上创建一个data目录。由于我们之前已经在215上启动了consul，所以先执行killall consul来杀掉进程，然后执行下面这条命令：1nohup ./consul agent -server -bind 192.168.140.215 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-215 &amp;解释一下上面这条命令的含义:-server表示以服务的形式启动agent-bind表示绑定到当前Linux的ip（有些服务器会绑定多块网卡，可以通过bind参数强制指定绑定的ip）-client指定客户端访问的ip（consul有丰富的api接口，这里的客户端指浏览器或调用方），0.0.0.0表示不限客户端ip-bootstrap-expect=3表示server集群最低节点数为3，低于这个值将工作不正常(注：类似zookeeper一样，通常集群数为奇数，方便选举，consul采用的是raft算法)-data-dir表示指定数据的存放目录（该目录必须存在）-node表示节点的名称接着在213服务器上执行下面这条命令：1nohup ./consul agent -server -bind 192.168.140.213 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-213 &amp;最后在216上执行下面这条命令：1nohup ./consul agent -server -bind 192.168.140.216 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-216 -ui &amp;和前两条命令相比，这条命令多了-ui选项，表示开启管理界面UI。然后分别在213和215下执行下面这条命令：1./consul join 192.168.140.216这样213和215成功加入到了216构成了一个三节点集群，运行./consul members查看：访问http://192.168.140.216:8500：访问http://192.168.140.215:9002/hello：这时候在215执行killall consul命令，杀死consul服务，然后在216上执行./consul members：可以看到215节点已经挂了，再次访问http://192.168.140.215:9002/hello：服务依旧获取成功。可见，虽然我们在application.yml中配置consul的地址是192.168.140.215:8500，但由于我们构建的是consul集群，所以微服务启动时会获取到整个集群信息，即使215这个节点挂了，微服务可以从别的consul节点上获取注册的服务信息。参考文档：https://learn.hashicorp.com/consul/getting-started/install.htmlhttps://cloud.spring.io/spring-cloud-consul/spring-cloud-consul.html#spring-cloud-consul-hystrix源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/55.Spring-Cloud-Consul]]></content>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Kafka]]></title>
    <url>%2FSpring-Boot-Kafka.html</url>
    <content type="text"><![CDATA[Kafka是一个分布式的、可分区的、可复制的消息系统，下面是Kafka的几个基本术语：Kafka将消息以topic为单位进行归纳；将向Kafka topic发布消息的程序成为producers；将预订topics并消费消息的程序成为consumer；Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个broker。producers通过网络将消息发送到Kafka集群，集群向消费者提供消息，如下图所示：创建一个topic时，可以指定partitions（分区）数目，partitions数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到producers发送的消息之后，会根据均衡策略将消息存储到不同的partitions中：在每个partitions中，消息以顺序存储，最晚接收的的消息会最后被消费。producers在向kafka集群发送消息的时候，可以通过指定partitions来发送到指定的partitions中。也可以通过指定均衡策略来将消息发送到不同的partitions中。如果不指定，就会采用默认的随机均衡策略，将消息随机的存储到不同的partitions中。在consumer消费消息时，kafka使用offset来记录当前消费的位置：在kafka的设计中，可以有多个不同的group来同时消费同一个topic下的消息，如图，我们有两个不同的group同时消费，他们的的消费的记录位置offset各不项目，不互相干扰。对于一个group而言，consumer的数量不应该多于partitions的数量，因为在一个group中，每个partitions至多只能绑定到一个consumer上，即一个consumer可以消费多个partitions，一个partitions只能给一个consumer消费。因此，若一个group中的consumer数量大于partitions数量的话，多余的consumer将不会收到任何消息。Kafka安装使用这里演示在Windows下Kafka安装与使用。Kafka下载地址：http://kafka.apache.org/downloads，选择二进制文件下载（Binary downloads），然后解压即可。Kafka的配置文件位于config目录下，因为Kafka集成了Zookeeper（Kafka存储消息的地方），所以config目录下除了有Kafka的配置文件server.properties外，还可以看到一个Zookeeper配置文件zookeeper.properties：打开server.properties，将broker.id的值修改为1，每个broker的id都必须设置为Integer类型，且不能重复。Zookeeper的配置保持默认即可。接下来开始使用Kafka。启动Zookeeper在Windows下执行下面这些命令可能会出现找不到或无法加载主类的问题，解决方案可参考：https://blog.csdn.net/cx2932350/article/details/78870135。在Kafka根目录下使用cmd执行下面这条命令，启动ZK：1bin\windows\zookeeper-server-start.bat config\zookeeper.properties在Linux下，可以使用后台进程的方式启动ZK：1bin/zookeeper-server-start.sh -daemon config/zookeeper.properties启动Kafka执行下面这条命令启动Kafka：1bin\windows\kafka-server-start.bat config\server.propertiesLinux对应命令：1bin/kafka-server-start.sh config/server.properties当看到命令行打印如下信息，说明启动完毕:创建Topic执行下面这条命令创建一个Topic1bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test这条命令的意思是，创建一个Topic到ZK（指定ZK的地址），副本个数为1，分区数为1，Topic的名称为test。Linux对应的命令为:1bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test创建好后我们可以查看Kafka里的Topic列表：1bin\windows\kafka-topics.bat --list --zookeeper localhost:2181可看到目前只包含一个我们刚创建的test Topic。Linux对应的命令为：1bin/kafka-topics.sh --list --zookeeper localhost:2181查看test Topic的具体信息：1bin\windows\kafka-topics.bat --describe --zookeeper localhost:2181 --topic testLinux对应的命令为：1bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test生产消息和消费消息启动Producers1bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic test9092为生产者的默认端口号。这里启动了生产者，准备往test Topic里发送数据。Linux下对应的命令为：1bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test启动Consumers接着启动一个消费者用于消费生产者生产的数据，新建一个cmd窗口，输入下面这条命令：1bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginningfrom-beginning表示从头开始读取数据。Linux下对应的命令为：1bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning启动好生产者和消费者后我们在生产者里生产几条数据:消费者成功接收到数据：Spring Boot整合Kafaka上面简单介绍了Kafka的使用，下面我们开始在Spring Boot里使用Kafka。新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入如下依赖:12345678 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;生产者配置新建一个Java配置类KafkaProducerConfig，用于配置生产者：1234567891011121314151617181920212223242526@Configurationpublic class KafkaProducerConfig &#123; @Value("$&#123;spring.kafka.bootstrap-servers&#125;") private String bootstrapServers; @Bean public ProducerFactory&lt;String, String&gt; producerFactory() &#123; Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put( ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); configProps.put( ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put( ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); return new DefaultKafkaProducerFactory&lt;&gt;(configProps); &#125; @Bean public KafkaTemplate&lt;String, String&gt; kafkaTemplate() &#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125;&#125;首先我们配置了一个producerFactory，方法里配置了Kafka Producer实例的策略。bootstrapServers为Kafka生产者的地址，我们在配置文件application.yml里配置它：123spring: kafka: bootstrap-servers: localhost:9092ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG和ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG指定了key，value序列化策略，这里指定为Kafka提供的StringSerializer，因为我们暂时只发送简单的String类型的消息。接着我们使用producerFactory配置了kafkaTemplate，其包含了发送消息的便捷方法，后面我们就用这个对象来发送消息。发布消息配置好生产者，我们就可以开始发布消息了。新建一个SendMessageController：1234567891011@RestControllerpublic class SendMessageController &#123; @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate; @GetMapping("send/&#123;message&#125;") public void send(@PathVariable String message) &#123; this.kafkaTemplate.send("test", message); &#125;&#125;我们注入了kafkaTemplate对象，key-value都为String类型，并通过它的send方法来发送消息。其中test为Topic的名称，上面我们已经使用命令创建过这个Topic了。send方法是一个异步方法，我们可以通过回调的方式来确定消息是否发送成功，我们改造SendMessageController：123456789101112131415161718192021222324@RestControllerpublic class SendMessageController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate; @GetMapping("send/&#123;message&#125;") public void send(@PathVariable String message) &#123; ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; future = this.kafkaTemplate.send("test", message); future.addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() &#123; @Override public void onSuccess(SendResult&lt;String, String&gt; result) &#123; logger.info("成功发送消息：&#123;&#125;，offset=[&#123;&#125;]", message, result.getRecordMetadata().offset()); &#125; @Override public void onFailure(Throwable ex) &#123; logger.error("消息：&#123;&#125; 发送失败，原因：&#123;&#125;", message, ex.getMessage()); &#125; &#125;); &#125;&#125;消息发送成功后，会回调onSuccess方法，发送失败后回调onFailure方法。消费者配置接着我们来配置消费者，新建一个Java配置类KafkaConsumerConfig：123456789101112131415161718192021222324252627282930313233343536373839404142@EnableKafka@Configurationpublic class KafkaConsumerConfig &#123; @Value("$&#123;spring.kafka.bootstrap-servers&#125;") private String bootstrapServers; @Value("$&#123;spring.kafka.consumer.group-id&#125;") private String consumerGroupId; @Value("$&#123;spring.kafka.consumer.auto-offset-reset&#125;") private String autoOffsetReset; @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put( ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put( ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId); props.put( ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, autoOffsetReset); props.put( ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put( ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return new DefaultKafkaConsumerFactory&lt;&gt;(props); &#125; @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); return factory; &#125;&#125;consumerGroupId和autoOffsetReset需要在application.yml里配置：12345spring: kafka: consumer: group-id: test-consumer auto-offset-reset: latest其中group-id将消费者进行分组（你也可以不进行分组），组名为test-consumer，并指定了消息读取策略，包含四个可选值：earliest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费latest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据none:topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常exception:直接抛出异常在KafkaConsumerConfig中我们配置了ConsumerFactory和KafkaListenerContainerFactory。当这两个Bean成功注册到Spring IOC容器中后，我们便可以使用@KafkaListener注解来监听消息了。配置类上需要@EnableKafka注释才能在Spring托管Bean上检测@KafkaListener注解。消息消费配置好消费者，我们就可以开始消费消息了，新建KafkaMessageListener：12345678910@Componentpublic class KafkaMessageListener &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @KafkaListener(topics = "test", groupId = "test-consumer") public void listen(String message) &#123; logger.info("接收消息: &#123;&#125;", message); &#125;&#125;我们通过@KafkaListener注解来监听名称为test的Topic，消费者分组的组名为test-consumer。演示启动Spring Boot项目，启动过程中，控制台会输出Kafka的配置，启动好后，访问http://localhost:8080/send/hello,mrbird，控制台输出如下：@KafkaListener详解@KafkaListener除了可以指定Topic名称和分组id外，我们还可以同时监听来自多个Topic的消息:1@KafkaListener(topics = "topic1, topic2")我们还可以通过@Header注解来获取当前消息来自哪个分区（partitions）:12345@KafkaListener(topics = "test", groupId = "test-consumer")public void listen(@Payload String message, @Header(KafkaHeaders.RECEIVED_PARTITION_ID) int partition) &#123; logger.info("接收消息: &#123;&#125;，partition：&#123;&#125;", message, partition);&#125;重启项目，再次访问http://localhost:8080/send/hello,mrbird，控制台输出如下：因为我们没有进行分区，所以test Topic只有一个区，下标为0。我们可以通过@KafkaListener来指定只接收来自特定分区的消息：123456789@KafkaListener(groupId = "test-consumer", topicPartitions = @TopicPartition(topic = "test", partitionOffsets = &#123; @PartitionOffset(partition = "0", initialOffset = "0") &#125;))public void listen(@Payload String message, @Header(KafkaHeaders.RECEIVED_PARTITION_ID) int partition) &#123; logger.info("接收消息: &#123;&#125;，partition：&#123;&#125;", message, partition);&#125;如果不需要指定initialOffset，上面代码可以简化为：12@KafkaListener(groupId = "test-consumer", topicPartitions = @TopicPartition(topic = "test", partitions = &#123; "0", "1" &#125;))消息过滤器我们可以为消息监听添加过滤器来过滤一些特定的信息。我们在消费者配置类KafkaConsumerConfig的kafkaListenerContainerFactory方法里配置过滤规则：1234567891011@Beanpublic ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); // ------- 过滤配置 -------- factory.setRecordFilterStrategy( r -&gt; r.value().contains("fuck") ); return factory;&#125;setRecordFilterStrategy接收RecordFilterStrategy&lt;K, V&gt;，他是一个函数式接口：123public interface RecordFilterStrategy&lt;K, V&gt; &#123; boolean filter(ConsumerRecord&lt;K, V&gt; var1);&#125;所以我们用lambda表达式指定了上面这条规则，即如果消息内容包含fuck这个粗鄙之语的时候，则不接受消息。配置好后我们重启项目，分别发送下面这两条请求：http://localhost:8080/send/fuck,mrbirdhttp://localhost:8080/send/love,mrbird观察控制台：可以看到，fuck,mrbird这条消息没有被接收。发送复杂的消息截至目前位置我们只发送了简单的字符串类型的消息，我们可以自定义消息转换器来发送复杂的消息。定义消息实体创建一个Message类：1234567891011121314151617181920212223242526public class Message implements Serializable &#123; private static final long serialVersionUID = 6678420965611108427L; private String from; private String message; public Message() &#123; &#125; public Message(String from, String message) &#123; this.from = from; this.message = message; &#125; @Override public String toString() &#123; return "Message&#123;" + "from='" + from + '\'' + ", message='" + message + '\'' + '&#125;'; &#125; // get set 略&#125;改造消息生产者配置1234567891011121314151617181920212223242526@Configurationpublic class KafkaProducerConfig &#123; @Value("$&#123;spring.kafka.bootstrap-servers&#125;") private String bootstrapServers; @Bean public ProducerFactory&lt;String, Message&gt; producerFactory() &#123; Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;(); configProps.put( ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); configProps.put( ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); configProps.put( ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); return new DefaultKafkaProducerFactory&lt;&gt;(configProps); &#125; @Bean public KafkaTemplate&lt;String, Message&gt; kafkaTemplate() &#123; return new KafkaTemplate&lt;&gt;(producerFactory()); &#125;&#125;我们将value序列化策略指定为了Kafka提供的JsonSerializer，并且kafkaTemplate返回类型为KafkaTemplate&lt;String, Message&gt;。发送新的消息在SendMessageController里发送复杂的消息:1234567@Autowiredprivate KafkaTemplate&lt;String, Message&gt; kafkaTemplate;@GetMapping("send/&#123;message&#125;")public void sendMessage(@PathVariable String message) &#123; this.kafkaTemplate.send("test", new Message("mrbird", message));&#125;修改消费者配置修改消费者配置KafkaConsumerConfig：123456789101112131415161718192021222324252627282930313233343536373839@EnableKafka@Configurationpublic class KafkaConsumerConfig &#123; @Value("$&#123;spring.kafka.bootstrap-servers&#125;") private String bootstrapServers; @Value("$&#123;spring.kafka.consumer.group-id&#125;") private String consumerGroupId; @Value("$&#123;spring.kafka.consumer.auto-offset-reset&#125;") private String autoOffsetReset; @Bean public ConsumerFactory&lt;String, Message&gt; consumerFactory() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put( ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put( ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId); props.put( ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, autoOffsetReset); return new DefaultKafkaConsumerFactory&lt;&gt;( props, new StringDeserializer(), new JsonDeserializer&lt;&gt;(Message.class)); &#125; @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, Message&gt; kafkaListenerContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;String, Message&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); return factory; &#125;&#125;修改消息监听修改KafkaMessageListener：1234@KafkaListener(topics = "test", groupId = "test-consumer")public void listen(Message message) &#123; logger.info("接收消息: &#123;&#125;", message);&#125;重启项目，访问http://localhost:8080/send/hello，控制台输出如下：更多配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394spring.kafka.admin.client-id= # ID to pass to the server when making requests. Used for server-side logging.spring.kafka.admin.fail-fast=false # Whether to fail fast if the broker is not available on startup.spring.kafka.admin.properties.*= # Additional admin-specific properties used to configure the client.spring.kafka.admin.ssl.key-password= # Password of the private key in the key store file.spring.kafka.admin.ssl.key-store-location= # Location of the key store file.spring.kafka.admin.ssl.key-store-password= # Store password for the key store file.spring.kafka.admin.ssl.key-store-type= # Type of the key store.spring.kafka.admin.ssl.protocol= # SSL protocol to use.spring.kafka.admin.ssl.trust-store-location= # Location of the trust store file.spring.kafka.admin.ssl.trust-store-password= # Store password for the trust store file.spring.kafka.admin.ssl.trust-store-type= # Type of the trust store.spring.kafka.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Applies to all components unless overridden.spring.kafka.client-id= # ID to pass to the server when making requests. Used for server-side logging.spring.kafka.consumer.auto-commit-interval= # Frequency with which the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' is set to true.spring.kafka.consumer.auto-offset-reset= # What to do when there is no initial offset in Kafka or if the current offset no longer exists on the server.spring.kafka.consumer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for consumers.spring.kafka.consumer.client-id= # ID to pass to the server when making requests. Used for server-side logging.spring.kafka.consumer.enable-auto-commit= # Whether the consumer's offset is periodically committed in the background.spring.kafka.consumer.fetch-max-wait= # Maximum amount of time the server blocks before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by "fetch-min-size".spring.kafka.consumer.fetch-min-size= # Minimum amount of data the server should return for a fetch request.spring.kafka.consumer.group-id= # Unique string that identifies the consumer group to which this consumer belongs.spring.kafka.consumer.heartbeat-interval= # Expected time between heartbeats to the consumer coordinator.spring.kafka.consumer.key-deserializer= # Deserializer class for keys.spring.kafka.consumer.max-poll-records= # Maximum number of records returned in a single call to poll().spring.kafka.consumer.properties.*= # Additional consumer-specific properties used to configure the client.spring.kafka.consumer.ssl.key-password= # Password of the private key in the key store file.spring.kafka.consumer.ssl.key-store-location= # Location of the key store file.spring.kafka.consumer.ssl.key-store-password= # Store password for the key store file.spring.kafka.consumer.ssl.key-store-type= # Type of the key store.spring.kafka.consumer.ssl.protocol= # SSL protocol to use.spring.kafka.consumer.ssl.trust-store-location= # Location of the trust store file.spring.kafka.consumer.ssl.trust-store-password= # Store password for the trust store file.spring.kafka.consumer.ssl.trust-store-type= # Type of the trust store.spring.kafka.consumer.value-deserializer= # Deserializer class for values.spring.kafka.jaas.control-flag=required # Control flag for login configuration.spring.kafka.jaas.enabled=false # Whether to enable JAAS configuration.spring.kafka.jaas.login-module=com.sun.security.auth.module.Krb5LoginModule # Login module.spring.kafka.jaas.options= # Additional JAAS options.spring.kafka.listener.ack-count= # Number of records between offset commits when ackMode is "COUNT" or "COUNT_TIME".spring.kafka.listener.ack-mode= # Listener AckMode. See the spring-kafka documentation.spring.kafka.listener.ack-time= # Time between offset commits when ackMode is "TIME" or "COUNT_TIME".spring.kafka.listener.client-id= # Prefix for the listener's consumer client.id property.spring.kafka.listener.concurrency= # Number of threads to run in the listener containers.spring.kafka.listener.idle-event-interval= # Time between publishing idle consumer events (no data received).spring.kafka.listener.log-container-config= # Whether to log the container configuration during initialization (INFO level).spring.kafka.listener.monitor-interval= # Time between checks for non-responsive consumers. If a duration suffix is not specified, seconds will be used.spring.kafka.listener.no-poll-threshold= # Multiplier applied to "pollTimeout" to determine if a consumer is non-responsive.spring.kafka.listener.poll-timeout= # Timeout to use when polling the consumer.spring.kafka.listener.type=single # Listener type.spring.kafka.producer.acks= # Number of acknowledgments the producer requires the leader to have received before considering a request complete.spring.kafka.producer.batch-size= # Default batch size.spring.kafka.producer.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for producers.spring.kafka.producer.buffer-memory= # Total memory size the producer can use to buffer records waiting to be sent to the server.spring.kafka.producer.client-id= # ID to pass to the server when making requests. Used for server-side logging.spring.kafka.producer.compression-type= # Compression type for all data generated by the producer.spring.kafka.producer.key-serializer= # Serializer class for keys.spring.kafka.producer.properties.*= # Additional producer-specific properties used to configure the client.spring.kafka.producer.retries= # When greater than zero, enables retrying of failed sends.spring.kafka.producer.ssl.key-password= # Password of the private key in the key store file.spring.kafka.producer.ssl.key-store-location= # Location of the key store file.spring.kafka.producer.ssl.key-store-password= # Store password for the key store file.spring.kafka.producer.ssl.key-store-type= # Type of the key store.spring.kafka.producer.ssl.protocol= # SSL protocol to use.spring.kafka.producer.ssl.trust-store-location= # Location of the trust store file.spring.kafka.producer.ssl.trust-store-password= # Store password for the trust store file.spring.kafka.producer.ssl.trust-store-type= # Type of the trust store.spring.kafka.producer.transaction-id-prefix= # When non empty, enables transaction support for producer.spring.kafka.producer.value-serializer= # Serializer class for values.spring.kafka.properties.*= # Additional properties, common to producers and consumers, used to configure the client.spring.kafka.ssl.key-password= # Password of the private key in the key store file.spring.kafka.ssl.key-store-location= # Location of the key store file.spring.kafka.ssl.key-store-password= # Store password for the key store file.spring.kafka.ssl.key-store-type= # Type of the key store.spring.kafka.ssl.protocol= # SSL protocol to use.spring.kafka.ssl.trust-store-location= # Location of the trust store file.spring.kafka.ssl.trust-store-password= # Store password for the trust store file.spring.kafka.ssl.trust-store-type= # Type of the trust store.spring.kafka.streams.application-id= # Kafka streams application.id property; default spring.application.name.spring.kafka.streams.auto-startup=true # Whether or not to auto-start the streams factory bean.spring.kafka.streams.bootstrap-servers= # Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for streams.spring.kafka.streams.cache-max-size-buffering= # Maximum memory size to be used for buffering across all threads.spring.kafka.streams.client-id= # ID to pass to the server when making requests. Used for server-side logging.spring.kafka.streams.properties.*= # Additional Kafka properties used to configure the streams.spring.kafka.streams.replication-factor= # The replication factor for change log topics and repartition topics created by the stream processing application.spring.kafka.streams.ssl.key-password= # Password of the private key in the key store file.spring.kafka.streams.ssl.key-store-location= # Location of the key store file.spring.kafka.streams.ssl.key-store-password= # Store password for the key store file.spring.kafka.streams.ssl.key-store-type= # Type of the key store.spring.kafka.streams.ssl.protocol= # SSL protocol to use.spring.kafka.streams.ssl.trust-store-location= # Location of the trust store file.spring.kafka.streams.ssl.trust-store-password= # Store password for the trust store file.spring.kafka.streams.ssl.trust-store-type= # Type of the trust store.spring.kafka.streams.state-dir= # Directory location for the state store.spring.kafka.template.default-topic= # Default topic to which messages are sent.源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/54.Spring-Boot-Kafka]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 WebFlux编程]]></title>
    <url>%2FSpring-Boot-2-0-WebFlux.html</url>
    <content type="text"><![CDATA[Spring MVC Web架构是基于阻塞式Servlet API构建的。Servlet 3.1后提供了非阻塞API，Spring 5.0后基于这些API构建了一套全新的非阻塞Web框架 —— WebFlux。Spring Boot 2.0基于Spring 5.0构建，所以要在Spring Boot中使用WebFlux架构，版本必须大于2.0。通过下面这张图了解下Spring MVC和Spring WebFlux的区别： https://www.cnblogs.com/javabg/p/7976977.html可以看到，Spring WebFlux是非阻塞式的，支持 Reactive Streams背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。其目前只支持非关系型数据库，如Mongo，Redis等。非阻塞式的编程模型可以提高程序的并发量，提升性能和吞吐量。异步Servlet既然WebFlux是基于异步Servelt API构建的，那么我们先来看看什么是异步Servlet。使用IDEA创建一个传统的Java Web应用（可以参考https://www.cnblogs.com/javabg/p/7976977.html），然后创建一个SyncServlet：12345678910111213141516171819202122232425262728@WebServlet(urlPatterns = "/sync")public class SyncServlet extends HttpServlet &#123; private static final long serialVersionUID = 7583536145022393360L; private Logger log = Logger.getLogger(SyncServlet.class.getName()); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) &#123; long start = System.currentTimeMillis(); this.execute(request, response); log.info("总耗时：" + (System.currentTimeMillis() - start) + "ms"); &#125; private void execute(HttpServletRequest request, HttpServletResponse response) &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; response.getWriter().append("hello"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;doGet方法中线程阻塞2秒，然后打印hello。部署项目到Tomcat，context-path为/servlet，启动后访问http://localhost:8080/servlet/sync:传统的Servlet API是阻塞的，log.info(&quot;总耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;)这行代码必须等待this.execute()执行完毕后才开始执行。接下来看看非阻塞Servlet API是怎么搞的。新建一个AsyncServlet：123456789101112131415161718192021222324252627282930313233@WebServlet(urlPatterns = "/async", asyncSupported = true)public class AsyncServlet extends HttpServlet &#123; private static final long serialVersionUID = 393375716683413545L; private Logger log = Logger.getLogger(AsyncServlet.class.getName()); @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) &#123; long start = System.currentTimeMillis(); AsyncContext asyncContext = request.startAsync(); CompletableFuture.runAsync(() -&gt; execute( asyncContext, asyncContext.getRequest(), asyncContext.getResponse()) ); log.info("总耗时：" + (System.currentTimeMillis() - start) + "ms"); &#125; private void execute(AsyncContext asyncContext, ServletRequest request, ServletResponse response) &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; response.getWriter().append("hello"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; asyncContext.complete(); &#125;&#125;在类上使用@WebServlet(asyncSupported = true)开启异步支持，通过AsyncContext asyncContext = request.startAsync();获取异步上下文AsyncContext，AsyncContext的complete方法用于标识异步调用结束。CompletableFuture为Java 8提供的Future接口实现类，可以方便的处理异步调用。启动项目，访问http://localhost:8080/servlet/async，响应耗时也在2秒左右，但是这个过程是异步的，查看控制台日志就可以证明这点：所以，异步调用适用于那些对方法返回值没有影响的操作，比如异步记录用户操作日志等。如果方法的返回值依赖于异步调用的结果，那么方法耗时在同步和异步上是没有区别的。Mono和Flux了解了异步Servlet后，我们回到WebFlux，新建一个SpringBoot程序，版本为2.1.3.RELEASE，并引入spring-boot-starter-webflux依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;Reactor 是Spring WebFlux所使用的响应式库，其提供了两个特殊的类Mono和Flux。Mono和Flux在发布订阅模式中都属于发布者（不清楚的可以参考Java 9 Flow API学习），查看源码会发现它们都实现了Publisher接口。Mono表示0 ~ 1个元素的数据发布者，Flux表示 0 ~ N个元素的数据发布者。我们可以通过一个例子来了解Mono和Flux，创建MonoFluxTest类：12345678910111213141516171819202122232425262728293031323334353637383940public class MonoFluxTest &#123; public static void main(String[] args) &#123; Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;Integer&gt;() &#123; private Subscription subscription; @Override public void onSubscribe(Subscription subscription) &#123; this.subscription = subscription; this.subscription.request(1); &#125; @Override public void onNext(Integer item) &#123; System.out.println("接受到数据: " + item); try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.subscription.request(1); &#125; @Override public void onError(Throwable throwable) &#123; throwable.printStackTrace(); this.subscription.cancel(); &#125; @Override public void onComplete() &#123; System.out.println("处理完了!"); &#125; &#125;; String[] strs = &#123;"1", "2", "3"&#125;; Flux.fromArray(strs).map(Integer::parseInt).subscribe(subscriber); Mono.fromSupplier(() -&gt; 1).map(s -&gt; s + 1).subscribe(subscriber); &#125;&#125;程序首先创建了一个订阅者（参考Java 9 Flow API学习），然后分别使用Flux.fromArray和Mono.fromSupplier构造了Flux类型发布者和Mono类型发布者，并和订阅者保持订阅关系。运行main方法，控制台输出：了解了Mono和Flux后，我们新建一个TestController：1234567891011121314151617181920212223242526272829@RestControllerpublic class TestController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @GetMapping("sync") public String sync() &#123; logger.info("sync method start"); String result = this.execute(); logger.info("sync method end"); return result; &#125; @GetMapping("async/mono") public Mono&lt;String&gt; asyncMono() &#123; logger.info("async method start"); Mono&lt;String&gt; result = Mono.fromSupplier(this::execute); logger.info("async method end"); return result; &#125; private String execute() &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return "hello"; &#125;&#125;execute方法返回一个值hello，所以可以使用Mono来处理返回值，使它成为一个异步方法。asyncMono方法返回Mono&lt;String&gt;类型，也就是一个String类型的数据发布者，我们不用去手动处理订阅关系，Spring会帮我们处理，我们直接返回即可。启动项目，可以看到WebFlux默认使用的是Netty服务器：分别访问http://localhost:8080/sync和http://localhost:8080/async/mono，控制台输出如下：可以看到asyncMono方法里的Mono&lt;String&gt; result = Mono.fromSupplier(this::execute)是异步非阻塞的，并且http://localhost:8080/async/mono返回的值为字符串hello。下面我们来看一个返回类型为Flux&lt;String&gt;类型的例子。Server Sent Events返回值类型为Flux的时候，它是一个数据流，不是一次性数据包，服务端会不断地（假如Flux数据长度大于1）往客户端发送数据。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。这种模式称为Server-Sent Events。在TestController新增一个asyncFlux方法：1234567891011121314@GetMapping(value = "async/flux", produces = MediaType.TEXT_EVENT_STREAM_VALUE)public Flux&lt;String&gt; asyncFlux() &#123; logger.info("async method start"); Flux&lt;String&gt; result = Flux.fromStream(IntStream.range(1, 5).mapToObj(i -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return "int value：" + i; &#125;)); logger.info("async method end"); return result;&#125;@GetMapping必须通过produces指定数据类型为text/event-stream，重启项目，访问http://localhost:8080/async/flux：前端可以通过H5的EventSource来接收。引入thymeleaf依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;然后在resources/templates下新建flux.html：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test sse&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt; var es = new EventSource("async/flux"); es.onmessage = function (evt) &#123; console.log(evt.data); if (evt.data === "int value：4") &#123; es.close(); &#125; &#125;;&lt;/script&gt;&lt;/html&gt;需要调用es.close()来关闭事件流，不然EventSource会在数据传输完毕会自动重连，这样就会不间断的调用localhost:8080/async/flux请求了。添加一个ViewController，用来访问flux.html：12345678@Controllerpublic class ViewController &#123; @GetMapping("flux") public String flux() &#123; return "flux"; &#125;&#125;重启项目，访问http://localhost:8080/flux，浏览器控制台输出如下所示:Mono,Flux常用方法通过上面的例子，我们简单了解了Mono和Flux的用法和区别，下面我们列举一些它们的常用方法。源头操作Flux可以通过Flux类的静态方法来生成：just()：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。fromArray()，fromIterable()和 fromStream()：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。empty()：创建一个不包含任何元素，只发布结束消息的序列。error(Throwable error)：创建一个只包含错误消息的序列。never()：创建一个不包含任何消息通知的序列。range(int start, int count)：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。interval(Duration period)和 interval(Duration delay, Duration period)：创建一个包含了从 0 开始递增的 Long 对象的序列。其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。举些例子：123456789public static void main(String[] args) throws InterruptedException &#123; Flux.just("Hello", "World").subscribe(System.out::println); Flux.fromArray(new Integer[] &#123;1, 2, 3&#125;).subscribe(System.out::println); Flux.empty().subscribe(System.out::println); Flux.range(1, 4).subscribe(System.out::println); Flux.interval(Duration.of(1, ChronoUnit.SECONDS)).subscribe(System.out::println); // 线程延迟关闭，不然最后一个例子木有输出 Thread.currentThread().join(10000);&#125;输出如下所示： 上面的这些静态方法适合于简单的Flux序列生成，当序列的生成需要复杂的逻辑时，则应该使用generate()或create()方法。generate()generate()方法通过同步和逐一的方式来产生 Flux 序列。序列的产生是通过调用所提供的 SynchronousSink 对象的 next()，complete()和 error(Throwable)方法来完成的：12345678910111213141516Flux.generate(sink -&gt; &#123; sink.next("Hello"); sink.complete();&#125;).subscribe(System.out::println);final Random random = new Random();Flux.generate(ArrayList::new, (list, sink) -&gt; &#123; int value = random.nextInt(100); list.add(value); sink.next(value); if (list.size() == 10) &#123; sink.complete(); &#125; return list;&#125;).subscribe(System.out::println);输出如下所示:如果不调用 complete()方法，所产生的是一个无限序列。create()create()方法与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素：123456Flux.create(sink -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; sink.next(i); &#125; sink.complete();&#125;).subscribe(System.out::println);MonoMono 的创建方式与之前介绍的 Flux 比较相似。Mono 类中也包含了一些与 Flux 类中相同的静态方法。这些方法包括 just()，empty()，error()和 never()等。除了这些方法之外，Mono 还有一些独有的静态方法：fromCallable()、fromCompletionStage()、fromFuture()、fromRunnable()和 fromSupplier()：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。delay(Duration duration)：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。ignoreElements(Publisher&lt;T&gt; source)：创建一个 Mono 序列，忽略作为源的 Publisher 中的所有元素，只产生结束消息。justOrEmpty(Optional&lt;? extends T&gt; data)和 justOrEmpty(T data)：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。举些例子:1234Mono.just("are").subscribe(System.out::println);Mono.empty().subscribe(System.out::println);Mono.fromSupplier(() -&gt; "you").subscribe(System.out::println);Mono.justOrEmpty(Optional.of("ok")).subscribe(System.out::println);输出:还可以通过 create()方法来使用 MonoSink 来创建 Mono：1Mono.create(sink -&gt; sink.success("Hello")).subscribe(System.out::println);中间操作filter对流中包含的元素进行过滤，只留下满足 Predicate 指定条件的元素：1Flux.range(1, 10).filter(i -&gt; i % 2 == 0).subscribe(System.out::println);输出前10偶数。taketake 系列操作符用来从当前流中提取元素。提取的方式可以有很多种。take(long n)：按照指定的数量来提取。takeLast(long n)：提取流中的最后 N 个元素。takeUntil(Predicate&lt;? super T&gt; predicate)：提取元素直到 Predicate 返回 true。4 takeWhile(Predicate&lt;? super T&gt; continuePredicate)： 当 Predicate 返回 true 时才进行提取。举些例子：1234Flux.range(1, 20).take(10).subscribe(System.out::println);Flux.range(1, 20).takeLast(10).subscribe(System.out::println);Flux.range(1, 20).takeWhile(i -&gt; i &lt; 10).subscribe(System.out::println);Flux.range(1, 20).takeUntil(i -&gt; i == 10).subscribe(System.out::println);reduce 和 reduceWithreduce 和 reduceWith 操作符对流中包含的所有元素进行累积操作，得到一个包含计算结果的 Mono 序列。累积操作是通过一个 BiFunction 来表示的。在操作时可以指定一个初始值。如果没有初始值，则序列的第一个元素作为初始值。比如：12Flux.range(1, 10).reduce((x, y) -&gt; x + y).subscribe(System.out::println);Flux.range(1, 10).reduceWith(() -&gt; 10, (x, y) -&gt; x + y).subscribe(System.out::println);第一行语句对流中的元素进行相加操作，结果为 55；第二行语句同样也是进行相加操作，不过通过一个 Supplier 给出了初始值为 10，所以结果为 65。mergemerge操作符用来把多个流合并成一个 Flux 序列：1234Flux.merge( Flux.interval(Duration.of(500, ChronoUnit.MILLIS)).take(2), Flux.interval(Duration.of(500, ChronoUnit.MILLIS)).take(2)).toStream().forEach(System.out::println);输出 0 0 1 1。buffer直接看例子吧：123Flux.range(1, 100).buffer(20).subscribe(System.out::println);Flux.range(1, 10).bufferUntil(i -&gt; i % 2 == 0).subscribe(System.out::println);Flux.range(1, 10).bufferWhile(i -&gt; i % 2 == 0).subscribe(System.out::println);输出如下所示：类似于数据流分区。zipWith将两个流的元素安装元素位置一一组合：123Flux.just("a", "b", "c", "d") .zipWith(Flux.just("e", "f", "g", "h", "i")) .subscribe(System.out::println);输出：没有配对上的被丢弃。另外一个例子：123Flux.just("a", "b", "c", "d") .zipWith(Flux.just("e", "f", "g", "h", "i"), (s1, s2) -&gt; String.format("%s-%s", s1, s2)) .subscribe(System.out::println);输出如下:flatMap把流中的每个元素转换成一个流，再把所有流中的元素进行合并。比如：123Flux.just(5, 10).flatMap( x -&gt; Flux.range(1, x).take(x) ).subscribe(System.out::println);终端处理通过subscribe()方法处理正常和错误消息：123Flux.just(1, 2) .concatWith(Mono.error(new IllegalStateException())) .subscribe(System.out::println, System.err::println);输出:12312java.lang.IllegalStateException出现错误时返回默认值：1234Flux.just(1, 2) .concatWith(Mono.error(new IllegalStateException())) .onErrorReturn(0) .subscribe(System.out::println);输出：123120出现错误时使用另外的流：12345678910Flux.just(1, 2) .concatWith(Mono.error(new IllegalArgumentException())) .onErrorResume(e -&gt; &#123; if (e instanceof IllegalStateException) &#123; return Mono.just(0); &#125; else if (e instanceof IllegalArgumentException) &#123; return Mono.just(-1); &#125; return Mono.empty(); &#125;).subscribe(System.out::println);输出如下:12312-1源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/57.Spring-Boot-WebFlux参考链接:https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webfluxhttps://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_eventshttp://www.ruanyifeng.com/blog/2017/05/server-sent_events.htmlhttps://projectreactor.io/docs/core/release/reference/#fluxhttps://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>WebFlux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Mongo DB]]></title>
    <url>%2FSpring-Boot-Mongo-DB-CRUD.html</url>
    <content type="text"><![CDATA[这节我们将整合Spring Boot与Mongo DB实现增删改查的功能，并且实现序列递增。Mongo DB下载地址：https://www.mongodb.com/download-center/community。Mongo DB的基本介绍和增删改查的用法可以参考我之前的文章： MongoDB shell 、 MongoDB文档CUD 和 MongoDB 文档查询 。新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入如下依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;然后可以通过Mongo Shell或者Mongo Compass工具创建一个名称为testdb的数据库，并新增user文档（文档，类似与关系型数据库里的数据表）：在配置文件application.yml里配置Mongo DB：123456spring: data: mongodb: host: localhost port: 27017 database: testdbMongo DB的默认端口为27017，使用的数据库为刚刚创建的testdb。创建User实体类：1234567891011121314@Document(collection = "user")public class User &#123; @Id private String id; private String name; private Integer age; private String description; // get set 略&#125;@Document(collection = &quot;user&quot;)表明这是一个文档对象，名称为user，对应Mongo DB里的user表。@Id标注主键字段，String类型的主键值在插入的时候Mongo DB会帮我们自动生成。如果对象中的某个属性为非表字段，可以使用注解@Transient进行排除。准备好这些后，我们开始编写一些简单的增删改查样例。简单增删改查创建一个UserDao接口：123@Repositorypublic interface UserDao extends MongoRepository&lt;User, String&gt; &#123;&#125;接口继承自MongoRepository，泛型分别为实体对象和主键类型。通过继承MongoRepository，UserDao包含了一些增删改查的方法，如下图所示：接着编写UserService，为了方便这里不再编写接口：12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; getUsers() &#123; return userDao.findAll(); &#125; public Optional&lt;User&gt; getUser(String id) &#123; return this.userDao.findById(id); &#125; /** * 新增和修改都是 save方法， * id 存在为修改，id 不存在为新增 */ public User createUser(User user) &#123; user.setId(null); return userDao.save(user); &#125; public void deleteUser(String id) &#123; this.userDao.findById(id) .ifPresent(user -&gt; this.userDao.delete(user)); &#125; public void updateUser(String id, User user) &#123; this.userDao.findById(id) .ifPresent( u -&gt; &#123; u.setName(user.getName()); u.setAge(user.getAge()); u.setDescription(user.getDescription()); this.userDao.save(u); &#125; ); &#125;&#125;上面我们编写了基本的增删改查样例，新增和修改都是通过save方法完成的，当主键存在时则为修改，主键不存在则为新增。最后编写一个RESTful的UserController（为了方便，没有对参数进行校验）：123456789101112131415161718192021222324252627282930313233343536@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping public List&lt;User&gt; getUsers() &#123; return userService.getUsers(); &#125; @PostMapping public User createUser(User user) &#123; return userService.createUser(user); &#125; @DeleteMapping("/&#123;id&#125;") public void deleteUser(@PathVariable String id) &#123; userService.deleteUser(id); &#125; @PutMapping("/&#123;id&#125;") public void updateUser(@PathVariable String id, User user) &#123; userService.updateUser(id, user); &#125; /** * 根据用户 id查找 * 存在返回，不存在返回 null */ @GetMapping("/&#123;id&#125;") public User getUser(@PathVariable String id) &#123; return userService.getUser(id).orElse(null); &#125;&#125;启动项目，使用postman来测试接口的可用性。测试新增用户：新增成功，查看数据库：测试查询用户：查询成功。测试通过用ID查找用户：更新用户：查看数据库是否更新成功：更新成功。最后测试通过用户ID删除用户：返回状态码200，删除成功。查看数据库，删除成功：多条件查询其实UserDao通过继承MongoRepository已经具有了JPA的特性，我们可以通过方法名来构建多查询条件的SQL。比如通过用户的年龄段来查询：123456789101112@Repositorypublic interface UserDao extends MongoRepository&lt;User, String&gt; &#123; /** * 根据年龄段来查找 * * @param from from * @param to to * @return List&lt;User&gt; */ List&lt;User&gt; findByAgeBetween(Integer from, Integer to);&#125;在输入findBy后，IDEA会根据实体对象的属性和SQL的各种关键字自动组合提示：比如再在创建一个通过年龄段，用户名和描述（模糊查询）查询用户的方法：12345678910/** * 通过年龄段，用户名，描述（模糊查询） * * @param from from * @param to to * @param name name * @param description description * @return List&lt;User&gt; */List&lt;User&gt; findByAgeBetweenAndNameEqualsAndDescriptionIsLike(Integer from, Integer to, String name, String description);方法参数个数需要和方法名中所需要的参数个数对应上。排序与分页排序和分页需要使用MongoTemplate对象来完成，在UserService里新增一个getUserByCondition方法：12345678910111213141516171819202122@Autowiredprivate MongoTemplate template;public Page&lt;User&gt; getUserByCondition(int size, int page, User user) &#123; Query query = new Query(); Criteria criteria = new Criteria(); if (!StringUtils.isEmpty(user.getName())) &#123; criteria.and("name").is(user.getName()); &#125; if (!StringUtils.isEmpty(user.getDescription())) &#123; criteria.and("description").regex(user.getDescription()); &#125; query.addCriteria(criteria); Sort sort = new Sort(Sort.Direction.DESC, "age"); Pageable pageable = PageRequest.of(page, size, sort); List&lt;User&gt; users = template.find(query.with(pageable), User.class); return PageableExecutionUtils.getPage(users, pageable, () -&gt; template.count(query, User.class));&#125;size表示每页显示的条数，page表示当前页码数，0表示第一页。上面的方法通过name和description（模糊查询）来查询用户分页信息，并且查询结果使用age字段降序排序。方法返回Page对象。在UserController里添加：1234@GetMapping("/condition")public Page&lt;User&gt; getUserByCondition(int size, int page, User user) &#123; return userService.getUserByCondition(size, page, user);&#125;重启项目，我们往数据库里多加几条数据：获取第1页数据，每页显示10条：返回数据：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; "content": [ &#123; "id": "5ca56ae2f08f0b6048fd470d", "name": "jane", "age": 26, "description": "web developer" &#125;, &#123; "id": "5ca56ad1f08f0b6048fd470c", "name": "scott", "age": 23, "description": "ui designer" &#125;, &#123; "id": "5ca56afaf08f0b6048fd470e", "name": "mike", "age": 21, "description": "python developer" &#125;, &#123; "id": "5ca56b38f08f0b6048fd470f", "name": "mrbird", "age": 18, "description": "java noob" &#125; ], "pageable": &#123; "sort": &#123; "sorted": true, "unsorted": false, "empty": false &#125;, "offset": 0, "pageSize": 10, "pageNumber": 0, "unpaged": false, "paged": true &#125;, "last": true, "totalPages": 1, "totalElements": 4, "number": 0, "size": 10, "sort": &#123; "sorted": true, "unsorted": false, "empty": false &#125;, "numberOfElements": 4, "first": true, "empty": false&#125;剩下可以自己测试。postman测试样例及源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/56.Spring-Boot-MongoDB-crud]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 9 Flow API 学习]]></title>
    <url>%2FJava-9-Flow-API-Learn.html</url>
    <content type="text"><![CDATA[响应式编程（Reactive Programming）可以理解为一种处理数据项（Data Item）的异步流，即在数据项产生的时候，接收者就对其进行响应。在响应式编程中，会有一个数据发布者（Publisher）和数据订阅者（Subscriber），后者用于异步接收发布者发布的数据。在该模式中，还引入了一个更高级的特性：数据处理器（Processor），它用于将数据发布者发布的数据进行某些转换操作，然后再发布给数据订阅者。总之，响应式编程是异步非阻塞编程，能够提升程序性能，可以解决传统编程模型遇到的困境。基于这个模型实现的有Java 9 Flow API、RxJava和Reactor等，这里主要介绍的是Java 9 Flow API的使用。Flow接口概览Java 9 新增了一个Flow接口，位于java.util.concurrent路径下，构成如下图所示：其中Publisher为数据发布者，Subscriber为数据订阅者，Subscription为发布者和订阅者之间的订阅关系，Processor为数据处理器。PublisherPublisher部分的源码如下所示:它是一个函数式接口，只包含一个subscribe方法，通过这个方法将数据发布出去。SubscriberSubscriber部分的源码如下所示: 该接口包含了四个方法：方法描述onSubscribe订阅成功的回调方法，用于初始化Subscription，并且表明可以开始接收订阅数据了onNext接收下一项订阅数据的回调方法onError在Publisher或Subcriber遇到不可恢复的错误时调用此方法，Subscriber不再接收订阅消息onComplete当接收完所有订阅数据，并且发布者已经关闭后会回调这个方法SubscriptionSubscription部分的源码如下所示：该接口包含了两个方法：方法描述request用于向数据发布者请求n个数据项cancel取消消息订阅，订阅者将不再接收数据ProcessorProcessor部分的代码如下所示：它是一个空接口，但是它继承了Publisher和Subscriber，所以它既能发布数据也能订阅数据。基于这个特性，它可以充当数据转换的角色，先从数据发布者那接收数据项，然后经过处理后再发布给最终的数据订阅者。发布订阅示例接下来我们举个数据发布和数据订阅的简单示例，以此了解Java 9 Flow API的使用。先入为主，直接贴出整个示例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class FlowApiTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 1. 定义 String 类型的数据发布者，JDK 9自带的 // SubmissionPublisher 实现了 Publisher SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;(); // 2. 创建一个订阅者，用于接收发布者的消息 Subscriber&lt;String&gt; subscriber = new Subscriber&lt;&gt;() &#123; private Subscription subscription; @Override public void onSubscribe(Subscription subscription) &#123; // 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈 this.subscription = subscription; // 请求一个数据 this.subscription.request(1); &#125; @Override public void onNext(String item) &#123; // 接收发布者发布的消息 System.out.println("【订阅者】接收消息 &lt;------ " + item); // 接收后再次请求一个数据 this.subscription.request(1); // 如果不想再接收数据，也可以直接调用 cancel，表示不再接收了 // this.subscription.cancel(); &#125; @Override public void onError(Throwable throwable) &#123; // 过程中出现异常会回调这个方法 System.out.println("【订阅者】数据接收出现异常，" + throwable); // 出现异常，取消订阅，告诉发布者我不再接收数据了 // 实际测试发现，只要订阅者接收消息出现异常，进入了这个回调 // 订阅者就不会再继续接收消息了 this.subscription.cancel(); &#125; @Override public void onComplete() &#123; // 当发布者发出的数据都被接收了， // 并且发布者关闭后，会回调这个方法 System.out.println("【订阅者】数据接收完毕"); &#125; &#125;; // 3. 发布者和订阅者需要建立关系 publisher.subscribe(subscriber); // 4. 发布者开始发布数据 for (int i = 0; i &lt; 10; i++) &#123; String message = "hello flow api " + i; System.out.println("【发布者】发布消息 ------&gt; " + message); publisher.submit(message); &#125; // 5. 发布结束后，关闭发布者 publisher.close(); // main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了 Thread.currentThread().join(2000); &#125;&#125;上面使用JDK 自带的Publisher实现类SubmissionPublisher来发布 String类型的数据，然后用匿名实现类的方式创建了一个Subscriber实现类。接着使用SubmissionPublisher的subscribe方法来为发布者和订阅者建立关系。建立关系后，发布者就可以发布数据，接收者也开始接收数据。详细的说明注释里都写了，这里就不再赘述代码的逻辑了。程序的输出如下所示：模拟背压所谓的背压（Backpressure）通俗的讲就是数据接收者的压力，传统模式下，发布者只关心数据的创造与发布，而当数据发布速率远高于数据接收速率的时候，数据接收者缓冲区将被填满，无法再接收数据。发布者并不关心这些，依旧不断地发送数据，所以就造成了IO阻塞。基于响应式模型实现的Flow API可以很好地解决这个问题。在Java 9的Flow API定义中，Subscriber会将Publisher发布的数据缓冲在Subscription中，其长度默认为256：假如当这个缓冲区都被填满后，Publisher将会停止发送数据，直到Subscriber接收了数据Subscription有空闲位置的时候，Publisher才会继续发布数据，而非一味地发个不停。下面用代码来演示这个情况：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class FlowApiTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 1. 定义String类型的数据发布者，JDK 9自带的 // SubmissionPublisher实现了 Publisher SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;(); // 2. 创建一个订阅者，用于接收发布者的消息 Subscriber&lt;String&gt; subscriber = new Subscriber&lt;&gt;() &#123; private Subscription subscription; @Override public void onSubscribe(Subscription subscription) &#123; // 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈 this.subscription = subscription; // 请求一个数据 this.subscription.request(1); &#125; @Override public void onNext(String item) &#123; // 接收发布者发布的消息 System.out.println("【订阅者】接收消息 &lt;------ " + item); // 模拟接收数据缓慢，让缓冲池填满 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 接收后再次请求一个数据，表示我已经处理完了，你可以再发数据过来了 this.subscription.request(1); // 如果不想再接收数据，也可以直接调用cancel，表示不再接收了 // this.subscription.cancel(); &#125; @Override public void onError(Throwable throwable) &#123; // 过程中出现异常会回调这个方法 System.out.println("【订阅者】数据接收出现异常，" + throwable); // 出现异常，取消订阅，告诉发布者我不再接收数据了 // 实际测试发现，只要订阅者接收消息出现异常，进入了这个回调 // 订阅者就不会再继续接收消息了 this.subscription.cancel(); &#125; @Override public void onComplete() &#123; // 当发布者发出的数据都被接收了， // 并且发布者关闭后，会回调这个方法 System.out.println("【订阅者】数据接收完毕"); &#125; &#125;; // 3. 发布者和订阅者需要建立关系 publisher.subscribe(subscriber); // 4. 发布者开始发布数据 for (int i = 0; i &lt; 500; i++) &#123; String message = "hello flow api " + i; System.out.println("【发布者】发布消息 ------&gt; " + message); publisher.submit(message); &#125; // 5. 发布结束后，关闭发布者 publisher.close(); // main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了 Thread.currentThread().join(20000); &#125;&#125;上面代码中，我们在Subscriber的onNext方法中用下面的代码模拟延迟，让数据处理过程维持在2秒左右：12345try &#123; TimeUnit.SECONDS.sleep(2);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;然后数据发布量调整到了500，当程序启动的时候，由于数据发布的速度非常快（普通for循环），所以数据订阅者的数据缓冲区瞬间被填满，于是你会看到下面这个情况，只有当数据订阅者处理了一个数据的时候，数据发布者才会相应地再次发布一个新数据：Processor示例Processor的使用也很简单，其实它就是Publisher和Subscriber的结合体，充当数据处理的角色，通常的做法是用它来接收发布者发布的消息，然后进行相应的处理，再将数据发布出去，供消息订阅者接收。下面是一个Processor用法的简单示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class FlowApiTest2 &#123; static class MyProcessor extends SubmissionPublisher&lt;String&gt; implements Processor&lt;String, String&gt; &#123; private Subscription subscription; @Override public void onSubscribe(Subscription subscription) &#123; // 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈 this.subscription = subscription; // 请求一个数据 this.subscription.request(1); &#125; @Override public void onNext(String item) &#123; // 接收发布者发布的消息 System.out.println("【处理器】接收消息 &lt;------ " + item); // 处理器将消息进行转换 String newItem = "【处理器加工后的数据: " + item + "】"; this.submit(newItem); // 接收后再次请求一个数据，表示我已经处理完了，你可以再发数据过来了 this.subscription.request(1); // 如果不想再接收数据，也可以直接调用cancel，表示不再接收了 // this.subscription.cancel(); &#125; @Override public void onError(Throwable throwable) &#123; // 过程中出现异常会回调这个方法 System.out.println("【处理器】数据接收出现异常，" + throwable); // 出现异常，取消订阅，告诉发布者我不再接收数据了 this.subscription.cancel(); &#125; @Override public void onComplete() &#123; System.out.println("【处理器】数据处理完毕"); // 处理器处理完数据后关闭 this.close(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 1. 定义String类型的数据发布者，JDK 9自带的 // SubmissionPublisher实现了 Publisher SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;(); // 2. 创建处理器，用于接收发布者发布的消息， // 转换后再发送给订阅者 MyProcessor processor = new MyProcessor(); // 3. 发布者和处理器建立订阅的关系 publisher.subscribe(processor); // 4.创建一个订阅者，用于接收处理器的消息 Subscriber&lt;String&gt; subscriber = new Subscriber&lt;&gt;() &#123; private Subscription subscription; @Override public void onSubscribe(Subscription subscription) &#123; this.subscription = subscription; this.subscription.request(1); &#125; @Override public void onNext(String item) &#123; System.out.println("【订阅者】接收消息 &lt;------ " + item + ""); this.subscription.request(1); &#125; @Override public void onError(Throwable throwable) &#123; System.out.println("【订阅者】数据接收出现异常，" + throwable); this.subscription.cancel(); &#125; @Override public void onComplete() &#123; System.out.println("【订阅者】数据接收完毕"); &#125; &#125;; // 5. 处理器和订阅者建立订阅关系 processor.subscribe(subscriber); // 6. 发布者开始发布数据 for (int i = 0; i &lt; 10; i++) &#123; String message = "hello flow api " + i; System.out.println("【发布者】发布消息 ------&gt; " + message); publisher.submit(message); &#125; // 7. 发布结束后，关闭发布者 publisher.close(); // main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了 Thread.currentThread().join(2000); &#125;&#125;程序运行结果如下所示：参考文档：https://community.oracle.com/docs/DOC-1006738]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 9</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 10 新特性之var]]></title>
    <url>%2FJava10-new-feature-var.html</url>
    <content type="text"><![CDATA[今年3月，Java 10 如期发布，Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性，其中最备受关注的莫过于局部变量的类型推断。所以这里主要记录一下这个特性的用法。看几个Java 10之前声明变量的例子:12345List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list.stream();InputStreamReader reader = new InputStreamReader(System.in);HttpClient httpClient = HttpClient.newHttpClient();在Java 10 中，只要是编译器能够通过对象类型来确定变量类型的情况下，变量类型声明可以使用var保留字代替：12345var list = new ArrayList&lt;&gt;();var stream = list.stream();var reader = new InputStreamReader(System.in);var httpClient = HttpClient.newHttpClient();引入这个特性使得我们的Java 代码变得更加的简洁易读。除此之外我们也可以在增强for循环中使用var：12345var list = new ArrayList&lt;&gt;();list.add("hello");list.add("java 10");for (var s : list) System.out.println(s);当然，var并不是在何时何地都能使用，用于变量声明时，仅局限于具有构造器的变量或基本数据类型，比如下面这些例子编译是不通过的：1234var a;a = "hello world";var b = &#123;1, 2, 3&#125;;编译器将会告警：]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 9 新特性学习]]></title>
    <url>%2FJava-9-Feature.html</url>
    <content type="text"><![CDATA[在Java 8 发布3年多后，Java 9 终于在2017年9月21日正式发布。Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、 可交互的REPL工具jShell、JDK编译工具、Java公共API和私有代码，以及安全增强、扩展提升和性能管理改善等。在学习这些新特性之前，我们得先安装好JDK 9，JDK 9 下载地址：https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html。模块化Java 9 中的模块化（Module）类似于ES6中的模块化，都是为了解决项目中减少内存的开销，提供可维护性和系统性能而提出的。通俗地说，Java 9 的模块化本质上就是在包（package）上再包裹一层（Module），默认模块里的内容都是隐藏的，只能通过（exports）关键字来暴露模块里的内容，而别的模块需要用到这些内容则需要使用（requires）关键字来导入。下面我们用代码来演示这一个新特性。新建一个Java 工程，然后在工程下面创建一个名为ModuleOne的模块：同样的，我们再创建一个ModuleTwo模块，创建完后项目目录如下所示：接着我们在ModuleOne的src目录下创建cc.mrbird.domain包，并创建一个名为Person的类：1234567891011121314151617181920212223242526272829303132333435package cc.mrbird.domain;public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;然后在ModuleTwo的src目录下创建一个cc.mrbid.test包，并且创建一个Test类，用于待会测试。至此，工程目录结构如下所示:我们在ModuleTwo的Test类下试图引入ModuleOne的Person类，会发现是行不通的：正如上面所说，模块里的东西默认都是隐藏的，要让其可以被别的模块使用，需要通过exports关键字来暴露它们。在ModuleOne模块下的src上右键，新建一个module-info.java：代码如下所示:1234module ModuleOne &#123; // 导出包 exports cc.mrbird.domain;&#125;上面代码中导出了cc.mrbird.domain包下的所有内容，对别的模块来说，它们是可见的了。然后同样地在ModuleTwo模块下的src上右键，也新建一个module-info.java，代码如下所示:1234module ModuleTwo &#123; // 导入模块 requires ModuleOne;&#125;这里我们主要做的是将ModuleOne导入进来，所以其暴露的cc.mrbird.domain包下的内容就可以在ModuleTwo下被使用了。这时候回到ModuleTwo模块下的Test类，IDEA会自动帮我们导入需要的类，代码就不会报错了：我们继续在Test类中加入一些内容：上面我们使用了java.util.logging.Logger来打印日志，但是代码编译是不通过的，使用Alt+Enter快捷键后选择第一项，IDEA会自动帮我们在module-info.java文件中导入需要的包，非常方便。导入后，module-info.java下的代码如下所示：12345module ModuleTwo &#123; // 导入模块 requires ModuleOne; requires java.logging;&#125;总的来说，通过模块化来构建项目可以带来以下好处:减少内存的开销；简化各种类库和大型应用的开发和维护；改进其安全性，可维护性，提高性能。jshell命令在Java 9 之前，我们要想使用Java来输出一句hello world或者计算两个数的和都必须创建一个Java项目，然后创建类在里面写main方法来运行。Java 9 后就不必这样了，其提供了REPL工具：jshell。利用 jshell 在没有创建类的情况下直接声明变量，计算表达式，执行语句。即开发时可以在命令行里直接运行 Java 的代码，而无需创建 Java 文件。在JDK 9 的bin目录下有个jshell.exe文件，我们运行它：下面演示一些jshell的常用操作。基本使用在jshell中，代码末尾的;是可选的。导包操作查看所有已经导入的包使用Tab键补全代码查看当前环境下所有有效代码查看当前环境下所有变量查看当前环境下所有方法使用外部代码编辑器来修改add方法界面弹出：修改完毕点击Accept和Exit按钮即可：加载外部代码在桌面新建一个Hello.java文件：1234public void hello() &#123; System.out.println("hello world");&#125;hello();然后使用/open命令执行这个文件：更多关于jshell的功能介绍，可以使用/help命令来查看。接口中的私有方法我们都知道，在JDK 8之前，接口只能包含public static final的成员变量和public abstract修饰的抽象方法；而在JDK 8中，接口中可以定义静态方法和默认方法了；JDK 9的接口又加了新的特性，其允许接口中包含私有的方法，下面这个接口定义在JDK 9 中是合法的：123456789101112131415161718public interface TestInterface &#123; // before jdk 7 : void method1(); // jdk 8: static void method2() &#123; System.out.println("mehtod2"); &#125; default void method3() &#123; System.out.println("mehtod3"); &#125; // jdk 9: private void method4() &#123; System.out.println("mehtod4"); &#125;&#125;Diamond Operator使用升级在Java 9 之前的版本中，我们不能将钻石操作符（Diamond Operator）和匿名实现类放在一起使用，比如下面这个例子在Java 9 之前的版本中编译是不通过的：而在Java 9中取消了这个限制，我们可以通过这个特性来进行一些初始化操作:try使用升级在Java 9 之前，我们可以使用下面这种优雅的方式来进行流的关闭操作：12345try (InputStreamReader reader = new InputStreamReader(System.in)) &#123; reader.read();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;在try后面的括号中声明初始化的流Java会自动帮我们进行关闭操作。Java 9 对这个特性进行了升级，我们可以在try后面的括号中使用已经初始化过的资源，此时的资源是final的：123456InputStreamReader reader = new InputStreamReader(System.in);try (reader) &#123; reader.read();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;如果对reader再次进行赋值操作，编译将不通过：下划线标识符的限制Java 8 中，我们可以使用下划线_作为标识符使用，比如下面这段代码是合法的：12String _ = "mrbird";System.out.println(_);而在Java 9 中，下划线_已经不能用于标识符了：String存储结构变更Java 9 之前，字符串的底层是用char[]进行存储的，Java 9 中，字符串改用成了byte[]进行存储:之所以做出这个改变是因为：大多数String类型对象存储的都是拉丁字符，这些字符只占一个字节，而char能够存储两个字节，所以大部分情况下都浪费了一半的存储空间。Java 9 将String类的内部表示从UTF-16的char数组更改为byte数组加上encoding-flag字段。新String类将根据字符串的内容存储编码为ISO-8859-1 / Latin-1（每个字符一个字节）或UTF-16（每个字符两个字节）的字符。encoding-flag编码标志将指示使用哪种编码。基于String的类如StringBuffer和StringBuilder等也是做出了相同的改变。具体可参考：http://openjdk.java.net/jeps/254。集合的of方法Java 9 之前我们可以使用下面的方式来创建不可变集合：12345678List&lt;Integer&gt; list = Collections.unmodifiableList(Arrays.asList(1, 2, 3));Set&lt;Integer&gt; set = Collections.unmodifiableSet(new HashSet&lt;&gt;(Arrays.asList(1, 2, 3)));Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("mrbird", 18);map.put("kangkang", 20);Map&lt;String, Object&gt; map1 = Collections.unmodifiableMap(map);Java 9 中的集合类都添加了一个of方法，可以快速的构造不可变集合：123List&lt;Integer&gt; list = List.of(1, 2, 3);Set&lt;Integer&gt; set = Set.of(1, 2, 3);Map&lt;String, Object&gt; map1 = Map.of("mrbird", 18, "kangkang", 20);对不可变集合进行赋值操作将抛出异常：增强的Steam API在 Java 9 中，Stream API变得更好，Stream接口中添加了 4 个新的方法：dropWhile, takeWhile, ofNullable，还有个 iterate方法的新重载方法，可以让你提供一个Predicate（判断条件）来指定什么时候结束迭代。下面举例来演示这几个的用法：takeWhiletakeWhile用于从Stream中获取一部分数据，接收一个Predicate来进行选择。在有序的Stream中，takeWhile返回从开头开始的尽量多的元素。12List&lt;Integer&gt; list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88);list.stream().takeWhile(x -&gt; x &lt; 50).forEach(System.out::println);结果输出:程序从头开始判断当前值是否小于50，当判断到第三个元素76时，发现不满足，于是程序就结束了。所以takeWhile不同于过滤器。dropWhiledropWhile的行为与takeWhile相反，返回剩余的元素：12List&lt;Integer&gt; list = Arrays.asList(45, 43, 76, 87, 42, 77, 90, 73, 67, 88);list.stream().dropWhile(x -&gt; x &lt; 50).forEach(System.out::println);程序输出:ofNullableJava 8 中Stream不能完全为null（只有一个元素，且为null），否则会报空指针异常。而Java 9 中的ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream：1234567891011121314151617181920// 报 NullPointerException// Stream&lt;Object&gt; stream1 = Stream.of(null);// System.out.println(stream1.count());// 不报异常，允许通过Stream&lt;String&gt; stringStream = Stream.of("AA", "BB", null);System.out.println(stringStream.count()); // 3// 不报异常，允许通过List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("AA");list.add(null);System.out.println(list.stream().count()); // 2// ofNullable()：允许值完全为 nullStream&lt;Object&gt; stream1 = Stream.ofNullable(null);System.out.println(stream1.count()); // 0Stream&lt;String&gt; stream = Stream.ofNullable("hello world");System.out.println(stream.count()); // 1Steam iterator的重载方法1234// Java 8 中的Stream.iterate(0, x -&gt; x + 1).limit(10).forEach(System.out::println);// 等价于 Java 9 中的Stream.iterate(0, x -&gt; x &lt; 10, x -&gt; x + 1).forEach(System.out::println);除了上面几个新特性外，Java 9 还支持将optional转换为流的操作：1234567891011121314List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("mrbird");list.add("kangkang");list.add("maria");Optional&lt;List&lt;String&gt;&gt; optional = Optional.of(list);// 流中的元素为 listStream&lt;List&lt;String&gt;&gt; stream = optional.stream();stream.forEach(System.out::println);// 流中的元素为 list中的每个元素Stream&lt;String&gt; stringStream = optional.stream().flatMap(Collection::stream);stringStream.forEach(System.out::println);程序输出：HTTP ClientJava 9 中新增了全新的HttpClient来替代HttpURLConnection，其可以从jdk.incubator.httpclient模块中获取。因为在默认情况下，这个模块是不能根据classpath获取的，需要使用add modules命令选项配置这个模块，将这个模块添加到 classpath中。我们在src下的module-info.java中引入这个模块：1requires jdk.incubator.httpclient;写个基于HttpClient的例子:12345678HttpClient client = HttpClient.newHttpClient();HttpRequest req = HttpRequest.newBuilder(URI.create("https://mrbird.cc")) .GET() .build();HttpResponse&lt;String&gt; response = client.send(req, HttpResponse.BodyHandler.asString());System.out.println(response.statusCode());System.out.println(response.version().name());System.out.println(response.body());输出结果：参考自：https://www.jianshu.com/u/5f70a16b98e7]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 9</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose]]></title>
    <url>%2FDocker-Compose.html</url>
    <content type="text"><![CDATA[部署一个应用可能需要用到多个Docker容器，比如MySQL，Redis，Nginx等，单独的去管理每个容器可能会比较麻烦。Docker Compose可以通过一个yml文件来统一管理这些容器，可以极大简化我们的应用部署过程。这里以部署WordPress为例，介绍如何使用Docker Compose去统一管理多个Docker容器。先来看看不用Docker Compose时部署WordPress的步骤。Docker部署WordPress安装MySQLDocker拉取MySQL镜像：1docker pull mysql:5.7.25创建MySQL容器:1docker run -d --name mysql -v mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=wordpress -p 3306:3306 mysql:5.7.25安装WordPressDocker拉取WordPress镜像：1docker pull wordpress创建WordPress容器：1docker run -d -p 8080:80 --link mysql -e WORDPRESS_DB_HOST=mysql:3306 -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=123456 -e WORDPRESS_DB_NAME=wordpress wordpress查看是否成功：Docker Compose部署WordPress接下来看一下如何使用Docker Compose部署WordPress。在此之前，我们需要先删除上面创建的两个容器，然后安装Docker Compose，安装教程：https://docs.docker.com/compose/install/。查看是否安装成功：编写一个docker-compose.yml：1vim docker-compose.yml内容如下：123456789101112131415161718192021222324252627282930313233version: '3'services: wordpress: image: wordpress ports: - 8080:80 environment: WORDPRESS_DB_HOST: mysql:3306 WORDPRESS_DB_NAME: wordpress WORDPRESS_DB_USER: root WORDPRESS_DB_PASSWORD: 123456 networks: - my-bridge mysql: image: mysql:5.7.25 ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-bridgevolumes: mysql-data:networks: my-bridge: driver: bridge然后执行命令docker-compose up -d运行：查看WordPress是否部署成功：docker-compose.yml上面例子中我们通过一个docker-compose.yml文件，运行docker-compose up命令一次性创建了两个容器：docker-compose.yml一般包含三个部分:services、networks和volumes。services一个service代表一个container，可以从Docker Hub的image创建，也可以通过本地的dockerfile创建的image来创建。service类似于docker run，docker run支持的选项 service也可以用。举两个例子:基于镜像：1234567services: db: image: mysql:5.7.25 volumes: - mysql-data:/var/lib/mysql networks: - my-bridge类似于命令：1docker run -d --network my-bridge -v mysql-data:/var/lib/mysql mysql:5.7.25基于dockerfile：12345678services: worker: build: ./worker links: - db - redis networks: - my-bridge基于当前目录下worker/文件夹里的dockerfile构建container。networks一个networks的例子：123networks: my-bridge: driver: bridge等价于：1docker network create -d bridge my-bridgevolumes一个volumes的例子：12volumes: mysql-data:等价于1docker volume create mysql-data现在回头看看刚刚的yml文件:version: 3表示基于第三版本docker-compose.yml语法构建，然后创建了两个容器wordpress和mysql，一个volume——mysql-data，一个network，名称为my-bridge，采用bridge网络模式。在wordpress的定义中，使用image指定了基于wordpress镜像构建，ports进行端口映射，environment配置了wordpress镜像支持的环境变量，指定网络为my-bridge。mysql的定义和wordpress类似，不再赘述。更多docker-compose.yml支持的命令可以参考：https://www.jianshu.com/p/2217cfed29d7。docker-compose命令看看docker-compose支持哪些命令：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[root@mrbird vagrant]# docker-composeDefine and run multi-container applications with Docker.Usage: docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...] docker-compose -h|--helpOptions: -f, --file FILE Specify an alternate compose file (default: docker-compose.yml) -p, --project-name NAME Specify an alternate project name (default: directory name) --verbose Show more output --log-level LEVEL Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) --no-ansi Do not print ANSI control characters -v, --version Print version and exit -H, --host HOST Daemon socket to connect to --tls Use TLS; implied by --tlsverify --tlscacert CA_PATH Trust certs signed only by this CA --tlscert CLIENT_CERT_PATH Path to TLS certificate file --tlskey TLS_KEY_PATH Path to TLS key file --tlsverify Use TLS and verify the remote --skip-hostname-check Don't check the daemon's hostname against the name specified in the client certificate --project-directory PATH Specify an alternate working directory (default: the path of the Compose file) --compatibility If set, Compose will attempt to convert keys in v3 files to their non-Swarm equivalentCommands: build Build or rebuild services bundle Generate a Docker bundle from the Compose file config Validate and view the Compose file create Create services down Stop and remove containers, networks, images, and volumes events Receive real time events from containers exec Execute a command in a running container help Get help on a command images List images kill Kill containers logs View output from containers pause Pause services port Print the public port for a port binding ps List containers pull Pull service images push Push service images restart Restart services rm Remove stopped containers run Run a one-off command scale Set number of containers for a service start Start services stop Stop services top Display the running processes unpause Unpause services up Create and start containers version Show the Docker-Compose version information查看运行中的容器：1docker-compose ps停止：1docker-compose stop启动：1docker-compose start停止并删除（删除创建的network，volume，container）：1docker-compose down参考🔗：https://docs.docker.com/compose/compose-file/]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker存储]]></title>
    <url>%2FDocker-Volume.html</url>
    <content type="text"><![CDATA[Docker容器在运行的时候会产生数据，为了不让这些数据随着容器的删除而删除，Docker支持数据持久化。Docker数据持久化主要有两种方式：volume和bind mount。使用volume数据将持久化在Docker管理的volume中（保存在/var/lib/docker/volumes目录下），使用bind mount，数据将持久化在我们指定的宿主机的某个目录中。和数据持久化相关的Docker命令：1234567891011121314root@mrbird vagrant]# docker volume --helpUsage: docker volume COMMANDManage volumesCommands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumesRun 'docker volume COMMAND --help' for more information on a command.volume以MySQL为例子，查看5.7.25版本的 MySQL Dockerfile，会看到末尾处有这么一行：1VOLUME /var/lib/mysql意思是在Docker创建MySQL容器时，Docker会自动创建一个volume，MySQL容器中/var/lib/mysql目录下的内容将同步到这个volume中。我们来创建一个MySQL容器：1docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.25然后查看是否创建了volume：volume默认的名称好长哦，我们可以在创建容器的时候指定volume的名称，我们删掉MySQL这个容器，重新创建个，并指定volume的名称为mysql：1docker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v mysql:/var/lib/mysql mysql:5.7.25-v mysql:/var/lib/mysql的意思是使用名称为mysql的volume（没有则创建），存储容器/var/lib/mysql目录下的内容（和MySQL Dockerfile中使用VOLUME指定的目录一致）。查看volume：可以看到多了个名称为mysql的volume。接下来我们做个实验：进入到MySQL容器中，创建一个名称为docker的数据库：退出容器并删除该容器，然后创建一个新的MySQL容器，volume指定为mysql：可以看到docker这个数据库还在，说明数据恢复了。bind mountbind mount例子：1docker run -v /home/aaa:/root/aaa宿主机的/home/aaa将和容器中的/root/aaa同步，宿主机/home/aaa目录下文件做了修改，容器中/root/aaa目录下文件也会被修改，反之亦然。以Nginx为例，拉取Nginx stable镜像：1docker pull nginx:1.14.2创建Nginx容器:1docker run -d --name nginx -p 80:80 -v $(pwd):/usr/share/nginx/html nginx:1.14.2通过$(pwd):/usr/share/nginx/html我们将宿主机的当前目录和Nginx容器内部的/usr/share/nginx/html目录进行了同步。我们在宿主机当前目录下新建一个hello.html：然后进入到Nginx容器内的/usr/share/nginx/html目录：同步是ok的，在宿主机外访问 http://192.168.33.10/hello.html 看看（我的宿主机IP为192.168.33.10）：参考🔗：https://docs.docker.com/storage/volumes/]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker网络配置]]></title>
    <url>%2FDocker-network.html</url>
    <content type="text"><![CDATA[在安装好Docker后，其默认提供了三种网络模式：bridge、host和none。其中bridge是Docker默认的网络模式，在该模式下，容器拥有自己的IP namespace，容器可以通过宿主机上的docker0网桥与别的容器、宿主机或者外部网络进行通信。此外我们还可以通过端口映射的方式让外部环境也能访问到容器内部。Docker默认的网络模式如下图所示：bridge网络模式Docker三种网络模式：下面我们通过busybox来进行演示。BusyBox 是一个集成了一百多个最常用 Linux 命令和工具（如 cat、echo、grep、mount、telnet 、ping、ifconfig 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。下载busybox镜像:通过该镜像创建两个容器test1和test2：使用docker network inspect bridge命令查看bridge网络详情：可以看到test1和test2都连接到了bridge（因为是Docker默认的网络模式），并且test1内部IP为172.17.0.2，test2内部IP为172.17.0.3。我们看下在test1容器内部是否可以ping通test2的IP：可以看到是没问题的。看下test1内部ping宿主机IP（192.168.33.10）和外部网络是否可行：link我们可以在创建容器的使用使用--link来让容器间的网络建立映射关系。我们删除test2容器，重新创建test2容器，并且让其和test1建立网络映射关系：这样我们就可以在test2容器内部使用ping test1ping通test1网络了：创建自定义网桥我们可以通过docker network create来创建自定义的网桥，比如我们创建一个新的网桥，名称为my-bridge：模式选择的是bridge。我们让test1和test2容器都连接到这个新的网桥上（也可以在创建容器的时候使用--network来指定需要连接的网桥）：查看my-bridge详情：可以看到test1和test2都连接上来了。使用自定义网桥有个明显的好处是，容器间可以通过容器名称进行网络通信（无需在创建容器的时候使用--link来指定）。我们在创建test1容器的时候并没有使用--link test2来连接test2，我们看看在连接到my-bridge后，test1内部是否可以通过ping test2ping通test2 IP：可以看到是没问题的。端口映射在宿主机上我们是无法访问Docker容器内部网络的，不过我们可以通过端口映射的方式来实现这个需求。以MySQL为例子，我们拉取MySQL镜像：1docker pull mysql:5.7.25在创建MySQL容器的时候可以使用-p或-P让容器暴露的端口和宿主机的端口进行映射：-e指定环境变量。-p 3306:3306（冒号前面的端口为宿主机端口，后面的端口为容器端口）的意思是，让容器暴露的3306端口映射到宿主机的3306端口，这样我们就可以在宿主机外部通过192.168.33.10:3306来连接MySQL容器了：Docker的host和none网络模式使用较少这里就不介绍了。参考🔗：https://docs.docker.com/v17.09/engine/userguide/networking/#set-the-environment-variables-manually]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Dockerfile]]></title>
    <url>%2FDockerfile.html</url>
    <content type="text"><![CDATA[在 Docker 镜像与容器 一节中我们通过Dockerfile构建了镜像，这节我们来了解下Dockerfile的语法。Dockerfile包含了诸多关键字，所以要学习Dockerfile的用法，得先从这些关键字入手。FROM位于Dockerfile开头，表示基于什么镜像构建：12FROM scratch # 制作base imageFROM ubuntu:16.04 #使用ubuntu:16.04这个image出于安全考虑，最好使用官方的image作为base image。LABELDockerfile的元数据，描述作用。1LABEL version=&quot;1.0&quot; author=&quot;mrbird&quot; description=&quot;dockerfile demo&quot;Dockerfile最好都要有元数据，这样更易于理解。RUN运行命令，每次run都会生成一个图层，所以最好将命令合并:123FROM ubuntuRUN apt-get update \ &amp;&amp; apt-get install -y vim\换行WORKDIR用于指定工作目录，切换路径：1234FROM ubuntuWORKDIR /test # 没有则自动创建test目录WORKDIR demoRUN pwd输出 /test/demo。最好不要用RUN cd来切换目录，而使用WORKDIR，这样可以减少不必要的图层，尽量使用绝对目录。ADD &amp; COPYADD 和COPY都可以将构建环境中的文件或目录复制到镜像中，比如12WORKDIR /demoADD test test/12WORKDIR /demoCOPY test test/最终都会将test文件添加到/demo/test/目录下。区别：ADD 添加的文件是压缩文件的话，会自动解压。COPY 只能复制构建目录下的文件，ADD可以添加一个构建上下文中的文件或目录，也可以是一个URL，如：1ADD http://wordpress.org/latest.zip /ENV设置环境变量常量。12ENV MYSQL_VERSION 5.7RUN apt-get install -y mysql-server=&quot;$&#123;MYSQL_VERSION&#125;&quot;通过设定常量，可以提高可维护性。VOLUME &amp; EXPOSE存储和网络，这里先略，后面学习到这一块再说。CMD设置容器启动后默认执行的命令和参数。docker run指定了其他命令，CMD命令会被忽略。定义了多个CMD，只有最后一个有效。比如有如下Dockerfile：1234FROM ubuntuENV name mrbirdCMD echo &quot;hello docker&quot;CMD echo &quot;hello $name&quot;构建镜像，运行：1docker run [image]输出 hello mrbird。如果运行：1docker run -it [image] /bin/bash则没有输出。ENTRYPOINT设置容器启动时运行的命令。不会被忽略，一定会执行。一般写一个shell脚本作为ENTRYPOINT。比如mongodb官方Dockerfile末尾一段：12345COPY docker-entrypoint.sh /usr/local/bin/ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 27017CMD [&quot;mongod&quot;]ENTRYPOINT和CMD结合使用有一个技巧：比如有如下一个Dockerfile：123FROM ubuntuENTRYPOINT [&quot;/bin/ls&quot;]CMD []意思是在ubuntu这个镜像上构建，通过ENTRYPOINT运行/bin/ls命令，然后CMD []这行可以介绍额外的参数选项。通过这个Dockerfile构建镜像后(image id为95c35bb00761)，分别运行下面这些命令来创建容器：可以看到我们通过相同的镜像构建出了不同的容器。Shell和Exec格式在Dockerfile中，命令的写法有Shell格式和Exec格式：Shell格式的Dockerfile如下：123RUN apt-get install -y vimCMD echo &quot;hello world&quot;ENTRYPOINTT echo &quot;hello world&quot;Exec格式如下所示:123RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]CMD [&quot;/bin/echo&quot;,&quot;hello world&quot;]ENTRYPOINTT [&quot;/bin/echo&quot;,&quot;hello world&quot;]在使用Exec格式的时候需要注意和常量的搭配使用问题，比如在Shell格式下：123FROM ubuntuENV name mrbirdENTRYPOINTER echo &quot;hello $name&quot;创建镜像，运行容器后输出：hello mrbird。但是在Exec格式下：123FROM ubuntuENV name mrbirdENTRYPOINTER [&quot;/bin/echo&quot;,&quot;hello $name&quot;]创建镜像，运行容器后输出：hello $name。正确的写法是:123FROM ubuntuENV name mrbirdENTRYPOINTER [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]参考文档：https://docs.docker.com/engine/reference/builder/]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 镜像与容器]]></title>
    <url>%2FDocker-Image-Container.html</url>
    <content type="text"><![CDATA[开始之前，可以通过 Vagrant构建一个CentOS环境 ，然后根据 官方文档 来安装Dokcer，下面的例子运行在CentOS7环境下。Docker Image俗称Docker镜像，它是由一系列图层（Layer）构成的，每个图层代表Dockerfile（通过Dockerfile我们可以创建镜像）中的一行指令，镜像是只读的。那什么是Dockerfile呢，举个简单的Dockerfile示例：12FROM centosRUN yum install -y vim上面的Dockerfile包含两行命令（所以它对应两个图层），第一行表示从centos这个镜像中创建一个图层，然后第二行表示接着运行yum install -y vim来安装vim。通过这个Dockerfile我们可以构建一个镜像，通过镜像我们可以创建一个容器（Container）。什么是Docker容器？容器是通过镜像构建的一个隔离的应用平台，它包含了运行应用程序所需要的一切。和镜像相比，它在顶部多了一层可读写图层，就如下图所示：镜像和容器的关系就像是Java里类与对象的关系那样，镜像是构建容器的模板，容器是镜像构建出来的实例。Docker镜像通过docker image ls查看当前有哪些镜像（等价于docker images）：当前暂无镜像，可以通过docker pull [OPTIONS] NAME[:TAG|@DIGEST]来从 DockerHub 拉取镜像，比如拉取一个Ubuntu镜像：不带tag则是拉取最新的镜像，可以通过tag来指定拉取的版本，比如拉取Ubuntu16.04：1docker pull ubuntu:16.04可以通过docker history [OPTIONS] IMAGE来查看image的构建历史（图层）：可以通过镜像的名称或者镜像ID来指定。使用镜像ID的时候，可以只指定前几位，只要能唯一标识一个镜像即可，所以上面的94e814e2efa8可以简写为94e。删除镜像使用的命令为docker image rm [OPTIONS] IMAGE [IMAGE...]，等价于docker rmi [OPTIONS] IMAGE [IMAGE...]。更多关于镜像的命令可以使用docker image --help来查看：Docker容器可以通过docker run [OPTIONS] IMAGE [COMMAND] [ARG...]命令来运行镜像，生成容器，比如运行刚刚拉去下来的ubuntu镜像，然后通过docker container ls命令查看当前正在运行的容器：没有正在运行的容器，我们可以通过docker container ls -a命令来查看所有状态下的容器（可简写为docker ps -a）：可看到，ubuntu这个容器状态为Exited退出状态，要让运行容器常驻，可以使用docker run -it命令：我们已经进入到ubuntu容器环境里了，可以在上面执行任何ubuntu支持的操作。这时候新开一个cmd窗口，查看目前容器的状态：上面包含了一开始创建的exited状态的容器以及常驻内存的状态为up的容器。退出容器环境使用exit命令即可。可以使用docker container rm [OPTIONS] CONTAINER [CONTAINER...]命令来删除容器：上面的命令也可以简化为docker rm dd1。可以通过docker rm $(docker container ls -aq)命令来一次性删除全部的container，docker container ls -aq作用为列出所有container id。可以使用docker rm $(docker container ls -f &quot;status=xxx&quot; -q)来删除指定状态的容器，比如仅删除状态为Exited的容器：1docker rm $(docker container ls -f "status=exited" -q)容器状态改变对于Exited状态的容器，我们可以使用docker container start来启动容器：进入运行中的容器的命令为：暂停容器：恢复容器：停止容器:下图展示了Docker容器的完整生命周期：更多关于container的命令可以使用docker container --help来查看：Docker镜像的构建Docker镜像的构建有两种方式：基于容器commit和通过Dockerfile构建。基于容器比如我们在刚刚运行中的unubtu容器中安装vim插件：然后exit退出，使用docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]命令来创建一个新的镜像：查看该镜像的history：停止容器：可以看到，它是在id为94e814e2efa8镜像上加了一层图层，id为cc7609287eaa，也就是新的镜像的id。一般不推荐这种方式来构建镜像，因为通过修改容器commit来构建新的镜像，我们不清楚原来的容器被修改了什么（比如安装恶意软件）。推荐的做法是通过Dockerfile来构建镜像。基于Dockerfile新建一个目录：1mkdir ubuntu-vim然后在该目录下编辑Dockerfile12cd ubuntu-vimvim DockerfileDockerfile内容如下所示：1234FROM ubuntuRUN apt-get updateRUN apt-get installRUN apt-get install -y vim意思是在ubuntu这个镜像基础上，分别运行apt-get update，apt-get install和apt-get install -y vim（-y指的是在命令行交互提示中，直接输入 yes）。创建好这个Dockerfile后，运行下面这条命令来构建镜像：意思是通过当前目录下的Dockerfile构建进行，镜像名称为mrbird/ubuntu-vim-dk。构建好后，查看当前镜像列表：其大小和我之前通过修改容器的方式构建的镜像一样。查看其history：可以看到Dockerfile的每一行RUN指令都创建了一个新的图层，通过这种方式来构建镜像的好处是，我们可以通过分享Dockerfile的方式来分享容器，并且对原镜像的修改过程一目了然。发布镜像我们可以将本地构建的镜像发布到 Docker Hub 上。首先得在 Docker Hub 上注册个账号：我的id为wuyouzhuguli。然后新建一个目录，并创建一个Dockerfile：123mkdir hellocd hellovim Dockerfile123FROM centosLABEL user=&quot;mrbird&quot; email=&quot;852252810@qq.com&quot; description=&quot;hello demo&quot;CMD echo &quot;hello docker by mrbird&quot;接着通过这个Dockerfile构建镜像:tag部分必须和上面注册账号一致。然后使用命令docker login登录 Docker：登录成功，开始push操作：push成功，查看 Docker Hub：关联Github创建除了通过docker push往Docker Hub上传镜像外，我们可以通过关联Github仓库的方式来创建镜像。首先在Github下新建一个仓库，然后上传Dockerfile：然后回到Docker Hub，新建一个仓库：关联Github账号，然后点击Create，然后在Builds选项卡里选择Github：然后选择Github的Dockerfiles仓库，路径选择hello：点击save and build按钮后，Docker Hub会根据关联的Github仓库下的Dockerfile来构建一个镜像：一般推荐这种方式。参考链接：https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/#images-and-layershttps://stackoverflow.com/questions/21498832/in-docker-whats-the-difference-between-a-container-and-an-image]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Vagrant创建CentOS虚拟机]]></title>
    <url>%2FCreate-Virtual-Machine-By-Vagrant.html</url>
    <content type="text"><![CDATA[Vagrant是一款由HashiCorp公司提供的，用于快速构建虚拟机环境的软件。本节我们将使用Vagrant结合Oracle VM VirtualBox快速地在win10环境下构建CentOS7虚拟机。在此之前需要先安装好 Vagrant 和 VirtualBox。构建CentOS7虚拟机在https://app.vagrantup.com/boxes/search下搜索centos：然后在win10任意盘符下创建vagrant_vm目录（注意目录最好不要有中文和空格），然后在该目录下使用cmd执行vagrant init centos/7命令：然后执行vagrant up启动（这时候最好也打开VirtualBox）：构建完毕，这时候VirtualBox的列表里会出现一台正在运行的虚拟机：这就是我们刚刚通过Vagrant构建的CentOS7虚拟机了。如果当你执行vagrant up命令后，虚拟机文件下载非常的慢的话，可以使用下面这种方式来构建：在上面的日志中可以找到这么一行：1Downloading: https://vagrantcloud.com/centos/boxes/7/versions/1902.01/providers/virtualbox.box后面这个URL就是下载地址了，将它黏贴到迅雷等下载工具下载即可。然后将下载好后的xxx.box文件复制到vagrant_vm目录下，并且重命名为centos7.box（删除centos7.box之外的文件和目录，只保留centos7.box一个文件）。接着运行vagrant box add -name &#39;centos/7&#39; centos7.box命令：添加成功后执行vagrant init centos/7初始化：初始化成功后执行vagrant up启动：构建成功，效果和一开始在线下载构建是一样的。连接虚拟机我们先用vagrant status命令查看一下虚拟机的状态：可以看到虚拟机是运行中的状态，我们可以执行vagrant halt来关闭虚拟机：启动虚拟机的命令为vagrant up，我们也可以使用vagrant suspend命令来暂停运行中的虚拟机，以保持它的运行状态：暂停后可以使用vagrant resume命令来恢复虚拟机：连接正在运行中的虚拟机的命令为vagrant ssh：重启虚拟机使用的命令为vagrant reload。如果你不想要这个虚拟机的话可以使用vagrant distroy命令进行销毁。目录共享Vagrant的根目录（就是我们一开始创建的vagrant_vm）和虚拟机里的/vagrant目录是共享的。我们在vagrant_vm目录下新建一个hello.txt文件，内容为hello：然后连接虚拟机，查看虚拟机/vagrant目录下有什么内容:说明同步成功。我们也可以自定义共享路劲，编辑vagrant_vm文件夹下的Vagrantfile文件：在这行下面添加如下配置：1config.vm.synced_folder &quot;./data&quot;, &quot;/share&quot;, create:true, owner: &quot;root&quot;, group: &quot;root&quot;这个配置的意思是将当前路径下的data文件夹和虚拟机的/share目录共享，拥有者为root，群组为root，如果路径不存在则创建。修改了Vagrantfile文件需要执行 vagrant reload重启。重启后我们在data文件夹下新建一个world.txt文件，然后连接虚拟机看看是否共享成功：共享成功！在这途中，遇到了如下问题:Vagrant was unable to mount VirtualBox shared folders. This is usually because the filesystem “vboxsf” is not available. This filesystem is made available via the VirtualBox Guest Additions and kernel module. Please verify that these guest additions are properly installed in the guest. This is not a bug in Vagrant and is usually caused by a faulty Vagrant box. For context, the command attempted was…The error output from the command was: mount: unknown filesystem type ‘vboxsf’安装下面这个插件可解决问题：1vagrant plugin install vagrant-vbguest网络配置虚拟机私有网络在Vagrantfile里打开下面这行配置：然后使用命令vagrant reload重启虚拟机，重启后我们使用ping命令看是否可以在windows上访问到这个ip：访问成功，连接虚拟机，使用ifconfig查看其IP：正是我们刚刚配置的那个IP。虚拟机公有网络编辑Vagrantfile，将我们刚刚开启的私有网络配置注释，然后开启下面这行配置：然后重启虚拟机，重启过程中会然你根据当前网络环境选择：因为我电脑连接的是家里wifi所以选择第四个选项，重启好后连接虚拟机，查看其IP：新开一个cmd窗口，ping 这个地址看是否能通:公有网络和私有网络的区别是，公有网络是无线路由器自动分配的IP地址，并且在同一个wifi网络下的其他设备也是可以访问这个IP地址的。比如我们在windows浏览器里输入http://192.168.28.83/：然后让手机连接和电脑相同的wifi网络，并且访问http://192.168.28.83/：结果说明公有网络配置成功。多主机配置使用Vagrant可以轻松地创建多台虚拟主机。下面我们开始通过Vagrant来创建两台新的虚拟主机“prod”和“dev”。在vagrant_vm目录下新建一个目录，名称为multi，然后通过现有的box来初始化一个Vagrantfile配置：接着编辑multi目录下的Vagrantfile文件，新增下面两项配置：运行vagrant status：可以看到多了两台状态为not created的虚拟机，名称分别为“prod”和“dev”。我们可以使用vagrant up来启动两台主机，也可以通过vagrant up prod来单独启动“prod”这台虚拟主机。启动后（第一次启动耗时可能比较长），使用vagrant status来查看它们的状态：通过vagrant ssh 主机名就可以连接上它们了。网络配置接下来开始配置网络，让它们之间可以通讯。我们按照上面介绍网络配置的方式来为这两台虚拟主机配置私有网络：值得注意的是，在配置私有网络的时候，IP网段不能和Windows主机相同。配置好后重启这两台虚拟机，然后分别连接这两台虚拟机，看是否能够ping通：配置成功。自定义主机名编辑Vagrantfile，添加如下配置：重启后，连接虚拟机，可以看到hostname已经修改为我们设置的名称了：多主机的共享目录默认的这两台虚拟主机的/vagrant和当前目录multi/是共享的。我们也可以分别为它们设置不同的共享目录。编辑Vagrantfile，添加如下配置：然后重启这两台虚拟主机就好了。更多Vagrant的配置可以查看官方文档：https://www.vagrantup.com/docs/]]></content>
      <tags>
        <tag>Vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 中的异步调用]]></title>
    <url>%2FSpring-Boot-Async.html</url>
    <content type="text"><![CDATA[通常我们开发的程序都是同步调用的，即程序按照代码的顺序一行一行的逐步往下执行，每一行代码都必须等待上一行代码执行完毕才能开始执行。而异步编程则没有这个限制，代码的调用不再是阻塞的。所以在一些情景下，通过异步编程可以提高效率，提升接口的吞吐量。这节将介绍如何在Spring Boot中进行异步编程。开启异步新建一个Spring Boot项目，版本为2.1.0.RELEASE，并引入spring-boot-starter-web依赖，项目结构如下所示：要开启异步支持，首先得在Spring Boot入口类上加上@EnableAsync注解：1234567@SpringBootApplication@EnableAsyncpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;接下来开始编写异步方法。在com.example.demo路径下新建service包，并创建TestService：1234567891011121314151617181920212223@Servicepublic class TestService &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Async public void asyncMethod() &#123; sleep(); logger.info("异步方法内部线程名称：&#123;&#125;", Thread.currentThread().getName()); &#125; public void syncMethod() &#123; sleep(); &#125; private void sleep() &#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;上面的Service中包含一个异步方法asyncMethod（开启异步支持后，只需要在方法上加上@Async注解便是异步方法了）和同步方法syncMethod。sleep方法用于让当前线程阻塞2秒钟。接着在com.example.demo路径下新建controller包，然后创建TestController：1234567891011121314151617181920212223242526272829303132@RestControllerpublic class TestController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private TestService testService; @GetMapping("async") public void testAsync() &#123; long start = System.currentTimeMillis(); logger.info("异步方法开始"); testService.asyncMethod(); logger.info("异步方法结束"); long end = System.currentTimeMillis(); logger.info("总耗时：&#123;&#125; ms", end - start); &#125; @GetMapping("sync") public void testSync() &#123; long start = System.currentTimeMillis(); logger.info("同步方法开始"); testService.syncMethod(); logger.info("同步方法结束"); long end = System.currentTimeMillis(); logger.info("总耗时：&#123;&#125; ms", end - start); &#125;&#125;启动项目，访问 http://localhost:8080/sync 请求，控制台输出如下：可看到默认程序是同步的，由于sleep方法阻塞的原因，testSync方法执行了2秒钟以上。访问 http://localhost:8080/async ，控制台输出如下：可看到testAsync方法耗时极少，因为异步的原因，程序并没有被sleep方法阻塞，这就是异步调用的好处。同时异步方法内部会新启一个线程来执行，这里线程名称为task - 1。默认情况下的异步线程池配置使得线程不能被重用，每次调用异步方法都会新建一个线程，我们可以自己定义异步线程池来优化。自定义异步线程池在com.example.demo下新建config包，然后创建AsyncPoolConfig配置类：1234567891011121314151617181920@Configurationpublic class AsyncPoolConfig &#123; @Bean public ThreadPoolTaskExecutor asyncThreadPoolTaskExecutor()&#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(20); executor.setMaxPoolSize(200); executor.setQueueCapacity(25); executor.setKeepAliveSeconds(200); executor.setThreadNamePrefix("asyncThread"); executor.setWaitForTasksToCompleteOnShutdown(true); executor.setAwaitTerminationSeconds(60); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125;&#125;上面我们通过ThreadPoolTaskExecutor的一些方法自定义了一个线程池，这些方法的含义如下所示：corePoolSize：线程池核心线程的数量，默认值为1（这就是默认情况下的异步线程池配置使得线程不能被重用的原因）。maxPoolSize：线程池维护的线程的最大数量，只有当核心线程都被用完并且缓冲队列满后，才会开始申超过请核心线程数的线程，默认值为Integer.MAX_VALUE。queueCapacity：缓冲队列。keepAliveSeconds：超出核心线程数外的线程在空闲时候的最大存活时间，默认为60秒。threadNamePrefix：线程名前缀。waitForTasksToCompleteOnShutdown：是否等待所有线程执行完毕才关闭线程池，默认值为false。awaitTerminationSeconds：waitForTasksToCompleteOnShutdown的等待的时长，默认值为0，即不等待。rejectedExecutionHandler：当没有线程可以被使用时的处理策略（拒绝任务），默认策略为abortPolicy，包含下面四种策略：callerRunsPolicy：用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。abortPolicy：直接抛出java.util.concurrent.RejectedExecutionException异常。discardOldestPolicy：当线程池中的数量等于最大线程数时、抛弃线程池中最后一个要执行的任务，并执行新传入的任务。discardPolicy：当线程池中的数量等于最大线程数时，不做任何动作。要使用该线程池，只需要在@Async注解上指定线程池Bean名称即可：12345678910@Servicepublic class TestService &#123; ...... @Async("asyncThreadPoolTaskExecutor") public void asyncMethod() &#123; ...... &#125; ......&#125;重启项目，再次访问 http://localhost:8080/async ，控制台输出入下：处理异步回调如果异步方法具有返回值的话，需要使用Future来接收回调值。我们修改TestService的asyncMethod方法，给其添加返回值：123456@Async("asyncThreadPoolTaskExecutor")public Future&lt;String&gt; asyncMethod() &#123; sleep(); logger.info("异步方法内部线程名称：&#123;&#125;", Thread.currentThread().getName()); return new AsyncResult&lt;&gt;("hello async");&#125;泛型指定返回值的类型，AsyncResult为Spring实现的Future实现类：接着改造TestController的testAsync方法：123456789101112131415@GetMapping("async")public String testAsync() throws Exception &#123; long start = System.currentTimeMillis(); logger.info("异步方法开始"); Future&lt;String&gt; stringFuture = testService.asyncMethod(); String result = stringFuture.get(); logger.info("异步方法返回值：&#123;&#125;", result); logger.info("异步方法结束"); long end = System.currentTimeMillis(); logger.info("总耗时：&#123;&#125; ms", end - start); return stringFuture.get();&#125;Future接口的get方法用于获取异步调用的返回值。重启项目，访问 http://localhost:8080/async 控制台输出如下所示:通过返回结果我们可以看出Future的get方法为阻塞方法，只有当异步方法返回内容了，程序才会继续往下执行。get还有一个get(long timeout, TimeUnit unit)重载方法，我们可以通过这个重载方法设置超时时间，即异步方法在设定时间内没有返回值的话，直接抛出java.util.concurrent.TimeoutException异常。比如设置超时时间为60秒：1String result = stringFuture.get(60, TimeUnit.SECONDS);源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/49.Spring-Boot-Async]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 中处理跨域]]></title>
    <url>%2FSpring-Boot-Deal-CORS.html</url>
    <content type="text"><![CDATA[HTML 5中新增的跨域资源访问（Cross-Origin Resource Sharing）特性可以让我们在开发后端系统的时候决定资源是否允许被跨域访问。所谓跨域指的是域名不同或者端口不同或者协议不同，比如当从mrbrid.cc网站访问mrbird.cc:8080网站资源就会存在跨域问题。Spring从4.2版本开始就提供了跨域的支持，开箱即用。这里介绍如何在Spring Boot开发中解决跨域的问题，主要分为注解驱动和接口编程的方式。模拟跨域要解决跨域问题，我们就得先模拟一个跨域情景。新建Spring Boot项目，版本为2.1.0.RELEASE，并引如下依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;项目结构如下所示：在com.example.demo路径下新建controller包，并创建TestController：1234567891011121314@Controllerpublic class TestController &#123; @RequestMapping("index") public String index () &#123; return "index"; &#125; @RequestMapping("hello") @ResponseBody public String hello()&#123; return "hello"; &#125;&#125;然后在resources/templates下新建index.html：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;跨域测试&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="hello"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; $(function () &#123; $.get("http://test.mrbird.cc:8080/hello", function (data) &#123; $("#hello").text(data); &#125;) &#125;)&lt;/script&gt;&lt;/html&gt;编辑本地hosts文件，将http://test.mrbird.cc网址映射到127.0.0.1上：启动项目访问http://localhost:8080/，会发现页面并没有成功显示hello，并且F12观察浏览器控制台会发现其报错了：这是因为我们在http://localhost:8080/域名下试图访问http://test.mrbird.cc:8080下的hello接口，这就存在跨域问题，接下来我们来解决这个问题。注解驱动Spring 4.2后提供了@CrossOrigin注解，该注解可以标注于方法或者类上，包含了以下属性:属性含义value指定所支持域的集合，*表示所有域都支持，默认值为*。这些值对应HTTP请求头中的Access-Control-Allow-Originorigins同valueallowedHeaders允许请求头中的header，默认都支持exposedHeaders响应头中允许访问的header，默认为空methods支持请求的方法，比如GET，POST，PUT等，默认和Controller中的方法上标注的一致。allowCredentials是否允许cookie随请求发送，使用时必须指定具体的域maxAge预请求的结果的有效期，默认30分钟我们来改造TestController中的hello方法：123456@RequestMapping("hello")@ResponseBody@CrossOrigin(value = "*")public String hello() &#123; return "hello";&#125;表示允许所有域都支持，重启项目，再次访问http://localhost:8080/：接口编程除了使用@CrossOrigin注解外，我们可以使用接口编程的方式进行统一配置。在com.example.demo路径下新建config包，然后创建WebConfigurer，实现WebMvcConfigurer，重写addCorsMappings默认实现：12345678910@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**") .allowedOrigins("*") .allowedMethods("GET"); &#125;&#125;上面配置表示允许所有请求支持跨域访问，并且不限定域，但是支持持GET方法。将hello方法上的@CrossOrigin注解注释掉，重启项目，再次访问http://localhost:8080/，结果也是OK的。过滤器实现查看官方文档，发现其还提供了基于过滤器的实现方式：1234567891011@Beanpublic FilterRegistrationBean corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin("*"); source.registerCorsConfiguration("/**", config); FilterRegistrationBean bean = new FilterRegistrationBean(new CorsFilter(source)); bean.setOrder(0); return bean;&#125;Actuator跨域如果项目里集成了Actuator相关功能，其暴露的接口也支持跨域，只需要在配置文件中添加如下配置即可：ENDPOINTS CORS CONFIGURATION (CorsEndpointProperties)123456management.endpoints.web.cors.allow-credentials= # Whether credentials are supported. When not set, credentials are not supported.management.endpoints.web.cors.allowed-headers= # Comma-separated list of headers to allow in a request. &apos;*&apos; allows all headers.management.endpoints.web.cors.allowed-methods= # Comma-separated list of methods to allow. &apos;*&apos; allows all methods. When not set, defaults to GET.management.endpoints.web.cors.allowed-origins= # Comma-separated list of origins to allow. &apos;*&apos; allows all origins. When not set, CORS support is disabled.management.endpoints.web.cors.exposed-headers= # Comma-separated list of headers to include in a response.management.endpoints.web.cors.max-age=1800s # How long the response from a pre-flight request can be cached by clients. If a duration suffix is not specified, seconds will be used.源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/48.Spring-Boot-CORS-Support]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Spring Boot 内容协商]]></title>
    <url>%2FSpring-Boot-Diy-Resolver.html</url>
    <content type="text"><![CDATA[内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。HTTP请求头中Content-Type，Accept等内容就是内容协商判断的标准。在Spring Boot中，一个完整的内容协商过程如下图所示：这个过程的核心组件：组件名称说明ContentNegotiationManager内容协商管理器ContentNegotiationStrategy 控制策略MediaType媒体类型HTTP 消息媒体类型，如 text/html@RequestMapping#consumes消费媒体类型请求头 Content-Type 媒体类型映射@RequestMapping#produces生产媒体类型响应头 Content-Type 媒体类型映射HttpMessageConverterHTTP消息转换器接口HTTP 消息转换器，用于反序列化 HTTP 请求或序列化响应WebMvcConfigurerWeb MVC 配置器配置 REST 相关的组件HandlerMethod处理方法@RequestMapping 标注的方法HandlerMethodArgumentResolver处理方法参数解析器用于 HTTP 请求中解析 HandlerMethod 参数内容HandlerMethodReturnValueHandler处理方法返回值解析器用于 HandlerMethod 返回值解析为 HTTP 响应内容HttpMessageConverter为HTTP消息转换接口，Spring根据不同的媒体类型进行了相应的实现。比如上图中Accept为application/json，所以在第7步中，会选择使用HttpMessageConverter的实现类MappingJackson2HttpMessageConverter来处理返回值。自定义HttpMessageConverter除了Spring给我们提供的HttpMessageConverter实现外，我们也可以自定义HttpMessageConverter的实现，来处理一些实际业务需求。假如现在要实现一个用于处理 Content-Type 为 text/properties 媒体类型的 HttpMessageConverter 实现类 PropertiesHttpMessageConverter，当我们在请求体中传输下面内容时：12name:mrbridage:18能够自动转换为Properties对象。我们可以参照MappingJackson2HttpMessageConverter的实现方式来进行实现，查看MappingJackson2HttpMessageConverter的原型图：所以我们可以通过继承AbstractGenericHttpMessageConverter的方式来实现HttpMessageConverter接口。新建Spring Boot项目，版本为2.1.0.RELEASE，并引入spring-boot-starter-web依赖，项目结构如下所示:我们在com.example.demo路径下新建converter包，然后创建PropertiesHttpMessageConverter，继承AbstractGenericHttpMessageConverter：1234567891011121314public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter&lt;Properties&gt; &#123; @Override protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; &#125; @Override protected Properties readInternal(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; return null; &#125; @Override public Properties read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; return null; &#125;&#125;其中readxxx为反序列化过程，即将HTTP请求反序列化为参数的过程；writeInternal为序列化过程，将响应序列化。反序列化过程我们继续编写PropertiesHttpMessageConverter：1234567891011121314151617181920212223242526272829303132333435public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter&lt;Properties&gt; &#123; @Override protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; &#125; @Override protected Properties readInternal(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; Properties properties = new Properties(); // 获取请求头 HttpHeaders headers = inputMessage.getHeaders(); // 获取 content-type MediaType contentType = headers.getContentType(); // 获取编码 Charset charset = null; if (contentType != null) &#123; charset = contentType.getCharset(); &#125; charset = charset == null ? Charset.forName("UTF-8") : charset; // 获取请求体 InputStream body = inputMessage.getBody(); InputStreamReader inputStreamReader = new InputStreamReader(body, charset); properties.load(inputStreamReader); return properties; &#125; @Override public Properties read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException &#123; return readInternal(null, inputMessage); &#125;&#125;在readInternal方法中，我们获取了HTTP请求体中的输入流和编码，然后调用Properties对象的load方法来将流转换为Properties对象。反序列化过程完成了，我们还需将PropertiesHttpMessageConverter添加到HttpMessageConverter集合中。在com.example.demo路径下新建config包，然后创建WebConfigurer配置类：1234567@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; converters.add(new PropertiesHttpMessageConverter()); &#125;&#125;extendMessageConverters方法为WebMvcConfigurer的默认方法，这里我们重写这个方法，用于将PropertiesHttpMessageConverter添加到消息转换器集合中。接着创建一个Controller来测试一波，在com.example.demo路径下新建controller包，然后创建TestController：12345678@RestControllerpublic class TestController &#123; @GetMapping(value = "test", consumes = "text/properties") public Properties test(@RequestBody Properties properties) &#123; return properties; &#125;&#125;我们通过@GetMapping注解的consumes属性指定了方法接收的媒体类型为text/properties，如果方法能够成功被调用，并且可以返回Properties对象，则说明我们自定义的HTTP消息转换器是可行的。启动项目，使用PostMan访问：请求头中指定Content-Type为text/properties，请求体内容如下所示:访问后，控制台输出错误如下：1Resolved [org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public java.util.Properties com.example.demo.controller.TestController.test(java.util.Properties)]为什么呢？因为我们在自定义PropertiesHttpMessageConverter的时候需要在其构造器中指定它能够处理的媒体类型，我们查看MappingJackson2HttpMessageConverter的构造器，看看它是怎么实现的：所以我们在PropertiesHttpMessageConverter的构造器中添加相应的媒体类型：123public PropertiesHttpMessageConverter() &#123; super(new MediaType("text", "properties"));&#125;这时候，重启项目，再次访问上面的请求，可看到响应如下所示:序列化过程序列化的过程就是处理HTTP响应的过程，对应PropertiesHttpMessageConverter的writeInternal方法。那为什么我们都还实现这个方法，上面的Controller请求却能返回正常的JSON内容呢？两个原因：这里我们定义的是REST接口，所以响应默认会被序列化为JSON格式；由于使用converters.add(new PropertiesHttpMessageConverter());这种方式来添加自定义HTTP消息处理器默认会被添加到集合的末尾，在处理JSON响应的时候被排在前面的MappingJackson2HttpMessageConverter优先处理了。我们可以通过debug来查看PropertiesHttpMessageConverter是否真的被添加到集合末尾了：所以我们要换下面这种方式来添加自定义HTTP处理器：123456789@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; // converters.add(new PropertiesHttpMessageConverter()); // 指定顺序，这里为第一个 converters.add(0, new PropertiesHttpMessageConverter()); &#125;&#125;我们重启项目，再次debug：可看到，PropertiesHttpMessageConverter已经排在第一个了。这时候再次访问上面的请求，响应如下所示:没有任何返回值，这是因为我们还没实现writeInternal呢。继续实现writeInternal方法：123456789101112131415161718192021222324252627public class PropertiesHttpMessageConverter extends AbstractGenericHttpMessageConverter&lt;Properties&gt; &#123; ... @Override protected void writeInternal(Properties properties, Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException &#123; // 获取请求头 HttpHeaders headers = outputMessage.getHeaders(); // 获取 content-type MediaType contentType = headers.getContentType(); // 获取编码 Charset charset = null; if (contentType != null) &#123; charset = contentType.getCharset(); &#125; charset = charset == null ? Charset.forName("UTF-8") : charset; // 获取请求体 OutputStream body = outputMessage.getBody(); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(body, charset); properties.store(outputStreamWriter, "Serialized by PropertiesHttpMessageConverter#writeInternal"); &#125; ...&#125;过程和反序化差不多，这里是通过Properties对象的store方法来进行写操作。重启项目，再次访问上面的请求，响应如下所示：自定义HandlerMethodArgumentResolver上面这种方式必须依赖于@RequestBody和@ResponseBody注解，除此之外我们还可以通过自定义HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler实现类的方式来处理内容协商。HandlerMethodArgumentResolver俗称方法参数解析器，用于解析由@RequestMapping注解（或其派生的注解）所标注的方法的参数。这里我们开始通过实现HandlerMethodArgumentResolver的方式来将HTTP请求体的内容自动解析为Properties对象。在com.example.demo路径下新建resolver包，然后创建PropertiesHandlerMethodReturnValueHandler实现HandlerMethodArgumentResolver接口：12345678910111213141516171819202122232425public class PropertiesHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; return Properties.class.equals(parameter.getParameterType()); &#125; @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest; HttpServletRequest request = servletWebRequest.getRequest(); String contentType = request.getHeader("Content-Type"); MediaType mediaType = MediaType.parseMediaType(contentType); // 获取编码 Charset charset = mediaType.getCharset() == null ? Charset.forName("UTF-8") : mediaType.getCharset(); // 获取输入流 InputStream inputStream = request.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charset); // 输入流转换为 Properties Properties properties = new Properties(); properties.load(inputStreamReader); return properties; &#125;&#125;方法supportsParameter用于指定支持解析的参数类型，这里为Properties类型。resolveArgument方法用于实现解析逻辑，解析过程和上面定义的PropertiesHttpMessageConverter的readInternal方法类似。接着，我们还需将PropertiesHandlerMethodArgumentResolver添加到Spring自带的HandlerMethodArgumentResolver实现类集合中。值得注意的是，我们不能在配置类WebMvcConfigurer中通过重写addArgumentResolvers的方式来添加，查看该方法源码上的注释：大致意思是通过这个方法来添加的方法参数解析器不会覆盖Spring内置的方法参数解析器，如果需要这么做的话，可以直接通过修改RequestMappingHandlerAdapter来实现。所以我们可以通过下面这个方式来实现：1234567891011121314151617181920@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; @Autowired private RequestMappingHandlerAdapter requestMappingHandlerAdapter; @PostConstruct public void init() &#123; // 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象 List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers(); List&lt;HandlerMethodArgumentResolver&gt; newArgumentResolvers = new ArrayList&lt;&gt;(argumentResolvers.size() + 1); // 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置 newArgumentResolvers.add(0, new PropertiesHandlerMethodArgumentResolver()); // 将原 ArgumentResolver 添加到集合中 newArgumentResolvers.addAll(argumentResolvers); // 重新设置 ArgumentResolver对象集合 requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers); &#125;&#125;我们在WebConfigurer配置类装配完毕的时候，通过requestMappingHandlerAdapter对象的setArgumentResolvers方法来重新设置方法解析器集合，将PropertiesHandlerMethodArgumentResolver添加到集合的第一个位置。之所以要将PropertiesHandlerMethodArgumentResolver添加到第一个位置是因为Properties本质也是一个Map对象，而Spring内置的MapMethodProcessor就是用于处理Map参数类型的，如果不将PropertiesHandlerMethodArgumentResolver优先级提高，那么Properties类型参数会被MapMethodProcessor解析，从而出错。配置完毕后，我们改造一下TestController：12345678910111213141516// @RestController@Controllerpublic class TestController &#123; @GetMapping(value = "test", consumes = "text/properties") @ResponseBody public Properties test(@RequestBody Properties properties) &#123; return properties; &#125; @GetMapping(value = "test1", consumes = "text/properties") @ResponseBody public Properties test1(Properties properties) &#123; return properties; &#125;&#125;test1方法的参数没有被@RequestBody标注，启动项目，访问下面这个请求：可以看到方法成功执行，并且返回了正确的内容，说明我们自定义的方法参数解析器PropertiesHandlerMethodArgumentResolver是可行的。但是方法的返回值还是由PropertiesHttpMessageConverter的writeInternal方法解析的，并且依赖于@ResponseBody注解，接着我们开始实现自定义方法返回值解析器，并且不依赖于@ResponseBody注解。自定义HandlerMethodReturnValueHandlerHandlerMethodArgumentResolver俗称方法返回值解析器，用于解析由@RequestMapping注解（或其派生的注解）所标注的方法的返回值。这里我们开始通过实现HandlerMethodReturnValueHandler的方式来自定义一个用于处理返回值类型为Properties类型的解析器。在com.example.demo路径下新建handler包，然后创建PropertiesHandlerMethodReturnValueHandler实现HandlerMethodReturnValueHandler：1234567891011121314151617181920212223242526272829303132333435public class PropertiesHandlerMethodReturnValueHandler implements HandlerMethodReturnValueHandler &#123; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return Properties.class.equals(returnType.getMethod().getReturnType()); &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; Properties properties = (Properties) returnValue; ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest; HttpServletResponse response = servletWebRequest.getResponse(); ServletServerHttpResponse servletServerHttpResponse = new ServletServerHttpResponse(response); // 获取请求头 HttpHeaders headers = servletServerHttpResponse.getHeaders(); MediaType contentType = headers.getContentType(); // 获取编码 Charset charset = null; if (contentType != null) &#123; charset = contentType.getCharset(); &#125; charset = charset == null ? Charset.forName("UTF-8") : charset; // 获取请求体 OutputStream body = servletServerHttpResponse.getBody(); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(body, charset); properties.store(outputStreamWriter, "Serialized by PropertiesHandlerMethodReturnValueHandler#handleReturnValue"); &#125;&#125;supportsReturnType方法指定了处理返回值的类型，handleReturnValue方法用于处理返回值，这里的逻辑和PropertiesHttpMessageConverter的writeInternal方法基本一致，不再赘述。接着将PropertiesHandlerMethodReturnValueHandler添加到到Spring自带的HandlerMethodReturnValueHandler实现类集合中，添加方式和自定义HandlerMethodArgumentResolver一致：123456789101112131415161718192021222324252627282930@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; @Autowired private RequestMappingHandlerAdapter requestMappingHandlerAdapter; @PostConstruct public void init() &#123; // 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象 List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers(); List&lt;HandlerMethodArgumentResolver&gt; newArgumentResolvers = new ArrayList&lt;&gt;(argumentResolvers.size() + 1); // 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置 newArgumentResolvers.add(0, new PropertiesHandlerMethodArgumentResolver()); // 将原 ArgumentResolver 添加到集合中 newArgumentResolvers.addAll(argumentResolvers); // 重新设置 ArgumentResolver对象集合 requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers); // 获取当前 RequestMappingHandlerAdapter 所有的 returnValueHandlers对象 List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = requestMappingHandlerAdapter.getReturnValueHandlers(); List&lt;HandlerMethodReturnValueHandler&gt; newReturnValueHandlers = new ArrayList&lt;&gt;(returnValueHandlers.size() + 1); // 添加 PropertiesHandlerMethodReturnValueHandler 到集合第一个位置 newReturnValueHandlers.add(0, new PropertiesHandlerMethodReturnValueHandler()); // 将原 returnValueHandlers 添加到集合中 newReturnValueHandlers.addAll(returnValueHandlers); // 重新设置 ReturnValueHandlers对象集合 requestMappingHandlerAdapter.setReturnValueHandlers(newReturnValueHandlers); &#125;&#125;配置好后，我们将TestController的test1方法的@ResponseBody注解去掉，重启项目，再次访问:可以看到，返回值成功被PropertiesHandlerMethodReturnValueHandler的handleReturnValue方法解析了。但是这里还有一个问题，我们查看控制台，会发现如下异常:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950javax.servlet.ServletException: Circular view path [test1]: would dispatch back to the current handler URL [/test1] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.) at org.springframework.web.servlet.view.InternalResourceView.prepareForRendering(InternalResourceView.java:209) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:147) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:316) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:998) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:890) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:875) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) ~[tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:770) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.12.jar:9.0.12] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.12.jar:9.0.12] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_171] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_171] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.12.jar:9.0.12] at java.lang.Thread.run(Thread.java:748) [na:1.8.0_171]这是因为，在Spring中如果Controller中的方法没有被@ResponseBody标注的话，默认会把返回值当成视图的名称，而这里我们并不希望解析的Properties值被当成视图名称，所以我们需要在PropertiesHandlerMethodReturnValueHandler的handleReturnValue方法最后一行添加如下代码：12// 告诉 Spring MVC 请求已经处理完毕mavContainer.setRequestHandled(true);这行代码告诉Spring，请求已经成功完成了，无需进行后续的处理。重启项目再次访问上面的请求，控制台便不再抛异常了。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/47.Spring-Boot-Content-Negotiation]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot配合Hibernate Validator参数校验]]></title>
    <url>%2FSpring-Boot-Hibernate-Validator-Params-Check.html</url>
    <content type="text"><![CDATA[Spring Boot中结合Hibernate Validator可以实现优雅的参数校验，而不必在业务代码中写一大堆的参数校验逻辑。Hibernate Validator的基本使用可以参考Spring表单校验，这里介绍一种结合全局异常捕获的方式来实现低耦合简洁的参数校验解决方案。方法参数校验新建一个Spring Boot工程，版本为2.1.0.RELEASE，artifactId为validator，并引入spring-boot-starter-web和commons-lang3依赖：1234567891011 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;项目结构如下所示：spring-boot-starter-web已经包含了hibernate-validator，所以无需单独引入： 在com.example.demo下新建controller包，然后创建TestController，定义一个test1方法：1234567891011@RestController@Validatedpublic class TestController &#123; @GetMapping("test1") public String test1( @NotBlank(message = "&#123;required&#125;") String name, @Email(message = "&#123;invalid&#125;") String email) &#123; return "success"; &#125;&#125;test1方法的name参数使用@NotBlank标注，表示不能为空，提示信息为{required}占位符里的内容；email参数使用@Email注解标注，表示必须为一个合法的邮箱值（可以为空），提示信息为{invalid}占位符里的内容。要让参数校验生效，我们还需在类上使用@Validated注解标注。接下来定义上面两个占位符的内容。在resources目录下新建ValidationMessages.properties文件，内容如下：12required=\u4e0d\u80fd\u4e3a\u7a7ainvalid=\u683c\u5f0f\u4e0d\u5408\u6cd5内容为中文转Unicode后的值，可以使用http://tool.chinaz.com/tools/unicode.aspx网站转换，\u4e0d\u80fd\u4e3a\u7a7a转为中文为“不能为空”，\u683c\u5f0f\u4e0d\u5408\u6cd5转为中文为“格式不合法”。启动项目，使用Postman进行测试，参数内容如下所示：这里name参数值为空，email参数值为123，访问后，控制台输出异常如下：可见，使用这种方式参数校验不通过时，会抛出javax.validation.ConstraintViolationException，我们使用全局异常捕获来处理这种异常：在com.example.demo下新建handler包，然后创建GlobalExceptionHandler：123456789101112131415161718192021222324@RestControllerAdvice@Order(value = Ordered.HIGHEST_PRECEDENCE)public class GlobalExceptionHandler &#123; /** * 统一处理请求参数校验(普通传参) * * @param e ConstraintViolationException * @return FebsResponse */ @ExceptionHandler(value = ConstraintViolationException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public String handleConstraintViolationException(ConstraintViolationException e) &#123; StringBuilder message = new StringBuilder(); Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = e.getConstraintViolations(); for (ConstraintViolation&lt;?&gt; violation : violations) &#123; Path path = violation.getPropertyPath(); String[] pathArr = StringUtils.splitByWholeSeparatorPreserveAllTokens(path.toString(), "."); message.append(pathArr[1]).append(violation.getMessage()).append(","); &#125; message = new StringBuilder(message.substring(0, message.length() - 1)); return message.toString(); &#125;&#125;上面主要的逻辑是获取校验不通过的参数名称，然后拼接上提示信息，并且HTTP返回状态码为400。重启项目，再次访问刚刚的链接，响应如下所示：使用实体传参当参数较少的时候可以使用上面这种方式，但如果参数众多上面的方式就略显繁琐了。这时候我们可以使用实体对象来进行传参。为了模拟这种情况，我们在com.example.demo路径下新建domain包，然后新建User类：12345678910111213141516171819202122232425public class User implements Serializable &#123; private static final long serialVersionUID = -2731598327208972274L; @NotBlank(message = "&#123;required&#125;") private String name; @Email(message = "&#123;invalid&#125;") private String email; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125;接着在TestController里创建一个test2方法:1234@GetMapping("test2")public String test2(@Valid User user) &#123; return "success";&#125;使用实体对象传参的方式参数校验需要在相应的参数前加上@Valid注解。重启项目，再次访问下面这个请求： 控制台会输出如下信息:123Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 2 errorsField error in object &apos;user&apos; on field &apos;name&apos;: rejected value []; codes [NotBlank.user.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.name,name]; arguments []; default message [name]]; default message [不能为空]Field error in object &apos;user&apos; on field &apos;email&apos;: rejected value [123]; codes [Email.user.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@5fb82092,org.springframework.validation.beanvalidation.SpringValidatorAdapter$ResolvableAttribute@cc0c307]; default message [格式不合法]]这时候我们需要在GlobalExceptionHandler捕获org.springframework.validation.BindException异常：123456789101112131415161718/** * 统一处理请求参数校验(实体对象传参) * * @param e BindException * @return FebsResponse */@ExceptionHandler(BindException.class)@ResponseStatus(HttpStatus.BAD_REQUEST)public String validExceptionHandler(BindException e) &#123; StringBuilder message = new StringBuilder(); List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors(); for (FieldError error : fieldErrors) &#123; message.append(error.getField()).append(error.getDefaultMessage()).append(","); &#125; message = new StringBuilder(message.substring(0, message.length() - 1)); return message.toString();&#125;重启项目，再次访问刚刚的请求，响应如下所示:我们将请求参数改为合法的内容：点击访问，响应如下所示:源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/46.Spring-Boot-Hibernate-Validator]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习Spring Boot中的SpringApplication]]></title>
    <url>%2Fdeepin-springboot-application.html</url>
    <content type="text"><![CDATA[在Spring Boot的入口类中，我们通常是通过调用SpringApplication的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。自定义SpringApplication默认的我们都是直接通过SpringApplication的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。通过SpringApplication API调整我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，artifactId为SpringApplication，并引入spring-boot-starter-web依赖。项目结构如下所示:我们将入口类的代码改为：12345SpringApplication application = new SpringApplication(DemoApplication.class);application.setBannerMode(Banner.Mode.OFF);application.setWebApplicationType(WebApplicationType.NONE);application.setAdditionalProfiles("dev");application.run(args);通过调用SpringApplication的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，SpringApplication还包含了许多别的方法，具体可以查看源码或者官方文档：通过SpringApplicationBuilder API调整SpringApplicationBuilder提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：12345new SpringApplicationBuilder(DemoApplication.class) .bannerMode(Banner.Mode.OFF) .web(WebApplicationType.NONE) .profiles("dev") .run(args);SpringApplication准备阶段SpringApplication的生命周期阶段大致可以分为准备阶段和运行阶段。我们通过源码来查看SpringApplication的有参构造器：通过有参构造器里的代码我们可以将SpringApplication的准备阶段分为以下几个步骤：配置源构造器中this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));这行代码用于加载我们配置的Spring Boot Bean源。通常我们使用SpringApplication或者SpringApplicationBuilder的构造器来直接指定源。所谓的Spring Boot Bean源指的是某个被@SpringBootApplication注解标注的类，比如入口类：我们也可以将上面的代码改为下面这种方式：123456789101112public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(ApplicationResource.class); application.run(args); &#125; @SpringBootApplication public static class ApplicationResource &#123; &#125;&#125;这样也是可行的。查看SpringApplication的单个参数构造器：说明我们除了配置单个源外，还可以配置多个源。推断应用类型构造器中这行this.webApplicationType = WebApplicationType.deduceFromClasspath();代码用于推断当前Spring Boot应用类型。Spring Boot 2.0后，应用可以分为下面三种类型：WebApplicationType.NONE：非WEB类型；WebApplicationType.REACTIVE：Web Reactive类型；WebApplicationType.SERVLET：Web Servlet类型。WebApplicationType.deduceFromClasspath()方法根据当前应用ClassPath中是否存在相关的实现类来判断应用类型到底是哪个，deduceFromClasspath方法的源码如下所示:我们也可以直接通过SpringApplication的setWebApplicationType方法或者SpringApplicationBuilder的web方法来指定当前应用的类型。加载应用上下文初始器接着下一行代码setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));用于加载应用上下文初始器ApplicationContextInitializer。getSpringFactoriesInstances方法的源码如下所示：上面代码利用Spring工厂加载机制，实例化ApplicationContextInitializer实现类，并进行排序。所以我们可以通过实现ApplicationContextInitializer接口用于在Spring Boot应用初始化之前执行一些自定义操作。举个例子，在com.example.demo下新建initializer包，然后创建一个HelloApplicationContextInitializer类，实现ApplicationContextInitializer接口：1234567@Order(Ordered.HIGHEST_PRECEDENCE)public class HelloApplicationContextInitializer implements ApplicationContextInitializer &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ConfigurableApplicationContext.id - " + applicationContext.getId()); &#125;&#125;上面代码中实现了initialize方法，并且使用@Order注解指定优先级。其中Ordered.HIGHEST_PRECEDENCE等于Integer.MIN_VALUE，Ordered.LOWEST_PRECEDENCE等于Integer.MAX_VALUE。所以数值越小，优先级越高。除了使用@Order注解来指定优先级外，我们也可以通过实现org.springframework.core.Ordered接口的getOrder方法来指定优先级。接着我们来创建一个优先级比HelloApplicationContextInitializer低的Initializer —— AfterHelloApplicationContextInitializer：1234567891011public class AfterHelloApplicationContextInitializer implements ApplicationContextInitializer, Ordered &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("AfterHelloApplicationContextInitializer: " + applicationContext.getId()); &#125; @Override public int getOrder() &#123; return Ordered.LOWEST_PRECEDENCE; &#125;&#125;上面通过getOrder方法来指定了优先级为最低优先级。创建好后，我们还需在工厂配置文件里配置这两个实现类。在resources目录下新建META-INF目录，并创建spring.factories文件：1234# Initializersorg.springframework.context.ApplicationContextInitializer=\com.example.demo.initializer.HelloApplicationContextInitializer,\com.example.demo.initializer.AfterHelloApplicationContextInitializer这时候，启动Spring Boot项目，会发现控制台在打印Banner后就执行了这两个初始化器，并且HelloApplicationContextInitializer的initialize方法执行时机先于AfterHelloApplicationContextInitializer的initialize方法：加载应用事件监听器在加载完应用上下文初始器后，下一行的setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));代码加载了应用事件监听器。与加载事件上下文初始器类似，Spring Boot也是通过Spring的工厂方法来实例化ApplicationListener的实现类，并进行排序。既然是事件监听，那么其可以监听什么事件呢？其监听的是ApplicationEvent接口的实现类，我们查看一下都有哪些事件实现了这个接口：这里我们以ContextClosedEvent为例子来编写自定义的应用事件监听器，监听Spring上下文关闭事件。在com.example.demo下新建listener包，然后创建一个ContextClosedEventListener类，实现ApplicationListener接口：12345678@Order(Ordered.HIGHEST_PRECEDENCE)public class ContextClosedEventListener implements ApplicationListener&lt;ContextClosedEvent&gt; &#123; @Override public void onApplicationEvent(ContextClosedEvent event) &#123; System.out.println("ContextClosedEvent: " + event.getApplicationContext().getId()); &#125;&#125;上面代码实现了对ContextClosedEvent事件的监听，并且分配了最高优先级。接着创建一个优先级比ContextClosedEventListener低的监听器AfterContextClosedEventListener：1234567891011public class AfterContextClosedEventListener implements ApplicationListener&lt;ContextClosedEvent&gt;, Ordered &#123; @Override public void onApplicationEvent(ContextClosedEvent event) &#123; System.out.println("AfterContextClosedEventr: " + event.getApplicationContext().getId()); &#125; @Override public int getOrder() &#123; return Ordered.HIGHEST_PRECEDENCE + 1; &#125;&#125;最后，别忘了在Spring工厂配置文件里进行配置：1234# Application Listenersorg.springframework.context.ApplicationListener=\com.example.demo.listener.ContextClosedEventListener,\com.example.demo.listener.AfterContextClosedEventListener在Spring Boot入口类中将环境指定为非WEB环境（这样在启动后应用会马上关闭）:123new SpringApplicationBuilder(DemoApplication.class) .web(WebApplicationType.NONE) .run(args);运行Spring Boot入口类，控制台输出如下： 推断入口类接着构造器里的代码下一行this.mainApplicationClass = deduceMainApplicationClass();用于推断运行Spring Boot应用的入口类。查看deduceMainApplicationClass方法源码：代码主要逻辑是根据Main线程执行堆栈判断实际的入口类。准备阶段介绍完毕后，接下来开始介绍运行阶段。SpringApplication运行阶段SpringApplication的运行阶段对应SpringApplication的run方法，我们查看其源码：12345678910111213141516171819202122232425262728293031323334353637383940414243public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125;运行阶段大致可以分为下面这几个过程：开启时间监听run方法开头的这两行代码用于开启时间监听：12StopWatch stopWatch = new StopWatch();stopWatch.start();上面代码用于开启Spring Boot应用启动时间监听，配合下面的stopWatch.stop();便可以计算出完整的启动时间。开启运行监听器run方法的这几行代码用于加载Spring应用运行监听器（SpringApplicationRunListener）：12SpringApplicationRunListeners listeners = getRunListeners(args);listeners.started();getRunListeners方法源码：12345private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args));&#125;上面代码通过SpringFactoriesLoader检索META-INF/spring.factories找到声明的所有SpringApplicationRunListener的实现类并将其实例化，然后装配到List&lt;SpringApplicationRunListener&gt;运行监听器集合中。listeners.started();用于遍历运行监听器集合中的所有SpringApplicationRunListener的实现类，并逐一调用它们的starting方法，广播Spring Boot应用要开始启动了。在Spring Boot中SpringApplicationRunListener接口用于监听整个Spring Boot应用生命周期，其代码如下所示：123456789101112131415public interface SpringApplicationRunListener &#123; void starting(); void environmentPrepared(ConfigurableEnvironment environment); void contextPrepared(ConfigurableApplicationContext context); void contextLoaded(ConfigurableApplicationContext context); void started(ConfigurableApplicationContext context); void running(ConfigurableApplicationContext context); void failed(ConfigurableApplicationContext context, Throwable exception);&#125;这些方法对应着Spring Boot应用生命周期的各个阶段：方法名称对应生命周期Spring Boot起始版本starting()Spring 应用刚启动1.0environmentPrepared(ConfigurableEnvironment)ConfigurableEnvironment 准备完毕，允许将其调整1.0contextPrepared(ConfigurableApplicationContext)ConfigurableApplicationContext 准备完毕，允许将其调整1.0contextLoaded(ConfigurableApplicationContext)ConfigurableApplicationContext 已装载，但仍未启动1.0started(ConfigurableApplicationContext)ConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成2.0running(ConfigurableApplicationContext)Spring 应用正在运行2.0failed(ConfigurableApplicationContext,Throwable)Spring 应用运行失败2.0我们在com.example.demo.linstener下自定义一个SpringApplicationRunListener接口实现类HelloSpringApplicationRunListener：12345678910111213141516171819202122232425262728293031323334353637383940public class HelloApplicationRunListener implements SpringApplicationRunListener &#123; public HelloApplicationRunListener(SpringApplication application, String[] args) &#123; &#125; @Override public void starting() &#123; System.out.println("HelloApplicationRunListener starting......"); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; &#125; @Override public void started(ConfigurableApplicationContext context) &#123; &#125; @Override public void running(ConfigurableApplicationContext context) &#123; &#125; @Override public void failed(ConfigurableApplicationContext context, Throwable exception) &#123; &#125;&#125;通过这个实现类，我们可以在Spring Boot应用刚启动的时候在控制台输出HelloApplicationRunListener starting......。因为其基于Spring的工厂方法来实现，所以我们需要在spring.factories文件里配置这个实现类:123# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\com.example.demo.run.HelloApplicationRunListener启动Spring Boot应用便可以在控制台看到如下输出了：创建 Environmentrun方法中的这行代码用于创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）：1ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);我们已经在准备阶段里推断出了应用类型，这里只要根据相应的应用类型来创建相应的应用环境即可，类型和环境对应关系如下：Web Reactive： StandardReactiveWebEnvironmentWeb Servlet： StandardServletEnvironment非 Web： StandardEnvironment在prepareEnvironment方法中会执行listeners.environmentPrepared(environment);，用于遍历调用所有SpringApplicationRunListener实现类的environmentPrepared()方法，广播Environment准备完毕。是否打印Bannerrun方法中的这行代码会根据我们的配置来决定是否打印Banner：1Banner printedBanner = printBanner(environment);创建Contextrun方法中的这行代码用于创建ApplicationContext：1context = createApplicationContext();不同的环境对应不同的ApplicationContext：Web Reactive： AnnotationConfigReactiveWebServerApplicationContextWeb Servlet： AnnotationConfigServletWebServerApplicationContext非 Web： AnnotationConfigApplicationContext装配Contextrun方法中的这行代码用于装配Context：1prepareContext(context, environment, listeners, applicationArguments, printedBanner);方法prepareContext的源码如下所示:123456789101112131415161718192021222324252627private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; context.setEnvironment(environment); postProcessApplicationContext(context); applyInitializers(context); listeners.contextPrepared(context); if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // Add boot specific singleton beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton("springApplicationArguments", applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton("springBootBanner", printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, "Sources must not be empty"); load(context, sources.toArray(new Object[0])); listeners.contextLoaded(context);&#125;prepareContext方法开头为ApplicationContext加载了environment，之后通过applyInitializers方法逐个执行ApplicationContextInitializer的initialize方法来进一步封装ApplicationContext，并调用所有的SpringApplicationRunListener实现类的contextPrepared方法，广播ApplicationContext已经准备完毕了。之后初始化IOC容器，并调用SpringApplicationRunListener实现类的contextLoaded方法，广播ApplicationContext加载完成，这里就包括通过@EnableAutoConfiguration导入的各种自动配置类。Refresh Contextrun方法中的这行代码用于初始化所有自动配置类，并调用ApplicationContext的refresh方法：1refreshContext(context);广播应用已启动run方法中的这行代码用于广播Spring Boot应用已启动：1listeners.started(context);started方法会调用所有的SpringApplicationRunListener的finished方法，广播SpringBoot应用已经成功启动。执行Runnerrun方法中的这行代码callRunners(context, applicationArguments);遍历所有ApplicationRunner和CommandLineRunner的实现类，并执行其run方法。我们可以实现自己的ApplicationRunner或者CommandLineRunner，来对Spring Boot的启动过程进行扩展。我们在com.example.demo下新建runner包，然后创建一个ApplicationRunner的实现类HelloApplicationRunner：1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) &#123; System.out.println("HelloApplicationRunner: hello spring boot"); &#125;&#125;这里我们需要将HelloApplicationRunner使用@Component注解标注，让其注册到IOC容器中。然后再创建一个CommandLineRunner的实现类HelloCommandLineRunner：1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) &#123; System.out.println("HelloCommandLineRunner: hello spring boot"); &#125;&#125;启动Spring Boot应用，便可以在应用刚启动好后看到如下输出：广播应用运行中run方法中的这行代码listeners.running(context);用于调用SpringApplicationRunListener的running方法，广播Spring Boot应用正在运行中。当run方法运行出现异常时，便会调用handleRunFailure方法来处理异常，该方法里会通过listeners.failed(context, exception);来调用SpringApplicationRunListener的failed方法，广播应用启动失败，并将异常扩散出去。上面所有的广播事件都是使用Spring的应用事件广播器接口ApplicationEventMulticaster的实现类SimpleApplicationEventMulticaster来进行广播的。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习Spring Boot自动装配]]></title>
    <url>%2Fdeepin-springboot-autoconfig.html</url>
    <content type="text"><![CDATA[模式注解Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有@Service，@Repository，@Controller等，它们都“派生”自@Component注解。我们都知道，凡是被@Component标注的类都会被Spring扫描并纳入到IOC容器中，那么由@Component派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要通过自定义模式注解来了解@Component的“派生性”和“层次性”。@Component “派生性”新建一个Spring Boot工程，Spring Boot版本为2.1.0.RELEASE，artifactId为autoconfig，并引入spring-boot-starter-web依赖。项目结构如下所示:在com.example.demo下新建annotation包，然后创建一个FirstLevelService注解：1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Servicepublic @interface FirstLevelService &#123; String value() default "";&#125;这个注解定义由@Service标注，查看@Service的源码会发现其被@Component注解标注，所以它们的层次关系为:123└─@Component └─@Service └─@FirstLevelService即@FirstLevelService为@Component派生出来的模式注解，我们来测试一下被它标注的类是否能够被扫描到IOC容器中：在com.example.demo下新建service包，然后创建一个TestService类：123@FirstLevelServicepublic class TestService &#123;&#125;在com.example.demo下新建bootstrap包，然后创建一个ServiceBootStrap类，用于测试注册TestService并从IOC容器中获取它：123456789101112@ComponentScan("com.example.demo.service")public class ServiceBootstrap &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = new SpringApplicationBuilder(ServiceBootstrap.class) .web(WebApplicationType.NONE) .run(args); TestService testService = context.getBean("testService", TestService.class); System.out.println("TestService Bean: " + testService); context.close(); &#125;&#125;运行该类的main方法，控制台输出如下：@Component “层次性”我们在com.example.demo.annotation路径下再创建一个SecondLevelService注解定义，该注解由上面的@FirstLevelService标注：1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@FirstLevelServicepublic @interface SecondLevelService &#123; String value() default "";&#125;这时候层次关系为：1234└─@Component └─@Service └─@FirstLevelService └─@SecondLevelService我们将TestService上的注解换成@SecondLevelService，然后再次运行ServiceBootStrap的main方法，输出如下：可见结果也是成功的。这里有一点需要注意的是：@Component注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个value属性定义。@Enable模块驱动@Enable模块驱动在Spring Framework 3.1后开始支持。这里的模块通俗的来说就是一些为了实现某个功能的组件的集合。通过@Enable模块驱动，我们可以开启相应的模块功能。@Enable模块驱动可以分为“注解驱动”和“接口编程”两种实现方式，下面逐一进行演示：注解驱动Spring中，基于注解驱动的示例可以查看@EnableWebMvc源码：123456@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123;&#125;该注解通过@Import导入一个配置类DelegatingWebMvcConfiguration：该配置类又继承自WebMvcConfigurationSupport，里面定义了一些Bean的声明。所以，基于注解驱动的@Enable模块驱动其实就是通过@Import来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。我们来定义一个基于注解驱动的@Enable模块驱动。在com.example.demo下新建configuration包，然后创建一个HelloWorldConfiguration配置类：12345678@Configurationpublic class HelloWorldConfiguration &#123; @Bean public String hello() &#123; return "hello world"; &#125;&#125;这个配置类里定义了一个名为hello的Bean，内容为hello world。在com.example.demo.annotation下创建一个EnableHelloWorld注解定义：123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(HelloWorldConfiguration.class)public @interface EnableHelloWorld &#123;&#125;我们在该注解类上通过@Import导入了刚刚创建的配置类。接着在com.example.demo.bootstrap下创建一个TestEnableBootstap启动类来测试@EnableHelloWorld注解是否生效：1234567891011@EnableHelloWorldpublic class TestEnableBootstap &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = new SpringApplicationBuilder(TestEnableBootstap.class) .web(WebApplicationType.NONE) .run(args); String hello = context.getBean("hello", String.class); System.out.println("hello Bean: " + hello); context.close(); &#125;&#125;运行该类的main方法，控制台输出如下：说明我们自定义的基于注解驱动的@EnableHelloWorld是可行的。接口编程除了使用上面这个方式外，我们还可以通过接口编程的方式来实现@Enable模块驱动。Spring中，基于接口编程方式的有@EnableCaching注解，查看其源码：1234567891011@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;CachingConfigurationSelector.class&#125;)public @interface EnableCaching &#123; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default 2147483647;&#125;EnableCaching注解通过@Import导入了CachingConfigurationSelector类，该类间接实现了ImportSelector接口，在 深入学习Spring组件注册 中，我们曾介绍了可以通过ImportSelector来实现组件注册。所以通过接口编程实现@Enable模块驱动的本质是：通过@Import来导入接口ImportSelector实现类，该实现类里可以定义需要注册到IOC容器中的组件，以此实现相应模块对应组件的注册。接下来我们根据这个思路来自个实现一遍：在com.example.demo下新建selector包，然后在该路径下新建一个HelloWorldImportSelector实现ImportSelector接口：123456public class HelloWorldImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;HelloWorldConfiguration.class.getName()&#125;; &#125;&#125;如果看不懂上面这段代码含义的朋友可以阅读深入学习Spring组件注册一文。接着我们修改EnableHelloWorld：123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(HelloWorldImportSelector.class)public @interface EnableHelloWorld &#123;&#125;上面导入的是HelloWorldImportSelector，而非HelloWorldConfiguration。再次运行TestEnableBootstap的main方法，你会发现输出是一样的。自动装配Spring Boot中的自动装配技术底层主要用到了下面这些技术:Spring 模式注解装配Spring @Enable 模块装配Spring 条件装配装（深入学习Spring组件注册中有介绍）Spring 工厂加载机制Spring 工厂加载机制的实现类为SpringFactoriesLoader，查看其源码：该类的方法会读取META-INF目录下的spring.factories配置文件，我们查看spring-boot-autoconfigure-2.1.0.RELEASE.jar下的该文件：当启动类被@EnableAutoConfiguration标注后，上面截图中的所有类Spring都会去扫描，看是否可以纳入到IOC容器中进行管理。比如我们查看org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration的源码：可看到该类上标注了一些注解，其中@Configuration为模式注解，@EnableConfigurationProperties为模块装配技术，ConditionalOnClass为条件装配技术。这和我们上面列出的Spring Boot自动装配底层主要技术一致，所以我们可以根据这个思路来自定义一个自动装配实现。新建一个配置类HelloWorldAutoConfiguration：12345@Configuration@EnableHelloWorld@ConditionalOnProperty(name = "helloworld", havingValue = "true")public class HelloWorldAutoConfiguration &#123;&#125;然后在resources目录下新建META-INF目录，并创建spring.factories文件：123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.example.demo.configuration.HelloWorldAutoConfiguration接着在配置文件application.properties中添加helloworld=true配置1helloworld=true最后创建EnableAutoConfigurationBootstrap，测试下HelloWorldAutoConfiguration是否生效：123456789101112@EnableAutoConfigurationpublic class EnableAutoConfigurationBootstrap &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = new SpringApplicationBuilder(EnableAutoConfigurationBootstrap.class) .web(WebApplicationType.NONE) .run(args); String hello = context.getBean("hello", String.class); System.out.println("hello Bean: " + hello); context.close(); &#125;&#125;运行该main方法，控制台输出如下：说明我们自定义的自动装配已经成功了。下面简要分析下代码的运行逻辑：Spring 的工厂加载机制会自动读取META-INF目录下spring.factories文件内容；我们在spring.factories定义了：12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.example.demo.configuration.HelloWorldAutoConfiguration我们在测试类上使用了@EnableAutoConfiguration注解标注，那么HelloWorldAutoConfiguration就会被Spring扫描，看是否符合要求，如果符合则纳入到IOC容器中；HelloWorldAutoConfiguration上的@ConditionalOnProperty的注解作用为：当配置文件中配置了helloworld=true（我们确实添加了这个配置，所以符合要求）则这个类符合扫描规则；@EnableHelloWorld注解是我们前面例子中自定义的模块驱动注解，其引入了hello这个Bean，所以IOC容器中便会存在hello这个Bean了；通过上面的步骤，我们就可以通过上下文获取到hello这个Bean了。源码链接： https://github.com/wuyouzhuguli/SpringAll/tree/master/44.Spring-Boot-Autoconfiguration]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习Spring Bean生命周期]]></title>
    <url>%2FSpring-Bean-Lifecycle.html</url>
    <content type="text"><![CDATA[所谓Spring Bean的生命周期指的是Bean从创建到初始化再到销毁的过程，这个过程由IOC容器管理。一个完整的Bean生命周期可以参考Spring Bean生命周期。这里我们主要记录一些和Bean生命周期相关的细节。Bean的初始化和销毁在整个生命周期过程中，我们可以自定义Bean的初始化和销毁钩子函数，当Bean的生命周期到达相应的阶段的时候，Spring会调用我们自定义的Bean的初始化和销毁方法。自定义Bean初始化和销毁方法有多种方式，下面逐一介绍。@Bean上一节中介绍了可以在配置类中通过@Bean注解来注册Bean，我们也可以通过它来指定Bean的初始化和方法。为了演示，我们新建一个Spring Boot项目，然后创建一个User类：1234567891011public class User &#123; public User() &#123; System.out.println("调用无参构造器创建User"); &#125; public void init() &#123; System.out.println("初始化User"); &#125; public void destory() &#123; System.out.println("销毁User"); &#125;&#125;然后在配置类里注册该组件，并指定初始化和销毁方法：12345678@Configurationpublic class WebConfig &#123; @Bean(initMethod = "init", destroyMethod = "destory") public User user() &#123; return new User(); &#125;&#125;其中initMethod = &quot;init&quot;和destroyMethod = &quot;destory&quot;与User类里的init，destory方法相对应。在Spring Boot入口类中测试:12345// 返回 IOC 容器，使用注解配置，传入配置类AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);User user = context.getBean(User.class);// 关闭 IOC 容器context.close();启动项目，观察控制台输出:从上面的输出我们看出在容器启动之前，先调用对象的无参构造器创建对象，然后调用初始化方法，在容器关闭的时候调用销毁方法。上面的情况是对于单例而言的，如果组件是多例模式又是什么情况呢？我们把上面的组件注册配置改为多例，然后再次启动项目，观察控制台输出:控制台的输出和我们上节讨论的一致，即在多例模式下，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象，创建完对象后再调用初始化方法。但在容器关闭后，Spring并没有调用相应的销毁方法，这是因为在多例模式下，容器不会管理这个组件（只负责在你需要的时候创建这个组件），所以容器在关闭的时候并不会调用相应的销毁方法。InitializingBean&amp;DisposableBean除了上面这种方式指定初始化和销毁方法外，Spring还为我们提供了和初始化，销毁相对应的接口：InitializingBean接口包含一个afterPropertiesSet方法，我们可以通过实现该接口，然后在这个方法中编写初始化逻辑。DisposableBean接口包含一个destory方法，我们可以通过实现该接口，然后再这个方法中编写销毁逻辑。新建一个类，名称为Bird，然后实现这两个接口：123456789101112131415public class Bird implements InitializingBean, DisposableBean &#123; public Bird() &#123; System.out.println("调用无参构造器创建Bird"); &#125; @Override public void destroy() &#123; System.out.println("销毁Bird"); &#125; @Override public void afterPropertiesSet() &#123; System.out.println("初始化Bird"); &#125;&#125;在配置类中注册这个组件:1234@Beanpublic Bird bird() &#123; return new Bird();&#125;测试一波：123AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);System.out.println("容器创建完毕");context.close();启动项目，观察控制台输出:@PostConstruct&amp;@PreDestroy除了上面两种指定初始化和销毁方法的方式外，我们还可以使用@PostConstruct和@PreDestroy注解修饰方法来指定相应的初始化和销毁方法。新建一个类，名称为Fish：123456789101112131415public class Fish &#123; public Fish() &#123; System.out.println("调用无参构造器创建Fish"); &#125; @PostConstruct public void init() &#123; System.out.println("初始化Fish"); &#125; @PreDestroy public void destory() &#123; System.out.println("销毁Fish"); &#125;&#125;在配置类中注册这个组件:1234@Beanpublic Fish fish()&#123; return new Fish();&#125;测试一波：123AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);System.out.println("容器创建完毕");context.close();启动项目，观察控制台输出:效果和上面两种方式一致。这两个注解并非Spring提供，而是JSR250规范提供。BeanPostProcessorSpring提供了一个BeanPostProcessor接口，俗称Bean后置通知处理器，它提供了两个方法postProcessBeforeInitialization和postProcessAfterInitialization。其中postProcessBeforeInitialization在组件的初始化方法调用之前执行，postProcessAfterInitialization在组件的初始化方法调用之后执行。它们都包含两个入参：bean：当前组件对象；beanName：当前组件在容器中的名称。两个方法都返回一个Object类型，我们可以直接返回当前组件对象，或者包装后返回。我们来定义一个BeanPostProcessor接口的实现类MyBeanPostProcessor：123456789101112public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(beanName + " 初始化之前调用"); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(beanName + " 初始化之后调用"); return bean; &#125;&#125;在配置类中注册该组件:1234@Beanpublic MyBeanPostProcessor myBeanPostProcessor () &#123; return new MyBeanPostProcessor();&#125;再次启动项目，观察控制台输出:源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/51.Spring-Bean-Lifecycle]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习Spring组件注册]]></title>
    <url>%2FSpring-Bean-Regist.html</url>
    <content type="text"><![CDATA[接触过Spring的同学肯定都听过IOC。在传统的Java编程中，当需要用到某个对象的时候，我们都是主动显式创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。这里主要记录组件注册的一些细节。通过@Bean注册组件在较早版本的Spring中，我们都是通过XML的方式来往IOC容器中注册组件的，下面这段代码大家肯定不会陌生：123// 返回 IOC 容器，基于 XML配置，传入配置文件的位置ApplicationContext applicationContext = new ClassPathXmlApplicationContext("xxx.xml");User user = (User) applicationContext.getBean("user");Spring 4后推荐我们使用Java Config的方式来注册组件。为了演示，我们通过http://start.spring.io/搭建一个简单Spring Boot应用，然后引入Lombok依赖（编辑器也需要安装Lombok插件）：12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;然后创建一个User类：1234567@ToString@AllArgsConstructor@Datapublic class User &#123; private String name; private Integer age;&#125;接着创建一个配置类，在里面通过@Bean注解注册User类：1234567@Configurationpublic class WebConfig &#123; @Bean() public User user() &#123; return new User("mrbird", 18); &#125;&#125;通过@Bean注解，我们向IOC容器注册了一个名称为user（Bean名称默认为方法名，我们也可以通过@Bean(&quot;myUser&quot;)方式来将组件名称指定为myUser）。组件注册完毕后，我们测试一下从IOC容器中获取这个组件。在Spring Boot入口类中编写如下代码：1234567891011@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); // 返回 IOC 容器，使用注解配置，传入配置类 ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class); User user = context.getBean(User.class); System.out.println(user); &#125;&#125;因为我们是通过注解方式来注册组件的，所以需要使用AnnotationConfigApplicationContext来获取相应的IOC容器，入参为配置类。启动项目，看下控制台输出：说明组件注册成功。我们将组件的名称改为myUser，然后看看IOC容器中，User类型组件是否叫myUser：1234567891011@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class); // 查看 User 这个类在 Spring 容器中叫啥玩意 String[] beanNames = context.getBeanNamesForType(User.class); Arrays.stream(beanNames).forEach(System.out::println); &#125;&#125;启动项目，观察控制台输出:使用@ComponentScan扫描在使用XML配置组件扫描的时候，我们都是这样配置的：1&lt;context:component-scan base-package=""&gt;&lt;/context:component-scan&gt;其中base-package指定了扫描的路径。路径下所有被@Controller、@Service、@Repository和@Component注解标注的类都会被纳入IOC容器中。现在我们脱离XML配置后，可以使用@ComponentScan注解来扫描组件并注册。在使用@ComponentScan扫描之前，我们先创建一个Controller，一个Service，一个Dao，并标注上相应的注解。然后修改配置类：123456789@Configuration@ComponentScan("cc.mrbird.demo")public class WebConfig &#123; // @Bean("myUser") // public User user() &#123; // return new User("mrbird", 18); // &#125;&#125;在配置类中，我们通过@ComponentScan(&quot;cc.mrbird.demo&quot;)配置了扫描路径，并且将User组件注册注释掉了，取而代之的是在User类上加上@Component注解：123456789@ToString@AllArgsConstructor@NoArgsConstructor@Data@Componentpublic class User &#123; private String name; private Integer age;&#125;值得注意的是，我们不能将Spring Boot的入口类纳入扫描范围中，否则项目启动将出错。接下来我们看下在基于注解的IOC容器中是否包含了这些组件：1234567891011@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class); // 查看基于注解的 IOC容器中所有组件名称 String[] beanNames = context.getBeanDefinitionNames(); Arrays.stream(beanNames).forEach(System.out::println); &#125;&#125;启动项目，观察控制台：可见，组件已经成功被扫描进去了，并且名称默认为类名首字母小写。这里，配置类WebConfig也被扫描并注册了，查看@Configuration源码就会发现原因：1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; String value() default "";&#125;指定扫描策略@ComponentScan注解允许我们指定扫描策略，即指定哪些被扫描，哪些不被扫描，查看其源码可发现这两个属性：1234567891011121314151617/** * Specifies which types are eligible for component scanning. * &lt;p&gt;Further narrows the set of candidate components from everything in &#123;@link #basePackages&#125; * to everything in the base packages that matches the given filter or filters. * &lt;p&gt;Note that these filters will be applied in addition to the default filters, if specified. * Any type under the specified base packages which matches a given filter will be included, * even if it does not match the default filters (i.e. is not annotated with &#123;@code @Component&#125;). * @see #resourcePattern() * @see #useDefaultFilters() */Filter[] includeFilters() default &#123;&#125;;/** * Specifies which types are not eligible for component scanning. * @see #resourcePattern */Filter[] excludeFilters() default &#123;&#125;;其中Filter也是一个注解:1234567891011121314151617/** * Declares the type filter to be used as an &#123;@linkplain ComponentScan#includeFilters * include filter&#125; or &#123;@linkplain ComponentScan#excludeFilters exclude filter&#125;. */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;&#125;)@interface Filter &#123; FilterType type() default FilterType.ANNOTATION; @AliasFor("classes") Class&lt;?&gt;[] value() default &#123;&#125;; @AliasFor("value") Class&lt;?&gt;[] classes() default &#123;&#125;; String[] pattern() default &#123;&#125;;&#125;接下来我们使用excludeFilters来排除一些组件的扫描：12345678910@Configuration@ComponentScan(value = "cc.mrbird.demo", excludeFilters = &#123; @Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class, Repository.class&#125;), @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = User.class) &#125;)public class WebConfig &#123;&#125;上面我们指定了两种排除扫描的规则：根据注解来排除（type = FilterType.ANNOTATION）,这些注解的类型为classes = {Controller.class, Repository.class}。即Controller和Repository注解标注的类不再被纳入到IOC容器中。根据指定类型类排除（type = FilterType.ASSIGNABLE_TYPE），排除类型为User.class，其子类，实现类都会被排除。启动项目，观察控制台：可见排除成功。除了上面两种常用的规则外，我们还可以使用别的规则，查看FilterType源码：1234567891011121314151617181920212223242526272829303132333435public enum FilterType &#123; /** * Filter candidates marked with a given annotation. * * @see org.springframework.core.type.filter.AnnotationTypeFilter */ ANNOTATION, /** * Filter candidates assignable to a given type. * * @see org.springframework.core.type.filter.AssignableTypeFilter */ ASSIGNABLE_TYPE, /** * Filter candidates matching a given AspectJ type pattern expression. * * @see org.springframework.core.type.filter.AspectJTypeFilter */ ASPECTJ, /** * Filter candidates matching a given regex pattern. * * @see org.springframework.core.type.filter.RegexPatternTypeFilter */ REGEX, /** * Filter candidates using a given custom * &#123;@link org.springframework.core.type.filter.TypeFilter&#125; implementation. */ CUSTOM&#125;可看到，我们还可以通过ASPECTJ表达式，REGEX正则表达式和CUSTOM自定义规则（下面详细介绍）来指定扫描策略。includeFilters的作用和excludeFilters相反，其指定的是哪些组件需要被扫描：12345678@Configuration@ComponentScan(value = "cc.mrbird.demo", includeFilters = &#123; @Filter(type = FilterType.ANNOTATION, classes = Service.class) &#125;, useDefaultFilters = false)public class WebConfig &#123;&#125;上面配置了只将Service纳入IOC容器，并且需要用useDefaultFilters = false来关闭Spring默认的扫描策略才能让我们的配置生效（Spring Boot入口类的@SpringBootApplication注解包含了一些默认的扫描策略）。启动项目，观察控制台：可看到，IOC容器中将不再包含dao，controller。多扫描策略配置在Java 8之前，我们可以使用@ComponentScans来配置多个@ComponentScan以实现多扫描规则配置：而在Java 8中，新增了@Repeatable注解，使用该注解修饰的注解可以重复使用，查看@ComponentScan源码会发现其已经被该注解标注：所以除了使用@ComponentScans来配置多扫描规则外，我们还可以通过多次使用@ComponentScan来指定多个不同的扫描规则。自定义扫描策略自定义扫描策略需要我们实现org.springframework.core.type.filter.TypeFilter接口，创建MyTypeFilter实现该接口：123456public class MyTypeFilter implements TypeFilter &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; return false; &#125;&#125;该接口包含match方法，其两个入参MetadataReader和MetadataReaderFactory含义如下：MetadataReader：当前正在扫描的类的信息；MetadataReaderFactory：可以通过它来获取其他类的信息。当match方法返回true时说明匹配成功，false则说明匹配失败。继续完善这个过滤规则：1234567891011121314public class MyTypeFilter implements TypeFilter &#123; @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) &#123; // 获取当前正在扫描的类的注解信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); // 获取当前正在扫描的类的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); // 获取当前正在扫描的类的路径等信息 Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); return StringUtils.hasText("er"); &#125;&#125;上面指定了当被扫描的类名包含er时候，匹配成功，配合excludeFilters使用意指当被扫描的类名包含er时，该类不被纳入IOC容器中。我们在@ComponentScan中使用这个自定义的过滤策略：1234567@Configuration@ComponentScan(value = "cc.mrbird.demo", excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = MyTypeFilter.class) &#125;)public class WebConfig &#123;&#125;启动项目，观察输出： 因为User，UserMapper，UserService和UserController等类的类名都包含er，所以它们都没有被纳入到IOC容器中。组件作用域@Scope默认情况下，在Spring的IOC容器中每个组件都是单例的，即无论在任何地方注入多少次，这些对象都是同一个，我们来看下例子。首先将User对象中的@Component注解去除，然后在配置类中配置User Bean：1234567@Configurationpublic class WebConfig &#123; @Bean public User user() &#123; return new User("mrbird", 18); &#125;&#125;接着多次从IOC容器中获取这个组件，看看是否为同一个：12345// 返回 IOC 容器，使用注解配置，传入配置类ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);Object user1 = context.getBean("user");Object user2 = context.getBean("user");System.out.println(user1 == user2);启动项目，观察控制台输出:结果证实了上面的观点。在Spring中我们可以使用@Scope注解来改变组件的作用域：singleton：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（map.get()）；prototype：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；request：一个请求对应一个实例；session：同一个session对应一个实例。懒加载@Lazy懒加载是针对单例模式而言的，正如前面所说，IOC容器中的组件默认是单例的，容器启动的时候会调用方法创建对象然后纳入到IOC容器中。在User Bean注册的地方加入一句话以观察：12345678@Configurationpublic class WebConfig &#123; @Bean public User user() &#123; System.out.println("往IOC容器中注册user bean"); return new User("mrbird", 18); &#125;&#125;测试：12ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);System.out.println("容器创建完毕");启动项目观察控制台输出:可以看到，在IOC容器创建完毕之前，组件已经添加到容器中了。将User Bean改为懒加载的方式：123456789@Configurationpublic class WebConfig &#123; @Bean @Lazy public User user() &#123; System.out.println("往IOC容器中注册user bean"); return new User("mrbird", 18); &#125;&#125;再次启动项目，观察输出：可看到，容器创建完的时候，User Bean这个组件并未添加到容器中。所以懒加载的功能是，在单例模式中，IOC容器创建的时候不会马上去调用方法创建对象并注册，只有当组件第一次被使用的时候才会调用方法创建对象并加入到容器中。测试一下：1234ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);System.out.println("容器创建完毕");Object user1 = context.getBean("user");Object user2 = context.getBean("user");启动项目，观察输出:结果证实了我们的观点。条件注册组件@Conditional使用@Conditional注解我们可以指定组件注册的条件，即满足特定条件才将组件纳入到IOC容器中。在使用该注解之前，我们需要创建一个类，实现Condition接口：123456public class MyCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; return false; &#125;&#125;该接口包含一个matches方法，包含两个入参:ConditionContext：上下文信息；AnnotatedTypeMetadata：注解信息。简单完善一下这个实现类:1234567public class MyCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; String osName = context.getEnvironment().getProperty("os.name"); return osName != null &amp;&amp; osName.contains("Windows"); &#125;&#125;接着将这个条件添加到User Bean注册的地方：12345@Bean@Conditional(MyCondition.class)public User user() &#123; return new User("mrbird", 18);&#125;在Windows环境下，User这个组件将被成功注册，如果是别的操作系统，这个组件将不会被注册到IOC容器中。@Profile@Profile可以根据不同的环境变量来注册不同的组件，下面我们来学一下它的用法。新建一个接口CalculateService：123public interface CalculateService &#123; Integer sum(Integer... value);&#125;接着添加两个实现Java7CalculateServiceImpl和Java8CalculateServiceImpl:12345678910111213@Service@Profile("java7")public class Java7CalculateServiceImpl implements CalculateService &#123; @Override public Integer sum(Integer... value) &#123; System.out.println("Java 7环境下执行"); int result = 0; for (int i = 0; i &lt;= value.length; i++) &#123; result += i; &#125; return result; &#125;&#125;123456789@Service@Profile("java8")public class Java8CalculateServiceImpl implements CalculateService &#123; @Override public Integer sum(Integer... value) &#123; System.out.println("Java 8环境下执行"); return Arrays.stream(value).reduce(0, Integer::sum); &#125;&#125;通过@Profile注解我们实现了：当环境变量包含java7的时候，Java7CalculateServiceImpl将会被注册到IOC容器中；当环境变量包含java8的时候，Java8CalculateServiceImpl将会被注册到IOC容器中。测试一下：1234567ConfigurableApplicationContext context1 = new SpringApplicationBuilder(DemoApplication.class) .web(WebApplicationType.NONE) .profiles("java8") .run(args);CalculateService service = context1.getBean(CalculateService.class);System.out.println("求合结果： " + service.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));启动项目，控制台输出如下：如果将.profiles(&quot;java8&quot;)改为.profiles(&quot;java7&quot;)的话，控制台输出如下：导入组件@Import到目前为止，我们可以使用包扫描和@Bean来实现组件注册。除此之外，我们还可以使用@Import来快速地往IOC容器中添加组件。创建一个新的类Hello：12public class Hello &#123;&#125;然后在配置类中导入这个组件：12345@Configuration@Import(&#123;Hello.class&#125;)public class WebConfig &#123; ...&#125;查看IOC容器中所有组件的名称：123ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);String[] beanNames = context.getBeanDefinitionNames();Arrays.stream(beanNames).forEach(System.out::println);启动项目，控制台输出:可看到，通过@Import我们可以快速地往IOC容器中添加组件，Id默认为全类名。ImportSelector通过@Import我们已经实现了组件的导入，如果需要一次性导入较多组件，我们可以使用ImportSelector来实现。新增三个类Apple，Banana和Watermelon，代码略。查看ImportSelector源码：12345678public interface ImportSelector &#123; /** * Select and return the names of which class(es) should be imported based on * the &#123;@link AnnotationMetadata&#125; of the importing @&#123;@link Configuration&#125; class. */ String[] selectImports(AnnotationMetadata importingClassMetadata);&#125;ImportSelector是一个接口，包含一个selectImports方法，方法返回类的全类名数组（即需要导入到IOC容器中组件的全类名数组），包含一个AnnotationMetadata类型入参，通过这个参数我们可以获取到使用ImportSelector的类的全部注解信息。我们新建一个ImportSelector实现类MyImportSelector：12345678910public class MyImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123; "cc.mrbird.demo.domain.Apple", "cc.mrbird.demo.domain.Banana", "cc.mrbird.demo.domain.Watermelon" &#125;; &#125;&#125;上面方法返回了新增的三个类的全类名数组，接着我们在配置类的@Import注解上使用MyImportSelector来把这三个组件快速地导入到IOC容器中：1234@Import(&#123;MyImportSelector.class&#125;)public class WebConfig &#123; ...&#125;查看容器中是否已经有这三个组件:123ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);String[] beanNames = context.getBeanDefinitionNames();Arrays.stream(beanNames).forEach(System.out::println);启动项目，观察控制台：组件已经成功导入。ImportBeanDefinitionRegistrar除了上面两种往IOC容器导入组件的方法外，我们还可以使用ImportBeanDefinitionRegistrar来手动往IOC容器导入组件。查看其源码：123public interface ImportBeanDefinitionRegistrar &#123; public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);&#125;ImportBeanDefinitionRegistrar是一个接口，包含一个registerBeanDefinitions方法，该方法包含两个入参：AnnotationMetadata：可以通过它获取到类的注解信息；BeanDefinitionRegistry：Bean定义注册器，包含了一些和Bean有关的方法：123456789101112131415 public interface BeanDefinitionRegistry extends AliasRegistry &#123; void registerBeanDefinition(String var1, BeanDefinition var2) throws BeanDefinitionStoreException; void removeBeanDefinition(String var1) throws NoSuchBeanDefinitionException; BeanDefinition getBeanDefinition(String var1) throws NoSuchBeanDefinitionException; boolean containsBeanDefinition(String var1); String[] getBeanDefinitionNames(); int getBeanDefinitionCount(); boolean isBeanNameInUse(String var1);&#125;这里我们需要借助BeanDefinitionRegistry的registerBeanDefinition方法来往IOC容器中注册Bean。该方法包含两个入参，第一个为需要注册的Bean名称（Id）,第二个参数为Bean的定义信息，它是一个接口，我们可以使用其实现类RootBeanDefinition来完成：为了演示ImportBeanDefinitionRegistrar的使用，我们先新增一个类，名称为Strawberry，代码略。然后新增一个ImportBeanDefinitionRegistrar实现类MyImportBeanDefinitionRegistrar：1234567891011public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; final String beanName = "strawberry"; boolean contain = registry.containsBeanDefinition(beanName); if (!contain) &#123; RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Strawberry.class); registry.registerBeanDefinition(beanName, rootBeanDefinition); &#125; &#125;&#125;在上面的实现类中，我们先通过BeanDefinitionRegistry的containsBeanDefinition方法判断IOC容器中是否包含了名称为strawberry的组件，如果没有，则手动通过BeanDefinitionRegistry的registerBeanDefinition方法注册一个。定义好MyImportBeanDefinitionRegistrar后，我们同样地在配置类的@Import中使用它：12345@Configuration@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)public class WebConfig &#123; ...&#125;查看容器中是否已经有这个组件:123ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);String[] beanNames = context.getBeanDefinitionNames();Arrays.stream(beanNames).forEach(System.out::println);启动项目，观察控制台：组件已经注册成功。使用FactoryBean注册组件Spring还提供了一个FactoryBean接口，我们可以通过实现该接口来注册组件，该接口包含了两个抽象方法和一个默认方法：为了演示FactoryBean的使用，我们新增一个Cherry类，代码略。然后创建FactoryBean的实现类CherryFactoryBean:12345678910111213141516public class CherryFactoryBean implements FactoryBean&lt;Cherry&gt; &#123; @Override public Cherry getObject() &#123; return new Cherry(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Cherry.class; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125;getObject返回需要注册的组件对象，getObjectType返回需要注册的组件类型，isSingleton指明该组件是否为单例。如果为多例的话，每次从容器中获取该组件都会调用其getObject方法。定义好CherryFactoryBean后，我们在配置类中注册这个类：1234@Beanpublic CherryFactoryBean cherryFactoryBean() &#123; return new CherryFactoryBean();&#125;测试从容器中获取：123ApplicationContext context = new AnnotationConfigApplicationContext(WebConfig.class);Object cherry = context.getBean("cherryFactoryBean");System.out.println(cherry.getClass());启动项目，观察控制台输出：可看到，虽然我们获取的是Id为cherryFactoryBean的组件，但其获取到的实际是getObject方法里返回的对象。如果我们要获取cherryFactoryBean本身，则可以这样做：12Object cherryFactoryBean = context.getBean("&amp;cherryFactoryBean");System.out.println(cherryFactoryBean.getClass());启动项目，观察控制台：为什么加上&amp;前缀就可以获取到相应的工厂类了呢，查看BeanFactory的源码会发现原因:源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/50.Spring-Regist-Bean]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo的高可用]]></title>
    <url>%2FDubbo-High-Availability.html</url>
    <content type="text"><![CDATA[Dubbo的一些自身特性确保了Dubbo的高可用，比如当注册中心宕机后，服务提供者和服务消费者仍能通过本地缓存通讯；注册中心对等集群，任意一台宕掉后，将自动切换到另一台；当有多台服务提供者提供服务时，Dubbo内置了几种负载均衡算法，并且服务提供者是无状态的，任意一台宕掉后，不影响使用；我们还可以通过整合Hystrix来实现服务降级。注册中心这里模拟一下当所有服务注册中心宕机后，服务提供者和服务消费者是否能够正常通讯。在上一节的例子上，启动Zookeeper，然后分别启动server-proivder和server-consumer，启动好后关闭Zookeeper，这时候注册中心是宕机的状态：访问http://localhost:8081/hello/mrbird看是否可以成功消费服务：可以看到服务提供者和服务消费者通讯是正常的，因为注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。Dubbo直连使用注册中心来维护服务可以降低后期维护和拓展的复杂度，降低耦合。不过Dubbo也提供了绕过注册中心的方法，即服务消费者不通过注册中心，而是直接取访问服务提供者来获取服务，这种方式也称为Dubbo直连。我们在服务消费者的@Reference注解上直接指定服务提供者的地址，即可实现Dubbo直连：12@Reference(url = "http://127.0.0.1:8080")private HelloService helloService;负载均衡Dubbo提供了四种负载均衡机制：RandomLoadBalance，LeastActiveLoadBalance，ConsistentHashLoadBalance和RoundRobinLoadBalance。RandomLoadBalanceRandomLoadBalance是基于权重的负载均衡机制。假如现在有一个由三个服务提供者构成的集群，Server1的权重为100，Server2的权重为200，Server3的权重为300，那么当一个服务消费请求发送过来时，有1/6的几率命中Server1，1/3的记录命中Server2，1/2的记录命中Server3。LeastActiveLoadBalanceLeastActiveLoadBalance俗称最小活跃数负载均衡，假如现在有一个由Server1、Server2和Server3三个服务提供者构成的集群，在上一次请求中，Server1的耗时为100ms，Server2的耗时为200ms，Server3的耗时为300ms，那么当一个新的请求到来时，会命中耗时最少的那个服务，即Server1。ConsistentHashLoadBalance详见官方文档介绍：http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html。RoundRobinLoadBalanceRoundRobinLoadBalance是基于权重的轮询负载均衡机制，即服务请求在轮询的同时还得考虑权重。举个例子：假如现在有一个由三个服务提供者构成的集群，Server1的权重为100，Server2的权重为200，Server3的权重为300，现在有6个服务消费请求依法发送过来，按照轮询机制，第1个请求命中Server1，第2个请求命中Server2，第3个请求命中Server3，到这里三个服务提供者已经轮询完一次，第4个请求本应该从新开始轮询，命中Server1，但是由于Server1的权重为100（占1/6，即6次只会命中一次），所以第4个请求会被分配到Server2。接着轮询，第5个请求将命中Server3，第6个请求命中Server2。所以这6个请求命中的顺序为123232，这个概率和服务提供者的权重比相匹配。机制选择默认情况下，Dubbo采用RandomLoadBalance负载均衡机制。我们可以在服务提供者和服务消费者上指定使用哪种负载均衡：在客户端的@Reference注解上指定：12@Reference(loadbalance = RoundRobinLoadBalance.NAME)private HelloService helloService;在服务端的@Server注解上指定：1@Service(interfaceClass = HelloService.class, loadbalance = RoundRobinLoadBalance.NAME)权重分配我们可以在Dubbo提供的@Server注解上指定暴露服务的权重：1@Service(interfaceClass = HelloService.class, weight = 100)这时候在Dubbo Admin里可以看到这个服务的权重就为100了：我们可以可以通过Dubbo Admin来动态调节服务的权重:集群容错Dubbo支持多种容错模式：http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html服务降级Dubbo默认支持两种降级策略:mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。我们可以在Dubbo Admin控制台上来处理降级。为了模拟错误情况，我们改造服务提供者实现的hello方法：12345678910@Overridepublic String hello(String message) &#123; System.out.println("调用 cc.mrbird.provider.service.HelloServiceImpl#hello"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return "hello," + message;&#125;方法中让线程阻塞了2秒。接着改造服务消费者，在@Reference注解上配置超时时间：12@Reference(timeout = 1000)private HelloService helloService;在不进行服务降级的情况下，访问http://localhost:8081/hello/mrbird将看抛出异常:在Dubbo Admin消费者列表上的屏蔽按钮对应mock=force:return+null策略，即不调用服务，直接返回null，点击屏蔽后，再次访问http://localhost:8081/hello/mrbird：服务提供者的控制台也没有任何调用日志:而容错按钮则对应mock=fail:return+null机制。点击容错按钮，再次访问http://localhost:8081/hello/mrbird：上述结果证明了在mock=fail:return+null策略下，消费方对该服务的方法调用在失败后，再返回 null 值（之所以会输出多次调用日志，是因为Dubbo的重试机制）。整合Hystrix我们可以通过整合Spring-Cloud-Hystrix和Dubbo来拓展服务降级。在server-provider里引入Hystrix依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;然后再server-provider的入口类上使用@EnableHystrix注解开启Hystrix功能。接着改造server-provider的HelloServiceImpl：1234567891011121314151617@Service(interfaceClass = HelloService.classE)@Componentpublic class HelloServiceImpl implements HelloService &#123; @Override @HystrixCommand(fallbackMethod = "defaultHello") public String hello(String message) &#123; System.out.println("调用 cc.mrbird.provider.service.HelloServiceImpl#hello"); String a = null; a.toString(); return "hello," + message; &#125; public String defaultHello(String message) &#123; return "hello anonymous"; &#125;&#125;在hello方法中，我们制造一个空指针异常，通过@HystrixCommand(fallbackMethod = &quot;defaultHello&quot;)指定了降级的方法为defaultHello。值得注意的是，降级方法的方法参数和返回类型必须和原方法保持一致，不熟悉的读者可以参考https://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html。改造好后，重启服务提供者和服务消费者，访问http://localhost:8081/hello/mrbird：可见服务已经成功降级。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/53.Dubbo-High-Availability]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监控Dubbo服务]]></title>
    <url>%2Fdubbo-mointor.html</url>
    <content type="text"><![CDATA[Dubbo给我们提供了dubbo-admin和dubbo-monitor-simple用于监控Dubbo服务，可以用来监控接口暴露，注册情况，也可以显示接口的调用明细和调用时间。dubbo-admin和dubbo-monitor-simple的下载地址为：https://github.com/apache/incubator-dubbo-admin/tree/master，这里简单介绍它们如何使用。准备要监控Dubbo服务，首先我们必须在Dubbo应用上提供连接监控中心的配置，Dubbo支持两种方式：属性对应URL参数类型是否必填缺省值作用描述兼容性protocolprotocolstring可选dubbo服务治理监控中心协议，如果为protocol=”registry”，表示从注册中心发现监控中心地址，否则直连监控中心。2.0.9以上版本address&lt;url&gt;string可选N/A服务治理直连监控中心服务器地址，address=”10.20.130.230:12080”1.0.16以上版本这里我们采用第一种方式，在上一节中的server-provider和server-consumer的配置文件中添加如下配置:123dubbo: monitor: protocol: registry配置好后，依次启动server-provider和server-consumer，接下来开始搭建监控中心。dubbo-monitor-simple下载https://github.com/apache/incubator-dubbo-admin/tree/master源码后，使用IDEA导入dubbo-monitor-simple应用，修改其配置文件dubbo.properties内容：1234567891011dubbo.container=log4j,spring,registry,jetty-monitordubbo.application.name=simple-monitordubbo.application.owner=dubbodubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.protocol.port=7070dubbo.jetty.port=7000dubbo.jetty.directory=$&#123;user.home&#125;/monitordubbo.charts.directory=$&#123;user.home&#125;/monitor/chartsdubbo.statistics.directory=$&#123;user.home&#125;/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN上面主要指定了注册中心地址为zookeeper://127.0.0.1:2181，监控中心协议端口为7070以及监控应用访问端口为7000。配置好后，运行启动类MonitorStarter的main方法来启动应用，启动后，访问http://localhost:7000便可看到如下页面：在线应用信息:多次访问http://localhost:8081/hello/mrbird后，便可以在监控中心查看服务调用情况：dubbo-admin使用IDEA导入dubbo-admin应用，修改其配置文件application.properties：12345678910server.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181上面配置主要配置了注册中心地址为zookeeper://127.0.0.1:2181，应用端口号为7001，root和guest账户的密码。配置好后，启动应用（dubbo-admin使用Spring Boot构建，启动入口类即可），访问http://localhost:7001：duubo提供了新版的dubbo-admin，采用前后端分离的方式，前端由Vue.js构建，UI更为nice，不过还不完善，所以这里就不介绍了。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/52.Dubbo-OPS-Mointor]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Dubbo&Zookeeper]]></title>
    <url>%2FSpring-Boot-Dubbo-Zookeeper.html</url>
    <content type="text"><![CDATA[Dubbo是一款由阿里巴巴开发的远程服务调用框架（RPC），其可以透明化的调用远程服务，就像调用本地服务一样简单。截至目前，Dubbo发布了基于Spring Boot构建的版本，版本号为0.2.0，这使得其与Spring Boot项目整合变得更为简单方便。而Zookeeper在这里充当的是服务注册中心的角色，我们将各个微服务提供的服务通过Dubbo注册到Zookeeper中，然后服务消费者通过Dubbo从Zookeeper中获取相应服务并消费。本文案例的架构图可以简单用下图表示： 本文案例最终项目结构如下图所示：项目采用Maven构建，各模块的作用：模块描述common-api统一定义接口，供其余子模块引用server-provider服务提供者，实现common-api模块中的接口，然后暴露到Zookeeper中，供服务消费者使用server-consumer服务消费者，通过Dubbo从Zookeeper中获取服务并消费环境准备Zookeeper安装在搭建项目之前需要启动Zookeeper服务，Zookeeper下载地址：http://zookeeper.apache.org/releases.html#download。下载后解压，将config目录下的zoo_sample.cfg重命名为zoo.cfg(Zookeeper配置文件，默认端口为2181，可根据实际进行修改)。然后双击bin目录下的zkServer.cmd启动即可。构建父模块新建一个Maven项目，groupId为cc.mrbird，artifactId为dubbo-boot，packaging指定为pom。然后引入Spring Boot，dubbo-spring-boot-starter和Zookeeper相关依赖：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;dubbo-boot&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;dubbo-boot&lt;/name&gt; &lt;description&gt;Spring Boot-Dubbo-ZooKeeper&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.version&gt;1.0&lt;/project.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- dubbo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;构建Common-api新建一个Maven模块，artifactId为common-api，目录结构如下所示：pom.xml：12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo-boot&lt;/artifactId&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common-api&lt;/artifactId&gt;&lt;/project&gt;项目只包含一个HelloService接口：12345package cc.mrbird.common.api;public interface HelloService &#123; String hello(String message);&#125;至此我们可以开始构建服务提供者和服务消费者了。构建Server-Provider新建一个Maven模块，用于暴露Dubbo服务，artifactId为server-provider，目录结构如下所示：pom内容如下：123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo-boot&lt;/artifactId&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;server-provider&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;common-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;这里我们引入了common-api模块，用于后续实现相应的服务。在Spring Boot启动类中我们加入@EnableDubbo注解，表示要开启dubbo功能:123456789101112import com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@EnableDubbo@SpringBootApplicationpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); System.out.println("complete"); &#125;&#125;接着在application.yml中配置Dubbo：12345678910111213141516server: port: 8080dubbo: application: # 服务名称，保持唯一 name: server-provider # zookeeper地址，用于向其注册服务 registry: address: zookeeper://127.0.0.1:2181 #暴露服务方式 protocol: # dubbo协议，固定写法 name: dubbo # 暴露服务端口 （默认是20880，不同的服务提供者端口不能重复） port: 20880如果Zookeeper是集群的话，spring.dubbo.registry.address配置为：1234spring: dubbo: registry: address: zookeeper://127.0.0.1:2181?backup=127.0.0.1:2180,127.0.0.1:2182接下来我们在cc.mrbird.provider.service路径下创建一个HelloService接口的实现类：123456789101112import cc.mrbird.common.api.HelloService;import com.alibaba.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Service(interfaceClass = HelloService.class)@Componentpublic class HelloServiceImpl implements HelloService &#123; @Override public String hello(String message) &#123; return "hello," + message; &#125;&#125;值得注意的是@Service注解为Dubbo提供的com.alibaba.dubbo.config.annotation.Service，而非Spring的那个。其中interfaceClass是指要发布服务的接口。通过上面的配置，我们已经将HelloService接口的实现暴露到Zookeeper中了，接下来我们继续创建一个服务消费者，来消费这个服务。搭建Server-Consumer新建一个Maven模块，用于消费Dubbo服务，artifactId为server-consumer，目录结构如下所示：pom内容如下：123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubbo-boot&lt;/artifactId&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;server-consumer&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;common-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;同样的，我们也在Spring Boot启动类中我们加入@EnableDubbo注解，表示要开启dubbo功能。接着在application.yml中配置Dubbo：12345678910111213server: port: 8081dubbo: application: # 服务名称，保持唯一 name: server-consumer # zookeeper地址，用于从中获取注册的服务 registry: address: zookeeper://127.0.0.1:2181 protocol: # dubbo协议，固定写法 name: dubbo同服务提供者，我们需要指定Zookeeper的地址，协议为dubbo。接着我们定义一个TestController，演示服务消费：1234567891011121314151617import cc.mrbird.common.api.HelloService;import com.alibaba.dubbo.config.annotation.Reference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Reference private HelloService helloService; @GetMapping("/hello/&#123;message&#125;") public String hello(@PathVariable String message) &#123; return this.helloService.hello(message); &#125;&#125;通过Dubbo的@Reference注解注入需要使用的interface，类似于Spring的@Autowired。测试分别启动Server-Provider和Server-Consumer，访问http://localhost:8081/hello/mrbird：说明远程服务调用已经成功。这里只是通过Spring Boot和Dubbo的整合来简单了解Dubbo的使用，仅作抛砖引玉，更为详细的Dubbo配置可以查看官方文档：http://dubbo.apache.org/zh-cn/docs/user/quick-start.html源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/40.Spring-Boot-Dubbo-Zookeeper]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Dubbo</tag>
        <tag>Spring Boot</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用WireMock快速伪造RESTful服务]]></title>
    <url>%2FWireMock-mock-RESTful.html</url>
    <content type="text"><![CDATA[前后端分离的开发模式已经越来越流行，但是前后端的开发进度并不能完全保持一致，当前端需要调用后端尚未开发的RESTful接口时不得不等待后端开发完毕，这将影响并行开发的效率。http://wiremock.org就是一款用于解决这个问题的开源框架。WireMock可以快速的伪造RESTful接口并返回伪造的JSON数据。这里简单记录下WireMock的使用方法。搭建WireMock服务器我们在本地搭建一个WireMock服务器。通过http://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-standalone/2.18.0/wiremock-standalone-2.18.0.jar下载wiremock-standalone-x.xx.xx.jar，然后使用java -jar命令运行：1java -jar wiremock-standalone-2.18.0.jar --port=8080启动界面： WireMock的简单使用为了方便，我们在Spring Boot环境里进行编写。在项目中引入WireMock依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt; &lt;artifactId&gt;wiremock&lt;/artifactId&gt; &lt;version&gt;2.18.0&lt;/version&gt;&lt;/dependency&gt;新建一个MockServer类，包含main方法，并引入com.github.tomakehurst.wiremock.client.WireMock的所有静态方法：12345678910111213141516import static com.github.tomakehurst.wiremock.client.WireMock.*;public class MockService &#123; public static void main(String[] args) &#123; // 配置WireMock服务器的地址 http://localhost:8080 configureFor("127.0.0.1", 8080); // 清除WireMock服务器里之前的配置 removeAllMappings(); //伪造一个get请求，请求地址为 /user/1，然后返回体包含JSON数据，状态为200 stubFor(get(urlEqualTo("/user/1")) .willReturn(aResponse() .withBody("&#123;\"name\":\"mrbird\",\"url\":\"https://mrbird.cc\",\"age\":18&#125;") .withStatus(200))); &#125;&#125;上面代码主要分为三个步骤：使用configureFor方法配置WireMock服务器的地址为http://localhost:8080；调用removeAllMappings清除WireMock服务器里所有配置；调用stubFor打桩，并模拟了一个HTTP GET请求，然后返回200状态码，返回报文头部包含JSON信息。这里URL使用方法urlEqualTo全匹配，WireMock也提供了正则表达式匹配URL的方法。在配置完了后运行main方法，就可以将我们的配置写到WireMock服务器里，这时候在浏览器中调用http://localhost:8080/user/1便能看到我们模拟的输出结果：这里推荐个在线JSON编辑器：https://www.bejson.com/jsoneditoronline/。简单封装我们可以对上面的代码进行简单的封装，方便重用：123456789import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.springframework.core.io.ClassPathResource;private static void getMock(String url, String file) throws IOException &#123; ClassPathResource resource = new ClassPathResource("mock/response/" + file); String content = StringUtils.join(FileUtils.readLines(resource.getFile(), "UTF-8").toArray(), "\n"); stubFor(get(urlPathEqualTo(url)).willReturn(aResponse().withBody(content).withStatus(200)));&#125;上面代码封装了一个getMock方法，用于处理get类型的Mock，参数为模拟URL和模拟JSON文件。我们在src/main/resource/mock/response目录下创建一个user.json文件：12345&#123; "name": "mrbird", "url": "https://mrbird.cc", "age": 18&#125;后面我们只需要像下面这样调用就行了：1getMock("/user/1", "user.json");WireMock还提供了许多别的功能，具体可以参考官方文档 http://wiremock.org/docs/。]]></content>
      <tags>
        <tag>WireMock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring Cloud Sleuth跟踪微服务]]></title>
    <url>%2FSpring-Cloud-sleuth.html</url>
    <content type="text"><![CDATA[在微服务数量较多的系统架构中，一个完整的HTTP请求可能需要经过好几个微服务。如果想要跟踪一条完整的HTTP请求链路所产生的日志，我们需要到各个微服务上去查看日志并检索出我们需要的信息。随着业务发展，微服务的数量也会越来越多，这个过程也变得愈发困难。不过不用担心，Spring Cloud Sleuth为我们提供了分布式服务跟踪的解决方案。为了演示如何使用Spring Cloud Sleuth，我们需要构建一个小型的微服务系统。准备工作这里我们需要创建两个微服务Server-Provider1和Server-Provider2，它们都具有一个名为hello的REST接口，Server-Provider1的hello接口依赖于Server-Provider2的hello接口。并将这两个服务注册到Eureka-Server服务注册中心集群。Eureka-Server服务注册中心集群直接使用https://mrbird.cc/Spring-Cloud-Eureka.html里构建的即可，这里不再赘述。创建Server-Provider1新建一个Spring Boot工程，artifactId为Server-Provider1，并引入如下依赖：123456789101112131415161718192021222324252627282930&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;spring-cloud-starter-eureka用于注册微服务，spring-cloud-starter-ribbon用于调用Server-Provider2提供的服务，spring-cloud-starter-sleuth为Spring Cloud Sleuth依赖，用于跟踪微服务请求。接着在配置文件application.yml里添加如下配置:12345678910spring: application: name: server-provider1server: port: 9000eureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/配置中指定了微服务名称为server-provider1，端口号为9000以及服务注册中心地址。然后我们在入口类中添加@EnableDiscoveryClient注解，开启服务的注册与发现。并且注册RestTemplate，用于Ribbon服务远程调用：1234567891011121314@SpringBootApplication@EnableDiscoveryClientpublic class DemoApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;最后编写REST接口：123456789101112131415@RestController@RequestMapping("hello")public class HelloController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private RestTemplate restTemplate; @GetMapping public String hello() &#123; logger.info("调用server-provider1的hello接口"); return this.restTemplate.getForEntity("http://server-provider2/hello", String.class).getBody(); &#125;&#125;在hello接口中，我们通过RestTemplate远程调用了server-provider2的hello接口。创建Server-Provider2新建一个新建一个Spring Boot工程，artifactId为Server-Provider2，依赖和Server-Provider1相同。在application.yml中添加如下配置：12345678910spring: application: name: server-provider2server: port: 9001eureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/在入口类中添加@EnableDiscoveryClient注解，开启服务注册与发现。最后编写一个REST接口，供Server-Provider1调用：123456789101112@RestController@RequestMapping("hello")public class HelloController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @GetMapping public String hello() &#123; logger.info("调用server-provider2的hello接口"); return "hello world"; &#125;&#125;至此，Server-Provider2也搭建完了。测试Spring Cloud Sleuth启动8080和8081Eureka-Server集群，然后分别启动Server-Provider1和Server-Provider2。访问http://localhost:8080/查看服务是否都启动成功：可见服务都启动成功了，我们往Server-provider1发送http://localhost:9000/hello请求，然后观察各自的日志：Server-Provider1：12018-06-25 10:13:40.921 INFO [server-provider1,939ca3c1d060ed40,939ca3c1d060ed40,false] 12516 --- [nio-9000-exec-6] c.e.demo.controller.HelloController : 调用server-provider1的hello接口Server-Provider2：12018-06-25 10:13:40.931 INFO [server-provider2,939ca3c1d060ed40,3f31114e88154074,false] 6500 --- [nio-9001-exec-3] c.e.demo.controller.HelloController : 调用server-provider2的hello接口可以看到，日志里出现了[server-provider2,939ca3c1d060ed40,3f31114e88154074,false]信息，这些信息由Spring Cloud Sleuth生成，用于跟踪微服务请求链路。这些信息包含了4个部分的值，它们的含义如下：server-provider2微服务的名称，与spring.application.name对应；939ca3c1d060ed40称为Trace ID，在一条完整的请求链路中，这个值是固定的。观察上面的日志即可证实这一点；3f31114e88154074称为Span ID，它表示一个基本的工作单元；false表示是否要将该信息输出到Zipkin等服务中来收集和展示，这里我们还没有集成Zipkin，所以为false。集成Zipkin虽然我们已经可以通过Trace ID来跟踪整体请求链路了，但是我们还是得去各个系统中捞取日志。在并发较高得时候，日志是海量的，这个时候我们可以借助Zipkin来代替我们完成日志获取与分析。Zipkin是Twitter的一个开源项目，主要包含了以下四个组件：Collector：收集器，负责收集日志信息，以供后续的存储，分析与展示；Storage：存储模块，我们可以通过它将日志存储到MySQL中；RESTful API：API组件，它主要用来提供外部访问接口。 比如给客户端展示跟踪信息，或是外接系统访问以实现监控等；WEB UI：通过web页面，我们可以轻松的分析与跟踪请求日志。搭建Zipkin-Server在完成Spring Cloud Cleuth与Zipkin的整合之前，我们需要搭建一个Zipkin服务。新建一个Spring Boot应用，artifactId为Zipkin-Server，并引入如下依赖：1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;在入口类中添加@EnableZipkinServer注解，用于启动Zipkin服务。接着在application.yml中添加如下配置：12345spring: application: name: zipkin-serverserver: port: 9100启动项目，访问http://localhost:9100：微服务引入Zipkin接着我们需要在Server-Provider1和Server-Provider2里引入Zipkin服务。分别在Server-Provider1和Server-Provider2里添加Zipkin相关依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-sleuth-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;然后分别在Server-Provider1和Server-Provider2的配置文件里添加Zipkin服务地址：123spring: zipkin: base-url: http://localhost:9100至此，微服务改造完毕。测试启动Server-Provider1和Server-Provider2，再次往Server-Provider1发送多个http://localhost:9000/hello请求，当最后一个参数为true的时候，说明该跟踪信息会输出给Zipkin Server：这时候访问http://localhost:9100，观察Zipkin web页面：点击下方的跟踪信息，我们可以看到整个链路经过了哪些服务，总耗时等信息：点击“依赖分析”也可以看到请求里微服务的关系：这里之所以要往Server-Provider1发送多个http://localhost:9000/hello请求是因为spring.sleuth.sampler.percentage默认值为0.1，即采样率才1/10。如果想每次请求都被采样，即每次请求跟踪信息的第四个参数都为true的话，可以将这个值设置为1。数据存储这些跟踪信息在Zipkin-Server服务重启后便会丢失，我们可以将这些信息存储到MySQL数据库中。我们在Zipkin-Server中添加MySQL数据库驱动和JDBC依赖：123456789101112&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-storage-mysql&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;然后在application.yml中添加数据库连接信息：123456789spring: datasource: url: jdbc:mysql://127.0.0.1:3306/zipkin?useUnicode=true&amp;characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver username: root password: 123456zipkin: storage: type: mysql配置文件中同时通过zipkin.storage.type=mysql指定了Zipkin的存储方式为MySQL。接下来创建数据库和数据库表，新建一个名为zipkin的数据库：然后导入库表，库表SQL文件在io.zipkin.java:zipkin-storage-mysql:2.6.1依赖里可以找到：创建完后，我们重启Zipkin-Server，发送http://localhost:9000/hello请求，然后查看数据库会发现跟踪信息已经存储在库表里了：Zipkin API正如上面所说的，Zipkin提供了RESTful API供我们调用，在启动Zipkin-Server的时候，控制台打印日志包含如下信息：这些接口的功能如下表所示：接口请求方式描述/trace/{traceIdHex}GET根据Trace ID获取指定跟踪信息的Span列表/tracesGET根据指定条件查询并返回符合条件的trace清单/dependenciesGET用来获取通过收集到的Span分析出的依赖关系/servicesGET用来获取服务列表/spansGET根据服务名来获取所有的Span名也可以参考https://zipkin.io/zipkin-api/。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/43.Spring-Cloud-Sleuth。参考文章 Spring Cloud微服务实战]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring Cloud Bus刷新配置]]></title>
    <url>%2FSpring-Cloud-Bus.html</url>
    <content type="text"><![CDATA[在上一节Spring Cloud Config统一配置管理中，我们实现了通过往Config-Client发送/refreshPOST请求来刷新配置。不过这种方式只对单个Config-Client有效（往哪个Config-Client发送刷新请求，哪个配置就得到刷新，剩下的Config-Client获取的仍是旧的配置信息）。当Config-Client实例集群数量较多时，如果都要手动一个一个去刷新配置，不仅麻烦还容易遗漏。值得庆幸的是，我们可以借助Spring Cloud Bus来自动刷新集群的配置信息。Spring Cloud Bus使用轻量级的消息代理（如RabbitMQ，Kafka）连接分布式系统的节点，可以以广播的形式将一些变更信息（如配置的变更）扩散到分布式链路中去。所以我们可以在Config-Server和Config-Client集群中加入Spring Cloud Bus，然后往某个Config-Server实例发送/refresh请求来刷新集群中所有实例的配置信息。在引入Spring Cloud Bus之前，我们先来简单验证下开头的结论。我们用上一节的源码为基础，来搭建Eureka-Server、Config-Server和Config-Client的集群。将这三个项目打成jar包后，分别使用以下命令来启动一个双节点的Eureka-Server集群：12java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2然后分别使用以下命令来启动一个双节点的Config-Server集群：12java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12579java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12580最后分别使用以下命令来启动一个双节点的Config-Client集群：12java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12581java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12582访问http://localhost:8080/查看集群节点是否都启动成功：这时候我们访问http://localhost:12581/message查看message的值：接着手动修改Git仓库里的message值为&#39;呵呵呵呵&#39;，并往12581端口的Config-Client发送刷新请求：12&gt; curl -u mrbird:123456 -X POST http://localhost:12581/refresh[&quot;config.client.version&quot;,&quot;message&quot;]再次访问http://localhost:12581/message：可以看到12581端口的Config-Client获取的配置信息已经得到了更新，那12582端口的Config-Client呢？访问http://localhost:12582/message看看结果：可看到，其获取的配置仍然是旧的。这也证实了我们一开始的结论。引入Spring Cloud BusSpring Cloud Bus支持RabbitMQ和Kafka等消息中间件，这里只介绍配合RabbitMQ的使用方式。RabbitMQ的安装与启动可以参考https://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html中的介绍。在Config-Server和Config-Client的pom中引入spring-cloud-starter-bus-amqp和spring-boot-starter-actuator依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;其中spring-cloud-starter-bus-amqp是Spring Cloud Bus的RabbitMQ实现，刷新用的端点由spring-boot-starter-actuator提供。然后在Config-Server和Config-Client的application.yml中引入RabbitMQ的连接信息：12345678910spring: rabbitmq: # RabbitMQ IP host: localhost # RabbitMQ Port port: 5672 # default RabbitMQ username username: guest # default RabbitMQ password password: guest到这里，对Config-Server和Config-Client改造就完成了，没错就是这么简单🙂。我们重新打包Config-Server和Config-Client，然后运行以下命令启动双节点Config-Server集群：12java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12579java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12580接着分别使用以下命令来启动一个双节点的Config-Client集群：12java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12581java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12582启动后我们访问RabbitMQ的控制页面：http://localhost:15672，可看到在Queues中多了四个springCloudBus队列：手动修改Git仓库里message的配置值为&#39;spring cloud bus&#39;，然后往任意一个Config-Server节点发送/bus/refreshPOST请求：1curl -u mrbird:123456 -X POST http://localhost:12580/bus/refresh分别访问http://localhost:12581/message和http://localhost:12582/message：配置都已刷新成功。WebHooks配合WebHooks可以实现自动配置刷新，在配置得到修改的时候它可以代替我们向Config-Server发送刷新请求。以码云为例，添加一个WebHooks：由于这里是在本地运行测试没有公网IP，所以没法测试，这里就不演示了。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/42.Spring-Cloud-Bus]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Config统一配置管理]]></title>
    <url>%2FSpring-Cloud-Config.html</url>
    <content type="text"><![CDATA[Spring Cloud Config可以对微服务配置进行统一的外部管理，并且默认采用Git来管理配置信息。相对于传统的每个微服务对应一份自个儿的配置文件来说，通过Spring Cloud Config统一管理所有微服务配置具有如下优点：1.集中管理微服务配置，当微服务数量众多的时候，使用这种方式会更为方便；2.通过Git管理微服务配置，方便追踪配置修改记录；3.可以在应用运行期间修改配置，微服务能够自动更新配置。Spring Cloud Config包含了服务端Server和客户端Client。服务端用于从Git仓库中加载配置，并且缓存到本地；客户端用于从服务端获取配置信息。所以为了演示Spring Cloud Config，我们先来搭建一个服务端。搭建Config-Server在搭建Config-Server之前，我们需要创建好一个存储配置文件的Git仓库。这里以码云为例子，创建一个名称为Spring-Cloud-Config的参考，然后往仓库的master分支push四个配置文件：四个配置文件中分别都包含了一个message属性：febs.yml:1message: 'default properties (master v1.0)'febs-dev.yml:1message: 'dev properties (master v1.0)'febs-test.yml:1message: 'test properties (master v1.0)'febs-pro.yml:1message: 'pro properties (master v1.0)'接着创建一个test分支，同样push这四个配置文件，不过配置文件中message属性的内容末尾都改为了(test v1.0)。创建好配置文件仓库后，我们新建一个Spring Boot项目，artifactId为Config-Server，然后引入如下依赖：12345678910111213141516171819202122&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;在入口类中加入@EnableConfigServer注解，开启Spring Cloud Config服务端功能。接着配置application.yml：123456789101112spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/mrbird/spring-cloud-config username: xxx password: xxxserver: port: 12580uri的末尾加不加.git都可以。配置具体含义如下：spring.cloud.config.server.git.uri：配置了Git仓库的地址，这里用的是码云，当然你也可以使用别的Git代码托管平台；spring.cloud.config.server.git.username：仓库用户名，即Git托管平台的用户名；spring.cloud.config.server.git.password：仓库密码，即Git托管平台的密码。这里服务端的端口号为12580。启动应用，我们便可以使用下面这些格式来访问配置信息了：/{application}/{profile}[/{label}]/{application}-{profile}.yml/{label}/{application}-{profile}.yml/{application}-{profile}.properties/{label}/{application}-{profile}.properties比如当我们访问http://localhost:12580/master/febs-test时，响应信息如下所示：访问http://localhost:12580/master/febs-test.yml：访问http://localhost:12580/test/febs-test.yml：至此服务端搭建成功。搭建Config-Client新建一个Spring Boot项目，artifactId为Config-Client，然后引入如下依赖：1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;编写一个Controller，用于测试获取Config-Server中配置文件的message属性值：1234567891011@RestControllerpublic class TestController &#123; @Value("$&#123;message&#125;") private String message; @GetMapping("message") public String getMessage() &#123; return this.message; &#125;&#125;要想让上面的代码顺利的获取到message属性值，我们还需要在配置文件中进行一些额外配置：1234567891011spring: application: name: febs cloud: config: profile: dev label: test uri: http://localhost:12580server: port: 12581值得注意的是，这里配置文件并不是叫application.yml，而是必须命名为bootstrap.yml。上面配置含义如下：spring.application.name: 对应配置文件规则中的{application}；spring.cloud.config.profile: 对应配置文件规则中的{profile}部分；spring.cloud.config.label: 对应配置文件规则中的{label}部分；spring.cloud.config.uri: 对应Config-Server的地址。通过上面的配置，message的内容应该是Git仓库中test分支，febs-dev.yml中的message属性值。下面我们来证实一下这个推测。启动Config-Client（Config-Server没启动的话得先启动Config-Server），访问http://localhost:12581/message：结果证实了我们的推测。Config-Server额外配置上面我们简单的地搭建了一个Config-Server，下面我们来进一步了解Config-Server的可用配置。占位符的使用在Config-Server中，除了固定配置一个Git仓库地址外，我们也可以使用占位符来灵活的指定Git仓库地址。将上面Config-Server的Git仓库地址改为：123456spring: cloud: config: server: git: uri: https://gitee.com/mrbird/&#123;application&#125;这里使用占位符{application}来代替上面的spring-cloud-config，通过这种配置，我们可以让不同的Config-Client去不同的Git仓库获取配置。比如，当Config-Client的项目名称为febs的时候，对应Git仓库地址为:https://gitee.com/mrbird/febs，当名称为test时，对应Git仓库地址为:https://gitee.com/mrbird/test。这样我们就可以为不同的项目配置不同的Git仓库。子目录支持除了使用占位符为每个项目创建单独的Git仓库来存储配置信息外，我们也可以只创建一个Git仓库来存储配置，只不过是将不同的项目配置放置到不同的目录下，只需要像下面这样配置即可：123456789spring: cloud: config: server: git: uri: https://gitee.com/mrbird/spring-cloud-config/ username: xxxx password: xxxx search-paths: '&#123;application&#125;'通过上面的配置，我们可以实现在https://gitee.com/mrbird/spring-cloud-config/仓库中，一个Config-Client对应一个配置目录的效果，即当Config-Client的项目名称为febs的时候，其搜索配置的目录为https://gitee.com/mrbird/spring-cloud-config/febs。这里search-paths的占位符必须加上单引号&#39;&#39;，否则没办法正确读取配置，具体可参考：https://blog.csdn.net/weixin_35022258/article/details/79019033clone-on-start默认情况下Config-Server在启动的时候并不会马上就去Git参考clone配置文件，只有当Config-Clinet从Config-Server获取相关配置信息的时候，其才会去进行clone操作。我们可以将clone-on-start属性设置为true，其Config-Server在启动的时候就进行clone操作：123456spring cloud: config: server: git: clone-on-start: true这样做的好处在于，当Git连接信息有误时，可以马上发现。整合Spring SecurityConfig-Server中包含了Git连接信息，为了使其更加安全，我们可以通过Spring Security来做用户名密码认证。在Config-Server中加入Spring Security依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;然后在Config-Server的配置文件application.yml中加入用户名和密码：1234security: user: name: mrbird password: 123456与此同时，我们也需要在Config-Client中配置Config-Server的用户名和密码，否则在获取配置的时候将报401错误：12345spring: cloud: config: username: mrbird password: 123456加密解密截至目前为止，Config-Server中Git仓库的密码是直接明文配置的，我们可以对这些敏感信息进行加密处理。在此之前，需要先安装JCE（Java Cryptography Extension），本文使用的是JDK 8，与之对应的JCE下载地址为：https://www.oracle.com/technetwork/java/javase/downloads/jce-all-download-5170447.html：解压后，包含三个文件：把它们复制到$JAVA HOME/jre/lib/security目录下即可。对称加密使用对称加密的方式需要在Config-Server中配置加密用的密钥：12encrypt: key: hello配置好后重启Config-Server，访问http://localhost:12580/encrypt/status查看密钥是否配置成功:可见配置并未生效，查看Spring-Cloud-Config的Github issue找到了解决办法：https://github.com/spring-cloud/spring-cloud-config/issues/767。解决办法就是需要将密钥配置在bootstrap.yml中，再次访问http://localhost:12580/encrypt/status：假如我们Git仓库的密码为mrbird123，要对其加密的话我们可以使用curl命令来获取加密后的密码：因为Config-Server设置了用户名和密码，所以在使用curl命令时，需要带上-u mrbird:123456。可看到mrbird123被加密成了f413c4d441a7a00ef82d9aedfab087dae51772276c0201a9d9b13df3e2a9b64c，因为是对称加密，所以我们也可以将f413c4d441a7a00ef82d9aedfab087dae51772276c0201a9d9b13df3e2a9b64c解密：我们用加密后的密码替换掉Git连接的明文密码：123456spring: cloud: config: server: git: password: '&#123;cipher&#125;155315857d26a3235027679a015aa7c71a15ca43ae77e2a11ce9d122d1f4bd043d18'使用{cipher}开头表明这是一个加密的内容，Config-Server会自动为其解密。当然，你还可以为任何你想加密的属性值进行加密，不限于密码。非对称加密 非对称加密相比对称加密来说显得更加安全，要生成非对称加密的密码，需要借助keytool命令来生成密钥。keytool是JDK中的一个密钥和证书 管理工具。 位于%JAVA_HOME%\bin\目录下：我们使用如下命令来生成一个密钥文件：命令执行结束后，会在%JAVA_HOME%\bin\目录下生成一个 config-server.keystore文件。密钥文件的有效期默认为90天，我们可以使用-validity 365来改变其有效天数为365天。接着将密钥文件拷贝到Config-Server的resources目录下，然后在bootstrap.yml中添加如下配置：123456789#encrypt:## key: helloencrypt: key-store: location: classpath:config-server.keystore alias: Config-Server password: 123456 secret: 654321其中encrypt.key-store.password为第一次输入的口令，encrypt.key-store.secret为&lt;Config-Server&gt;的密钥口令的密钥口令。我们将Git连接的密码改回明文，然后重启Config-Server，运行如下命令重新对Git连接密码进行加密：然后将加密后的密码替换明文密码即可：123456spring: cloud: config: server: git: password: '&#123;cipher&#125;AQAjzCKbjLdmgBt+Zm0/jznvbwbCAZ7j1hZKl1NtcmdEj2GFGzF02Bi5jIk9ETz92XOV3z9U5UZTEBMLblKFlZqEzFNooJAZSEmCdwDY9iI5mbhe5oGApxlhbzF4pccF9wtkt4YIW3ElQWCfg01FhDuBiDIZ8NPlMJXRDjIV+/rhla/MkdHVWaphWW3PbHlF95D7bjssCLlyeDB5BjF4orOMpVdVAT/BZA5ANy+xDbEUiOd54E9E9pYAwxG+0qW6a3PvK6OCFozVfPgvT5xorAiJ50AzIH64ZjqILSPonpk3hcIm1PlTguOE5x2BYvgxYmq/CnlkhML07yJVElVAaWh4sTIs8I5hAwQ58SvAcgq/oDE5QluF+dHvoZFn748yCe0='Config-Client额外配置刷新配置在Config-Server和Config-Client都启动后，如果这时候Git仓库存储的配置信息改变了，在不重启Config-Client的情况下，配置信息是不会跟着更新的。那么如何在Git仓库存储的配置得到改变的时候也刷新Config-Client中获取到的配置值呢？很简单，我们只需要对Config-Client进行简单的改造：在Config-Client中添加spring-boot-starter-actuator依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;该依赖包含了/refresh端点，可以用来刷新配置。然后在获取配置的Controller上加入@RefreshScope注解：123456789101112@RestController@RefreshScopepublic class TestController &#123; @Value("$&#123;message&#125;") private String message; @GetMapping("message") public String getMessage() &#123; return this.message; &#125;&#125;值得注意的是，我们需要在Config-Client的配置文件中加入如下配置来关闭认证，否则我们无权访问/refresh端点，具体可见https://github.com/spring-guides/gs-centralized-configuration/issues/5：123management: security: enabled: false重启Config-Client，访问http://localhost:12581/message:这时候我们将Git仓库中对应的配置信息改为测试配置刷新，再次访问http://localhost:12581/message会发现值还是dev properties (master v1.0)。接着我们使用以下命令来刷新配置：这时候再次访问http://localhost:12581/message：可看到在不重启Config-Client的前提下配置值已经得到了更新。集群配置如果Config-Server只是单机部署的话，当其遇到问题宕机后，所有从Config-Server获取配置信息的微服务都无法正常工作了，这是灾难性的。所以我们很有必要对Config-Server进行集群处理。集群的方式有很多，这里介绍通过将Config-Server注册到Eureka的方式来搭建集群。我们使用在Spring Cloud Eureka服务治理一节中的Eureka-Service来构建Eureka-Server服务注册中心，使用以下命令启动Eureka-Server集群：12java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2启动后，访问http://localhost:8080/:说明Eureka集群启动成功。 接下来开始对Config-Server进行改造，将其注册到Eureka服务注册中心。在Config-Server中加入Eureka依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;然后在Config-Server的启动类中加入@EnableDiscoveryClient注解，用于将服务注册到Eureka服务注册中心上：12345678@SpringBootApplication@EnableConfigServer@EnableDiscoveryClientpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;最后在配置类application.yml中指定Eureka服务注册中心的地址：1234eureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/因为之前Eureka服务注册中心添加了认证，所以需要在url中指定用户名和密码。改造好后，启动Config-Server，再次访问Eureka服务注册中心地址：http://localhost:8080/：可看到Config-Server已经成功注册了。接着开始改造Config-Client，在其pom中同样引入Eureka依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;然后在bootstrap.yml中指定获取Config-Server服务的地址：1234567891011121314151617spring: application: name: febs cloud: config: profile: dev label: master username: mrbird password: 123456 discovery: enabled: true service-id: config-servereureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/其中eureka.client.serviceUrl.defaultZone指定了Eureka服务注册中心的地址；spring.cloud.config.discovery.enabled指定为true开启获取服务的功能，spring.cloud.config.discovery.service-id表明需要获取服务的名称为config-server。最后在Config-Client的启动类中引入@EnableDiscoveryClient注解：1234567@SpringBootApplication@EnableDiscoveryClientpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;启动Config-Client，访问：http://localhost:12581/message可看到，配置信息同样获取成功。参考文章：Spring Cloud微服务实战http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.4.3.RELEASE/single/spring-cloud-config.html源码地址：https://github.com/wuyouzhuguli/SpringAll/tree/master/41.Spring-Cloud-Config]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Zuul服务网关]]></title>
    <url>%2FSpring-Cloud-Zuul-Router.html</url>
    <content type="text"><![CDATA[在微服务的架构中，服务网关就是一个介于客户端与服务端之间的中间层。在这种情况下，客户端只需要跟服务网关交互，无需调用具体的微服务接口。这样的好处在于，客户端可以降低复杂性；对于需要认证的服务，只需要在服务网关配置即可；同样也方便后期微服务的变更和重构，即微服务接口变更只需在服务网关调整配置即可，无需更改客户端代码。Zuul是一款由Netflix开发的微服务网关开源软件，可以和其自家开发的Eureka，Ribbon和Hystrix配合使用，Spring Cloud对其进行了封装。Spring Cloud Zuul入门在构建微服务网关之前，我们先将相关微服务搭建好。这里我们直接使用前面的例子，分别启动如下服务：启动Eureka-Server集群，端口号为8080和8081；启动一个Eureka-Client，端口号为8082；启动一个Feign-Consumer，端口号为9000；查看http://localhost:8080/：其中Feign-Consumer虽然之前我们将它定义为服务消费者，但其也可以充当服务提供者的角色。启动好这些微服务后，我们开始构建一个微服务网关Zuul-Gateway。新建一个Spring Boot项目，artifactId为Zuul-Gateway，然后引入如下依赖：123456789101112131415161718192021&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;查看依赖关系可看到spring-cloud-starter-zuul包含以下依赖：因为spring-cloud-starter-zuul依赖已经包含了Hystrix和Ribbon，所以zuul支持前面介绍的Hystrix和Ribbon相关配置。接着在Spring Boot的入口类上标注@EnableZuulProxy注解，开启Zuul服务网关的功能：1234567@EnableZuulProxy@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;最后简单配置下application.yml：12345spring: application: name: Zuul-Gatewayserver: port: 12580至此一个简单的Zuul微服务网关就搭建好了，下面开始对路由规则进行配置。路由配置传统配置传统配置就是手动指定服务的转发地址，如在yml中配置：12345zuul: routes: api-a: path: /api-a/** url: http://localhost:8082通过上面的配置，所有符合/api-a/**规则的访问都将被路由转发到http://localhost:8082/地址上，即当我们向服务网关访问http://localhost:12580/api-a/hello请求的时候，请求将被转发到http://localhost:8082/hello服务上：基于服务名称配置传统的配置方式不便之处在于需要知道服务的具体地址和端口号等信息，我们可以借助Eureka来实现通过服务名称配置路由。在Zuul-Gateway项目中引入Eureka依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;然后在入口类中加入@EnableDiscoveryClient注解，使其具有获取服务的能力。接着在yml中配置基于服务名称的路由：123456789101112eureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/zuul: routes: api-b: path: /api-b/** serviceId: server-provider api-c: path: /api-c/** serviceId: server-consumer上面我们首先指明了Eureka服务注册中心的地址，然后配置了api-b和api-c的路由，它们都是通过serviceId来指定服务名称的。启动Zuul-Gateway，访问：http://localhost:12580/api-b/hello：访问：http://localhost:12580/api-c/user/1：基于服务名称的路由配置还可以进行简化，格式为zuul.routes.&lt;serviceid&gt;=&lt;path&gt;，所以我们可以将api-b和api-c的路由配置修改为：123456zuul: routes: server-provider: path: /api-b/** server-consumer: path: /api-c/**默认路由配置规则我们尝试访问http://localhost:12580/server-consumer/user/1:我们压根没配置这个路由啊，为什么可以正常响应？？其实Zuul配合Eureka后将会成一套默认的配置规则。当我们使用服务名称作为请求的前缀路径时，实际上就会匹配上类似下面的默认路由配置：12345zuul: routes: server-consumer: path: /server-consumer/** serviceId: server-consumer如果不想启动这个默认配置，我们可以使用zuul.ignored-services配置来关闭，如在yml中加入如下配置之后，再次访问http://localhost:12580/server-consumer/user/1将返回404：12zuul: ignored-services: server-consumer设置为zuul.ignored-services=*的时候将关闭所有默认路由配置规则。优先级假如某个请求路径可以和多个路由配置规则相匹配的话，Zuul根据匹配的先后顺序来决定最终使用哪个路由配置。比如：12345678zuul: routes: api-c: path: /api-c/** serviceId: server-consumer api-d: path: /api-c/user/1 serviceId: lol当我们访问http://localhost:12580/api-c/user/1的时候，api-c和api-d的路由配置都可以匹配上，但由于api-c先于api-d配置，所以最终生效的是api-c的配置。假如将api-c和api-d的配置顺序调换，再次访问http://localhost:12580/api-c/user/1时将抛出异常，原因是不存在服务名为lol的服务：Caused by: com.netflix.client.ClientException: Load balancer does not have available server for client: lol前缀配置zuul.prefix可以为网关的请求路径加个前缀，比如：12zuul: prefix: /gateway这样配置后，我们通过Zuul网关获取服务的时候，路径也得加上这个前缀，如http://localhost:12580/gateway/api-c/user/1。本地跳转Zuul网关除了支持将服务转发到各个微服务上之外，还支持将服务跳转到网关本身的服务上，比如现在yml中有如下一段配置:12345zuul: routes: api-e: path: /api-e/** url: forward:/test当访问http://localhost:12580/gateway/api-e/hello时，Zuul会从本地/test/hello获取服务。我们在Zuul-Gateway入口类中加上该REST服务：12345678910111213@EnableZuulProxy@EnableDiscoveryClient@SpringBootApplication@RestControllerpublic class DemoApplication &#123; @GetMapping("/test/hello") public String hello() &#123; return "hello zuul"; &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;效果如下所示：头部过滤 &amp; 重定向在使用Zuul网关的时候你可能会遇到Cookie丢失的情况，这是因为默认情况下Zuul会过滤掉HTTP请求头中的一些敏感信息，这些敏感信息通过下面的配置设定：12zuul: sensitive-headers: Cookie,Set-Cookie,Authorization如果想关闭这个默认配置，通过设置全局参数为空来覆盖默认值：12zuul: sensitive-headers:如果只想关闭某个路由的HTTP请求头过滤，可以这样：1234zuul: routes: api-a: sensitive-headers:使用Zuul另一个常见问题是重定向的问题，可以通过下面的设置解决：12zuul: add-host-header: true过滤器Zuul另一个核心的功能就是请求过滤。Zuul中默认定义了4种不同生命周期的过滤器类型，在如下图所示图片来自于 Zuul GitHub这4种过滤器处于不同的生命周期，所以其职责也各不相同：PRE：PRE过滤器用于将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址，并做一些前置加工，比如请求的校验等；ROUTING：ROUTING过滤器用于将外部请求转发到具体服务实例上去；POST：POST过滤器用于将微服务的响应信息返回到客户端，这个过程种可以对返回数据进行加工处理；ERROR：上述的过程发生异常后将调用ERROR过滤器。ERROR过滤器捕获到异常后需要将异常信息返回给客户端，所以最终还是会调用POST过滤器。核心过滤器Spring Cloud Zuul为各个生命周期阶段实现了一批过滤器，如下所示：这些过滤器的优先级和作用如下表所示：生命周期优先级过滤器功能描述pre-3ServletDetectionFilter标记处理Servlet的类型pre-2Servlet30WrapperFilter包装HttpServletRequest请求pre-1FormBodyWrapperFilter包装请求体route1DebugFilter标记调试标志route5PreDecorationFilter处理请求上下文供后续使用route10RibbonRoutingFilterserviceId请求转发route100SimpleHostRoutingFilterurl请求转发route500SendForwardFilterforward请求转发post0SendErrorFilter处理有错误的请求响应post1000SendResponseFilter处理正常的请求响应其中优先级数字越小，优先级越高。要关闭这些过滤器可以在application.yml中按照格式zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true配置即可。比如关闭SendResponseFilter过滤器：12345zuul: SendResponseFilter: post: disable: true自定义Zuul过滤器我们自定义一个PreSendForwardFilter用于获取请求转发前的一些信息：1234567891011121314151617181920212223import com.netflix.zuul.ZuulFilter;public class PreSendForwardFilter extends ZuulFilter &#123; @Override public String filterType() &#123; return null; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return false; &#125; @Override public Object run() &#123; return null; &#125;&#125;可以看到自定义Zuul过滤器只需要继承ZuulFilter，然后实现以下四个抽象方法即可：filterType：对应Zuul生命周期的四个阶段：pre、post、route和error；filterOrder：过滤器的优先级，数字越小，优先级越高；shouldFilter：方法返回boolean类型，true时表示是否执行该过滤器的run方法，false则表示不执行；run：过滤器的过滤逻辑。继续完善PreSendForwardFilter：123456789101112131415161718192021222324252627282930@Componentpublic class PreSendForwardFilter extends ZuulFilter &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 1; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); String host = request.getRemoteHost(); String method = request.getMethod(); String uri = request.getRequestURI(); log.info("请求URI：&#123;&#125;，HTTP Method：&#123;&#125;，请求IP：&#123;&#125;", uri, method, host); return null; &#125;&#125;这时候访问http://localhost:12580/api-a/hello，控制台将打印出：1c.e.demo.filter.PreSendForwardFilter : 请求URI：/api-a/hello，HTTP Method：GET，请求IP：0:0:0:0:0:0:0:1源码链接 https://github.com/wuyouzhuguli/SpringAll/tree/master/39.Spring-Cloud-Zuul-Router参考资料： Spring Cloud微服务实战]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Feign 声明式服务调用]]></title>
    <url>%2FSpring-Cloud-Feign.html</url>
    <content type="text"><![CDATA[前面我们分别通过Spring Cloud Ribbon和Spring Cloud Hystrix实现了客户端负载均衡和服务容错，而Spring Cloud Feign不但整合了这两者的功能，而且还提供了一种比Ribbon更简单的服务调用方式 ——— 声明式服务调用。在Spring Cloud Feign中编写服务调用代码非常简单，几乎可以直接将服务提供者的代码复制过来，改为接口即可，下面通过例子来演示这个特性。搭建Feign Consumer创建一个新的Spring Boot应用，版本为1.5.13.RELEASE，artifactId改为Feign-Consumer，并引入下面这些依赖：12345678910111213141516171819202122232425&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;除了spring-cloud-starter-feign依赖外，我们还引入了spring-cloud-starter-eureka，目的是为了从Eureka服务注册中心获取服务。在Spring Boot的入口类中加入@EnableFeignClients和@EnableDiscoveryClient注解，用于开启Spring Cloud Feign和服务注册与发现：12345678@EnableDiscoveryClient@EnableFeignClients@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;在前面几节中，我们曾在服务提供者Eureka-Client中定义了一个UserController，代码如下所示：1234567891011121314151617181920212223242526272829303132333435@RestController@RequestMapping("user")public class UserController &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @GetMapping("/&#123;id:\\d+&#125;") public User get(@PathVariable Long id) &#123; log.info("获取用户id为 " + id + "的信息"); return new User(id, "mrbird", "123456"); &#125; @GetMapping public List&lt;User&gt; get() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L, "mrbird", "123456")); list.add(new User(2L, "scott", "123456")); log.info("获取用户信息 " + list); return list; &#125; @PostMapping public void add(@RequestBody User user) &#123; log.info("新增用户成功 " + user); &#125; @PutMapping public void update(@RequestBody User user) &#123; log.info("更新用户成功 " + user); &#125; @DeleteMapping("/&#123;id:\\d+&#125;") public void delete(@PathVariable Long id) &#123; log.info("删除用户成功 " + id); &#125;&#125;在Spring Cloud Ribbon中访问这些服务需要通过RestTemplate对象来实现，并且参数绑定的过程也比较繁琐。Spring Cloud Feign对这个步骤进行了进一步的封装，在Feign Consumer中调用这些服务只需要定义一个UserService接口，然后将UserController中的代码复制过并将方法体去掉即可，如：123456789101112131415161718@FeignClient("Server-Provider")public interface UserService &#123; @GetMapping("user/&#123;id&#125;") public User get(@PathVariable("id") Long id); @GetMapping("user") public List&lt;User&gt; get(); @PostMapping("user") public void add(@RequestBody User user); @PutMapping("user") public void update(@RequestBody User user); @DeleteMapping("user/&#123;id&#125;") public void delete(@PathVariable("id") Long id);&#125;对比Feign Consumer中的UserService和Eureka-Client中UserController代码，两者是不是很相似？在UserService中，我们通过@FeignClient(&quot;Server-Provider&quot;)注解来获取我们需要的服务，其中Server-Provider不区分大小写。需要注意的是，在定义各参数绑定时，@RequestParam、@RequestHeader等可 以指定参数名称的注解，它们的value千万不能少。在SpringMVC 程序中，这些注解会根据参数名来作为默认值，但是在Feign中绑定参数必须通过value属性来指明具体的参数名，不然会抛出illegalStateException异常，value 属性不能为空。接下来我们在Feign Consumer中定义一个TestController，来调用UserService中定义的服务：123456789101112131415161718192021222324252627282930313233@RestControllerpublic class TestController &#123; @Autowired private UserService userService; @GetMapping("user/&#123;id&#125;") public User getUser(@PathVariable Long id) &#123; return userService.get(id); &#125; @GetMapping("user") public List&lt;User&gt; getUsers() &#123; return userService.get(); &#125; @PostMapping("user") public void addUser() &#123; User user = new User(1L, "mrbird", "123456"); userService.add(user); &#125; @PutMapping("user") public void updateUser() &#123; User user = new User(1L, "mrbird", "123456"); userService.update(user); &#125; @DeleteMapping("user/&#123;id&#125;") public void deleteUser(@PathVariable Long id) &#123; userService.delete(id); &#125;&#125;最后配置一下application.yml：1234567891011server: port: 9000 spring: application: name: Server-Consumer eureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/上面配置指定了Eureka服务注册中心的地址，用于获取服务。最后我们分别启动以下服务：启动Eureka-Server集群，端口号为8080和8081；启动两个Eureka-Client，端口号为8082和8083；启动Feign-Consumer，端口号为9000。多次访问http://localhost:9000/user/1服务，观察8082和8083服务的控制台：12345678910111213142018-06-10 14:27:38.105 INFO 10120 --- [nio-8082-exec-8] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:39.989 INFO 10120 --- [nio-8082-exec-7] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:41.197 INFO 10120 --- [nio-8082-exec-6] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:41.802 INFO 10120 --- [nio-8082-exec-5] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:42.224 INFO 10120 --- [nio-8082-exec-4] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:42.865 INFO 10120 --- [nio-8082-exec-3] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:43.296 INFO 10120 --- [nio-8082-exec-2] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:38.358 INFO 9104 --- [nio-8083-exec-8] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:40.754 INFO 9104 --- [nio-8083-exec-7] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:41.397 INFO 9104 --- [nio-8083-exec-6] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:42.006 INFO 9104 --- [nio-8083-exec-5] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:42.445 INFO 9104 --- [nio-8083-exec-4] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-10 14:27:43.073 INFO 9104 --- [nio-8083-exec-3] c.e.demo.controller.UserController : 获取用户id为 1的信息使用Feign实现的消费者，依然是利用Ribbon维护了针对Seriver-Provider的服务列表信息，并且通过轮询实现了客户端负载均衡。而与Ribbon不同的是，通过Feign我们只需定义服务绑定接口，以声明式的方法，优雅而简单地实现了服务调用。Ribbon相关配置Spring Cloud Feign内部的客户端负载均衡是通过Ribbon来实现的，所以在Spring Cloud Feign中配置Ribbon，和之前在Spring Cloud Ribbon客户端负载均衡中介绍的Spring Cloud Ribbon配置一样，这里不再赘述。Hystrix相关配置要在Spring Cloud Feign中开启Hystrix，可以在yml中添加如下配置：123feign: hystrix: enabled: true剩下的Hystrix配置和之前在Spring Cloud Hystrix服务容错中介绍的Hystrix属性配置一样。在Spring Cloud Feign中配置服务降级和在Spring Cloud Hystrix中配置服务降级区别很大，下面具体来看下怎么在Feign-Consumer中配置服务降级。定义一个用于处理服务降级方法的类UserServiceFallback，并且实现上面定义的UserService接口：1234567891011121314151617181920212223242526272829@Componentpublic class UserServiceFallback implements UserService &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Override public User get(Long id) &#123; return new User(-1L, "default", "123456"); &#125; @Override public List&lt;User&gt; get() &#123; return null; &#125; @Override public void add(User user) &#123; log.info("test fallback"); &#125; @Override public void update(User user) &#123; log.info("test fallback"); &#125; @Override public void delete(Long id) &#123; log.info("test fallback"); &#125;&#125;在UserService的中通过@FeignClient注解的fallback属性来指定对应的服务降级实现类:1234@FeignClient(value = "Server-Provider", fallback = UserServiceFallback.class)public interface UserService &#123; ...&#125;重启Feign-Consumer，并关闭Eureka Client服务，访问http://localhost:9000/user/1，由于Eureka-Client服务提供者都关闭了，所以这里会直接触发服务降级，响应结果如下：可看到响应信息为服务降级方法中的返回结果。其余Feign配置除了Ribbon和Hystrix配置之外，Feign也有一些自个儿的配置。请求压缩Spring Cloud Feign支持对请求与响应进行GZIP压缩，以减少通信过程中的性能损耗：123456feign: compression: request: enabled: true response: enabled: true同时，我们还能对请求压缩做一些更细致的设置，比如下面的配置内容指定了压缩的请求数据类型，并设置了请求压缩的大小下限，只有超过这个大小的请求才会对其进行压缩:123456feign: compression: request: enabled: true mime-types: text/xml,application/xml,application/json min-request-size: 2048日志配置Feign提供了日志打印的功能，Feign的日志级别分为四种：NONE: 不记录任何信息。BASIC: 仅记录请求方法、URL以及响应状态码和执行时间。HEADERS: 除了记录BASIC级别的信息之外，还会记录请求和响应的头信息。FULL: 记录所有请求与响应的明细，包括头信息、请求体、元数据等。日志级别默认为NONE，要改变级别可以在入口类中定义一个日志配置Bean：123456789101112@EnableDiscoveryClient@EnableFeignClients@SpringBootApplicationpublic class DemoApplication &#123; @Bean Logger.Level feignLoggerLevel() &#123; return Logger.Level.FULL; &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;然后在yml中配置Feign客户端的日志级别为debug，Feign日志记录仅响应debug级别：1234567logging: level: com: example: demo: service: UserService: debug重启项目访问，可以看到控制台打印日志如下：12345678[UserService#get] &lt;--- HTTP/1.1 200 (506ms)[UserService#get] content-type: application/json;charset=UTF-8[UserService#get] date: Stu, 10 Jun 2018 01:44:45 GMT[UserService#get] transfer-encoding: chunked[UserService#get] [UserService#get] &#123;&quot;id&quot;:1,&quot;username&quot;:&quot;mrbird&quot;,&quot;password&quot;:&quot;123456&quot;&#125;[UserService#get] &lt;--- END HTTP (48-byte body)Flipping property: Server-Provider.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647源码链接 https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/33.Spring-Cloud-Feign-Declarative-REST-Client]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Hystrix Dashboard仪表盘]]></title>
    <url>%2FSpring-Cloud-Hystrix-Dashboard.html</url>
    <content type="text"><![CDATA[Hystrix提供了Hystrix Dashboard来实时监控Hystrix的运行情况，通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。Spring Cloud对Hystrix Dashboard进行了整合，这里将介绍如何使用Hystrix Dashboard监控单个和多个Hystrix实例。监控单个Hystrix实例创建一个Spring Boot项目，Spring Boot版本为1.5.13.RELEASE，artifactId填Hystrix-Dashboard，然后引入如下依赖：12345678910111213141516171819202122232425&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;稍微配置下yml：12345spring: application: name: Hystrix-Dashboardserver: port: 9002然后在入口类上加入注解@EnableHystrixDashboard来启用Hystrix Dashboard的功能。启动项目访问http://localhost:9002/hystrix就可以看到如下页面了：可以看到页面上提供了三种监控的模式：Cluster via Turbine(default cluster)、Cluster via Turbine(custom cluster)和Single Hystrix App：前两种都是集群监控的，下面再介绍，这里先介绍第三种单机监控。在上一节Spring Cloud Hystrix服务容错的基础上，要对Ribbon-Consumer进行监控还必须加入spring-boot-starter-actuator依赖，然后分别启动Eureka-Serve集群，Eureka-Client，Ribbon-Consumer，启动后在刚刚的监控页面上输入：http://localhost:9000/hystrix.stream ，然后往Ribbon-Consumer发几条请求，便可以看到如下监控页面：至于这张图上面的指标代表什么含义，我们可以参考官方给的图例：到这里我们已经实现了使用Hystrix Dashboard对单个Hystrix实例进行监控了，然而实际中一般会有多个Hystrix实例需要同时进行监控，下面我们使用Turbine来实现集群监控。Turbine集群监控使用Turbine实现对Hystrix的集群监控的思路是：Turbine从Eureka服务注册中心通过服务名Ribbon-Consumer获取服务实例，然后Hystrix Dashboard对Turbine进行监控，这样就实现了Hystrix Dashboard同时对多个Hystrix（Ribbon-consumer）实例同时进行监控的功能。创建一个Spring Boot项目，Spring Boot版本为1.5.13.RELEASE，artifactId填Turbine，然后引入如下依赖：1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;然后在入口类中加入@EnableTurbine来开启Turbine的功能，并且加入@EnableDiscoveryClient注解，开启服务获取功能。最后在yml中加入一些配置：1234567891011121314spring: application: name: Turbineserver: port: 9003eureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/turbine: app-config: Ribbon-Consumer cluster-name-expression: new String('default') combine-host-port: true上面配置了Eureka-Server的集群地址，并且指定了端口号为9003，应用名称为Turbine。剩下的配置为Turbine的配置，含义如下：turbine.app-config指定了需要收集监控信息的服务名，这里为Ribbon-Consumer；turbine.cluster-name-expression参数指定了集群名称为default, 当服务数量非常多的时候，可以启动多个Turbine 服务来构建不同的聚合集群， 而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需在Hystrix Stream的URL中通过cluster参数来指定(即Cluster via Turbine(custom cluster))；turbine.combine-host-port参数设置为七rue, 可以让同一主机上的服务通过主机名与端口号的组合来进行区分， 默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。配置完毕后，我们分别启动下面这些服务：启动Eureka-Server集群，端口号为8080和8081；启动一个Eureka-Client，端口号为8082；启动两个Ribbon-Consumer，端口号为9000和9001；启动Turbine服务，端口号为9003；最后启动Hystrix-Dashboard服务，端口号为9002。启动好这些服务后，访问Eureka-server的http://localhost:8080可看到这些实例：说明服务都已启动成功，我们观察Turbine的控制台，可以看到如下日志信息：即Turbine已经从服务注册中心找到了9000和9001端口的Ribbon-Consumer实例。这时候我们访问Hystrix-dashboard的地址http://localhost:9002/hystrix，在页面的地址栏输入http://localhost:9003/turbine.stream，然后分别往9000和9001端口的Ribbon-Consumer实例发送一些请求，这时候可以看到Dashboard的画面如下：可以看到Hosts的值已经是2了，并且由于两个Hystrix实例的名称都是Ribbon-Consumer，所以Turbine 会将相同名称的服务作为整体来看待，汇总成一个监控图。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/31.Spring-Cloud-Hystrix-Dashboard-Turbine使用消息中间件除了直接用Turbine从服务注册中心获取Ribbon-Consumer实例监控数据外，还可以将Ribbon-Consumer的监控数据发送到消息中间件，然后Turbine从消息中间件中获取。这里我们选择RabbitMQ作为消息中间件。在安装RabbitMQ之前，需要先安装Erlang/OTP，下载地址为：http://www.erlang.org/downloads/，下载exe文件安装即可。安装完毕后，下载RabbitMQ，下载地址为http://www.rabbitmq.com/install-windows.html，下载exe文件安装即可。安装完RabbitMQ之后，我们到RabbitMQ安装目录的sbin下执行如下命令：1rabbitmq-plugins enable rabbitmq_management然后在浏览器中输入http://localhost:15672，用户名和密码都是guest，登录后可看到：说明启动成功。接下来我们对Ribbon-Consumer进行改造，实现其将监控信息输出到RabbitMQ，在pom中添加如下依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-hystrix-stream&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;修改Ribbon-Consumer的yml配置文件，加入RabbitMQ的连接配置：123456spring: rabbitmq: host: localhost port: 5672 username: guest password: guest最后我们来修改Turbine，让其从RabbitMQ中读取监控信息。在Turbine项目中引入如下依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine-stream&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;同时删除spring-cloud-starter-eureka和spring-cloud-starter-turbine依赖，因为我们不再从服务注册中心去获取监控的服务信息了，并且spring-cloud-starter-turbine-stream已经包含了spring-cloud-starter-turbine依赖。修改Turbine的入口类，删除@EnableTurbine和@EnableDiscoveryClient注解，添加@EnableTurbineStream注解。将Turbine的yml配置修改为：12345678910spring: application: name: Turbine rabbitmq: host: localhost port: 5672 username: guest password: guestserver: port: 9003修改完毕后，我们分别启动下面这些服务：启动Eureka-Server集群，端口号为8080和8081；启动一个Eureka-Client，端口号为8082；启动两个Ribbon-Consumer，端口号为9000和9001；启动Turbine服务，端口号为9003；最后启动Hystrix-Dashboard服务，端口号为9002。同样的我们访问Hystrix-dashboard的地址http://localhost:9002/hystrix，在页面的地址栏输入http://localhost:9003/turbine.stream，然后分别往9000和9001端口的Ribbon-Consumer实例发送一些请求，这时候可以看到Dashboard的画面如下：效果和从服务注册中心获取服务的监控信息一致。并且这时候观察RabbitMQ的页面：可看到Queued messages已经有数据了。至此我们完成了Turbine从消息中间件RabbitMQ来收集监控信息的过程。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/32.Spring-Cloud-Hystrix-Dashboard-Turbine-RabbitMQ]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Hystrix服务容错]]></title>
    <url>%2FSpring-Cloud-Hystrix-Circuit-Breaker.html</url>
    <content type="text"><![CDATA[在微服务的架构中，服务间通常会形成相互依赖的关系，比如现在有三个微服务节点：A，B和C，B为A的消费者，C为B的消费者。假如由于网络波动或者A服务自身故障，导致B调用A服务的线程被挂起进入长时间的等待。在高并发的情况下可能导致B的资源被耗竭随之崩溃，从而导致C服务也不可用。这种连环式的雪崩效应在微服务中较为常见，为了解决这个问题，服务熔断技术应运而出。熔断一词来自电路学，指的是电路在出现短路状况时，“断路器”能够及时地切断故障电路，避免电路过载发热引发火灾。类似的，微服务架构中的断路器能够及时地发现故障服务，并向服务调用方返回错误响应，而不是长时间的等待。Spring Cloud Hystrix在Hystrix（又是一款由Netflix开发的开源软件，Github地址https://github.com/Netflix/Hystrix）的基础上进行了封装，提供了服务熔断，服务降级，线程隔离等功能，通过这些功能可以提供服务的容错率。使用Hystrix这里将在上一节Spring Cloud Ribbon客户端负载均衡源码的基础上配置Hystrix。我们先看下在没有配置Hystrix之前，关闭Eureka-Client是什么效果。分别使用peer1和peer2配置启动Eureka-Server集群，然后启动两个Eureka-Client实例，端口分别为8082和8083，最后启动Ribbon-Consumer。准备完毕后，我们关闭端口为8082的Eureka-Client，然后发送GET请求http://localhost:9000/user/1，返回结果如下：下面开始使用使用Spring Cloud Hystrix，在项目Ribbon-Consumer中引入Spring Cloud Hystrix依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;在入口类上加入@EnableHystrix或者@EnableCircuitBreaker注解。这两个注解是等价的，查看@EnableHystrix注解源码就可以证实这一点：1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@EnableCircuitBreakerpublic @interface EnableHystrix &#123;&#125;在引入@EnableHystrix或者@EnableCircuitBreaker注解后，我们的入口类代码如下：12345678910111213@EnableCircuitBreaker@EnableDiscoveryClient@SpringBootApplicationpublic class DemoApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;入口类上总共包含了三个注解@EnableCircuitBreaker、@EnableDiscoveryClient和@SpringBootApplication，这三个注解的组合可以使用@SpringCloudApplication来代替，@SpringCloudApplication源码如下：123456789@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic @interface SpringCloudApplication &#123;&#125;接着将UserController中的方法提取出来，创建一个UserService（为了简单起见，不再创建Service接口）：12345678910111213141516171819202122232425262728293031323334@Service("userService")public class UserService &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private RestTemplate restTemplate; public User getUser(@PathVariable Long id) &#123; return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, id); &#125; public List&lt;User&gt; getUsers() &#123; return this.restTemplate.getForObject("http://Server-Provider/user", List.class); &#125; public String addUser() &#123; User user = new User(1L, "mrbird", "123456"); HttpStatus status = this.restTemplate.postForEntity("http://Server-Provider/user", user, null).getStatusCode(); if (status.is2xxSuccessful()) &#123; return "新增用户成功"; &#125; else &#123; return "新增用户失败"; &#125; &#125; public void updateUser() &#123; User user = new User(1L, "mrbird", "123456"); this.restTemplate.put("http://Server-Provider/user", user); &#125; public void deleteUser(@PathVariable Long id) &#123; this.restTemplate.delete("http://Server-Provider/user/&#123;1&#125;", id); &#125;&#125;接着改造UserService的getUser方法：1234567891011@HystrixCommand(fallbackMethod = "getUserDefault")public User getUser(@PathVariable Long id) &#123; return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, id);&#125;public User getUserDefault(Long id) &#123; User user = new User(); user.setId(-1L); user.setUsername("defaultUser"); user.setPassword("123456"); return user;&#125;我们在getUser方法上加入了@HystrixCommand注解，注解的fallbackMethod属性指定了被调用的方法不可用时的回调方法（服务熔断时的回调处理逻辑，即服务降级），这里为getUserDefault方法（必须与getUser方法的参数及返回值类型一致）。在UserController中调用UserService的getUser方法：123456789101112@RestControllerpublic class TestController &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private UserService userService; @GetMapping("user/&#123;id&#125;") public User getUser(@PathVariable Long id) &#123; return userService.getUser(id); &#125;&#125;修改完后启动Ribbon-Consumer并重重新启动8082端口的Eureka-Client，发送数次GET请求http://localhost:9000/user/1后，再次关闭8082端口的Eureka-Client。断开后，继续发送GET请求http://localhost:9000/user/1，当轮询到8082端口时返回数据如下图所示：可以看到，当轮询到服务不可用时，触发了熔断机制，接口回调了fallbackMethod指定的方法。我们也可以模拟服务超时的情况，可以在Eureka-Client提供的接口方法中设置线程等待，等待时间大于2000（Hystrix默认超时时间为2000 毫秒）即可触发调用方Ribbon-Consumer的服务熔断。@HystrixCommand详解@HystrixCommand注解还包含许多别的属性功能，下面介绍一些常用的属性配置。服务降级上面TestController中的getUser中我们用@HystrixCommand注解指定了服务降级方法getUserDefault。如果getUserDefault方法也抛出异常，那么我们可以再次使用@HystrixCommand注解指定getUserDefault方法降级的方法，比如定义一个getUserDefault2方法：12345678910111213141516171819@HystrixCommand(fallbackMethod = "getUserDefault2")public User getUserDefault(Long id) &#123; String a = null; // 测试服务降级 a.toString(); User user = new User(); user.setId(-1L); user.setUsername("defaultUser"); user.setPassword("123456"); return user;&#125;public User getUserDefault2(Long id) &#123; User user = new User(); user.setId(-2L); user.setUsername("defaultUser2"); user.setPassword("123456"); return user;&#125;重启Ribbon-Consumer，并关闭8082端口的Eureka Client服务，访问http://localhost:9000/user/1：异常处理在使用@HystrixCommand注解标注的方法中，除了HystrixBadRequestException异常外，别的异常都会触发服务降级。假如我们想指定某个异常不触发服务降级，可以使用@HystrixCommand注解的ignoreExceptions属性进行忽略。如：123456789101112@HystrixCommand(fallbackMethod = "getUserDefault2", ignoreExceptions = &#123;NullPointerException.class&#125;)public User getUserDefault(Long id) &#123; String a = null; // 测试服务降级 a.toString(); User user = new User(); user.setId(-1L); user.setUsername("defaultUser"); user.setPassword("123456"); throw new HystrixBadRequestException() return user;&#125;此外，对于方法抛出的异常信息，我们可以在服务降级的方法中使用Throwable对象获取，如：123456789@HystrixCommand(fallbackMethod = "getUserDefault2")public User getUserDefault(Long id, Throwable e) &#123; System.out.println(e.getMessage()); User user = new User(); user.setId(-2L); user.setUsername("defaultUser2"); user.setPassword("123456"); return user;&#125;命名与分组通过指定@HystrixCommand注解的commandKey、groupKey以及threadPoolKey属性可以设置命令名称、分组以及线程池划分，如：123456@HystrixCommand(fallbackMethod = "getUserDefault", commandKey = "getUserById", groupKey = "userGroup", threadPoolKey = "getUserThread")public User getUser(@PathVariable Long id) &#123; log.info("获取用户信息"); return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, id);&#125;上面的配置指定了命令的名称为getUserById，组名为userGroup，线程池名称为getUserThread。通过设置命令组，Hystrix会根据组来组织和统计命令的告警、仪表盘等信息。默认情况下，Hystrix命令通过组名来划分线程池，即组名相同的命令放到同一个线程池里，如果通过threadPoolKey设置了线程池名称，则按照线程池名称划分。当getUser方法被调用时，日志打印如下：12018-06-06 15:32:55.945 INFO 16192 --- [getUserThread-1] com.example.demo.Service.UserService : 获取用户信息可看到线程名称为getUserThread-1。Hystrix缓存我们在Controller中调用三次getUser方法，参数都为1L：12345678910111213@RestControllerpublic class TestController &#123; @Autowired private UserService userService; @GetMapping("testCache") public void testCache()&#123; userService.getUser(1L); userService.getUser(1L); userService.getUser(1L); &#125;&#125;当访问http://localhost:9000/testCache时，控制台输出如下： 开启缓存可以让getUser方法只被调用一次，剩下两次直接从缓存里获取。开启缓存要在Hystrix中开启缓存很简单，只需使用@CacheResult注解即可，修改UserService的getUser方法：1234@CacheResultpublic User getUser(@PathVariable Long id) &#123; return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, id);&#125;通过上面的设定，Hystrix会将返回的User对象进行缓存，缓存的key默认为方法的所有参数，这里只有一个id参数，所以缓存的key为用户id。这里在测试的时候遇到一个异常：java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext? at com.netflix.hystrix.HystrixRequestCache.get(HystrixRequestCache.java:104) ~[hystrix-core-1.5.12.jar:1.5.12] at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:478) ~[hystrix-core-1.5.12.jar:1.5.12] at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:454) ~[hystrix-core-1.5.12.jar:1.5.12] …在Hystrix的issue中找到了类似的提问：https://github.com/Netflix/Hystrix/issues/1314。大致意思是在使用Hytrix缓存之前，需要通过HystrixRequestContext.initializeContext初始化Hystrix请求上下文，请求结束之后需要调用shutdown方法关闭请求。所以我们可以定义一个过滤器来实现这个过程：123456789101112131415161718@Component@WebFilter(filterName = "hystrixRequestContextServletFilter", urlPatterns = "/*", asyncSupported = true)public class HystrixRequestContextServletFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HystrixRequestContext context = HystrixRequestContext.initializeContext(); filterChain.doFilter(servletRequest, servletResponse); context.close(); &#125; @Override public void destroy() &#123; &#125;&#125;到这里，我才意识到，其实Hystrix的缓存还是蛮鸡肋的，请求缓存不是只写入一次结果就不再变化的，而是每次请求到达Controller的时候，我们都需要为HystrixRequestContext进行初始化，之前的缓存也就是不存在了，我们是在同一个请求中保证结果相同，同一次请求中的第一次访问后对结果进行缓存，缓存的生命周期只有一次请求！改造完毕后，重启项目再次访问http://localhost:9000/testCache，控制台输出如下：设定key值我们也可以明确的指定缓存的key值是什么。指定key的值有两种方式：通过@CacheKey注解指定，如：1234567@CacheResult@HystrixCommand(fallbackMethod = "getUserDefault", commandKey = "getUserById", groupKey = "userGroup", threadPoolKey = "getUserThread")public User getUser(@CacheKey("id") @PathVariable Long id) &#123; log.info("获取用户信息"); return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, id);&#125;也可以指定参数对象内部属性为key值：1234567@CacheResult@HystrixCommand(fallbackMethod = "getUserDefault", commandKey = "getUserById", groupKey = "userGroup", threadPoolKey = "getUserThread")public User getUser(@CacheKey("id") User user) &#123; log.info("获取用户信息"); return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, user.getId());&#125;通过方法来指定，方法的返回值必须是String类型：1234567891011public String getCacheKey(Long id) &#123; return String.valueOf(id);&#125;@CacheResult(cacheKeyMethod = "getCacheKey")@HystrixCommand(fallbackMethod = "getUserDefault", commandKey = "getUserById", groupKey = "userGroup", threadPoolKey = "getUserThread")public User getUser(Long id) &#123; log.info("获取用户信息"); return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, id);&#125;值得注意的是，方法2的优先级比方法1高。缓存清除在涉及到更新User信息的方法上，我们要及时的清除相应的缓存，否则将会导致缓存数据和实际数据不一致的问题。我们在UserService的updateUser方法上做缓存清除操作：12345@CacheRemove(commandKey = "getUserById")@HystrixCommandpublic void updateUser(@CacheKey("id") User user) &#123; this.restTemplate.put("http://Server-Provider/user", user);&#125;@CacheRemove的commandKey属性和getUser里定义的一致。请求合并请求合并就是将多个单个请求合并成一个请求，去调用服务提供者，从而降低服务提供者负载的，一种应对高并发的解决办法。Hystrix中提供了一个@HystrixCollapser注解，该注解可以将处于一个很短的时间段（默认10 毫秒）内对同一依赖服务的多个请求进行整合并以批量方式发起请求。为了演示@HystrixCollapser注解的使用方法，我们改造下Eureka-Client（服务提供者）的UserController接口，提供一个批量处理的方法：12345678910111213141516@RestController@RequestMapping("user")public class UserController &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @GetMapping("users") public List&lt;User&gt; get(String ids) &#123; log.info("批量获取用户信息"); List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (String id : ids.split(",")) &#123; list.add(new User(Long.valueOf(id), "user" + id, "123456")); &#125; return list; &#125; ...&#125;然后在Ribbon-Consumer的UserService里添加两个方法：12345678910111213141516171819@HystrixCollapser(batchMethod = "findUserBatch", collapserProperties = &#123; @HystrixProperty(name = "timerDelayInMilliseconds", value = "100")&#125;)public Future&lt;User&gt; findUser(Long id) &#123; log.info("获取单个用户信息"); return new AsyncResult&lt;User&gt;() &#123; @Override public User invoke() &#123; return restTemplate.getForObject("http://Server-Provider/user/&#123;id&#125;", User.class, id); &#125; &#125;;&#125;@HystrixCommandpublic List&lt;User&gt; findUserBatch(List&lt;Long&gt; ids) &#123; log.info("批量获取用户信息,ids: " + ids); User[] users = restTemplate.getForObject("http://Server-Provider/user/users?ids=&#123;1&#125;", User[].class, StringUtils.join(ids, ",")); return Arrays.asList(users);&#125;@HystrixCollapser注解的batchMethod属性指定了批量处理的方法为下面定义的findUserBatch方法，timerDelayInMilliseconds的值为100（毫秒），意思是在100毫秒这个时间范围内的所有对findUser的调用，都将被合并为一个批量处理操作，进行批量处理操作的方法就是findUserBatch。我们在TestController中添加一个测试方法：123456789101112@GetMapping("testRequestMerge")public void testRequerstMerge() throws InterruptedException, ExecutionException &#123; Future&lt;User&gt; f1 = userService.findUser(1L); Future&lt;User&gt; f2 = userService.findUser(2L); Future&lt;User&gt; f3 = userService.findUser(3L); f1.get(); f2.get(); f3.get(); Thread.sleep(200); Future&lt;User&gt; f4 = userService.findUser(4L); f4.get();&#125;上面的测试方法中对findUser方法进行了4次的调用，最后一次调用（f4）之前先让线程等待200毫秒（大于timerDelayInMilliseconds中定义的100毫秒），所以我们的预期是前三次调用会被合并，而最后一次调用不会被合并进去。启动Ribbon-Consumer，访问http://localhost:9000/testRequestMerge,控制台输出如下：可以看到，控制台的输出符合我们的预期，f1、f2和f3被合并成了一个请求。而且可以看到，控制台并没有打印出findUser方法中的获取单个用户信息的日志，实际上findUser方法并不会被调用，所以上面的代码可以简化为：1234567891011121314 @HystrixCollapser(batchMethod = "findUserBatch", collapserProperties = &#123; @HystrixProperty(name = "timerDelayInMilliseconds", value = "100")&#125;)public Future&lt;User&gt; findUser(Long id) &#123; log.info("获取单个用户信息"); return null;&#125;@HystrixCommandpublic List&lt;User&gt; findUserBatch(List&lt;Long&gt; ids) &#123; log.info("批量获取用户信息,ids: " + ids); User[] users = restTemplate.getForObject("http://Server-Provider/user/users?ids=&#123;1&#125;", User[].class, StringUtils.join(ids, ",")); return Arrays.asList(users);&#125;虽然通过请求的合并可以减轻带宽和服务的压力，但合并请求的过程也会带来额外的开销。就拿上面的testCache来说，比如我们对单个findUser的方法调用耗时5ms，那么调用4次耗时可以粗略的估算为20ms。当我们使用Hystrix的请求合并功能后，前3次请求（f1、f2和f3）进行了合并，第4次请求（f4）没有进行合并，那么耗时可以粗略的估算为3*5+100+5=120ms（100为上面timerDelayInMilliseconds中指定的时间范围，在该时间段过后，才会调用第4次请求），结果明显比单独调用4次来得高。所以实际中是否该使用Hystrix的请求合并功能，需结合实际需求进行抉择。Hystrix属性除了上面涉及到的Hystrix属性配置外，其还包含了大量的别的可用配置。配置可以分为四个级别，优先级从低到高分别为：全局默认配置、全局配置、实例默认值、实例配置。Commondexecutionexecution.isolation.strategy： 该属性用来设置执行的隔离策略，它有如下两个选项。THREAD: 通过线程池隔离的策略。它在独立的线程上执行， 并且它的并发限制受线程池中线程数量的限制。SEMAPHORE: 通过信号量隔离的策略。它在调用线程上执行， 并且它的并发限制受信号量计数的限制。属性级别默认值、配置方式、配置属性全局默认配置THREAD全局配置hystrix.command.default.execution.isolation.strategy实例默认值@HystrixProperty(name=”execution.isolation.strategy”, value=”THREAD”)实例配置hystrix.command.HystrixCommandKey.execution.isolation.strategy实例配置中的HystrixCommandKey对应@HystrixCommand注解中commandKey 属性指定的值。execution.isolation.thread.timeoutinMilliseconds： 该属性用来配置HystrixCommand执行的超时时间，单位为毫秒。当HystrixCommand执行时间超过该配置值之后， Hystrix会将该执行命令标记为TIMEOUT并进入服务降级处理逻辑。属性级别默认值、配置方式、配置属性全局默认配置1000亳秒全局配置hystrix.command.default.execution.isolation.thread. timeoutinMilliseconds实例默认值@HystrixProperty(name=”execution.isolation.thread.timeoutinMilliseconds”,value=”2000”)实例配置hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutinMillisecondsexecution.timeout.enabled: 该属性用来配置HystrixCommand的执行是否启用超时时间。默认为true, 如果设置为false, 那么execution.isolation.thread.timeoutinMilliseconds属性的配置将不再起作用。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.command.default.execution.timeout.enabled实例默认值@HystrixProperty(name=”execution.timeout.enabled”, value=”false”)实例配置hystrix.command.HystrixCommandKey.execution.timeout.enabledexecution.isolation.thread.interruptOnTimeout: 该属性用来配置当HystrixCommand执行超时的时候是否要将它中断。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.command.default.execution.isolation.thread.interruptOnTimeout实例默认值@HystrixProperty(name=”execution.isolation.thread.interruptOnTimeout”,value=”false”)实例配置hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnTimeoutexecution.isolation.thread.interruptOnCancel: 该属性用来配置当HystrixCommand执行被取消的时候是否要将它中断。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.command.default.execution.isolation.thread.interruptOnCancel实例默认值@HystrixProperty(name=”execution.isolation.thread.interruptOnCancel”,value= “false”)实例配置hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnCancelexecution.isolation.semaphore.maxConcurrentRequests: 当HystrixCommand的隔离策略使用信号量的时候，该属性用来配置信号量的大小（并发请求数）。当最大并发请求数达到该设置值时，后续的请求将会被拒绝。属性级别默认值、配置方式、配置属性全局默认配置10全局配置hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests实例默认值@HystrixProperty(name=”execution.isolation.semaphore.maxConcurrentRequests”, value=”2”)实例配置hystrix.command.HystrixCommandKey.execution.isolation.semaphore.maxConcurrentRequestsfallbackfallback.enabled: 该属性用来设置服务降级策略是否启用，如果设置为false,那么当请求失败或者拒绝发生时，将不会调用降级服务。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.command.default.fallback.enabled实例默认值@HystrixProperty(name= “fallback.enabled”, value=”false”)实例配置hystrix.command.HystrixCommandKey.fallback.enabledcircuitBreaker断路器circuitBreaker.enabled: 该属性用来确定当服务请求命令失败时， 是否使用断路器来跟踪其健康指标和熔断请求。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.command.default.circuitBreaker.enabled实例默认值@HystrixProperty(name=”circutBreaker.enabled”,value=”false”)实例配置hystrix.command.HystrixCommandKey.circuitBreaker.enabledcircuitBreaker.requestVolumeThreshold: 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。属性级别默认值、配置方式、配置属性全局默认配置20全局配置hystrix.command.default.circuitBreaker.requestVolumeThreshold实例默认值@HystrixProperty(name=”circuitBreaker.requestVolumeThreshold”, value=”30”)实例配置hystrix.comrnand.HystrixComrnandKey.circuitBreaker.requestVolumeThresholdcircuitBreaker.sleepWindowinMilliseconds: 该属性用来设置当断路器打开之后的休眠时间窗。休眠时间窗结束之后，会将断路器置为“半开” 状态， 尝试熔断的请求命令，如果依然失败就将断路器继续设置为“打开” 状态，如果成功就设置为“关闭” 状态。属性级别默认值、配置方式、配置属性全局默认配置5000全局配置hystrix.command.default.circuitBreaker.sleepWindowinMilliseconds实例默认值@HystrixProperty(name=”circuitBreaker.sleepWindowinMilliseconds”,value=”3000”)实例配置hystrix.command.HystrixCommandKey.circuitBreaker.sleepWindowinMillisecondscircuitBreaker.errorThresholdPercentage: 该属性用来设置断路器打开的错误百分比条件。例如，默认值为5000 的情况下，表示在滚动时间窗中，在请求数量超过circuitBreaker.requestVolumeThreshold阅值的前提下，如果错误请求数的百分比超过50, 就把断路器设置为“打开” 状态， 否则就设置为“关闭” 状态。属性级别默认值、配置方式、配置属性全局默认配置50全局配置hystrix.command.default.circuitBreaker.errorThresholdPercentage实例默认值@HystrixProperty(name=”circuitBreaker.errorThresholdPercentage”, value=”40”)实例配置hystrix.command.HystrixCommandKey.circuitBreaker.errorThresholdPercentagecircuitBreaker.forceOpen: 如果将该属性设置为true, 断路器将强制进入“打开” 状态，它会拒绝所有请求。该属性优先于circuitBreaker.forceClosed属性。属性级别默认值、配置方式、配置属性全局默认配置false全局配置hystrix.command.default.circuitBreaker.forceOpen实例默认值@HystrixProperty (name=”circuitBreaker.forceOpen”, value=”true”)实例配置hystrix.command.HystrixCommandKey.circuitBreaker.forceOpencircuitBreaker.forceClosed: 如果将该属性设置为true, 断路器将强制进入“关闭” 状态， 它会接收所有请求。如果circuitBreaker.forceOpen属性为true, 该属性不会生效。属性级别默认值、配置方式、配置属性全局默认配置false全局配置hystrix.command.default.circuitBreaker.forceClosed实例默认值@HystrixProperty(name=”circui七Breaker.forceClosed”, value=”true”)实例配置hystrix.comrnand.HystrixComrnandKey.circuitBreaker.forceClosedmetrics配置该配置与HystrixCommand执行中捕获的指标信息有关。metrics.rollingStats.timeinMilliseconds: 该属性用来设置滚动时间窗的长度， 单位为毫秒。该时间用于断路器判断健康度时需要收集信息的持续时间。断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个“桶” 来累计各度量值，每个“桶” 记录了一段时间内的采集指标。例如，当采用默认值10000毫秒时， 断路器默认将其拆分成10个桶（桶的数量也可通过metrics.rollingStats.numBuckets参数设置），每个桶记录1000毫秒内的指标信息。属性级别默认值、配置方式、配置属性全局默认配置10000全局配置hystrix.command.default.metrics.rollingStats.timeinMilliseconds实例默认值@HystrixProperty(name=”metrics.rollingStats.timeinMilliseconds”,value=”20000”)实例配置hystrix.command.HystrixCommandKey.metrics.rollingStats.timeinMillisecondsmetrics.rollingstats.numBuckets: 该属性用来设置滚动时间窗统计指标信息时划分“桶” 的数量。属性级别默认值、配置方式、配置属性全局默认配置10全局配置hystrix.command.default.metrics.rollingStats.numBuckets实例默认值@HystrixProperty(name=”metrics.rollingStats.numBuckets”,value=”20”)实例配置hystrix.comrnand.HystrixComrnandKey.metrics.rollingStats.numBucketsmetrics.rollingPercentile.enabled: 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为false，那么所有的概要统计都将返回-1。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.command.default.metrics.rollingPercentile.enabled实例默认值@HystrixProperty(name=”metrics.rollingPercentile.enabled”, value=”false”)实例配置hystrix.command.HystrixCommandKey.metrics.rollingPercentile.enabledmetrics.rollingPercentile.timeinMilliseconds: 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。属性级别默认值、配置方式、配置属性全局默认配置60000全局配置hystrix.command.default.metrics.rollingPercentile.timeinMilliseconds实例默认值@HystrixProperty(name=”metrics.rollingPercentile.timeinMilliseconds”, value=”50000”)实例配置hystrix.command.HystrixCommandKey.metrics.rollingPercentile.timeinMillisecondsmetrics.rollingPercentile.numBuckets: 该属性用来设置百分位统计滚动窗口中使用“桶”的数量。属性级别默认值、配置方式、配置属性全局默认配置6全局配置hystrix.command.default.metrics.rollingPercentile.numBuckets实例默认值@HystrixProperty(name=”metrics.rollingPercentilee.numBuckets”,value=”5”)实例配置hystrix.command.HystrixCommandKey.metrics.rollingPercentile.numBucketsmetrics.rollingPercentile.bucketSize: 该属性用来设置在执行过程中每个“桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个“桶”中发生了500次执行，那么该“桶”中只保留最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。属性级别默认值、配置方式、配置属性全局默认配置100全局配置hystrix.command.default.metrics.rollingPercentile.bucketSize实例默认值@HystrixProperty(name=”metrics.rollingPercentile.bucketSize”,value= “120”)实例配置hystrix.command.HystrixCommandKey.metrics.rollingPercentile.bucketSizemetrics.healthSnapshot.intervalinMilliseconds: 该属性用来设置采集影响断路器状态的健康快照（请求的成功、错误百分比）的间隔等待时间。属性级别默认值、配置方式、配置属性全局默认配置500全局配置hystrix.comrnand.default.metrics.healthSnapshot.intervalinMilliseconds实例默认值@HystrixProperty(name=”metrics.healthSnapshot.intervalinMilliseconds”,value=”600”)实例配置hystrix.command.HystrixCommandKey.metrics.healthSnapshot.intervalinMillisecondsrequestContextrequestCache.enabled: 此属性用来配置是否开启请求缓存。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.command.default.requestCache.enabled实例默认值@HystrixProperty(name=”requestCache.enabled”, value=”false”)实例配置hystrix.command.HystrixCommandKey.requestCache.enabledcollapsermaxRequestsinBatch: 该参数用来设置一次请求合并批处理中允许的最大请求数。属性级别默认值、配置方式、配置属性全局默认配置Integer.MAX_VALUE全局配置hystrix.collapser.default.maxRequestsinBatch实例默认值@HystrixProperty(name=”maxRequestsinBatch”,value=”false”)实例配置hystrix.collapser.HystrixCollapserKey.maxRequestsinBatchtimerDelayinMilliseconds: 该参数用来设置批处理过程中每个命令延迟的时间，单位为毫秒。属性级别默认值、配置方式、配置属性全局默认配置10全局配置hystrix.collapser.default.timerDelayinMilliseconds实例默认值@HystrixProperty(name=”timerDelayinMilliseconds”,value=”20”)实例配置hystrix.collapser.HystrixCollapserKey.timerDelayinMillisecondsrequest Cache.enabled: 该参数用来设置批处理过程中是否开启请求缓存。属性级别默认值、配置方式、配置属性全局默认配置true全局配置hystrix.collapser.default.requestCache.enabled实例默认值@HystrixProperty(name=”requestCache.enabled”, value=”false”)实例配置hystrix.collapser.HystrixCollapserKey.requestCache.enabledthreadPoolcoreSize: 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量。属性级别默认值、配置方式、配置属性全局默认配置10全局配置hystrix.threadpool.default.coreSize实例默认值@HystrixProperty(name=”coreSize”, value=”false”)实例配置hystrix.threadpool.HystrixThreadPoolKey.coreSizemaxQueueSize: 该参数用来设置线程池的最大队列大小。当设置为-1时，线程池将使用SynchronousQueue实现的队列，否则将使用LinkedBlockingQueue实现的队列。属性级别默认值、配置方式、配置属性全局默认配置-1全局配置hystrix.threadpool.default.maxQueueSize实例默认值@HystrixProperty(name=”maxQueueSize”,value=”lO”)实例配置hystrix.threadpool.HystrixThreadPoolKey.maxQueueSizequeueSizeRejectionThreshold: 该参数用来为队列设置拒绝阈值。通过该参数，即使队列没有达到最大值也能拒绝请求。该参数主要是对LinkedBlockingQueue队列的补充， 因为LinkedBlockingQueue队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。属性级别默认值、配置方式、配置属性全局默认配置5全局配置hystrix.threadpool.default.queueSizeRejectionThreshold实例默认值@HystrixProperty(name=”queueSizeRejectionThreshold”, value=”lO”实例配置hystrix.threadpool.HystrixThreadPoolKey.queueSizeRejectionThreshold不得不说，配置是真的多……源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/30.Spring-Cloud-Hystrix-Circuit-Breaker参考文章 《Spring Cloud微服务实战》]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Ribbon客户端负载均衡]]></title>
    <url>%2FSpring-Cloud-Ribbon-LoadBalance.html</url>
    <content type="text"><![CDATA[为了提高服务的可用性，我们一般会将相同的服务部署多个实例，负载均衡的作用就是使获取服务的请求被均衡的分配到各个实例中。负载均衡一般分为服务端负载均衡和客户端负载均衡，服务端的负载均衡通过硬件（如F5）或者软件（如Nginx）来实现，而Ribbon实现的是客户端负载均衡。服务端负载均衡是在硬件设备或者软件模块中维护一份可用服务清单，然后客户端发送服务请求到这些负载均衡的设备上，这些设备根据一些算法均衡的将请求转发出去。而客户端负载均衡则是客户端自己从服务注册中心（如之前提到的Eureka Server）中获取服务清单缓存到本地，然后通过Ribbon内部算法均衡的去访问这些服务。Ribbon简介Ribbon是由Netflix开发的一款基于HTTP和TCP的负载均衡的开源软件。我们可以直接给Ribbon配置好服务列表清单，也可以配合Eureka主动的去获取服务清单，需要使用到这些服务的时候Ribbon通过轮询或者随机等均衡算法去获取服务。在Spring Cloud Eureka服务治理一节中，我们已经在Server-Consumer中配置了Ribbon，并通过加了@LoadBalanced注解的RestTemplate对象去均衡的消费服务，所以这节主要记录的是RestTemplate的详细使用方法和一些额外的Ribbon配置。RestTemplate详解从名称上来看就可以知道它是一个用来发送REST请求的摸板，所以包含了GET,POST,PUT,DELETE等HTTP Method对应的方法。发送Get请求RestTemplate中与GET请求对应的方法有getForEntity和getForObject。getForEntitygetForEntity方法返回ResponseEntity对象，该对象包含了返回报文头，报文体和状态码等信息。getForEntity有三个重载方法：getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables)；getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)；getForEntity(URI url, Class&lt;T&gt; responseType)；第一个参数为Url，第二个参数为返回值的类型，第三个参数为请求的参数（可以是数组，也可以是Map）。举个getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables)的使用例子：1234@GetMapping("user/&#123;id:\\d+&#125;")public User getUser(@PathVariable Long id) &#123; return this.restTemplate.getForEntity("http://Server-Provider/user/&#123;name&#125;", User.class, id).getBody();&#125;{1}为参数的占位符，匹配参数数组的第一个元素。因为第二个参数指定了类型为User，所以调用getBody方法返回类型也为User。方法参数除了可以放在数组里外，也可以放在Map里，举个getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)使用例子：123456@GetMapping("user/&#123;id:\\d+&#125;")public User getUser(@PathVariable Long id) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("id", id); return this.restTemplate.getForEntity("http://Server-Provider/user/&#123;id&#125;", User.class, params).getBody();&#125;只有两个参数的重载方法getForEntity(URI url, Class&lt;T&gt; responseType)第一个参数接收java.net.URI类型，可以通过org.springframework.web.util.UriComponentsBuilder来创建，举个该方法的使用例子：12345678@GetMapping("user/&#123;id:\\d+&#125;")public User getUser(@PathVariable Long id) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("id", id); URI uri = UriComponentsBuilder.fromUriString("http://Server-Provider/user/&#123;id&#125;") .build().expand(params).encode().toUri(); return this.restTemplate.getForEntity(uri, User.class).getBody();&#125;其中expand方法也可以接收数组和Map两种类型的参数。getForObjectgetForObject方法和getForEntity方法类似，getForObject方法相当于getForEntity方法调用了getBody方法，直接返回结果对象，为不是ResponseEntity对象。getForObject方法和getForEntity方法一样，也有三个重载方法，参数类型和getForEntity方法一致，所以不再列出。发送POST请求使用RestTemplate发送POST请求主要有postForEntity，postForObject和postForLocation（这个目前较少使用，所以不做介绍）三个方法。postForEntity和postForObject也分别有三个重载方法，方法参数和使用方式和上面介绍的getForEntity和getForObject一样，所以不再详细介绍。简单举个getForObject的使用例子：1234 @GetMapping("user")public List&lt;User&gt; getUsers() &#123; return this.restTemplate.getForObject("http://Server-Provider/user", List.class);&#125;发送PUT请求使用RestTemplate发送PUT请求，使用的是它的put方法，put方法返回值是void类型，该方法也有三个重载方法：put(String url, Object request, Object... uriVariables)；put(String url, Object request, Map&lt;String, ?&gt; uriVariables)；put(URI url, Object request)。举个例子：12345@GetMapping("user/update")public void updateUser() throws JsonProcessingException &#123; User user = new User(1L, "mrbird", "123456"); this.restTemplate.put("http://Server-Provider/user", user);&#125;在RESTful风格的接口中，判断成功失败不再是通过返回值的某个标识来判断的，而是通过返回报文的状态码是否为200来判断。当这个方法成功执行并返回时，返回报文状态为200，即可判断方法执行成功。发送DELETE请求使用RestTemplate发送DELETE请求，使用的是它的delete方法，delete方法返回值是void类型，该方法也有三个重载方法：delete(String url, Object... uriVariables)；delete(String url, Map&lt;String, ?&gt; uriVariables);delete(URI url)。举个例子：1234@GetMapping("user/delete/&#123;id:\\d+&#125;")public void deleteUser(@PathVariable Long id) &#123; this.restTemplate.delete("http://Server-Provider/user/&#123;1&#125;", id);&#125;RestTemplates实战我们在Spring Cloud Eureka服务治理中的Eureka客户端（Server-Provider）中编写一套RESTful风格的测试接口：1234567891011121314151617181920212223242526272829303132333435@RestController@RequestMapping("user")public class UserController &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @GetMapping("/&#123;id:\\d+&#125;") public User get(@PathVariable Long id) &#123; log.info("获取用户id为 " + id + "的信息"); return new User(id, "mrbird", "123456"); &#125; @GetMapping public List&lt;User&gt; get() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(1L, "mrbird", "123456")); list.add(new User(2L, "scott", "123456")); log.info("获取用户信息 " + list); return list; &#125; @PostMapping public void add(@RequestBody User user) &#123; log.info("新增用户成功 " + user); &#125; @PutMapping public void update(@RequestBody User user) &#123; log.info("更新用户成功 " + user); &#125; @DeleteMapping("/&#123;id:\\d+&#125;") public void delete(@PathVariable Long id) &#123; log.info("删除用户成功 " + id); &#125;&#125;User对象代码：12345678910111213141516171819202122232425public class User implements Serializable &#123; private static final long serialVersionUID = 1339434510787399891L; private Long id; private String username; private String password; public User() &#123; &#125; public User(Long id, String username, String password) &#123; this.id = id; this.username = username; this.password = password; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", password='" + password + '\'' + '&#125;'; &#125; // get,set略&#125;需要注意的是，User对象必须有默认的构造方法，否则在JSON与实体对象转换的时候会抛出如下异常：JSON parse error: Can not construct instance of model.Class: no suitable constructor found然后在Server-Consumer中使用RestTemplates分别去获取这些服务：123456789101112131415161718192021222324252627282930313233343536373839404142@RestControllerpublic class TestController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("user/&#123;id:\\d+&#125;") public User getUser(@PathVariable Long id) &#123; Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put("id", id); URI uri = UriComponentsBuilder.fromUriString("http://Server-Provider/user/&#123;id&#125;") .build().expand(params).encode().toUri(); return this.restTemplate.getForEntity(uri, User.class).getBody(); &#125; @GetMapping("user") public List&lt;User&gt; getUsers() &#123; return this.restTemplate.getForObject("http://Server-Provider/user", List.class); &#125; @GetMapping("user/add") public String addUser() &#123; User user = new User(1L, "mrbird", "123456"); HttpStatus status = this.restTemplate.postForEntity("http://Server-Provider/user", user, null).getStatusCode(); if (status.is2xxSuccessful()) &#123; return "新增用户成功"; &#125; else &#123; return "新增用户失败"; &#125; &#125; @GetMapping("user/update") public void updateUser() &#123; User user = new User(1L, "mrbird", "123456"); this.restTemplate.put("http://Server-Provider/user", user); &#125; @GetMapping("user/delete/&#123;id:\\d+&#125;") public void deleteUser(@PathVariable Long id) &#123; this.restTemplate.delete("http://Server-Provider/user/&#123;1&#125;", id); &#125;&#125;我们分别启动两个Eureka Server用于集群，两个Eureka Client（Server-Provider）实例，然后启动Server-Consumer。使用Restlet Client访问http://localhost:9000/user/1（后面每个方法我们都访问两次，用于观察负载均衡），返回结果如下：剩下的方法测试结果这里不贴出来了，当我们分别访问下面的连接后：http://localhost:9000/user/http://localhost:9000/user/addhttp://localhost:9000/user/updatehttp://localhost:9000/user/delete/1查看Eureka客户端8082和8083的后台日志：123456789101112131415161718192021222324252018-06-03 18:17:26.231 INFO 11188 --- [ main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 80832018-06-03 18:17:26.236 INFO 11188 --- [ main] com.example.demo.DemoApplication : Started DemoApplication in 52.252 seconds (JVM running for 54.321)2018-06-03 18:21:29.097 INFO 11188 --- [io-8083-exec-10] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2018-06-03 18:21:29.098 INFO 11188 --- [io-8083-exec-10] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started2018-06-03 18:21:29.177 INFO 11188 --- [io-8083-exec-10] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 79 ms2018-06-03 18:21:29.312 INFO 11188 --- [io-8083-exec-10] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-03 18:21:50.798 INFO 11188 --- [nio-8083-exec-9] c.e.demo.controller.UserController : 获取用户信息 [User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;, User&#123;id=2, username=&apos;scott&apos;, password=&apos;123456&apos;&#125;]2018-06-03 18:22:25.351 INFO 11188 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints via configuration2018-06-03 18:22:44.718 INFO 11188 --- [nio-8083-exec-8] c.e.demo.controller.UserController : 新增用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;2018-06-03 18:24:34.313 INFO 11188 --- [nio-8083-exec-6] c.e.demo.controller.UserController : 删除用户成功 12018-06-03 18:17:21.296 INFO 16188 --- [ main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 80822018-06-03 18:17:21.303 INFO 16188 --- [ main] com.example.demo.DemoApplication : Started DemoApplication in 57.152 seconds (JVM running for 58.239)2018-06-03 18:21:27.517 INFO 16188 --- [io-8082-exec-10] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2018-06-03 18:21:27.517 INFO 16188 --- [io-8082-exec-10] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started2018-06-03 18:21:27.567 INFO 16188 --- [io-8082-exec-10] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 50 ms2018-06-03 18:21:27.732 INFO 16188 --- [io-8082-exec-10] c.e.demo.controller.UserController : 获取用户id为 1的信息2018-06-03 18:21:49.639 INFO 16188 --- [nio-8082-exec-9] c.e.demo.controller.UserController : 获取用户信息 [User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;, User&#123;id=2, username=&apos;scott&apos;, password=&apos;123456&apos;&#125;]2018-06-03 18:22:12.313 INFO 16188 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints via configuration2018-06-03 18:22:46.111 INFO 16188 --- [nio-8082-exec-8] c.e.demo.controller.UserController : 新增用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;2018-06-03 18:23:55.732 INFO 16188 --- [nio-8082-exec-6] c.e.demo.controller.UserController : 更新用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;2018-06-03 18:23:58.297 INFO 16188 --- [nio-8082-exec-5] c.e.demo.controller.UserController : 更新用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;2018-06-03 18:24:37.266 INFO 16188 --- [nio-8082-exec-3] c.e.demo.controller.UserController : 删除用户成功 12018-06-03 18:27:12.314 INFO 16188 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver : Resolving eureka endpoints via configuration发现方法都成功调用，并且是均衡的。Spring Cloud Ribbon配置Spring Cloud Ribbon的配置分为全局和指定服务名称。比如我要指定全局的服务请求连接超时时间为200毫秒：12ribbon: ConnectTimeout: 200如果只是设置获取Server Provider服务的请求连接超时时间，我们只需要在配置最前面加上服务名称就行了，如：123Server-Provider: ribbon: ConnectTimeout: 200设置获取Server-Provider服务的负载均衡算法从轮询改为随机：123Server-Provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule设置处理Server-Provider服务的超时时间：123Server-Provider: ribbon: ReadTimeout: 1000开启重试机制，即获取服务失败是否从另外一个节点重试，默认值为false：12345spring: cloud: loadbalancer: retry: enabled: true对Server-Provider的所有请求在失败的时候都进行重试：123Server-Provider: ribbon: OkToRetryOnAllOperations: true切换Server-Provider实例的重试次数：123Server-Provider: ribbon: MaxAutoRetriesNextServer: 1对Server-Provider当前实例的重试次数：123Server-Provider: ribbon: MaxAutoRetries: 1根据如上配置当访问Server-Provider服务实例（比如是8082）遇到故障的时候，Ribbon会再尝试访问一次当前实例（次数由MaxAutoRetries配置），如果不行，就换到8083实例进行访问（更换次数由 MaxAutoRetriesNextServer决定），如果还是不行，那就GG思密达，返回失败。如果不和Eureka搭配使用的话，我们就需要手动指定服务清单给Ribbon：123Server-Provider: ribbon: listOfServers: localhost:8082,localhost:8083上面配置了名称为Server-Provider的服务，有两个节点可供使用（8082和8083）。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/29.Spring-Cloud-Ribbon-LoadBalance参考文章 《Spring Cloud微服务实战》]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Eureka服务治理]]></title>
    <url>%2FSpring-Cloud-Eureka.html</url>
    <content type="text"><![CDATA[考虑当前有两个微服务实例A和B，A服务需要调用B服务的某个REST接口。假如某一天B服务迁移到了另外一台服务器，IP和端口也发生了变化，这时候我们不得不去修改A服务中调用B服务REST接口的静态配置。随着公司业务的发展，微服务的数量也越来越多，服务间的关系可能变得非常复杂，传统的微服务维护变得愈加困难，也很容易出错。所谓服务治理就是用来实现各个微服务实例的自动化注册与发现，在这种模式下，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务注册中心获取服务名并发起请求调用实现。Eureka是由Netflix开发的一款服务治理开源框架，Spring-cloud对其进行了集成。Eureka既包含了服务端也包含了客户端，Eureka服务端是一个服务注册中心(Eureka Server)，提供服务的注册和发现，即当前有哪些服务注册进来可供使用；Eureka客户端为服务提供者(Server Provider)，它将自己提供的服务注册到Eureka服务端，并周期性地发送心跳来更新它的服务租约，同时也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。这样服务消费者(Server Consumer)便可以从服务注册中心获取服务名称，并消费服务。三者关系如下图所示:搭建Eureka-Server服务注册中心说了那么多，我们先来搭建一个Eureka服务端来充当服务注册中心。新建一个Spring Boot项目，artifactId填Eureka-Service，然后引入Spring Cloud Edgware.SR3和spring-cloud-starter-eureka-server:123456789101112131415161718&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;在启动类上添加@EnableEurekaServer注解，表明这是一个Eureka服务端：1234567@EnableEurekaServer@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;接着在application.yml中添加一些配置：1234567891011server: port: 8080 eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/上面配置了服务的端口为8080，剩下几个为Eureka配置：eureka.instance.hostname指定了Eureka服务端的IP；eureka.client.register-with-eureka表示是否将服务注册到Eureka服务端，由于自身就是Eureka服务端，所以设置为false；eureka.client.fetch-registry表示是否从Eureka服务端获取服务信息，因为这里只搭建了一个Eureka服务端，并不需要从别的Eureka服务端同步服务信息，所以这里设置为false；eureka.client.serviceUrl.defaultZone指定Eureka服务端的地址，默认值为http://localhost:8761/eureka。配置完毕后启动服务，访问http://localhost:8080/，可看到：由于还没有Eureka客户端将服务注册进来，所以Instances currently registered with Eureka列表是空的。下面我们接着搭建一个Eureka客户端来提供服务。搭建Eureka-Client服务提供者新建一个Spring Boot项目，artifactId填Eureka-Client，然后引入以下依赖：123456789101112131415161718192021&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;接着编写一个TestController，对外提供一些REST服务：1234567891011121314151617181920@RestControllerpublic class TestController &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private DiscoveryClient client; @GetMapping("/info") public String info() &#123; @SuppressWarnings("deprecation") ServiceInstance instance = client.getLocalServiceInstance(); String info = "host：" + instance.getHost() + "，service_id：" + instance.getServiceId(); log.info(info); return info; &#125; @GetMapping("/hello") public String hello() &#123; return "hello world"; &#125;&#125;上面代码注入了org.springframework.cloud.client.discovery.DiscoveryClient对象，可以获取当前服务的一些信息。编写启动类，在启动类上加@EnableDiscoveryClient注解，表明这是一个Eureka客户端：1234567@EnableDiscoveryClient@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;最后配置application.yml：12345678910111213server: port: 8082 spring: application: name: Server-Provider eureka: client: register-with-eureka: true fetch-registry: true serviceUrl: defaultZone: http://localhost:8080/eureka/稍微说明下这些配置的意思：server.port指定了服务的端口为8082；spring.application.name指定服务名称为Server-Provider，后续服务消费者要获取上面TestController中接口的时候会用到这个服务名；eureka.client.serviceUrl.defaultZone指定Eureka服务端的地址，这里为上面定义的Eureka服务端地址；eureka.client.register-with-eureka和eureka.client.fetch-registry上面已经解释了其意思，虽然这两个配置的默认值就是true，但这里还是显式配置下，使Eureka客户端的功能更为直观（即向服务端注册服务并定时从服务端获取服务缓存到本地）。配置好后，启动Eureka-Client，可以从控制台中看到注册成功的消息：1234567891011121314Registered Applications size is zero : trueApplication version is -1: trueGetting all instance registry info from the eureka serverThe response status is 200Starting heartbeat executor: renew interval is: 30InstanceInfoReplicator onDemand update allowed rate per min is 4Discovery Client initialized at timestamp 1530667498944 with initial instances Registering application Server-Provider with eureka with status UPSaw local status change event StatusChangeEvent [timestamp=1530667498949, current=UP, previous=STARTING] DiscoveryClient_SERVER-PROVIDER/192.168.73.109:Server-Provider:8082: registering service... DiscoveryClient_SERVER-PROVIDER/192.168.73.109:Server-Provider:8082 - registration status: 204Tomcat started on port(s): 8082 (http)Updating port to 8082Started DemoApplication in 7.007 seconds (JVM running for 8.355)第3，4行输出表示已经成功从Eureka服务端获取到了服务；第5行表示发送心跳给Eureka服务端，续约（renew）服务；第8到11行表示已经成功将服务注册到了Eureka服务端。再次访问http://localhost:8080/，可看到服务列表里已经出现了名字为Server-providerde服务了：UP表示在线的意思（如果Eureka客户端正常关闭，那么这里的状态将变为DOWN），点击后面的链接192.168.73.109:Server-Provider:8082将访问该服务的/info接口：这时候关闭Eureka客户端，再次刷新http://localhost:8080/：可看到虽然Eureka客户端已经关闭了，但是Eureka服务端页面的服务服务列表中依然还有该服务，并且页面红色文字提示：EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.大致意思是Eureka已经进入了保护模式。微服务在部署之后可能由于网络问题造成Eureka客户端无法成功的发送心跳给Eureka服务端，这时候Eureka服务端认定Eureka客户端已经挂掉了，虽然实际上Eureka客户端还在正常的运行着。而保护模式就是为了解决这个问题，即当Eureka服务端在短时间内同时丢失了过多的Eureka客户端时，Eureka服务端会进入保护模式，不去剔除这些客户端。因为我们这里只部署了一个Eureka客户端服务，所以关闭客户端后满足“短时间内丢失过多Eureka客户端”的条件。在开发中可以先将保护模式给关了，我们在Eureka服务端加上一条配置:123eureka: server: enable-self-preservation: falseEureka-Server集群Eureka服务端充当了重要的角色，所有Eureka客户端都将自己提供的服务注册到Eureka服务端，然后供所有服务消费者使用。如果单节点的Eureka服务端宕机了，那么所有服务都无法正常的访问，这必将是灾难性的。为了提高Eureka服务端的可用性，我们一般会对其集群部署，即同时部署多个Eureka服务端，并且可以相互间同步服务。在搭建Eureka服务端的时候我们曾把下面两个配置给关闭了：1234eureka: client: register-with-eureka: false fetch-registry: false实际上在Eureka集群模式中，开启这两个参数可以让当前Eureka服务端将自己也作为服务注册到别的Eureka服务端，并且从别的Eureka服务端获取服务进行同步。所以这里我们将这两个参数置为true（默认就是true），下面开始搭建Eureka服务端集群，为了简单起见这里只搭建两个节点的Eureka服务端集群。在Eureka-Server项目的src/main/resource目录下新建application-peer1.yml，配置如下：123456789101112131415server: port: 8080spring: application: name: Eureka-Servereureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8081/eureka/ server: enable-self-preservation: falseserver.port=8080指定端口为8080；spring.application.name=Eureka-Server指定了服务名称为Eureka-Server；eureka.instance.hostname=peer1指定地址为peer1；eureka.client.serviceUrl.defaultZone=http://peer2:8081/eureka/指定Eureka服务端的地址为另外一个Eureka服务端的地址peer2。下面我们创建另外一个Eureka服务端peer2的yml配置application-peer2.yml：123456789101112131415server: port: 8081spring: application: name: Eureka-Servereureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8080/eureka/ server: enable-self-preservation: falsepeer2中的serviceUrl我们指向Eureka服务端peer1。为了让这种在一台机器上配置两个hostname的方式生效，我们需要修改下hosts文件（位置C:\Windows\System32\drivers\etc）：12127.0.0.1 peer1127.0.0.1 peer2我们将Eureka-Server项目打包成jar，然后分别运行以下两条命令来部署peer1和peer2：12java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2启动后，我们来访问peer1http://localhost:8080/：可看到DS Replicas(副本)指向了peer2，registered-replicas和available-replicas都指向了http://peer2:8081/eureka/。访问http://localhost:8081/我们也可以看到类似的信息。因为Eureka服务端做了集群处理，所以Eureka客户端指定的服务端地址也要进行修改：1234eureka: client: serviceUrl: defaultZone: http://peer1:8080/eureka/,http://peer2:8081/eureka/我们将Eureka客户端（Server-Provider）打成jar包，然后分别用端口8082和8083启动两个服务：12java -jar Eureka-Client-0.0.1-SNAPSHOT.jar --server.port=8082java -jar Eureka-Client-0.0.1-SNAPSHOT.jar --server.port=8083然后访问http://peer2:8080/eureka/或者http://peer2:8081/eureka/： 搭建Server-Consumer服务消费者在实际项目中，Eureka客户端即是服务提供者，也是服务消费者，即自身的接口可能被别的服务访问，同时也可能调用别的服务接口。这里为了更好的演示，我们把服务消费者单独的分开来演示。新建一个Spring Boot项目，artifactId填Server-Consumer，其主要的任务就是将自身的服务注册到Eureka服务端，并且获取Eureka服务端提供的服务并进行消费。这里服务的消费我们用Ribbon来完成，Ribbon是一款实现服务负载均衡的开源软件，这里不做详细介绍。引入Eureka客户端和Ribbon依赖：12345678910111213141516171819202122232425&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;同样的，在入口类中加入@EnableDiscoveryClient注解用于发现服务和注册服务，并配置一个RestTemplate Bean，然后加上@LoadBalanced注解来开启负载均衡：1234567891011121314151617181920import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@EnableDiscoveryClient@SpringBootApplicationpublic class DemoApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;接着编写一个TestController，用于消费服务：12345678910@RestControllerpublic class TestController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("/info") public String getInfo() &#123; return this.restTemplate.getForEntity("http://Server-Provider/info", String.class).getBody(); &#125;&#125;上面代码注入了RestTemplate，getInfo中使用RestTemplate对象均衡的去获取服务并消费。可以看到我们使用服务名称（Server-Provider）去获取服务的，而不是使用传统的IP加端口的形式。这就体现了使用Eureka去获取服务的好处，我们只要保证这个服务名称不变即可，IP和端口不再是我们关心的点。最后编写下配置文件application.yml：1234567891011server: port: 9000 spring: application: name: Server-Consumer eureka: client: serviceUrl: defaultZone: http://peer1:8080/eureka/,http://peer2:8081/eureka/端口为9000，服务名称为Server-Consumer并指定了Eureka服务端的地址。启动该项目，访问http://localhost:9000/info：成功获取到了信息，我们多次访问这个接口，然后观察8082和8083Eureka客户端的后台：可以看到它们的后台都打印出了信息，说明我们从9000去获取服务是均衡的。这时候我们关闭一个Eureka服务端，再次访问http://localhost:9000/info，还是可以成功获取到信息，这就是Eureka服务端集群的好处。Eureka-Server添加认证出于安全的考虑，我们可能会对Eureka服务端添加用户认证的功能。我们在Eureka-Server引入Spring-Security依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;然后在application.yml中配置用户名和密码：123456security: basic: enabled: true user: name: mrbird password: 123456Eureka服务端配置了密码之后，所有eureka.client.serviceUrl.defaultZone的配置也必须配置上用户名和密码，格式为：eureka.client.serviceUrl.defaultZone=http://${userName}:${password}@${hosetname}:${port}/eureka/，如：1234eureka: client: serviceUrl: defaultZone: http://mrbird:123456@peer2:8081/eureka/重新打包并部署后，访问http://localhost:8080/，页面将弹出验证窗口，输入用户名和密码后即可访问。Eureka配置下面我们总结一下在Eureka中常用的配置选项及代表的含义：配置含义默认值eureka.client.enabled是否启用Eureka Clienttrueeureka.client.register-with-eureka表示是否将自己注册到Eureka Servertrueeureka.client.fetch-registry表示是否从Eureka Server获取注册的服务信息trueeureka.client.serviceUrl.defaultZone配置Eureka Server地址，用于注册服务和获取服务http://localhost:8761/eurekaeureka.client.registry-fetch-interval-seconds默认值为30秒，即每30秒去Eureka Server上获取服务并缓存30eureka.instance.lease-renewal-interval-in-seconds向Eureka Server发送心跳的间隔时间，单位为秒，用于服务续约30eureka.instance.lease-expiration-duration-in-seconds定义服务失效时间，即Eureka Server检测到Eureka Client木有心跳后（客户端意外下线）多少秒将其剔除90eureka.server.enable-self-preservation用于开启Eureka Server自我保护功能trueeureka.client.instance-info-replication-interval-seconds更新实例信息的变化到Eureka服务端的间隔时间，单位为秒30eureka.client.eureka-service-url-poll-interval-seconds轮询Eureka服务端地址更改的间隔时间，单位为秒。300eureka.instance.prefer-ip-address表示使用IP进行配置为不是域名falseeureka.client.healthcheck.enabled默认Erueka Server是通过心跳来检测Eureka Client的健康状况的，通过置为true改变Eeureka Server对客户端健康检测的方式，改用Actuator的/health端点来检测。falseEureka还有许多别的配置，具体可以参考EurekaClientConfigBean，EurekaServerConfigBean和EurekaInstanceConfigBean配置类的源码。参考链接：http://cloud.spring.io/spring-cloud-netflix/1.4.x/multi/multi__service_discovery_eureka_clients.html源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/28.Spring-Cloud-Eureka-Server-Discovery]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security OAuth2 SSO]]></title>
    <url>%2FSpring-Security-OAuth2-SSO.html</url>
    <content type="text"><![CDATA[SSO（Single Sign On）即单点登录，效果是多个系统间，只要登录了其中一个系统，别的系统不用登录操作也能访问。比如在浏览器上同时打开天猫和淘宝页面，在天猫页面进行登录，然后回到淘宝页面刷新后会发现淘宝也已经是登录状态了。这节将介绍如何使用Spring Security OAuth2实现单点登录。框架搭建我们需要创建一个maven多模块项目，包含认证服务器和两个客户端。新建一个maven项目，作为项目的父模块，pom如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;sso-application-one&lt;/module&gt; &lt;module&gt;sso-application-two&lt;/module&gt; &lt;module&gt;sso-server&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;sso&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;sso&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;然后在该maven项目下新建一个module，artifactId为sso-server（作为认证服务器），pom如下所示：12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;sso&lt;/artifactId&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;sso-server&lt;/artifactId&gt;&lt;/project&gt;接着继续新增一个module模块，artifactId为sso-application-one（作为客户端一），pom如下所示：12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;sso&lt;/artifactId&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;sso-application-one&lt;/artifactId&gt;&lt;/project&gt;另外一个客户端和sso-application-one一致，只不过artifactId为sso-application-two。至此，项目的基本框架搭建好了，结构如下所示:认证服务器配置认证服务器作用就是作为统一令牌发放并校验的地方，所以我们先要编写一些基本的Spring Security 安全配置的代码指定如何进行用户认证。新建一个Spring Security配置类，继承WebSecurityConfigurerAdapter：12345678910111213141516@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .and() .authorizeRequests() .anyRequest() .authenticated(); &#125;&#125;上面简单配置了密码加密使用bcrypt方式，并且所有请求都需要认证，认证方式为Spring Security自带的登录页面认证（也可以根据前面教程来自定义登录页面，这里为了简单起见，就直接用自带的登录页了）。接着需要定义一个自定义用户登录认证的服务：1234567891011121314151617@Configurationpublic class UserDetailService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; MyUser user = new MyUser(); user.setUserName(username); user.setPassword(this.passwordEncoder.encode("123456")); return new User(username, user.getPassword(), user.isEnabled(), user.isAccountNonExpired(), user.isCredentialsNonExpired(), user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList("user:add")); &#125;&#125;基本逻辑是用户名随便写，密码为123456，并且拥有user:add权限。这些前面都介绍过了，就不再详细说明了。MyUser的代码如下：12345678910111213141516public class MyUser implements Serializable &#123; private static final long serialVersionUID = 3497935890426858541L; private String userName; private String password; private boolean accountNonExpired = true; private boolean accountNonLocked= true; private boolean credentialsNonExpired= true; private boolean enabled= true; // get，set略&#125;接着开始编写认证服务器配置。新建SsoAuthorizationServerConfig，继承AuthorizationServerConfigurerAdapter：1234567891011121314151617181920212223242526272829303132333435363738@Configuration@EnableAuthorizationServerpublic class SsoAuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private PasswordEncoder passwordEncoder; @Autowired private UserDetailService userDetailService; @Bean public TokenStore jwtTokenStore() &#123; return new JwtTokenStore(jwtAccessTokenConverter()); &#125; @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() &#123; JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter(); accessTokenConverter.setSigningKey("test_key"); return accessTokenConverter; &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; // 见下方 &#125; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.tokenStore(jwtTokenStore()) .accessTokenConverter(jwtAccessTokenConverter()) .userDetailsService(userDetailService); &#125; @Override public void configure(AuthorizationServerSecurityConfigurer security) &#123; security.tokenKeyAccess("isAuthenticated()"); // 获取密钥需要身份认证 &#125;&#125;Token使用JWT，这些配置都在前面几节OAuth2教程里介绍过了就不再赘述了，这里详细说下configure(ClientDetailsServiceConfigurer clients)的配置：1234567891011121314151617...@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("app-a") .secret(passwordEncoder.encode("app-a-1234")) .authorizedGrantTypes("refresh_token","authorization_code") .accessTokenValiditySeconds(3600) .scopes("all"); .and() .withClient("app-b") .secret(passwordEncoder.encode("app-b-1234")) .authorizedGrantTypes("refresh_token","authorization_code") .accessTokenValiditySeconds(7200) .scopes("all");&#125;...这里分配了两个客户端配置，分别为app-a和app-b，因为使用默认的Spring Security登录页面来进行认证，所以需要开启authorization_code类型认证支持。认证服务器的application.yml配置如下：1234server: port: 8080 servlet: context-path: /server认证服务器的搭建就告一段落了，接下来开始客户端代码编写。客户端配置两个客户端的代码基本一致，所以这里只介绍其中一个，另一个可以参考源码。在客户端SpringBoot入口类上添加@EnableOAuth2Sso注解，开启SSO的支持：12345678@EnableOAuth2Sso@SpringBootApplicationpublic class SsoApplicaitonOne &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(SsoApplicaitonOne.class).run(args); &#125;&#125;接下来的重点是配置文件application.yml的配置：1234567891011121314security: oauth2: client: client-id: app-a client-secret: app-a-1234 user-authorization-uri: http://127.0.0.1:8080/server/oauth/authorize access-token-uri: http://127.0.0.1:8080/server/oauth/token resource: jwt: key-uri: http://127.0.0.1:8080/server/oauth/token_keyserver: port: 9090 servlet: context-path: /app1security.oauth2.client.client-id和security.oauth2.client.client-secret指定了客户端id和密码，这里和认证服务器里配置的client一致（另外一个客户端为app-b）；user-authorization-uri指定为认证服务器的/oauth/authorize地址，access-token-uri指定为认证服务器的/oauth/token地址，jwt.key-uri指定为认证服务器的/oauth/token_key地址。这里端口指定为9090，context-path为app1，另一个客户端端口指定为9091，context-path为app2。接着在resources/static下新增一个index.html页面，用于跳转到另外一个客户端：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;管理系统一&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;管理系统一&lt;/h1&gt; &lt;a href="http://127.0.0.1:9091/app2/index.html"&gt;跳转到管理系统二&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;为了验证是否认证成功，我们新增一个控制器：12345678@RestControllerpublic class UserController &#123; @GetMapping("user") public Principal user(Principal principal) &#123; return principal; &#125;&#125;另外一个客户端的代码略，可以参考源码。测试效果先启动认证服务器，任何在启动两个客户端。启动后，访问http://127.0.0.1:9090/app1/index.html：可以看到页面被重定向到认证服务器的登录页面，根据我们定义的UserDetailService，用户名随便填，密码为123456。登录后页面跳转到：这个URL为:http://127.0.0.1:8080/server/oauth/authorize?client_id=app-a&amp;redirect_uri=http://127.0.0.1:9090/app1/login&amp;response_type=code&amp;state=7Dqcbr页面提示的意思是：非法请求，至少需要一个重定向URL被注册到client。从URL中可以看出，redirect_uri为http://127.0.0.1:9090/app1/login，所以我们修改认证服务器client相关配置如下：1234567891011121314151617@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("app-a") .secret(passwordEncoder.encode("app-a-1234")) .authorizedGrantTypes("refresh_token","authorization_code") .accessTokenValiditySeconds(3600) .scopes("all") .redirectUris("http://127.0.0.1:9090/app1/login") .and() .withClient("app-b") .secret(passwordEncoder.encode("app-b-1234")) .authorizedGrantTypes("refresh_token","authorization_code") .accessTokenValiditySeconds(7200) .scopes("all") .redirectUris("http://127.0.0.1:9091/app2/login");&#125;重启认证服务器，重复上面的过程，这次登录后，页面跳转到了授权页面：点击Authorize：这时候app-a对应的客户端已经登录了，点击跳转到系统二：页面直接来到授权页，而不需要重新输入用户名密码，继续点击Authorize：系统二也已经成功登录，访问http://127.0.0.1:9091/app2/user看是否能成功获取到用户信息：到这里我们已经实现了单点登录的基本功能了。但是在这个过程中需要用户点击Authorize授权，体验并不是很好，我们可以去掉它。修改认证服务器Client配置如下：12345678910111213141516171819@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("app-a") .secret(passwordEncoder.encode("app-a-1234")) .authorizedGrantTypes("refresh_token","authorization_code") .accessTokenValiditySeconds(3600) .scopes("all") .autoApprove(true) .redirectUris("http://127.0.0.1:9090/app1/login") .and() .withClient("app-b") .secret(passwordEncoder.encode("app-b-1234")) .authorizedGrantTypes("refresh_token","authorization_code") .accessTokenValiditySeconds(7200) .scopes("all") .autoApprove(true) .redirectUris("http://127.0.0.1:9091/app2/login");&#125;autoApprove(true)自动授权。修改后重启即可看到效果。权限校验Spring Security权限校验前面介绍过了，这里看下在单点登录模式下如何进行权限校验。在客户端控制器里加入如下代码:1234567891011@GetMapping("auth/test1")@PreAuthorize("hasAuthority('user:add')")public String authTest1()&#123; return "您拥有'user:add'权限";&#125;@GetMapping("auth/test2")@PreAuthorize("hasAuthority('user:update')")public String authTest2()&#123; return "您拥有'user:update'权限";&#125;在客户端新增Spring Security配置类:1234@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123;&#125;改完后，先启动认证服务器，在启动客户端。在启动客户端的时候出现异常：12345678910Caused by: java.lang.IllegalStateException: @Order on WebSecurityConfigurers must be unique. Order of 100 was already used on cc.mrbird.sso.client.config.WebSecurityConfigurer$$EnhancerBySpringCGLIB$$aa470b71@34d45ec0, so it cannot be used on org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2SsoDefaultConfiguration$$EnhancerBySpringCGLIB$$6f69df92@18137eab too. at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.setFilterChainProxySecurityConfigurer(WebSecurityConfiguration.java:148) ~[spring-security-config-5.1.5.RELEASE.jar:5.1.5.RELEASE] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_171] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_171] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_171] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_171] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:708) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) ~[spring-beans-5.1.8.RELEASE.jar:5.1.8.RELEASE] ... 16 common frames omitted大致意思是，认证服务器已经配置了Spring Security配置，并且顺序为100，和客户端的Spring Security配置冲突了。所以我们修改下客户端的Spring Security配置顺序：12345@Order(101)@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123;&#125;让它的优先级小于认证服务器的Spring Security配置。重新启动客户端，进行单点登录操作，登录成功后，访问http://127.0.0.1:9090/app1/auth/test1：访问http://127.0.0.1:9090/app1/auth/test2：返回403，没权限，说明权限注解生效了。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/66.Spring-Security-OAuth2-SSO]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Cloud</tag>
        <tag>Spring Security</tag>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6学习笔记]]></title>
    <url>%2FES2015-Learn-Note.html</url>
    <content type="text"><![CDATA[ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。这里主要记录下学习ES6中值得记录的地方，以备忘。const恒量cont限制的给恒量分配值得动作，而不是限制恒量里的值，比如下面这个例子失败的：12345const fruit = '🍎'console.log(fruit)const fruit = '🍋'console.log(fruit)而下面这个例子是可行的：123const fruit = []fruit.push('🍋')console.log(fruit)解构解构就是将一个数据结构进行分解，通常分为数组解构，对象解构和参数解构。数组解构在ES6之前，要将数组里的每个值分配给一个变量，需要这样做:123456789function food() &#123; return ['🍰', '☕', '🍓']&#125;var temp = food()var dessert = temp[0]var drink = temp[1]var fruit = temp[2]console.log(dessert, drink, fruit)ES6后可以这样做：123456function food() &#123; return ['🍰', '☕', '🍓']&#125;let [dessert, drink, fruit] = food()console.log(dessert, drink, fruit)输出结果是一样的，是不是很方便？对象解构将food返回改为一个对象，然后解构：123456function food() &#123; return &#123;dessert: '🍰', drink: '☕', fruit: '🍓'&#125;&#125;let &#123;dessert: dessert1, drink: drink1, fruit: fruit1&#125; = food()console.log(dessert1, drink1, fruit1)这里做的是将对象里的dessert属性值赋予给dessert1，依此类推，有点颠倒的感觉，结果如下：参数解构使用对象解构的方式，我们可以很容易的给函数传递一个对象参数：12345function food(dessert, drink, &#123;location, restaurant&#125; = &#123;&#125;) &#123; console.log(dessert, drink, location, restaurant)&#125;food('🎂', '☕', &#123;location: 'fuzhou', restaurant: 'MrBird\'s Restaurant'&#125;)模板字符串ES6之前的字符串拼接：123456let weather = '🌞', mood = '😄', drink = '🍸'let message = "今天天气：" + weather + "，喝了一杯：" + drink + "，心情：" + moodconsole.log(message)ES6后我们可以这样做：123456let weather = '🌞', mood = '😄', drink = '🍸'let message = `今天天气：$&#123;weather&#125; ，喝了一杯：$&#123;drink&#125; ，心情：$&#123;mood&#125;`console.log(message)带标签的模板字符串可以在模板字符串前加个标签，这个标签是个函数，我们可以在这个函数里输出一些值：12345678910let weather = '🌞', mood = '😄', drink = '🍸'let message = note`今天天气：$&#123;weather&#125; ，喝了一杯：$&#123;drink&#125; ，心情：$&#123;mood&#125;`function note(strings, ...params) &#123; console.log(strings) console.log(params)&#125;可以看到，strings里的内容是模板字符串的每一个部分，...params包含的是模板字符串里的所有变量值。字符串几个新方法以什么开头startsWith，以什么结尾endsWith，是否包含includes：1234567891011let weather = '🌞', mood = '😄', drink = '🍸'let message = `今天天气：$&#123;weather&#125; ，喝了一杯：$&#123;drink&#125; ，心情：$&#123;mood&#125;`console.log( message.startsWith('今天'), message.endsWith('😄'), message.includes('🍉'))参数默认值ES6后我们可以给函数参数指定默认值：123456789function food(dessert = '🎂', drink = '🍵') &#123; return `$&#123;dessert&#125; and $&#123;drink&#125;`&#125;console.log( food(), '\n', food('🌭', '🍺'))操作符...展开操作符在数组前加...，称为展开操作符，可以用于展开数组：123456789101112let fruits = ['🍍', '🍎'], foods = ['🍟', ...fruits]console.log( fruits, '\n', ...fruits, '\n', foods, '\n', ...foods)剩余操作符在函数参数前加...，称为剩余操作符，用于接收函数剩下的参数：12345function food(dessert,drink,...foods) &#123; console.log(dessert,drink,foods)&#125;food('🎂','🍺','🍟','🍤','🍖')剩余的参数被放到了一个数组里。函数的名字ES6函数新增了name属性，用于输出函数的名字:123456789function food() &#123; &#125;var food_1 = function () &#123; &#125;var food_2 = function deliciousFood() &#123; &#125;console.log( food.name, food_1.name, food_2.name)Object新增方法Object.is()判断两个东西是不是同一个：12345678console.log(+0 == -0)console.log(+0 === -0)console.log(NaN == NaN)console.log(NaN === NaN)console.log(Object.is(+0, -0))console.log(Object.is(NaN, NaN))Object.assign()作用就是将一个对象的内容赋予给另外一个对象：1234let food = &#123;dessert:'🍦'&#125;Object.assign(food, &#123;drink: '🥣', fruit: '🥝'&#125;)console.log(food)第一个参数为接收者，第二个参数为赋予者。Object.setPrototypeOf()设置对象的prototype，给个例子体会：12345678910111213141516171819let breakfast = &#123; getFood() &#123; return '🧀' &#125;&#125;let lunch = &#123; getFood() &#123; return '🍜' &#125;&#125;let dinner = Object.create(lunch)console.log(dinner.getFood())console.log(Object.getPrototypeOf(dinner) === lunch)Object.setPrototypeOf(dinner, breakfast)console.log(dinner.getFood())console.log(Object.getPrototypeOf(dinner) === breakfast)__proto__我们还可以用__proto__（前后各两个下划线）设置对象的prototype：123456789101112131415161718192021let breakfast = &#123; getFood() &#123; return '🧀' &#125;&#125;let lunch = &#123; getFood() &#123; return '🍜' &#125;&#125;let dinner = &#123; __proto__: lunch&#125;console.log(dinner.getFood())console.log(Object.getPrototypeOf(dinner) === lunch)dinner.__proto__ = breakfastconsole.log(dinner.getFood())console.log(Object.getPrototypeOf(dinner) === breakfast)super看下super的用法：12345678910111213let lunch = &#123; getFood() &#123; return '🍜' &#125;&#125;let dinner = &#123; __proto__: lunch, getFood() &#123; return super.getFood() + ' and 🥗' &#125;&#125;console.log(dinner.getFood())生成迭代器ES6中我们可以使用function*和yield生成一个迭代器：1234567891011function* cook(foods) &#123; for (value of foods) &#123; yield value &#125;&#125;let result = cook(['🌮', '🍿', '🥧'])console.log(result.next())console.log(result.next())console.log(result.next())console.log(result.next())class类ES6允许我们在JavaScript中定义一个类：1234567891011class Cook &#123; constructor(food) &#123; this.food = food &#125; make() &#123; console.log(this.food) &#125;&#125;let mrbird = new Cook(['🥞'])mrbird.make()类里包含了一个有参构造器和方法。get &amp;&amp; set我们可以在类里定义get和set：12345678910111213141516171819class Cook &#123; constructor(food) &#123; this.food = food &#125; get foods() &#123; return this.food &#125; set foods(value) &#123; this.food.push(value) &#125;&#125;let mrbird = new Cook(['🥞'])mrbird.foods ='🍣'mrbird.foods ='🥣'console.log(mrbird.foods)静态方法我们可以在类里定义静态方法，静态方法就是不需要实例化类就能调用的方法：12345678910class Cook &#123; constructor(food) &#123; this.food = food &#125; static make(food) &#123; console.log(food) &#125;&#125;Cook.make('🍪')继承ES6允许我们继承类：1234567891011121314151617class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; introduce() &#123; console.log(`$&#123;this.name&#125; is $&#123;this.age&#125; years old`) &#125;&#125;class HandsomeBoy extends Person &#123; constructor(name, age) &#123; super(name, age); &#125;&#125;new HandsomeBoy(&apos;MrBird&apos;, &apos;18&apos;).introduce()Set一些Set的常用操作：12345678910111213141516let foods = new Set('🧀🍧🍨')console.log(foods)foods.add('🍭')foods.add('🍭')console.log(foods)console.log(foods.size)console.log(foods.has('🍨'))foods.delete('🧀')console.log(foods)foods.forEach(food =&gt; console.log(food))foods.clear()console.log(foods)Map一些Map的常用操作：1234567891011121314151617181920212223let food = new Map()let fruit = &#123;&#125;, cook = () =&gt; &#123;&#125;, dessert = '甜点'food.set(fruit, '🍈')food.set(cook, '🥄')food.set(dessert, '🍦')console.log(food)console.log(food.size)console.log(food.get(fruit))console.log(food.get(cook))food.forEach((value, key) =&gt; &#123; console.log(`$&#123;key&#125; = $&#123;value&#125;`)&#125;)food.delete(dessert)console.log(food.has(dessert))food.clear()console.log(food)先到这里吧，详细的还是得参考http://es6.ruanyifeng.com/或者https://babeljs.io/docs/en/learn]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生态学习之Vuex,Vue-Router]]></title>
    <url>%2Fvuex-vuerouter.html</url>
    <content type="text"><![CDATA[文章已加密，请输入密码 😛： 密码错误 😭 No content to display! U2FsdGVkX19TZih8UTmGBJM5q5MJVu1P773cnGtxEXwnTCCgaBaSaJqAD9oyHdl51BMIYhTxcWBXq2p5jA9B9LRM2S4Sq5R4UY03KQyqA5cXNK3FnkwELOsKnakXnyR0JfOCQ6EugELuoCP6kn6M+vjCSMxf++JnwthITv6guHnd7Ml7H3jzuhm1YXpnPEKVUr2K+lK6gITlLZ3vo9P5UTcTuhMZiclpU/m8Wl6KomS/hrnzN2qJYIROw/oXSN+w9snd98Ejcu2ibCuUUK6Sf4IUmUa3VKPDX7joEXyPAw5Ox6jI1zjpQTAmutjhOOYOV5k23ElXKUDtJlU6AuSafP7WJsuJZ5oIFt03DuMLd1+WK45VDq87rq9d4fCgChrZjsKeKAzbin/+owenrVWF4oOLi7eMVz/PgvAAB+EJw/kzUMto08Biw2Q5YfdeB4oj9DZKsld334/IacSUcIOwwbqe4+IfaKZr5Z8ayj/qVtX1MwnuO103cZigTvK/MwJrkxde2Og31opnrb//yMrIxgUMxtL4Av3FVH6Dtl6dcF7jLp9LQPOz0L3+LMxWG73AaE0lIOWTP3IDNSp1NBG99H6Z0cuCwJXoBmXHsNOSW6/Jc7SBwCkTzsfyNoTc4v6x6afVaoYd+qCKVVBg6EySBzC1yiJxGIFz+Ki25uPDk1w=]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security OAuth2自定义令牌配置]]></title>
    <url>%2FSpring-Security-OAuth2-Token-Config.html</url>
    <content type="text"><![CDATA[在前面几节中，我们获取到的令牌都是基于Spring Security OAuth2默认配置生成的，Spring Security允许我们自定义令牌配置，比如不同的client_id对应不同的令牌，令牌的有效时间，令牌的存储策略等；我们也可以使用JWT来替换默认的令牌。自定义令牌配置我们让认证服务器AuthorizationServerConfig继承AuthorizationServerConfigurerAdapter，并重写它的configure(ClientDetailsServiceConfigurer clients)方法：1234567891011121314151617181920212223242526272829303132@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; ...... @Autowired private AuthenticationManager authenticationManager; @Autowired private UserDetailService userDetailService; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.authenticationManager(authenticationManager) .userDetailsService(userDetailService); &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("test1") .secret("test1111") .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000) .scopes("all", "a", "b", "c") .authorizedGrantTypes("password") .and() .withClient("test2") .secret("test2222") .accessTokenValiditySeconds(7200); &#125;&#125;认证服务器在继承了AuthorizationServerConfigurerAdapter适配器后，需要重写configure(AuthorizationServerEndpointsConfigurer endpoints)方法，指定 AuthenticationManager和UserDetailService。创建一个新的配置类SecurityConfig，在里面注册我们需要的AuthenticationManagerBean：123456789@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean(name = BeanIds.AUTHENTICATION_MANAGER) @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125;此外，重写configure(ClientDetailsServiceConfigurer clients)方法主要配置了：定义两个client_id，及客户端可以通过不同的client_id来获取不同的令牌；client_id为test1的令牌有效时间为3600秒，client_id为test2的令牌有效时间为7200秒；client_id为test1的refresh_token（下面会介绍到）有效时间为864000秒，即10天，也就是说在这10天内都可以通过refresh_token来换取新的令牌；在获取client_id为test1的令牌的时候，scope只能指定为all，a，b或c中的某个值，否则将获取失败；只能通过密码模式(password)来获取client_id为test1的令牌，而test2则无限制。启动项目，演示几个效果。启动项目后使用密码模式获取test1的令牌：和前面介绍的那样，头部需要传入test1:test1111经过base64加密后的值： 点击发送后，意外的返回了错误！控制台输出了 Encoded password does not look like BCrypt 的告警。查阅资料后发现，在新版本的spring-cloud-starter-oauth2指定client_secret的时候需要进行加密处理：123456789101112131415161718192021@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; ...... @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("test1") .secret(new BCryptPasswordEncoder().encode("test1111")) .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000) .scopes("all", "a", "b", "c") .authorizedGrantTypes("password") .and() .withClient("test2") .secret(new BCryptPasswordEncoder().encode("test2222")) .accessTokenValiditySeconds(7200); &#125;&#125;在前面自定义登录认证获取令牌一节中，我们在MyAuthenticationSucessHandler判断了client_secret的值是否正确。由于我们这里client_secret加密了，所以判断逻辑需要调整为下面这样:123456...else if (!passwordEncoder.matches(clientSecret, clientDetails.getClientSecret())) &#123; throw new UnapprovedClientAuthenticationException("clientSecret不正确");&#125; ...言归正传，修改后重启项目，重新使用密码模式获取令牌：123456&#123; "access_token": "c23376b0-efa3-4905-8356-8c9583c2a2a0", "token_type": "bearer", "expires_in": 3599, "scope": "all"&#125;可以看到expires_in的时间是我们定义的3600秒。将scope指定为d看看会有什么结果:由于我们定义了只能通过密码模式来获取client_id为test1的令牌，所以我们看看将grant_type改为xxoo会有什么结果:默认令牌是存储在内存中的，我们可以将它保存到第三方存储中，比如Redis。创建TokenStoreConfig：1234567891011@Configurationpublic class TokenStoreConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public TokenStore redisTokenStore ()&#123; return new RedisTokenStore(redisConnectionFactory); &#125;&#125;然后在认证服务器里指定该令牌存储策略。重写configure(AuthorizationServerEndpointsConfigurer endpoints)方法：123456789101112131415@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private TokenStore redisTokenStore; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.authenticationManager(authenticationManager) .tokenStore(redisTokenStore); &#125; ......&#125;重启项目获取令牌后，查看Redis中是否存储了令牌相关信息：可以看到，令牌信息已经存储到Redis里了。使用JWT替换默认令牌使用JWT替换默认的令牌（默认令牌使用UUID生成）只需要指定TokenStore为JwtTokenStore即可。创建一个JWTokenConfig配置类：123456789101112131415@Configurationpublic class JWTokenConfig &#123; @Bean public TokenStore jwtTokenStore() &#123; return new JwtTokenStore(jwtAccessTokenConverter()); &#125; @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() &#123; JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter(); accessTokenConverter.setSigningKey("test_key"); // 签名密钥 return accessTokenConverter; &#125;&#125;签名密钥为test_key。在配置类里配置好JwtTokenStore后，我们在认证服务器里指定它：1234567891011121314151617@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private TokenStore jwtTokenStore; @Autowired private JwtAccessTokenConverter jwtAccessTokenConverter; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; endpoints.authenticationManager(authenticationManager) .tokenStore(jwtTokenStore) .accessTokenConverter(jwtAccessTokenConverter); &#125; ......&#125;重启服务获取令牌，系统将返回如下格式令牌：1234567&#123; "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NjE1MzI1MDEsInVzZXJfbmFtZSI6Im1yYmlyZCIsImF1dGhvcml0aWVzIjpbImFkbWluIl0sImp0aSI6IjJkZjY4MGNhLWFmN2QtNGU4Ni05OTdhLWI1ZmVkYzQxZmYwZSIsImNsaWVudF9pZCI6InRlc3QxIiwic2NvcGUiOltdfQ.dZ4SeuU3VWnSJKy5vELGQ0YkVRddcEydUlJAVovlycg", "token_type": "bearer", "expires_in": 3599, "scope": "all", "jti": "2df680ca-af7d-4e86-997a-b5fedc41ff0e"&#125;将access_token中的内容复制到https://jwt.io/网站解析下：使用这个token访问/index可以成功获取到信息，这里就不演示了。拓展JWT上面的Token解析得到的PAYLOAD内容为：12345678910&#123; "exp": 1561532501, "user_name": "mrbird", "authorities": [ "admin" ], "jti": "2df680ca-af7d-4e86-997a-b5fedc41ff0e", "client_id": "test1", "scope": ["all"]&#125;如果想在JWT中添加一些额外的信息，我们需要实现TokenEnhancer（Token增强器）：123456789public class JWTokenEnhancer implements TokenEnhancer &#123; @Override public OAuth2AccessToken enhance(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication) &#123; Map&lt;String, Object&gt; info = new HashMap&lt;&gt;(); info.put("message", "hello world"); ((DefaultOAuth2AccessToken) oAuth2AccessToken).setAdditionalInformation(info); return oAuth2AccessToken; &#125;&#125;我们在Token中添加了message: hello world信息。然后在JWTokenConfig里注册该Bean：123456789@Configurationpublic class JWTokenConfig &#123; ...... @Bean public TokenEnhancer tokenEnhancer() &#123; return new JWTokenEnhancer(); &#125;&#125;最后在认证服务器里配置该增强器：12345678910111213141516171819202122232425@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; @Autowired private TokenStore jwtTokenStore; @Autowired private JwtAccessTokenConverter jwtAccessTokenConverter; @Autowired private TokenEnhancer tokenEnhancer; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123; TokenEnhancerChain enhancerChain = new TokenEnhancerChain(); List&lt;TokenEnhancer&gt; enhancers = new ArrayList&lt;&gt;(); enhancers.add(tokenEnhancer); enhancers.add(jwtAccessTokenConverter); enhancerChain.setTokenEnhancers(enhancers); endpoints.tokenStore(jwtTokenStore) .accessTokenConverter(jwtAccessTokenConverter) .tokenEnhancer(enhancerChain); &#125; ......&#125;重启项目，再次获取令牌，系统返回：1234567&#123; "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJtcmJpcmQiLCJzY29wZSI6W10sImV4cCI6MTU2MTUzNDQ1MCwibWVzc2FnZSI6ImhlbGxvIHdvcmxkIiwiYXV0aG9yaXRpZXMiOlsiYWRtaW4iXSwianRpIjoiY2E1NDA3ZTEtMzBmZS00MzA3LThiYmItYjU2NGY5Y2ViOWUzIiwiY2xpZW50X2lkIjoidGVzdDEifQ.qW92ssifRKi_rxX2XIH2u4D5IUPVcKECv812hTpuUuA", "token_type": "bearer", "expires_in": 3599, "message": "hello world", "jti": "ca5407e1-30fe-4307-8bbb-b564f9ceb9e3"&#125;可以看到，在返回的JSON内容里已经多了我们添加的message信息，此外将access_token复制到jwt.io网站解析，内容如下：1234567891011&#123; "user_name": "mrbird", "scope": [], "exp": 1561534450, "message": "hello world", "authorities": [ "admin" ], "jti": "ca5407e1-30fe-4307-8bbb-b564f9ceb9e3", "client_id": "test1"&#125;解析后的JWT也包含了我们添加的message信息。Java中解析JWT要在Java代码中解析JWT，需要添加如下依赖：12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;修改/index：1234567@GetMapping("index")public Object index(@AuthenticationPrincipal Authentication authentication, HttpServletRequest request) &#123; String header = request.getHeader("Authorization"); String token = StringUtils.substringAfter(header, "bearer "); return Jwts.parser().setSigningKey("test_key".getBytes(StandardCharsets.UTF_8)).parseClaimsJws(token).getBody();&#125;signkey需要和JwtAccessTokenConverter中指定的签名密钥一致。重启项目，获取令牌后访问/index，输出内容如下：123456789101112&#123; "exp": 1561557893, "user_name": "mrbird", "authorities": [ "admin" ], "jti": "3c29f89a-1344-40d8-bcfd-1b9c45fb8b89", "client_id": "test1", "scope": [ "all" ]&#125;刷新令牌令牌过期后我们可以使用refresh_token来从系统中换取一个新的可用令牌。但是从前面的例子可以看到，在认证成功后返回的JSON信息里并没有包含refresh_token，要让系统返回refresh_token，需要在认证服务器自定义配置里添加如下配置：123456789101112131415161718192021@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123; ...... @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient("test1") .secret(new BCryptPasswordEncoder().encode("test1111")) .authorizedGrantTypes("password", "refresh_token") .accessTokenValiditySeconds(3600) .refreshTokenValiditySeconds(864000) .scopes("all", "a", "b", "c") .and() .withClient("test2") .secret(new BCryptPasswordEncoder().encode("test2222")) .accessTokenValiditySeconds(7200); &#125;&#125;授权方式需要加上refresh_token，除了四种标准的OAuth2获取令牌方式外，Spring Security OAuth2内部把refresh_token当作一种拓展的获取令牌方式。通过上面的配置，使用test1这个client_id获取令牌时将返回refresh_token，refresh_token的有效期为10天，即10天之内都可以用它换取新的可用令牌。重启项目，认证成功后，系统返回如：12345678&#123; "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NjE1NTgwOTcsInVzZXJfbmFtZSI6Im1yYmlyZCIsImF1dGhvcml0aWVzIjpbImFkbWluIl0sImp0aSI6Ijg2NTdhMDBlLTFiM2MtNDA5NS1iMjNmLTJlMjUxOWExZmUwMiIsImNsaWVudF9pZCI6InRlc3QxIiwic2NvcGUiOlsiYWxsIl19.hrxKOz3NKY6Eq8k5QeOqKhXUQ4aAbicrb6J5y-LBRA0", "token_type": "bearer", "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJtcmJpcmQiLCJzY29wZSI6WyJhbGwiXSwiYXRpIjoiODY1N2EwMGUtMWIzYy00MDk1LWIyM2YtMmUyNTE5YTFmZTAyIiwiZXhwIjoxNTYyNDE4NDk3LCJhdXRob3JpdGllcyI6WyJhZG1pbiJdLCJqdGkiOiI2MTNjMDVlNS1hNzUzLTRmM2UtOWViOC1hZGE4MTJmY2IyYWQiLCJjbGllbnRfaWQiOiJ0ZXN0MSJ9.efw9OePFUN9X6UGMF3h9BF_KO3zqyIfpvfmE8XklBDs", "expires_in": 3599, "scope": "all", "jti": "8657a00e-1b3c-4095-b23f-2e2519a1fe02"&#125;假设现在access_token过期了，我们用refresh_token去换取新的令牌。使用postman发送如下请求：12345678&#123; "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NjE1NTgyMzEsInVzZXJfbmFtZSI6Im1yYmlyZCIsImF1dGhvcml0aWVzIjpbImFkbWluIl0sImp0aSI6ImFmNjU5MTE3LWJkMTItNDNmZS04YzE2LTM0MDQxMTMyZDFlOCIsImNsaWVudF9pZCI6InRlc3QxIiwic2NvcGUiOlsiYWxsIl19.4ZD5bXxsXjSw62_1wVl2QpHUKYcC8_1phdNRP02Iihs", "token_type": "bearer", "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJtcmJpcmQiLCJzY29wZSI6WyJhbGwiXSwiYXRpIjoiYWY2NTkxMTctYmQxMi00M2ZlLThjMTYtMzQwNDExMzJkMWU4IiwiZXhwIjoxNTYyNDE4NDk3LCJhdXRob3JpdGllcyI6WyJhZG1pbiJdLCJqdGkiOiI2MTNjMDVlNS1hNzUzLTRmM2UtOWViOC1hZGE4MTJmY2IyYWQiLCJjbGllbnRfaWQiOiJ0ZXN0MSJ9.e4p3CRyk_cZ82cGzjCBOb4p_0bqRqXElczJjf0nB58o", "expires_in": 3599, "scope": "all", "jti": "af659117-bd12-43fe-8c16-34041132d1e8"&#125;postman请求及源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/65.Spring-Security-OAuth2-Config]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Cloud</tag>
        <tag>Spring Security</tag>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security OAuth2自定义Token获取方式]]></title>
    <url>%2FSpring-Security-OAuth2-Customize.html</url>
    <content type="text"><![CDATA[在上一节Spring Security OAuth2入门中，我们使用了Spring Security OAuth2封装的授权码和密码模式成功获取了令牌，这节记录下如何通过自定义的用户名密码和手机短信验证码的方式来获取令牌。自定义用户名密码方式获取令牌在上一节的基础上，我们先在资源服务器上加入一些基本的Spring Security配置:12345678910111213141516171819202122@Configuration@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; @Autowired private MyAuthenticationSucessHandler authenticationSucessHandler; @Autowired private MyAuthenticationFailureHandler authenticationFailureHandler; @Override public void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单登录 .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and() .csrf().disable(); &#125;&#125;MyAuthenticationFailureHandler失败处理器的逻辑很简单，就是认证失败放回相应提示：12345678910111213@Componentpublic class MyAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; @Autowired private ObjectMapper mapper; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException &#123; response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); response.setContentType("application/json;charset=utf-8"); response.getWriter().write(mapper.writeValueAsString(exception.getMessage())); &#125;&#125;问题的关键是，如何在登录成功处理器里返回令牌。在研究Spring Security OAuth2自带的令牌获取方式后，会发现令牌的产生可以归纳为以下几个步骤：我们可以参考这个流程，来实现在登录成功处理器MyAuthenticationSucessHandler里生成令牌并返回：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Componentpublic class MyAuthenticationSucessHandler implements AuthenticationSuccessHandler &#123; private Logger log = LoggerFactory.getLogger(this.getClass()); @Autowired private ClientDetailsService clientDetailsService; @Autowired private AuthorizationServerTokenServices authorizationServerTokenServices; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException &#123; // 1. 从请求头中获取 ClientId String header = request.getHeader("Authorization"); if (header == null || !header.startsWith("Basic ")) &#123; throw new UnapprovedClientAuthenticationException("请求头中无client信息"); &#125; String[] tokens = this.extractAndDecodeHeader(header, request); String clientId = tokens[0]; String clientSecret = tokens[1]; TokenRequest tokenRequest = null; // 2. 通过 ClientDetailsService 获取 ClientDetails ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId); // 3. 校验 ClientId和 ClientSecret的正确性 if (clientDetails == null) &#123; throw new UnapprovedClientAuthenticationException("clientId:" + clientId + "对应的信息不存在"); &#125; else if (!StringUtils.equals(clientDetails.getClientSecret(), clientSecret)) &#123; throw new UnapprovedClientAuthenticationException("clientSecret不正确"); &#125; else &#123; // 4. 通过 TokenRequest构造器生成 TokenRequest tokenRequest = new TokenRequest(new HashMap&lt;&gt;(), clientId, clientDetails.getScope(), "custom"); &#125; // 5. 通过 TokenRequest的 createOAuth2Request方法获取 OAuth2Request OAuth2Request oAuth2Request = tokenRequest.createOAuth2Request(clientDetails); // 6. 通过 Authentication和 OAuth2Request构造出 OAuth2Authentication OAuth2Authentication auth2Authentication = new OAuth2Authentication(oAuth2Request, authentication); // 7. 通过 AuthorizationServerTokenServices 生成 OAuth2AccessToken OAuth2AccessToken token = authorizationServerTokenServices.createAccessToken(auth2Authentication); // 8. 返回 Token log.info("登录成功"); response.setContentType("application/json;charset=UTF-8"); response.getWriter().write(new ObjectMapper().writeValueAsString(token)); &#125; private String[] extractAndDecodeHeader(String header, HttpServletRequest request) &#123; byte[] base64Token = header.substring(6).getBytes(StandardCharsets.UTF_8); byte[] decoded; try &#123; decoded = Base64.getDecoder().decode(base64Token); &#125; catch (IllegalArgumentException var7) &#123; throw new BadCredentialsException("Failed to decode basic authentication token"); &#125; String token = new String(decoded, StandardCharsets.UTF_8); int delim = token.indexOf(":"); if (delim == -1) &#123; throw new BadCredentialsException("Invalid basic authentication token"); &#125; else &#123; return new String[]&#123;token.substring(0, delim), token.substring(delim + 1)&#125;; &#125; &#125;&#125;启动项目，使用postman发送登录请求localhost:8080/login：点击发送后便可以成功获取到令牌：123456&#123; "access_token": "88a3dd6c-ab27-41af-95ee-5cd406fe5ab1", "token_type": "bearer", "refresh_token": "b316177d-68e9-4fc9-9f4a-804a7367ebc9", "expires_in": 43199&#125;使用这个令牌便可以成功访问/index接口，这里就不演示了。短信验证码获取令牌在Spring Security短信验证码登录一节中，我们实现了通过短信验证码登录系统的功能，通过短信验证码获取令牌和它唯一的区别就是验证码的存储策略。之前的例子验证码存储在Session中，现在使用令牌的方式和系统交互后Session已经不适用了，我们可以使用第三方存储来保存我们的验证码（无论是短信验证码还是图形验证码都是一个道理），比如Redis等。引入Redis依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;定义一个RedisCodeService，用于验证码的增删改：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Redis操作验证码服务 */@Servicepublic class RedisCodeService &#123; private final static String SMS_CODE_PREFIX = "SMS_CODE:"; private final static Integer TIME_OUT = 300; @Autowired private StringRedisTemplate redisTemplate; /** * 保存验证码到 redis * * @param smsCode 短信验证码 * @param request ServletWebRequest */ public void save(SmsCode smsCode, ServletWebRequest request, String mobile) throws Exception &#123; redisTemplate.opsForValue().set(key(request, mobile), smsCode.getCode(), TIME_OUT, TimeUnit.SECONDS); &#125; /** * 获取验证码 * * @param request ServletWebRequest * @return 验证码 */ public String get(ServletWebRequest request, String mobile) throws Exception &#123; return redisTemplate.opsForValue().get(key(request, mobile)); &#125; /** * 移除验证码 * * @param request ServletWebRequest */ public void remove(ServletWebRequest request, String mobile) throws Exception &#123; redisTemplate.delete(key(request, mobile)); &#125; private String key(ServletWebRequest request, String mobile) throws Exception &#123; String deviceId = request.getHeader("deviceId"); if (StringUtils.isBlank(deviceId)) &#123; throw new Exception("请在请求头中设置deviceId"); &#125; return SMS_CODE_PREFIX + deviceId + ":" + mobile; &#125;&#125;然后将Spring Security短信验证码登录一节中的实现都挪到现在的Demo里，修改相应的地方（涉及到验证码的增删改的地方，具体可以参考下面的源码，这里就不赘述了）。启动系统，使用postman发送验证码：请求头中带上deviceId（这里为随便填写的模拟值）：点击发送后，控制台输出：1手机号17720202020的登录验证码为：619963，有效时间为120秒接着用这个验证码去换取令牌，使用postman发送如下请求：同样请求头中要带上deviceId和经过base64加密的client_id:client_secret：点击发送后，便可以成功获取到令牌：123456&#123; "access_token": "7fe22e67-1a11-4708-8707-0100555a9d1a", "token_type": "bearer", "refresh_token": "7c7a814f-2ace-4171-9748-56cb1994b04b", "expires_in": 41982&#125;源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/64.Spring-Security-OAuth2-Customize]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Cloud</tag>
        <tag>Spring Security</tag>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门学习]]></title>
    <url>%2FVue-Learn-Note.html</url>
    <content type="text"><![CDATA[Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。本篇记录Vue学习过程，用于心得备忘，对外可读性差🙃，学习Vue还是以官方文档为主。Vue入门通过一个Vue实现的todoList来入门：See the Pen todo-list by wuyouzhuguli (@mrbird) on CodePen.var app = new Vue({})创建了一个实例，通过el: &quot;#app&quot;接管了ID为app的div的所有内容。data属性用于装载数据，包含list和inputValue。v-for指令用于遍历集合，这里用于遍历list数组中的值；v-model指令用于双向数据绑定，即在&lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt;中输入的值会改变Vue实例中inputValue的值，通过JS改变Vue实例inputValue的值也会改变&lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt;中的值。@click指令用于绑定事件，这里绑定了createTodoList事件，对应Vue实例methods中的createTodoList。Vue组件我们可以对一些常用的HTML片段抽取出来组装成一个Vue组件，Vue组件分为全局组件和局部组件。全局Vue组件定义一个全局Vue组件改造上面的todoList：See the Pen todo-list2 by wuyouzhuguli (@mrbird) on CodePen.这里我们使用Vue.component(&#39;TodoItem&#39;,{})定义了一个名称为TodoItem全局Vue组件，可以在任何Vue管理的Dom中使用：TodoItem组件可以使用&lt;todo-item&gt;的方式使用，即大写可以转换为小写，第二个大写字母转小写后必须加上-前缀；v-bind指令用于绑定值，这里通过v-bind:content将content变量的值绑定为item(即list中的每个元素值)，通过v-bind:index将index变量的值绑定为index（即当前循环的下标）。v-bind可以简写为:；props属性用于向子组件传递数据，这里接收了由:bind指令传递了从父组件绑定过来的index和content变量；template定义了模板，即这个Vue组件呈现的样子（通常都是一段HTML加上父组件传递过来的变量值）。在这个过程中，我们除了学会了怎么定义全局Vue组件外，还学会了怎么从父组件中往子组件传值。&lt;div id=&quot;app&quot;&gt;这个Dom结构已经被Vue接管，其内部又包含了&lt;todo-item&gt;Vue组件，所以我们将&lt;div id=&quot;app&quot;&gt;称之为父组件，&lt;todo-item&gt;称之为子组件。局部Vue组件定义一个局部组件来改造上面的todoList：See the Pen todo-list3 by wuyouzhuguli (@mrbird) on CodePen.这里我们定义了一个局部JS对象TodoItem，然后在Vue实例app中的components属性中引入了该对象，名称依旧是TodoItem，这种就是局部Vue组件。这里主要记录下该局部组件中handleItemClick方法的实现过程：我们在子组件TodoItem中定义了一个handleItemClick方法；handleItemClick方法里通过this.$emit(&#39;delete&#39;, this.index)向父组件传递一个事件，事件名称为delete,事件包含一个index参数。子组件的@delete监听事件对应2中传递过来的delete事件，监听的方法为父组件的deleteTodoList方法，该方法中接受了2中传递过来的index参数，然后就可以在该方法中实现想要的逻辑了（这里为删除对应的点击对象）。在这个过程中，我们除了学会了怎么定义局部Vue组件外，还学会了怎么从子组件中往父组件传值。emit: 英[iˈmɪt],美[ɪˈmɪt] vt.发出; 发射Vue实例生命周期Vue实例从创建到销毁包含了多个生命周期，如下图所示：这个过程中包含了好几个生命周期函数，在相应的时间点会自动执行：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue实例生命周期函数&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: "#app", template: '&lt;span&gt;&#123;&#123;test&#125;&#125;&lt;/span&gt;', data: &#123; test: 'hello world' &#125;, beforeCreate: function () &#123; console.log("beforeCreate"); &#125;, created: function () &#123; console.log("created"); &#125;, beforeMount: function () &#123; console.log(this.$el); console.log("beforeMount"); &#125;, mounted: function () &#123; console.log(this.$el); console.log("mounted"); &#125;, beforeUpdate: function () &#123; console.log("beforeUpdate") &#125;, updated: function () &#123; console.log("updated"); &#125;, beforeDestroy: function () &#123; console.log("beforeDestroy") &#125;, destroyed: function () &#123; console.log("destroyed"); &#125;, &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;其实，除了上面8个生命周期函数外，Vue还包含3个特殊的生命周期函数：activated，deactivated 和 errorCaptured。计算属性，方法和监听器计算属性一个计算属性的例子：See the Pen 计算属性 by wuyouzhuguli (@mrbird) on CodePen.使用computed计算了fullName属性，值为firstName+lastName。计算属性具有缓存功能，当firstName和lastName都不改变的时候，fullName不会重新计算，比如我们改变age的值，fullName的值是不需要重新计算的：方法使用方法也可以实现上面的功能：See the Pen todo-list5 by wuyouzhuguli (@mrbird) on CodePen.不过methods并没有缓存特性，比如我们改变age的值，fullName()方法会被执行一遍：监听器使用监听器也可以实现上面的功能：See the Pen todo-list6 by wuyouzhuguli (@mrbird) on CodePen.这里监听了firstName和lastName的值，当它们任何一个改变的时侯fullName也跟变，我们改变age的值，fullName的值不会被重新计算，也具有缓存特性（不过代码比computed啰嗦）:当一个功能可以用上面三个方法来实现的时候，明显使用computed更合适，代码简单也有缓存特性。computed的getter和setter将上面计算属性的例子改为下面的形式：See the Pen get set by wuyouzhuguli (@mrbird) on CodePen.通过这种方式，我们可以在改变计算属性值的同时也改变和计算属性相关联的属性值。深入理解Vue组件is先来看一个bug，下面是一个简单的Vue组件使用：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;table&gt; &lt;tbody&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component('row', &#123; template: '&lt;tr&gt;&lt;td&gt;hello world&lt;/td&gt;&lt;/tr&gt;' &#125;); var app = new Vue(&#123; el: "#app" &#125;);&lt;/script&gt;&lt;/html&gt;虽然其在页面上看上去是正常的，但是查看器DOM结构就能发现问题：可看到table的结构是错误的，因为HTML5规范只允许&lt;tbody&gt;下面紧跟着&lt;tr&gt;标签，类似的&lt;ul&gt;下只能紧跟着&lt;li&gt;标签。为了解决这个问题，我们可以用is来改写代码：See the Pen is by wuyouzhuguli (@mrbird) on CodePen.子组件中的data应该为function改一下上面的例子：1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;title&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component('row', &#123; data: function()&#123; return &#123; content: 'hello world.' &#125; &#125;, template: '&lt;tr&gt;&lt;td&gt;&#123;&#123;content&#125;&#125;&lt;/td&gt;&lt;/tr&gt;' &#125;); var app = new Vue(&#123; el: "#app" &#125;);&lt;/script&gt;&lt;/html&gt;如果data只是一个JS对象的话，Vue将抛出异常，之所以有这样的限制是因为子组件可能会在不同的地方多次引用，为了保持数据的作用域不一样（相互独立，互不影响），所以使用函数包裹了下。ref在使用Vue的时候，总有不得不去操作DOM的时候，这时候可以使用ref来完成。在DOM中使用直接举个例子，使用ref来获取div标签中的内容：See the Pen ref1 by wuyouzhuguli (@mrbird) on CodePen.使用ref让div变成一个引用，名称为div，然后在hello()方法中，this.$refs表示当前Vue实例中的所有引用，this.$refs.div这里获取的是&lt;div ref=&quot;div&quot;&gt;这个DOM对象。在Vue组件中使用用Vue编写个求和的例子：See the Pen ref2 by wuyouzhuguli (@mrbird) on CodePen.这里ref的引用是一个Vue组件。可以自个console打印看看。父组件向子组件传值Vue规定，子组件不能直接修改父组件中传递过来的值。因为如果传递的是一个对象的话，你在一个子组件中修改了对象的属性值，很有可能别的子组件也用到了这个属性，那么就会一起修改了。变通的方法是，子组件去复制一份父组件传递过来的数据，然后修改这份拷贝。组件参数校验父组件往子组件传递参数的时候，子组件可以对这些参数的值进行一些规则校验，校验不通过Vue会抛出警告：123456789101112131415161718192021222324252627282930313233Vue.component('my-component', &#123; props: &#123; // 基础的类型检查 (`null` 匹配任何类型) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;)给组件绑定原生事件如果我们在组件上绑定一个监听事件，其并不会直接调用父组件的方法，如下所示，下面的点击事件是不会被触发的：See the Pen .native by wuyouzhuguli (@mrbird) on CodePen.因为这样写实际上@click是子组件向父组件抛出的一个监听事件，这里子组件并没有通过this.$emit(&#39;click&#39;)向父组件传递这个事件。如果想要在组件上绑定原生的事件，只需要改为`@click.native`即可：See the Pen .native2 by wuyouzhuguli (@mrbird) on CodePen.非父子组件传值父子组件传值上面已经介绍了，那非父子组件传值（不是直接的父子关系）呢？比如：第一层如何与第三层之间传值呢？相同层级之间的组件又如何相互传值呢？有两种办法：vuex（后面再说）总线机制（bus/发布订阅模式/观察者模式）看一个总线机制的例子（点击child-one会把child-one的innerHTML值传递给child-two）：See the Pen bus by wuyouzhuguli (@mrbird) on CodePen.解释一下上面的实现过程：通过Vue.prototype.bus = new Vue()实现了在每个Vue实例中添加了一个bus属性，这个bus属性为一个Vue实例，拥有Vue的所有特性。所以在每个Vue实例中都会有一个bus属性，属性值都指向同一个Vue实例；创建了两个兄弟子组件child-one和child-two；在子组件child-one中有一个handleClick事件，事件里通过this.bus.$emit抛出了一个change事件，并携带一个参数，值为child-one的innerHTML。之所以可以通过this.bus.$emit抛出，是因为如上面所说的那样，每个Vue实例都携带了一个bus属性，该属性指向一个Vue实例；child-one抛出的change事件可以在任何的Vue实例中通过this.bus.$on来监听到。所以我们可以在child-two里通过调用this.bus.$on来监听，但在哪里监听这个事件好呢？我们可以借助Vue的生命周期钩子函数mounted来监听change事件；上面主要有两个技巧：① 让所有Vue实例拥有同一个属性；② 这个属性也是一个Vue实例。其实就是强行让非父子组件扯上关系，搭建这个关系的桥梁就是上面定义的bus。如果只是简单的非父子组件之间的值的传递的话，全局Vue属性bus也可以指向一个简单对象，如下所示：See the Pen bus1 by wuyouzhuguli (@mrbird) on CodePen.效果就是，直接点击child-two弹出init；先点击child-one改变this.bus.name的值为one，再点击child-two将弹出one。插槽slot插槽要实现的是父组件优雅的往子组件传递DOM结构。https://cn.vuejs.org/v2/guide/components-slots.html。作用域插槽有的时候你希望提供的组件带有一个可从子组件获取数据的可复用的插槽，即从子组件获取的数据在父组件中可以以任何形式展现，这种插槽就是作用域插槽，看个例子：See the Pen slot1 by wuyouzhuguli (@mrbird) on CodePen.子组件里在插槽中使用:item=item绑定了list中的每一项数据，然后父组件中使用该插槽的时候用slot-scope=&quot;props&quot;接收了这些数据。动态组件看个例子：See the Pen dynamic by wuyouzhuguli (@mrbird) on CodePen.&lt;component&gt;标签用于加载动态组件，加载哪个名字的组件根据:is指定的值来选择。这里通过change事件来改变type的值。Vue动画特效Vue官方文档写的很详细，https://cn.vuejs.org/v2/guide/transitions.html。构建第一个Vue项目第一步，安装vue-cli：1cnpm install --global vue-cli安装好后，初始化一个简单的Vue项目：1vue init webpack vue-project-test过程中需要步骤确认：初始化完毕后，启动项目：12cd vue-project-testnpm run dev访问http://localhost:8080/：项目构建成功！前端也挺好玩的😋项目结构介绍打开上面创建好的vue-project-test，项目目录如下所示：先从外部的文件说起：package.json：第三方依赖配置；package-lock.json：package.json的锁文件，确定第三方依赖的版本，保持团队协作上版本的统一；index.html：项目首页模板；.postcssrc.js：postcss配置项（暂时不懂干嘛的）；.eslintrc.js：js语法检查；.eslintignore：配置排除js检查；.editorconfig：编辑配置；.babelrc：将Vue文件转换为浏览器能够识别的html；再来看目录：static/：项目静态资源存放，里面的资源直接可以通过URL访问；node_modules/：项目依赖的第三方包；src/：包含项目文件，结构如下所示：main.js：整个项目入口文件；App.vue：项目的根组件；router/：项目路由配置处；components/：存放项目所用到的组件；assets/：存放项目用到的图片资源；config/：项目配置文件目录，修改需要重启项目；build/：项目打包webpack配置处。单文件Vue组件当一个文件以.vue结尾的时候，他就是一个单文件Vue组件，比如上面的App.vue:1234567891011121314151617181920212223&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt;可以看到，单文件Vue组件主要包含了三个部分：templage、script和style。Vue路由路由就是根据不同的URL返回不同的内容给用户。可以看到上面单文件Vue组件里有个&lt;router-view/&gt;标签，它显示的是当前路由地址对应的内容，当前地址就是http://localhost:8080/#/，它对应的内容是下面红框部分：那它为什么就会显示出这个部分的内容呢？下面讲解下：在main.js中：123456789101112131415// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;)这里我们引入了router，并在Vue实例中使用了。ES6语法，当键值对名称相同时，可以简化，比如上面router指的是router: router；components: { App }指的是components: { App: App }import router from &#39;./router&#39;会帮我们引入当前目录下router文件夹下的内容，router目录下是一个index.js：123456789101112131415import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;)上面配置了一个路由规则，当访问项目根路径的时候，引入名称为Helloworld的Vue组件，这个组件来自&#39;@/components/HelloWorld&#39;，其中@表示src这个目录。HelloWorld.vue文件内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;template&gt; &lt;div class="hello"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="https://vuejs.org" target="_blank" &gt; Core Docs &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="https://forum.vuejs.org" target="_blank" &gt; Forum &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="https://chat.vuejs.org" target="_blank" &gt; Community Chat &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="https://twitter.com/vuejs" target="_blank" &gt; Twitter &lt;/a&gt; &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href="http://vuejs-templates.github.io/webpack/" target="_blank" &gt; Docs for This Template &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Ecosystem&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="http://router.vuejs.org/" target="_blank" &gt; vue-router &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="http://vuex.vuejs.org/" target="_blank" &gt; vuex &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="http://vue-loader.vuejs.org/" target="_blank" &gt; vue-loader &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="https://github.com/vuejs/awesome-vue" target="_blank" &gt; awesome-vue &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #6db33f;&#125;&lt;/style&gt;所以首页红框内会显示这个内容。函数节流比如我们的在输入的时候需要监控keypress事件，在页面滚动的时候监控页面的滚动事件，这时候事件执行的频率会非常之高，这时候我们可以用下面这个方法来节流：12345678910111213141516data () &#123; return &#123; keyword: '', timer: null &#125;&#125;,watch: &#123; keyword () &#123; if (this.timer) &#123; clearTimeout(this.timer) &#125; this.timer = setTimeout(() =&gt; &#123; // to something &#125;, 100) &#125;&#125;上面Vue监听了keyword变化，我们在监听函数里使用定时器的方式来节流，让频繁调用的时间延迟100毫秒，这个时间范围内只会执行一次监控事件。实际应用时，这个时间范围带来的节流影响肉眼上看不出区别即可。Vuex实现数据共享上面介绍了使用bus来进行非父子组件之间的传值，现在我们看看怎么通过Vuex来实现（官方推荐，更为强大方便）。来看下图:当多个组件之间需要传递复杂的值的时候，我们就可以借助Vuex来实现。Vuex相当于是一个存储公共数据部分的地方（类似于仓库Store），当一个值被改变的时候，别的用到这个值的地方也会感应到改变。上图绿色虚线部分就是Vuex区域。公共数据存储在State部分，组件（Vue compontents）可以直接通过Render方法引用。组件不能直接改变这个数据，需要通过调用Dispatch方法来改变Actions，由它来通过调用Commit方法来改变Mutations，最后由Mutations调用Mutate方法来改变公共数据。这个过程就对应上图的循环圈。这个过程也不是绝对的，有的时候组件也可以直接通过调用Commit方法来改变Mutations，再由Mutations调用Mutate方法来改变公共数据。Vuex安装：1npm install vuexVuex使用创建一个Storesrc下新建一个store目录，然后在下面创建index.js：12345678910import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; name: 'mrbird' &#125;&#125;)这里我们创建了一个Store，并定义了state，里面包含一个name属性，值为mrbird。在main.js里引入Store123456789...import store from './store'/* eslint-disable no-new */new Vue(&#123; el: '#app', store, ...&#125;)我们在main.js里引入了Store，即根组件里引入了，所以任何子组件都可以使用了。使用Store里存的值像下面这样使用：1this.$store.state.name这样就可以取出mrbird。改变Store里存的值在需要改变值的地方派发一个改变事件：1this.$store.dispatch('changeName', 'newName')然后在/store/index.js下添加actions：1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; name: 'mrbird' &#125;, actions: &#123; changeName (ctx, name) &#123; ctx.commit('changeName', name) &#125; &#125;, mutations: &#123; changeName (state, name) &#123; state.name = name &#125; &#125;&#125;)可看到，actions里定义的changeName方法对应this.$store.dispatch(&#39;changeName&#39;, name)派发的方法，通过第一个入参ctx执行ctx.commit(&#39;changeName&#39;, name)，这里的changeName对应mutations里的changeName方法，最终我们可以在这个方法里改变state里的name的值。上面这个过程对应图里流程，这个过程也可以简化👇在需要改变值的地方执行下面语句：1this.$store.commit('changeName', 'newName')然后/store/index.js下直接这样写即可：123456789101112131415import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; name: 'mrbird' &#125;, mutations: &#123; changeName (state, name) &#123; state.name = name &#125; &#125;&#125;)Vuex高级特性从Vuex里取出state里的值的时候，上面是这样写的：1this.$store.state.name这里可以简化一波：123456789import &#123; mapState &#125; from 'vuex'export default &#123; ... computed: &#123; ...mapState(['name']) &#125; ...&#125;然后取值的地方直接this.name就行了。也可以这样：1234567891011import &#123; mapState &#125; from 'vuex'export default &#123; ... computed: &#123; ...mapState(&#123; currentUser: 'user' &#125;) &#125; ...&#125;然后取值的地方直接this.currentUser就行了。取值的地方可以简化，那么改变值的地方也可以简化（import的时候也引入mapMutations）：1import &#123; mapMutations &#125; from 'vuex'然后在methods里这样：1234567methods: &#123; handleClick (name) &#123; // this.$store.commit('changeName', name) this.changeName(name) &#125;, ...mapMutations(['changeName'])&#125;实际项目中，actions和mutations里的内容一般都非常多，所以我们可以将它们剥离出来，然后引入即可，就像下面这样：新建mutations.js：123456export default &#123; changeName (state, name) &#123; state.name = name localStorage.name = name &#125;&#125;然后在store/index.js里引入：12345678910import Vue from 'vue'import Vuex from 'vuex'import mutations from './mutations'Vue.use(Vuex)export default new Vuex.Store(&#123; ... mutations&#125;)Vuex GetterGetter类似于Vuex版的computed，在store/index.js里定义Getter：123456789101112131415import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; name: 'mrbird' &#125;, getters: &#123; getMessage (state) &#123; return state.name + 'is so handsome' &#125; &#125;&#125;)引用的地方：12345678import &#123; mapGetters &#125; from 'vuex'export default &#123; ... computed: &#123; ...mapGetters(['getMessage']) &#125;&#125;然后this.getMessage就会得到mrbird is so handsome信息了。Getter详细文档： https://vuex.vuejs.org/zh/guide/getters.htmlVuex Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态详细文档： https://vuex.vuejs.org/zh/guide/modules.html路由跳转我们除了可以使用&lt;router-link&gt;创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现：1router.push('/home')具体：https://router.vuejs.org/zh/guide/essentials/navigation.html路由参数传递当路由path中包含参数的时候，比如：123456789export default new Router(&#123; routes: [ &#123; path: '/detail/:id', name: 'Detail', component: Detail &#125; ]&#125;)在Detail组件中，我们就可以使用this.$route.params.id来获取了。localStorageH5中新增的可以存储数据的东东，类似cookie，但比cookie更简单。改进一下上面Vuex的例子：1234567891011export default new Vuex.Store(&#123; state: &#123; name: localStorage.name || 'mrbird' &#125;, mutations: &#123; changeName (state, name) &#123; state.name = name localStorage.name = name &#125; &#125;&#125;)在mutations中，我们不但改变了state.name的值，还把值存到了localStorage中，这样即使浏览器刷新也不会重置回’mrbird’。和cookie类似，localStorage也可以通过浏览器禁用，所以我们在使用localStorage的时候要用try{}catch(){}来处理，防止代码抛出异常无法正常运行。keep-alivehttps://cn.vuejs.org/v2/api/#keep-alive组件的递归当一个数据具有上下级，而且级数无法确定的时候，我们可以使用递归组件来展示我们的层级数据，看下面这个栗子：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;div class="item" v-for="(item, index) of list" :key="index"&gt; &lt;div class="item-title border-bottom"&gt; &lt;span class="item-title-icon"&gt;&lt;/span&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;div v-if="item.children" class="item-chilren"&gt; &lt;detail-list :list="item.children"&gt;&lt;/detail-list&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'DetailList', data() &#123; return &#123; list: [ &#123; title: '爷爷', children: [ &#123; title: '爸爸' &#125;, &#123; title: '妈妈', children: [ &#123; title: '小明' &#125; ] &#125; ] &#125;, &#123; title: '奶奶' &#125; ] &#125; &#125;&#125;&lt;/script&gt;这个组件叫DetailList，在循环中，通过item.children来判断是否有下级，有的话调用组件自身。这样就可以很简单的实现递归了。Vue项目打包上线修改config/index.js：红框部分我们将assetsPublicPath指定为/vue。接着在项目根目录执行：1npm run build打包完，命令行会提示：然后项目里会出现一个dist目录：我们在tomcat的webapps目录下也新建一个vue目录，然后把dist里的内容拷贝进去，然后启动tomcat，访问http://{ip}:{port}/vue就能看到项目了。异步组件加载查看打包目录下的js文件夹：项目所有的逻辑都被打包在了appXXXX.js里了，即在加载首页的时候，整个项目js逻辑都被加载了。如果项目规模很大，这个文件将可能达到MB级别。我们也可以将组件进行异步的加载来解决这个问题，比如在路由中，我们这样引用组件：123456789101112131415161718192021222324import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: () =&gt; import('@/pages/home/Home') &#125;, &#123; path: '/dept', name: 'dept', component: () =&gt; import('@/pages/dept/Dept') &#125;, &#123; path: '/detail/:id', name: 'Detail', component: () =&gt; import('@/pages/detail/Detail') &#125; ]&#125;)component里我们使用箭头函数来引入对应的组件，这样就实现了异步加载，重新打包项目，再次查看js文件夹：可以看到appxxxx.js已经被拆分了。自定义Vue插件具体可查看：https://router.vuejs.org/zh/guide/advanced/lazy-loading.html]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security OAuth2入门]]></title>
    <url>%2FSpring-Security-OAuth2-Guide.html</url>
    <content type="text"><![CDATA[OAuth是一种用来规范令牌（Token）发放的授权机制，主要包含了四种授权模式：授权码模式、简化模式、密码模式和客户端模式。Spring Security OAuth2对这四种授权模式进行了实现。这节主要记录下什么是OAuth2以及Spring Security OAuth2的基本使用。四种授权模式在了解这四种授权模式之前，我们需要先学习一些和OAuth相关的名词。举个社交登录的例子吧，比如在浏览器上使用QQ账号登录虎牙直播，这个过程可以提取出以下几个名词：Third-party application 第三方应用程序，比如这里的虎牙直播；HTTP service HTTP服务提供商，比如这里的QQ（腾讯）;Resource Owner 资源所有者，就是QQ的所有人，你；User Agent 用户代理，这里指浏览器；Authorization server 认证服务器，这里指QQ提供的第三方登录服务；Resource server 资源服务器，这里指虎牙直播提供的服务，比如高清直播，弹幕发送等（需要认证后才能使用）。认证服务器和资源服务器可以在同一台服务器上，比如前后端分离的服务后台，它即供认证服务（认证服务器，提供令牌），客户端通过令牌来从后台获取服务（资源服务器）；它们也可以不在同一台服务器上，比如上面第三方登录的例子。大致了解了这几个名词后，我们开始了解四种授权模式。授权码模式授权码模式是最能体现OAuth2协议，最严格，流程最完整的授权模式，流程如下所示：A. 客户端将用户导向认证服务器；B. 用户决定是否给客户端授权；C. 同意授权后，认证服务器将用户导向客户端提供的URL，并附上授权码；D. 客户端通过重定向URL和授权码到认证服务器换取令牌；E. 校验无误后发放令牌。其中A步骤，客户端申请认证的URI，包含以下参数：response_type：表示授权类型，必选项，此处的值固定为”code”，标识授权码模式client_id：表示客户端的ID，必选项redirect_uri：表示重定向URI，可选项scope：表示申请的权限范围，可选项state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。code：表示上一步获得的授权码，必选项。redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。client_id：表示客户端ID，必选项。密码模式在密码模式中，用户像客户端提供用户名和密码，客户端通过用户名和密码到认证服务器获取令牌。流程如下所示：A. 用户向客户端提供用户名和密码；B. 客户端向认证服务器换取令牌；C. 发放令牌。B步骤中，客户端发出的HTTP请求，包含以下参数：grant_type：表示授权类型，此处的值固定为”password”，必选项。username：表示用户名，必选项。password：表示用户的密码，必选项。scope：表示权限范围，可选项。剩下两种授权模式可以参考下面的参考链接，这里就不介绍了。Spring Security OAuth2Spring框架对OAuth2协议进行了实现，下面学习下上面两种模式在Spring Security OAuth2相关框架的使用。Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：认证服务器主要包含了四种授权模式的实现和Token的生成与存储，我们也可以在认证服务器中自定义获取Token的方式（后面会介绍到）；资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。配置认证服务器新建一个Spring Boot项目，版本为2.1.6.RELEASE，并引入相关依赖，pom如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.mrbird&lt;/groupId&gt; &lt;artifactId&gt;security&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;在创建认证服务器前，我们先定义一个MyUser对象：1234567891011public class MyUser implements Serializable &#123; private static final long serialVersionUID = 3497935890426858541L; private String userName; private String password; private boolean accountNonExpired = true; private boolean accountNonLocked= true; private boolean credentialsNonExpired= true; private boolean enabled= true; // get set 略&#125;接着定义UserDetailService实现org.springframework.security.core.userdetails.UserDetailsService接口：123456789101112131415@Servicepublic class UserDetailService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; MyUser user = new MyUser(); user.setUserName(username); user.setPassword(this.passwordEncoder.encode("123456")); return new User(username, user.getPassword(), user.isEnabled(), user.isAccountNonExpired(), user.isCredentialsNonExpired(), user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList("admin")); &#125;&#125;这里的逻辑是用什么账号登录都可以，但是密码必须为123456，并且拥有”admin”权限（这些都在前面的Security教程里说过了，就不再详细说明了）。接下来开始创建一个认证服务器，并且在里面定义UserDetailService需要用到的PasswordEncoder。创建认证服务器很简单，只需要在Spring Security的配置类上使用@EnableAuthorizationServer注解标注即可。创建AuthorizationServerConfig，代码如下所示：123456789@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125;这时候启动项目，会发现控制台打印出了随机分配的client-id和client-secret：为了方便后面的测试，我们可以手动指定这两个值。在Spring Boot配置文件application.yml中添加如下配置:12345security: oauth2: client: client-id: test client-secret: test1234重启项目，发现控制台输出：说明替换成功。授权码模式获取令牌接下来开始往认证服务器请求授权码。打开浏览器，访问http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=test&amp;redirect_uri=http://mrbird.cc&amp;scope=all&amp;state=helloURL中的几个参数在上面的授权码模式的A步骤里都有详细说明。这里response_type必须为code，表示授权码模式，client_id就是刚刚在配置文件中手动指定的test，redirect_uri这里随便指定一个地址即可，主要是用来重定向获取授权码的，scope指定为all，表示所有权限。访问这个链接后，页面如下所示：需要登录认证，根据我们前面定义的UserDetailService逻辑，这里用户名随便输，密码为123456即可。输入后，页面跳转如下所示：原因是上面指定的redirect_uri必须同时在配置文件中指定，我们往application.yml添加配置：123456security: oauth2: client: client-id: test client-secret: test1234 registered-redirect-uri: http://mrbird.cc重启项目，重新执行上面的步骤，登录成功后页面成功跳转到了授权页面：选择同意Approve，然后点击Authorize按钮后，页面跳转到了我们指定的redirect_uri，并且带上了授权码信息:到这里我们就可以用这个授权码从认证服务器获取令牌Token了。使用postman发送如下请求POST请求localhost:8080/oauth/token：这里要填的参数和上面介绍的授权码模式D步骤介绍的一致。grant_type固定填authorization_code，code为上一步获取到的授权码，client_id和redirect_uri必须和我们上面定义的一致。除了这几个参数外，我们还需要在请求头中填写：key为Authorization，value为Basic加上client_id:client_secret经过base64加密后的值（可以使用http://tool.chinaz.com/Tools/Base64.aspx）:参数填写无误后，点击发送便可以获取到令牌Token：1234567&#123; "access_token": "950018df-0199-4936-aa80-a3a66183f634", "token_type": "bearer", "refresh_token": "cc22e8b2-e069-459d-8c24-cfda0bc72128", "expires_in": 42827, "scope": "all"&#125;一个授权码只能换一次令牌，如果再次点击postman的发送按钮，将返回：1234&#123; "error": "invalid_grant", "error_description": "Invalid authorization code: xw8x55"&#125;密码模式获取令牌和授权码模式相比，使用密码模式获取令牌就显得简单多了。同样使用postman发送POST请求localhost:8080/oauth/token：grant_type填password，表示密码模式；然后填写用户名和密码，头部也需要填写Authorization信息，内容和授权码模式介绍的一致，这里就不截图了。点击发送，也可以获得令牌：1234567&#123; "access_token": "d612cf50-6499-4a0c-9cd4-9c756839aa12", "token_type": "bearer", "refresh_token": "fdc6c77f-b910-46dc-a349-835dc0587919", "expires_in": 43090, "scope": "all"&#125;配置资源服务器为什么需要资源服务器呢？我们先来看下在没有定义资源服务器的时候，使用Token去获取资源时会发生什么。定义一个REST接口：12345678@RestControllerpublic class UserController &#123; @GetMapping("index") public Object index(Authentication authentication)&#123; return authentication; &#125;&#125;启动项目，为了方便我们使用密码模式获取令牌，然后使用该令牌获取/index这个资源：Authorization值为token_type access_token，发送请求后，返回：1234567&#123; "timestamp": "2019-03-24T13:13:43.818+0000", "status": 401, "error": "Unauthorized", "message": "Unauthorized", "path": "/index"&#125;虽然令牌是正确的，但是并无法访问/index，所以我们必须配置资源服务器，让客户端可以通过合法的令牌来获取资源。资源服务器的配置也很简单，只需要在配置类上使用@EnableResourceServer注解标注即可：12345@Configuration@EnableResourceServerpublic class ResourceServerConfig &#123;&#125;重启服务，重复上面的步骤，再次访问/index便可以成功获取到信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; "authorities": [ &#123; "authority": "admin" &#125; ], "details": &#123; "remoteAddress": "0:0:0:0:0:0:0:1", "sessionId": null, "tokenValue": "621f59ba-3161-4c9b-aff8-a8335ce6e3cc", "tokenType": "bearer", "decodedDetails": null &#125;, "authenticated": true, "userAuthentication": &#123; "authorities": [ &#123; "authority": "admin" &#125; ], "details": &#123; "grant_type": "password", "username": "mrbird", "scope": "all" &#125;, "authenticated": true, "principal": &#123; "password": null, "username": "mrbird", "authorities": [ &#123; "authority": "admin" &#125; ], "accountNonExpired": true, "accountNonLocked": true, "credentialsNonExpired": true, "enabled": true &#125;, "credentials": null, "name": "mrbird" &#125;, "credentials": "", "oauth2Request": &#123; "clientId": "test", "scope": [ "all" ], "requestParameters": &#123; "grant_type": "password", "username": "mrbird", "scope": "all" &#125;, "resourceIds": [], "authorities": [ &#123; "authority": "ROLE_USER" &#125; ], "approved": true, "refresh": false, "redirectUri": null, "responseTypes": [], "extensions": &#123;&#125;, "refreshTokenRequest": null, "grantType": "password" &#125;, "clientOnly": false, "principal": &#123; "password": null, "username": "mrbird", "authorities": [ &#123; "authority": "admin" &#125; ], "accountNonExpired": true, "accountNonLocked": true, "credentialsNonExpired": true, "enabled": true &#125;, "name": "mrbird"&#125;在同时定义了认证服务器和资源服务器后，再去使用授权码模式获取令牌可能会遇到 Full authentication is required to access this resource 的问题，这时候只要确保认证服务器先于资源服务器配置即可，比如在认证服务器的配置类上使用@Order(1)标注，在资源服务器的配置类上使用@Order(2)标注。源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/63.Spring-Security-OAuth2-Guide参考链接https://tools.ietf.org/html/rfc6749#section-4.1http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Cloud</tag>
        <tag>Spring Security</tag>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security权限控制]]></title>
    <url>%2FSpring-Security-Permission.html</url>
    <content type="text"><![CDATA[Spring Security权限控制可以配合授权注解使用，具体有哪些注解可以参考Spring-Security保护方法。接着上一节，要开启这些注解，只需要在Spring Security配置文件中添加如下注解：12345@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter &#123; ...&#125;在UserDetailService中，我们给当前登录用户授予了”admin”的权限，我们将这块代码改造一下：当登录用户为mrbird的时候，其拥有”admin”权限，其他用户则只有”test”权限：12345678910111213141516171819202122232425@Configurationpublic class UserDetailService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // 模拟一个用户，替代数据库获取逻辑 MyUser user = new MyUser(); user.setUserName(username); user.setPassword(this.passwordEncoder.encode("123456")); // 输出加密后的密码 System.out.println(user.getPassword()); List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); if (StringUtils.equalsIgnoreCase("mrbird", username)) &#123; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList("admin"); &#125; else &#123; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList("test"); &#125; return new User(username, user.getPassword(), user.isEnabled(), user.isAccountNonExpired(), user.isCredentialsNonExpired(), user.isAccountNonLocked(), authorities); &#125;&#125;添加一个方法，并且使用权限注解标明只有拥有“admin”权限的人才能访问：12345@GetMapping("/auth/admin")@PreAuthorize("hasAuthority('admin')")public String authenticationTest() &#123; return "您拥有admin权限，可以查看";&#125;启动系统，使用mrbird账号登录：可看到，mrbird可以访问该资源。使用scott账号登录：可以看到，soctt没有权限访问，返回403错误码。我们可以自定义权限不足处理器来处理权限不足时候的操作。新增一个处理器MyAuthenticationAccessDeniedHandler，实现AccessDeniedHandler接口：12345678910@Componentpublic class MyAuthenticationAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException &#123; response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); response.setContentType("application/json;charset=utf-8"); response.getWriter().write("很抱歉，您没有该访问权限"); &#125;&#125;然后将这个处理器添加到Spring Security配置链中: @Autowired private MyAuthenticationAccessDeniedHandler authenticationAccessDeniedHandler;1234567 @Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.exceptionHandling() .accessDeniedHandler(authenticationAccessDeniedHandler) .and() ......&#125;重启系统，再次使用scott账号访问/auth/admin： 源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/61.Spring-security-Permission]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security退出登录]]></title>
    <url>%2FSpring-Security-logout.html</url>
    <content type="text"><![CDATA[Spring Security默认的退出登录URL为/logout，退出登录后，Spring Security会做如下处理：是当前的Sesion失效；清除与当前用户关联的RememberMe记录；清空当前的SecurityContext；重定向到登录页。Spring Security允许我们通过配置来更改上面这些默认行为。自定义退出登录行为我们在Spring Security配置中添加如下配置:12345678.......and() .logout() .logoutUrl("/signout") .logoutSuccessUrl("/signout/success") .deleteCookies("JSESSIONID").and()......上面配置了退出登录的URL为/signout，退出成功后跳转的URL为/signout/success，退出成功后删除名称为JSESSIONID的cookie。在Controller中添加和/signout/success对应的方法：1234@GetMapping("/signout/success")public String signout() &#123; return "退出成功，请重新登录";&#125;接着将/signout/success添加到免认证路径里。启动项目，登录后访问/signout：可看到退出成功，并且请求重定向到了/signout/success。除了指定logoutUrl外，我们也可以通过logoutSuccessHandler指定退出成功处理器来处理退出成功后的逻辑：123456789101112@Autowiredprivate MyLogOutSuccessHandler logOutSuccessHandler;.......and() .logout() .logoutUrl("/signout") // .logoutSuccessUrl("/signout/success") .logoutSuccessHandler(logOutSuccessHandler) .deleteCookies("JSESSIONID").and()......MyLogOutSuccessHandler实现LogoutSuccessHandler：123456789@Componentpublic class MyLogOutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; httpServletResponse.setStatus(HttpStatus.UNAUTHORIZED.value()); httpServletResponse.setContentType("application/json;charset=utf-8"); httpServletResponse.getWriter().write("退出成功，请重新登录"); &#125;&#125;效果和上面一样： 源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/60.Spring-Security-Logout]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security Session管理]]></title>
    <url>%2FSpring-Security-Session-Manage.html</url>
    <content type="text"><![CDATA[用户登录成功后，信息保存在服务器Session中，这节学习下如何管理这些Session。这节将在Spring Security短信验证码登录的基础上继续扩展。Session超时设置Session超时时间也就是用户登录的有效时间。要设置Session超时时间很简单，只需要在配置文件中添加：123server: session: timeout: 3600单位为秒，通过上面的配置，Session的有效期为一个小时。值得注意的是，Session的最小有效期为60秒，也就是说即使你设置为小于60秒的值，其有效期还是为60秒。查看TomcatEmbeddedServletContainerFactory的源码即可发现原因：Session失效后，刷新页面后将跳转到认证页面，我们可以再添加一些配置，自定义Session失效后的一些行为。在Spring Security中配置Session管理器，并配置Session失效后要跳转的URL：1234567891011121314151617181920@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加验证码校验过滤器 .addFilterBefore(smsCodeFilter,UsernamePasswordAuthenticationFilter.class) // 添加短信验证码校验过滤器 .formLogin() // 表单登录 .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html", "/code/image","/code/sms","/session/invalid").permitAll() // 无需认证的请求路径 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and() .sessionManagement() // 添加 Session管理器 .invalidSessionUrl("/session/invalid") // Session失效后跳转到这个链接 ......&#125;上面配置了Session失效后跳转到/session/invalid，并且将这个URL添加到了免认证路径中。在Controller里添加一个方法，映射该请求：12345@GetMapping("session/invalid")@ResponseStatus(HttpStatus.UNAUTHORIZED)public String sessionInvalid()&#123; return "session已失效，请重新认证";&#125;为了演示，我们将Session的超时时间设置为最小值60秒，重启项目，认证后等待60秒并刷新页面：可看到请求跳转到了我们自定义的/session/invalidURL上。Session并发控制Session并发控制可以控制一个账号同一时刻最多能登录多少个。我们在Spring Security配置中继续添加Session相关配置:12345678910111213141516171819202122232425@Autowiredprivate MySessionExpiredStrategy sessionExpiredStrategy;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加验证码校验过滤器 .addFilterBefore(smsCodeFilter,UsernamePasswordAuthenticationFilter.class) // 添加短信验证码校验过滤器 .formLogin() // 表单登录 .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html", "/code/image","/code/sms","/session/invalid").permitAll() // 无需认证的请求路径 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and() .sessionManagement() // 添加 Session管理器 .invalidSessionUrl("/session/invalid") // Session失效后跳转到这个链接 .maximumSessions(1) .expiredSessionStrategy(sessionExpiredStrategy) .and() ......maximumSessions配置了最大Session并发数量为1个，如果mrbird这个账户登录后，在另一个客户端也使用mrbird账户登录，那么第一个使用mrbird登录的账户将会失效，类似于一个先入先出队列。expiredSessionStrategy配置了Session在并发下失效后的处理策略，这里为我们自定义的策略MySessionExpiredStrategy。MySessionExpiredStrategy实现SessionInformationExpiredStrategy：1234567891011@Componentpublic class MySessionExpiredStrategy implements SessionInformationExpiredStrategy &#123; @Override public void onExpiredSessionDetected(SessionInformationExpiredEvent event) throws IOException, ServletException &#123; HttpServletResponse response = event.getResponse(); response.setStatus(HttpStatus.UNAUTHORIZED.value()); response.setContentType("application/json;charset=utf-8"); response.getWriter().write("您的账号已经在别的地方登录，当前登录已失效。如果密码遭到泄露，请立即修改密码！"); &#125;&#125;为了演示这个效果，我们先将Session超时时间设置久一点，比如3600秒，然后重启项目，在Chrome里使用mrbird账户登录。登录成功后，在firefox上也是用mrbird账户登录，登录成功后回到chrome，刷新页面，效果如下所示：除了后者将前者踢出的策略，我们也可以控制当Session达到最大有效数的时候，不再允许相同的账户登录。要实现这个功能只需要在上面的配置中添加：123456789.......and() .sessionManagement() // 添加 Session管理器 .invalidSessionUrl("/session/invalid") // Session失效后跳转到这个链接 .maximumSessions(1) .maxSessionsPreventsLogin(true) .expiredSessionStrategy(sessionExpiredStrategy) .and()......重启系统，在chrome上登录mrbird账户后，在firefox上尝试使用mrbird账户登录：可以看到登录受限。在实际开发中，发现Session并发控制只对Spring Security默认的登录方式——账号密码登录有效，而像短信验证码登录，社交账号登录并不生效，解决方案可以参考我的开源项目https://github.com/wuyouzhuguli/FEBS-SecuritySession集群处理Session集群听着高大上，其实实现起来很简单。当我们登录成功后，用户认证的信息存储在Session中，而这些Session默认是存储在运行运用的服务器上的，比如Tomcat，netty等。当应用集群部署的时候，用户在A应用上登录认证了，后续通过负载均衡可能会把请求发送到B应用，而B应用服务器上并没有与该请求匹配的认证Session信息，所以用户就需要重新进行认证。要解决这个问题，我们可以把Session信息存储在第三方容器里（如Redis集群），而不是各自的服务器，这样应用集群就可以通过第三方容器来共享Session了。我们引入Redis和Spring Session依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;然后在yml中配置Session存储方式为Redis：123spring: session: store-type: redis为了方便，Redis配置采用默认配置即可。开启Redis，并且启动两个应用实例，一个端口为8080，另一个端口为9090。我们现在8080端口应用上登录：然后访问9090端口应用的主页：可以看到登录也是生效的。这就实现了集群化Session管理。其他操作SessionRegistry包含了一些使用的操作Session的方法，比如：踢出用户（让Session失效）：12String currentSessionId = request.getRequestedSessionId();sessionRegistry.getSessionInformation(sessionId).expireNow();获取所有Session信息：1List&lt;Object&gt; principals = sessionRegistry.getAllPrincipals();源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/59.Spring-Security-SessionManager]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security短信验证码登录]]></title>
    <url>%2FSpring-Security-SmsCode.html</url>
    <content type="text"><![CDATA[在Spring Security添加图形验证码一节中，我们已经实现了基于Spring Boot + Spring Security的账号密码登录，并集成了图形验证码功能。时下另一种非常常见的网站登录方式为手机短信验证码登录，但Spring Security默认只提供了账号密码的登录认证逻辑，所以要实现手机短信验证码登录认证功能，我们需要模仿Spring Security账号密码登录逻辑代码来实现一套自己的认证逻辑。短信验证码生成我们在上一节Spring Security添加图形验证码的基础上来集成短信验证码登录的功能。和图形验证码类似，我们先定义一个短信验证码对象SmsCode：12345678910111213141516171819public class SmsCode &#123; private String code; private LocalDateTime expireTime; public SmsCode(String code, int expireIn) &#123; this.code = code; this.expireTime = LocalDateTime.now().plusSeconds(expireIn); &#125; public SmsCode(String code, LocalDateTime expireTime) &#123; this.code = code; this.expireTime = expireTime; &#125; boolean isExpire() &#123; return LocalDateTime.now().isAfter(expireTime); &#125; // get,set略&#125;SmsCode对象包含了两个属性：code验证码和expireTime过期时间。isExpire方法用于判断短信验证码是否已过期。接着在ValidateCodeController中加入生成短信验证码相关请求对应的方法：1234567891011121314151617181920@RestControllerpublic class ValidateController &#123; public final static String SESSION_KEY_SMS_CODE = "SESSION_KEY_SMS_CODE"; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); @GetMapping("/code/sms") public void createSmsCode(HttpServletRequest request, HttpServletResponse response, String mobile) throws IOException &#123; SmsCode smsCode = createSMSCode(); sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY_SMS_CODE + mobile, smsCode); // 输出验证码到控制台代替短信发送服务 System.out.println("您的登录验证码为：" + smsCode.getCode() + "，有效时间为60秒"); &#125; private SmsCode createSMSCode() &#123; String code = RandomStringUtils.randomNumeric(6); return new SmsCode(code, 60); &#125;&#125;这里我们使用createSMSCode方法生成了一个6位的纯数字随机数，有效时间为60秒。然后通过SessionStrategy对象的setAttribute方法将短信验证码保存到了Session中，对应的key为SESSION_KEY_SMS_CODE。至此，短信验证码生成模块编写完毕，下面开始改造登录页面。改造登录页我们在登录页面中加入一个与手机短信验证码认证相关的Form表单：1234567891011&lt;form class="login-page" action="/login/mobile" method="post"&gt; &lt;div class="form"&gt; &lt;h3&gt;短信验证码登录&lt;/h3&gt; &lt;input type="text" placeholder="手机号" name="mobile" value="17777777777" required="required"/&gt; &lt;span style="display: inline"&gt; &lt;input type="text" name="smsCode" placeholder="短信验证码" style="width: 50%;"/&gt; &lt;a href="/code/sms?mobile=17777777777"&gt;发送验证码&lt;/a&gt; &lt;/span&gt; &lt;button type="submit"&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;其中a标签的href属性值对应我们的短信验证码生成方法的请求URL。Form的action对应处理短信验证码登录方法的请求URL，这个方法下面在进行具体实现。同时，我们需要在Spring Security中配置/code/sms路径免验证：12345678910111213141516171819@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加验证码校验过滤器 .formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html", "/code/image","/code/sms").permitAll() // 无需认证的请求路径 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and() .csrf().disable();&#125;重启项目，访问http://localhost:8080/login.html：点击发送验证码，控制台输出如下：1您的登录验证码为：693583，有效时间为60秒接下来开始实现使用短信验证码登录认证逻辑。添加短信验证码认证在Spring Security中，使用用户名密码认证的过程大致如下图所示：Spring Security使用UsernamePasswordAuthenticationFilter过滤器来拦截用户名密码认证请求，将用户名和密码封装成一个UsernamePasswordToken对象交给AuthenticationManager处理。AuthenticationManager将挑出一个支持处理该类型Token的AuthenticationProvider（这里为DaoAuthenticationProvider，AuthenticationProvider的其中一个实现类）来进行认证，认证过程中DaoAuthenticationProvider将调用UserDetailService的loadUserByUsername方法来获取UserDetails对象，如果UserDetails不为空并且密码和用户输入的密码匹配一致的话，则将认证信息保存到Session中，认证后我们便可以通过Authentication对象获取到认证的信息了。由于Spring Security并没用提供短信验证码认证的流程，所以我们需要仿照上面这个流程来实现：在这个流程中，我们自定义了一个名为SmsAuthenticationFitler的过滤器来拦截短信验证码登录请求，并将手机号码封装到一个叫SmsAuthenticationToken的对象中。在Spring Security中，认证处理都需要通过AuthenticationManager来代理，所以这里我们依旧将SmsAuthenticationToken交由AuthenticationManager处理。接着我们需要定义一个支持处理SmsAuthenticationToken对象的SmsAuthenticationProvider，SmsAuthenticationProvider调用UserDetailService的loadUserByUsername方法来处理认证。与用户名密码认证不一样的是，这里是通过SmsAuthenticationToken中的手机号去数据库中查询是否有与之对应的用户，如果有，则将该用户信息封装到UserDetails对象中返回并将认证后的信息保存到Authentication对象中。为了实现这个流程，我们需要定义SmsAuthenticationFitler、SmsAuthenticationToken和SmsAuthenticationProvider，并将这些组建组合起来添加到Spring Security中。下面我们来逐步实现这个过程。定义SmsAuthenticationToken查看UsernamePasswordAuthenticationToken的源码，将其复制出来重命名为SmsAuthenticationToken，并稍作修改，修改后的代码如下所示：12345678910111213141516171819202122232425262728293031323334353637383940public class SmsAuthenticationToken extends AbstractAuthenticationToken &#123; private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; private final Object principal; public SmsAuthenticationToken(String mobile) &#123; super(null); this.principal = mobile; setAuthenticated(false); &#125; public SmsAuthenticationToken(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); this.principal = principal; super.setAuthenticated(true); // must use super, as we override &#125; @Override public Object getCredentials() &#123; return null; &#125; public Object getPrincipal() &#123; return this.principal; &#125; public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123; if (isAuthenticated) &#123; throw new IllegalArgumentException( "Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead"); &#125; super.setAuthenticated(false); &#125; @Override public void eraseCredentials() &#123; super.eraseCredentials(); &#125;&#125;SmsAuthenticationToken包含一个principal属性，从它的两个构造函数可以看出，在认证之前principal存的是手机号，认证之后存的是用户信息。UsernamePasswordAuthenticationToken原来还包含一个credentials属性用于存放密码，这里不需要就去掉了。定义SmsAuthenticationFilter定义完SmsAuthenticationToken后，我们接着定义用于处理短信验证码登录请求的过滤器SmsAuthenticationFilter，同样的复制UsernamePasswordAuthenticationFilter源码并稍作修改：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SmsAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123; public static final String MOBILE_KEY = "mobile"; private String mobileParameter = MOBILE_KEY; private boolean postOnly = true; public SmsAuthenticationFilter() &#123; super(new AntPathRequestMatcher("/login/mobile", "POST")); &#125; public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (postOnly &amp;&amp; !request.getMethod().equals("POST")) &#123; throw new AuthenticationServiceException( "Authentication method not supported: " + request.getMethod()); &#125; String mobile = obtainMobile(request); if (mobile == null) &#123; mobile = ""; &#125; mobile = mobile.trim(); SmsAuthenticationToken authRequest = new SmsAuthenticationToken(mobile); setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; protected String obtainMobile(HttpServletRequest request) &#123; return request.getParameter(mobileParameter); &#125; protected void setDetails(HttpServletRequest request, SmsAuthenticationToken authRequest) &#123; authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); &#125; public void setMobileParameter(String mobileParameter) &#123; Assert.hasText(mobileParameter, "mobile parameter must not be empty or null"); this.mobileParameter = mobileParameter; &#125; public void setPostOnly(boolean postOnly) &#123; this.postOnly = postOnly; &#125; public final String getMobileParameter() &#123; return mobileParameter; &#125;&#125;构造函数中指定了当请求为/login/mobile，请求方法为POST的时候该过滤器生效。mobileParameter属性值为mobile，对应登录页面手机号输入框的name属性。attemptAuthentication方法从请求中获取到mobile参数值，并调用SmsAuthenticationToken的SmsAuthenticationToken(String mobile)构造方法创建了一个SmsAuthenticationToken。下一步就如流程图中所示的那样，SmsAuthenticationFilter将SmsAuthenticationToken交给AuthenticationManager处理。定义SmsAuthenticationProvider在创建完SmsAuthenticationFilter后，我们需要创建一个支持处理该类型Token的类，即SmsAuthenticationProvider，该类需要实现AuthenticationProvider的两个抽象方法：1234567891011121314151617181920212223242526272829303132public class SmsAuthenticationProvider implements AuthenticationProvider &#123; private UserDetailService userDetailService; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; SmsAuthenticationToken authenticationToken = (SmsAuthenticationToken) authentication; UserDetails userDetails = userDetailService.loadUserByUsername((String) authenticationToken.getPrincipal()); if (userDetails == null) throw new InternalAuthenticationServiceException("未找到与该手机号对应的用户"); SmsAuthenticationToken authenticationResult = new SmsAuthenticationToken(userDetails, userDetails.getAuthorities()); authenticationResult.setDetails(authenticationToken.getDetails()); return authenticationResult; &#125; @Override public boolean supports(Class&lt;?&gt; aClass) &#123; return SmsAuthenticationToken.class.isAssignableFrom(aClass); &#125; public UserDetailService getUserDetailService() &#123; return userDetailService; &#125; public void setUserDetailService(UserDetailService userDetailService) &#123; this.userDetailService = userDetailService; &#125;&#125;其中supports方法指定了支持处理的Token类型为SmsAuthenticationToken，authenticate方法用于编写具体的身份认证逻辑。在authenticate方法中，我们从SmsAuthenticationToken中取出了手机号信息，并调用了UserDetailService的loadUserByUsername方法。该方法在用户名密码类型的认证中，主要逻辑是通过用户名查询用户信息，如果存在该用户并且密码一致则认证成功；而在短信验证码认证的过程中，该方法需要通过手机号去查询用户，如果存在该用户则认证通过。认证通过后接着调用SmsAuthenticationToken的SmsAuthenticationToken(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities)构造函数构造一个认证通过的Token，包含了用户信息和用户权限。你可能会问，为什么这一步没有进行短信验证码的校验呢？实际上短信验证码的校验是在SmsAuthenticationFilter之前完成的，即只有当短信验证码正确以后才开始走认证的流程。所以接下来我们需要定一个过滤器来校验短信验证码的正确性。定义SmsCodeFilter短信验证码的校验逻辑其实和图形验证码的校验逻辑基本一致，所以我们在图形验证码过滤器的基础上稍作修改，代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445@Componentpublic class SmsCodeFilter extends OncePerRequestFilter &#123; @Autowired private AuthenticationFailureHandler authenticationFailureHandler; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; if (StringUtils.equalsIgnoreCase("/login/mobile", httpServletRequest.getRequestURI()) &amp;&amp; StringUtils.equalsIgnoreCase(httpServletRequest.getMethod(), "post")) &#123; try &#123; validateCode(new ServletWebRequest(httpServletRequest)); &#125; catch (ValidateCodeException e) &#123; authenticationFailureHandler.onAuthenticationFailure(httpServletRequest, httpServletResponse, e); return; &#125; &#125; filterChain.doFilter(httpServletRequest, httpServletResponse); &#125; private void validateSmsCode(ServletWebRequest servletWebRequest) throws ServletRequestBindingException &#123; String smsCodeInRequest = ServletRequestUtils.getStringParameter(servletWebRequest.getRequest(), "smsCode"); String mobile = ServletRequestUtils.getStringParameter(servletWebRequest.getRequest(), "mobile"); ValidateCode codeInSession = (ValidateCode) sessionStrategy.getAttribute(servletWebRequest, FebsConstant.SESSION_KEY_SMS_CODE + mobile); if (StringUtils.isBlank(smsCodeInRequest)) &#123; throw new ValidateCodeException("验证码不能为空！"); &#125; if (codeInSession == null) &#123; throw new ValidateCodeException("验证码不存在，请重新发送！"); &#125; if (codeInSession.isExpire()) &#123; sessionStrategy.removeAttribute(servletWebRequest, FebsConstant.SESSION_KEY_SMS_CODE + mobile); throw new ValidateCodeException("验证码已过期，请重新发送！"); &#125; if (!StringUtils.equalsIgnoreCase(codeInSession.getCode(), smsCodeInRequest)) &#123; throw new ValidateCodeException("验证码不正确！"); &#125; sessionStrategy.removeAttribute(servletWebRequest, FebsConstant.SESSION_KEY_SMS_CODE + mobile); &#125;&#125;方法的基本逻辑和之前定义的ValidateCodeFilter一致，这里不再赘述。配置生效在定义完所需的组件后，我们需要进行一些配置，将这些组件组合起来形成一个和上面流程图对应的流程。创建一个配置类SmsAuthenticationConfig：123456789101112131415161718192021222324252627@Componentpublic class SmsAuthenticationConfig extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; &#123; @Autowired private AuthenticationSuccessHandler authenticationSuccessHandler; @Autowired private AuthenticationFailureHandler authenticationFailureHandler; @Autowired private UserDetailService userDetailService; @Override public void configure(HttpSecurity http) throws Exception &#123; SmsAuthenticationFilter smsAuthenticationFilter = new SmsAuthenticationFilter(); smsAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class)); smsAuthenticationFilter.setAuthenticationSuccessHandler(authenticationSuccessHandler); smsAuthenticationFilter.setAuthenticationFailureHandler(authenticationFailureHandler); SmsAuthenticationProvider smsAuthenticationProvider = new SmsAuthenticationProvider(); smsAuthenticationProvider.setUserDetailService(userDetailService); http.authenticationProvider(smsAuthenticationProvider) .addFilterAfter(smsAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); &#125;&#125;在流程中第一步需要配置SmsAuthenticationFilter，分别设置了AuthenticationManager、AuthenticationSuccessHandler和AuthenticationFailureHandler属性。这些属性都是来自SmsAuthenticationFilter继承的AbstractAuthenticationProcessingFilter类中。第二步配置SmsAuthenticationProvider，这一步只需要将我们自个的UserDetailService注入进来即可。最后调用HttpSecurity的authenticationProvider方法指定了AuthenticationProvider为SmsAuthenticationProvider，并将SmsAuthenticationFilter过滤器添加到了UsernamePasswordAuthenticationFilter后面。到这里我们已经将短信验证码认证的各个组件组合起来了，最后一步需要做的是配置短信验证码校验过滤器，并且将短信验证码认证流程加入到Spring Security中。在BrowserSecurityConfig的configure方法中添加如下配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configurationpublic class BrowserSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private MyAuthenticationSucessHandler authenticationSucessHandler; @Autowired private MyAuthenticationFailureHandler authenticationFailureHandler; @Autowired private ValidateCodeFilter validateCodeFilter; @Autowired private SmsCodeFilter smsCodeFilter; @Autowired private SmsAuthenticationConfig smsAuthenticationConfig; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加验证码校验过滤器 .addFilterBefore(smsCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加短信验证码校验过滤器 .formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html", "/code/image","/code/sms").permitAll() // 无需认证的请求路径 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and() .csrf().disable() .apply(smsAuthenticationConfig); // 将短信验证码认证配置加到 Spring Security 中 &#125;&#125;具体含义见注释，这里不再赘述。测试重启项目，访问http://localhost:8080/login.html，点击发送验证码，控制台输出如下：1您的登录验证码为：169638，有效时间为60秒输入该验证码，点击登录后页面如下所示：认证成功。源码链接 https://github.com/wuyouzhuguli/SpringAll/tree/master/38.Spring-Security-SmsCode]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security添加记住我功能]]></title>
    <url>%2FSpring-Security-RememberMe.html</url>
    <content type="text"><![CDATA[在网站的登录页面中，记住我选项是一个很常见的功能，勾选记住我后在一段时间内，用户无需进行登录操作就可以访问系统资源。在Spring Security中添加记住我功能很简单，大致过程是：当用户勾选了记住我选项并登录成功后，Spring Security会生成一个token标识，然后将该token标识持久化到数据库，并且生成一个与该token相对应的cookie返回给浏览器。当用户过段时间再次访问系统时，如果该cookie没有过期，Spring Security便会根据cookie包含的信息从数据库中获取相应的token信息，然后帮用户自动完成登录操作。token持久化Spring Security的记住我功能的实现需要使用数据库来持久化token。我们在上一节Spring Security添加图形验证码的基础上来添加记住我的功能。在application.yml中添加数据源配置：123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/security?useUnicode=yes&amp;characterEncoding=UTF-8&amp;useSSL=false username: root password: 123456添加数据库依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;然后我们在BrowserSecurityConfig中配置个token持久化对象：12345678910111213141516@Configurationpublic class BrowserSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailService userDetailService; @Autowired private DataSource dataSource; @Bean public PersistentTokenRepository persistentTokenRepository() &#123; JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); jdbcTokenRepository.setCreateTableOnStartup(false); return jdbcTokenRepository; &#125; ...&#125;PersistentTokenRepository为一个接口类，这里我们用的是数据库持久化，所以实例用的是PersistentTokenRepository的实现类JdbcTokenRepositoryImpl。JdbcTokenRepositoryImpl需要指定数据源，所以我们将配置好的数据源对象DataSource注入进来并配置到JdbcTokenRepositoryImpl的dataSource属性中。createTableOnStartup属性用于是否启动项目时创建保存token信息的数据表，这里设置为false，我们自己手动创建。查看JdbcTokenRepositoryImpl的源码，可以看到其包含了一个CREATE_TABLE_SQL属性：这个其实就是用于保存token对象数据表的SQL语句，我们复制出来手动执行创建表：123456CREATE TABLE persistent_logins ( username VARCHAR (64) NOT NULL, series VARCHAR (64) PRIMARY KEY, token VARCHAR (64) NOT NULL, last_used TIMESTAMP NOT NULL)修改登录页完成上述配置后，我们稍微改造下登录页，加入记住我的勾选选项：1&lt;input type="checkbox" name="remember-me"/&gt; 记住我其中name属性必须为remember-me。配置生效最后我们需要在Spring Security的认证流程中启用记住我的功能，在BrowserSecurityConfig的configure方法中开启记住我功能：123456789101112131415161718192021222324@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加验证码校验过滤器 .formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .rememberMe() .tokenRepository(persistentTokenRepository()) // 配置 token 持久化仓库 .tokenValiditySeconds(3600) // remember 过期时间，单为秒 .userDetailsService(userDetailService) // 处理自动登录逻辑 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html", "/image/code").permitAll() // 无需认证的请求路径 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and() .csrf().disable();&#125;rememberMe()用于开启记住我功能；tokenRepository(persistentTokenRepository())用于指定token持久化方法；tokenValiditySeconds配置了token的有效时长，单为为秒；userDetailsService(userDetailService)用于处理通过token对象自动登录，这里为我们自定义的UserDetailsService接口实现。配置好后，重启项目，登录页面如下所示：比较难看，无伤大雅。勾选并成功登录后，可以看到网页多了个remember-me的cookie对象：查看数据库表persistent_logins：可以看到token信息已经成功持久化了，并且浏览器也成功生成了相应的cookie。在cookie未失效之前，无论是重开浏览器或者重启项目，用户都无需再次登录就可以访问系统资源了。源码链接 https://github.com/wuyouzhuguli/SpringAll/tree/master/37.Spring-Security-RememberMe]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security添加图形验证码]]></title>
    <url>%2FSpring-Security-ValidateCode.html</url>
    <content type="text"><![CDATA[添加验证码大致可以分为三个步骤：根据随机数生成验证码图片；将验证码图片显示到登录页面；认证流程中加入验证码校验。Spring Security的认证校验是由UsernamePasswordAuthenticationFilter过滤器完成的，所以我们的验证码校验逻辑应该在这个过滤器之前。下面一起学习下如何在上一节Spring Security自定义用户认证的基础上加入验证码校验功能。生成图形验证码验证码功能需要用到spring-social-config依赖：1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.social&lt;/groupId&gt; &lt;artifactId&gt;spring-social-config&lt;/artifactId&gt;&lt;/dependency&gt;首先定义一个验证码对象ImageCode：12345678910111213141516171819202122232425public class ImageCode &#123; private BufferedImage image; private String code; private LocalDateTime expireTime; public ImageCode(BufferedImage image, String code, int expireIn) &#123; this.image = image; this.code = code; this.expireTime = LocalDateTime.now().plusSeconds(expireIn); &#125; public ImageCode(BufferedImage image, String code, LocalDateTime expireTime) &#123; this.image = image; this.code = code; this.expireTime = expireTime; &#125; boolean isExpire() &#123; return LocalDateTime.now().isAfter(expireTime); &#125; // get,set 略&#125;ImageCode对象包含了三个属性：image图片，code验证码和expireTime过期时间。isExpire方法用于判断验证码是否已过期。接着定义一个ValidateCodeController，用于处理生成验证码请求：1234567891011121314@RestControllerpublic class ValidateController &#123; public final static String SESSION_KEY_IMAGE_CODE = "SESSION_KEY_IMAGE_CODE"; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); @GetMapping("/code/image") public void createCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; ImageCode imageCode = createImageCode(); sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_KEY, imageCode); ImageIO.write(imageCode.getImage(), "jpeg", response.getOutputStream()); &#125;&#125;createImageCode方法用于生成验证码对象，org.springframework.social.connect.web.HttpSessionSessionStrategy对象封装了一些处理Session的方法，包含了setAttribute、getAttribute和removeAttribute方法，具体可以查看该类的源码。使用sessionStrategy将生成的验证码对象存储到Session中，并通过IO流将生成的图片输出到登录页面上。其中createImageCode方法代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private ImageCode createImageCode() &#123; int width = 100; // 验证码图片宽度 int height = 36; // 验证码图片长度 int length = 4; // 验证码位数 int expireIn = 60; // 验证码有效时间 60s BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = image.getGraphics(); Random random = new Random(); g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); g.setFont(new Font("Times New Roman", Font.ITALIC, 20)); g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 155; i++) &#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x, y, x + xl, y + yl); &#125; StringBuilder sRand = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; String rand = String.valueOf(random.nextInt(10)); sRand.append(rand); g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110))); g.drawString(rand, 13 * i + 6, 16); &#125; g.dispose(); return new ImageCode(image, sRand.toString(), expireIn);&#125;private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) &#123; fc = 255; &#125; if (bc &gt; 255) &#123; bc = 255; &#125; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b);&#125;生成验证码的方法写好后，接下来开始改造登录页面。改造登录页在登录页面加上如下代码：1234&lt;span style="display: inline"&gt; &lt;input type="text" name="imageCode" placeholder="验证码" style="width: 50%;"/&gt; &lt;img src="/code/image"/&gt;&lt;/span&gt;&lt;img&gt;标签的src属性对应ValidateController的createImageCode方法。要使生成验证码的请求不被拦截，需要在BrowserSecurityConfig的configure方法中配置免拦截：1234567891011121314151617@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html", "/code/image").permitAll() // 无需认证的请求路径 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and().csrf().disable();&#125;重启项目，访问http://localhost:8080/login.html，效果如下：认证流程添加验证码校验在校验验证码的过程中，可能会抛出各种验证码类型的异常，比如“验证码错误”、“验证码已过期”等，所以我们定义一个验证码类型的异常类：1234567public class ValidateCodeException extends AuthenticationException &#123; private static final long serialVersionUID = 5022575393500654458L; ValidateCodeException(String message) &#123; super(message); &#125;&#125;注意，这里继承的是AuthenticationException而不是Exception。我们都知道，Spring Security实际上是由许多过滤器组成的过滤器链，处理用户登录逻辑的过滤器为UsernamePasswordAuthenticationFilter，而验证码校验过程应该是在这个过滤器之前的，即只有验证码校验通过后采去校验用户名和密码。由于Spring Security并没有直接提供验证码校验相关的过滤器接口，所以我们需要自己定义一个验证码校验的过滤器ValidateCodeFilter：12345678910111213141516171819202122232425262728@Componentpublic class ValidateCodeFilter extends OncePerRequestFilter &#123; @Autowired private AuthenticationFailureHandler authenticationFailureHandler; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; if (StringUtils.equalsIgnoreCase("/login", httpServletRequest.getRequestURI()) &amp;&amp; StringUtils.equalsIgnoreCase(httpServletRequest.getMethod(), "post")) &#123; try &#123; validateCode(new ServletWebRequest(httpServletRequest)); &#125; catch (ValidateCodeException e) &#123; authenticationFailureHandler.onAuthenticationFailure(httpServletRequest, httpServletResponse, e); return; &#125; &#125; filterChain.doFilter(httpServletRequest, httpServletResponse); &#125; private void validateCode(ServletWebRequest servletWebRequest) throws ServletRequestBindingException &#123; ... &#125; &#125;ValidateCodeFilter继承了org.springframework.web.filter.OncePerRequestFilter，该过滤器只会执行一次。在doFilterInternal方法中我们判断了请求URL是否为/login，该路径对应登录form表单的action路径，请求的方法是否为POST，是的话进行验证码校验逻辑，否则直接执行filterChain.doFilter让代码往下走。当在验证码校验的过程中捕获到异常时，调用Spring Security的校验失败处理器AuthenticationFailureHandler进行处理。validateCode的校验逻辑如下所示：1234567891011121314151617181920private void validateCode(ServletWebRequest servletWebRequest) throws ServletRequestBindingException &#123; ImageCode codeInSession = (ImageCode) sessionStrategy.getAttribute(servletWebRequest, ValidateController.SESSION_KEY); String codeInRequest = ServletRequestUtils.getStringParameter(servletWebRequest.getRequest(), "imageCode"); if (StringUtils.isBlank(codeInRequest)) &#123; throw new ValidateCodeException("验证码不能为空！"); &#125; if (codeInSession == null) &#123; throw new ValidateCodeException("验证码不存在！"); &#125; if (codeInSession.isExpire()) &#123; sessionStrategy.removeAttribute(servletWebRequest, ValidateController.SESSION_KEY); throw new ValidateCodeException("验证码已过期！"); &#125; if (!StringUtils.equalsIgnoreCase(codeInSession.getCode(), codeInRequest)) &#123; throw new ValidateCodeException("验证码不正确！"); &#125; sessionStrategy.removeAttribute(servletWebRequest, ValidateController.SESSION_KEY);&#125;我们分别从Session中获取了ImageCode对象和请求参数imageCode（对应登录页面的验证码&lt;input&gt;框name属性）,然后进行了各种判断并抛出相应的异常。当验证码过期或者验证码校验通过时，我们便可以删除Session中的ImageCode属性了。验证码校验过滤器定义好了，怎么才能将其添加到UsernamePasswordAuthenticationFilter前面呢？很简单，只需要在BrowserSecurityConfig的configure方法中添加些许配置即可：123456789101112131415161718192021@Autowiredprivate ValidateCodeFilter validateCodeFilter;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) // 添加验证码校验过滤器 .formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html", "/code/image").permitAll() // 无需认证的请求路径 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and().csrf().disable();&#125;上面代码中，我们注入了ValidateCodeFilter，然后通过addFilterBefore方法将ValidateCodeFilter验证码校验过滤器添加到了UsernamePasswordAuthenticationFilter前面。大功告成，重启项目，访问http://localhost:8080/login.html，当不输入验证码时点击登录，页面显示如下：当输入错误的验证码时点击登录，页面显示如下：当页面加载60秒后再输入验证码点击登录，页面显示如下：当验证码通过，并且用户名密码正确时，页面显示如下：源码链接 https://github.com/wuyouzhuguli/SpringAll/tree/master/36.Spring-Security-ValidateCode]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security自定义用户认证]]></title>
    <url>%2FSpring-Security-Authentication.html</url>
    <content type="text"><![CDATA[在Spring Boot中开启Spring Security一节中我们简单搭建了个Spring Boot + Spring Security的项目，认证的用户名和密码都是由Spring Security生成。Spring Security支持我们自定义认证的过程，如处理用户信息获取逻辑，使用我们自定义的登录页面替换Spring Security默认的登录页及自定义登录成功或失败后的处理逻辑等。这里将在上一节的源码基础上进行改造。自定义认证过程自定义认证的过程需要实现Spring Security提供的UserDetailService接口，该接口只有一个抽象方法loadUserByUsername，源码如下：123public interface UserDetailsService &#123; UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;&#125;loadUserByUsername方法返回一个UserDetail对象，该对象也是一个接口，包含一些用于描述用户信息的方法，源码如下：12345678910111213141516public interface UserDetails extends Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); String getPassword(); String getUsername(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled();&#125;这些方法的含义如下：getAuthorities获取用户包含的权限，返回权限集合，权限是一个继承了GrantedAuthority的对象；getPassword和getUsername用于获取密码和用户名；isAccountNonExpired方法返回boolean类型，用于判断账户是否未过期，未过期返回true反之返回false；isAccountNonLocked方法用于判断账户是否未锁定；isCredentialsNonExpired用于判断用户凭证是否没过期，即密码是否未过期；isEnabled方法用于判断用户是否可用。实际中我们可以自定义UserDetails接口的实现类，也可以直接使用Spring Security提供的UserDetails接口实现类org.springframework.security.core.userdetails.User。说了那么多，下面我们来开始实现UserDetailService接口的loadUserByUsername方法。首先创建一个MyUser对象，用于存放模拟的用户数据（实际中一般从数据库获取，这里为了方便直接模拟）：1234567891011121314151617public class MyUser implements Serializable &#123; private static final long serialVersionUID = 3497935890426858541L; private String userName; private String password; private boolean accountNonExpired = true; private boolean accountNonLocked= true; private boolean credentialsNonExpired= true; private boolean enabled= true; // get,set略&#125;接着创建MyUserDetailService实现UserDetailService：1234567891011121314151617181920@Configurationpublic class UserDetailService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // 模拟一个用户，替代数据库获取逻辑 MyUser user = new MyUser(); user.setUserName(username); user.setPassword(this.passwordEncoder.encode("123456")); // 输出加密后的密码 System.out.println(user.getPassword()); return new User(username, user.getPassword(), user.isEnabled(), user.isAccountNonExpired(), user.isCredentialsNonExpired(), user.isAccountNonLocked(), AuthorityUtils.commaSeparatedStringToAuthorityList("admin")); &#125;&#125;这里我们使用了org.springframework.security.core.userdetails.User类包含7个参数的构造器，其还包含一个三个参数的构造器User(String username, String password,Collection&lt;? extends GrantedAuthority&gt; authorities)，由于权限参数不能为空，所以这里先使用AuthorityUtils.commaSeparatedStringToAuthorityList方法模拟一个admin的权限，该方法可以将逗号分隔的字符串转换为权限集合。此外我们还注入了PasswordEncoder对象，该对象用于密码加密，注入前需要手动配置。我们在BrowserSecurityConfig中配置它：123456789@Configurationpublic class BrowserSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; ...&#125;PasswordEncoder是一个密码加密接口，而BCryptPasswordEncoder是Spring Security提供的一个实现方法，我们也可以自己实现PasswordEncoder。不过Spring Security实现的BCryptPasswordEncoder已经足够强大，它对相同的密码进行加密后可以生成不同的结果。这时候重启项目，访问http://localhost:8080/login，便可以使用任意用户名以及123456作为密码登录系统。我们多次进行登录操作，可以看到控制台输出的加密后的密码如下：可以看到，BCryptPasswordEncoder对相同的密码生成的结果每次都是不一样的。替换默认登录页默认的登录页面过于简陋，我们可以自己定义一个登录页面。为了方便起见，我们直接在src/main/resources/resources目录下定义一个login.html（不需要Controller跳转）：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel="stylesheet" href="css/login.css" type="text/css"&gt;&lt;/head&gt;&lt;body&gt; &lt;form class="login-page" action="/login" method="post"&gt; &lt;div class="form"&gt; &lt;h3&gt;账户登录&lt;/h3&gt; &lt;input type="text" placeholder="用户名" name="username" required="required" /&gt; &lt;input type="password" placeholder="密码" name="password" required="required" /&gt; &lt;button type="submit"&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;要怎么做才能让Spring Security跳转到我们自己定义的登录页面呢？很简单，只需要在BrowserSecurityConfig的configure中添加一些配置：123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/login.html") .loginProcessingUrl("/login") .and() .authorizeRequests() // 授权配置 .antMatchers("/login.html").permitAll() .anyRequest() // 所有请求 .authenticated(); // 都需要认证&#125;上面代码中.loginPage(&quot;/login.html&quot;)指定了跳转到登录页面的请求URL，.loginProcessingUrl(&quot;/login&quot;)对应登录页面form表单的action=&quot;/login&quot;，.antMatchers(&quot;/login.html&quot;).permitAll()表示跳转到登录页面的请求不被拦截，否则会进入无限循环。这时候启动系统，访问http://localhost:8080/hello，会看到页面已经被重定向到了http://localhost:8080/login.html：输入用户名和密码发现页面报错：我们先把CSRF攻击防御关了，修改BrowserSecurityConfig的configure：12345678910111213Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/login.html") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .and() .authorizeRequests() // 授权配置 .antMatchers("/login.html").permitAll() // 登录跳转 URL 无需认证 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and().csrf().disable();&#125;重启项目便可正常登录。假如现在有这样一个需求：在未登录的情况下，当用户访问html资源的时候跳转到登录页，否则返回JSON格式数据，状态码为401。要实现这个功能我们将loginPage的URL改为/authentication/require，并且在antMatchers方法中加入该URL，让其免拦截:12345678910111213@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html").permitAll() // 登录跳转 URL 无需认证 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and().csrf().disable();&#125;然后定义一个控制器BrowserSecurityController，处理这个请求：1234567891011121314151617@RestControllerpublic class BrowserSecurityController &#123; private RequestCache requestCache = new HttpSessionRequestCache(); private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); @GetMapping("/authentication/require") @ResponseStatus(HttpStatus.UNAUTHORIZED) public String requireAuthentication(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; SavedRequest savedRequest = requestCache.getRequest(request, response); if (savedRequest != null) &#123; String targetUrl = savedRequest.getRedirectUrl(); if (StringUtils.endsWithIgnoreCase(targetUrl, ".html")) redirectStrategy.sendRedirect(request, response, "/login.html"); &#125; return "访问的资源需要身份认证！"; &#125;&#125;其中HttpSessionRequestCache为Spring Security提供的用于缓存请求的对象，通过调用它的getRequest方法可以获取到本次请求的HTTP信息。DefaultRedirectStrategy的sendRedirect为Spring Security提供的用于处理重定向的方法。上面代码获取了引发跳转的请求，根据请求是否以.html为结尾来对应不同的处理方法。如果是以.html结尾，那么重定向到登录页面，否则返回”访问的资源需要身份认证！”信息，并且HTTP状态码为401（HttpStatus.UNAUTHORIZED）。这样当我们访问http://localhost:8080/hello的时候页面便会跳转到http://localhost:8080/authentication/require，并且输出”访问的资源需要身份认证！”，当我们访问http://localhost:8080/hello.html的时候，页面将会跳转到登录页面。处理成功和失败Spring Security有一套默认的处理登录成功和失败的方法：当用户登录成功时，页面会跳转会引发登录的请求，比如在未登录的情况下访问http://localhost:8080/hello，页面会跳转到登录页，登录成功后再跳转回来；登录失败时则是跳转到Spring Security默认的错误提示页面。下面我们通过一些自定义配置来替换这套默认的处理机制。自定义登录成功逻辑要改变默认的处理成功逻辑很简单，只需要实现org.springframework.security.web.authentication.AuthenticationSuccessHandler接口的onAuthenticationSuccess方法即可：123456789@Componentpublic class MyAuthenticationSucessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; response.setContentType("application/json;charset=utf-8"); response.getWriter().write(mapper.writeValueAsString(authentication)); &#125;&#125;其中Authentication参数既包含了认证请求的一些信息，比如IP，请求的SessionId等，也包含了用户信息，即前面提到的User对象。通过上面这个配置，用户登录成功后页面将打印出Authentication对象的信息。要使这个配置生效，我们还的在BrowserSecurityConfig的configure中配置它：12345678910111213141516171819202122232425@Configurationpublic class BrowserSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private MyAuthenticationSucessHandler authenticationSucessHandler; @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html").permitAll() // 登录跳转 URL 无需认证 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and().csrf().disable(); &#125;&#125;我们将MyAuthenticationSucessHandler注入进来，并通过successHandler方法进行配置。这时候重启项目登录后页面将会输出如下JSON信息：123456789101112131415161718192021222324252627&#123; "authorities": [ &#123; "authority": "admin" &#125; ], "details": &#123; "remoteAddress": "0:0:0:0:0:0:0:1", "sessionId": "8D50BAF811891F4397E21B4B537F0544" &#125;, "authenticated": true, "principal": &#123; "password": null, "username": "mrbird", "authorities": [ &#123; "authority": "admin" &#125; ], "accountNonExpired": true, "accountNonLocked": true, "credentialsNonExpired": true, "enabled": true &#125;, "credentials": null, "name": "mrbird"&#125;像password，credentials这些敏感信息，Spring Security已经将其屏蔽。除此之外，我们也可以在登录成功后做页面的跳转，修改MyAuthenticationSucessHandler：123456789101112131415@Componentpublic class MyAuthenticationSucessHandler implements AuthenticationSuccessHandler &#123; private RequestCache requestCache = new HttpSessionRequestCache(); private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); @Autowired private ObjectMapper mapper; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException &#123; SavedRequest savedRequest = requestCache.getRequest(request, response); redirectStrategy.sendRedirect(request, response, savedRequest.getRedirectUrl()); &#125;&#125;通过上面配置，登录成功后页面将跳转回引发跳转的页面。如果想指定跳转的页面，比如跳转到/index，可以将savedRequest.getRedirectUrl()修改为/index：12345678910@Componentpublic class MyAuthenticationSucessHandler implements AuthenticationSuccessHandler &#123; private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException &#123; redirectStrategy.sendRedirect(request, response, "/index"); &#125;&#125;然后在TestController中定义一个处理该请求的方法：1234567@RestControllerpublic class TestController &#123; @GetMapping("index") public Object index()&#123; return SecurityContextHolder.getContext().getAuthentication(); &#125;&#125;登录成功后，便可以使用SecurityContextHolder.getContext().getAuthentication()获取到Authentication对象信息。除了通过这种方式获取Authentication对象信息外，也可以使用下面这种方式:1234567@RestControllerpublic class TestController &#123; @GetMapping("index") public Object index(Authentication authentication) &#123; return authentication; &#125;&#125;重启项目，登录成功后，页面将跳转到http://localhost:8080/index：自定义登录失败逻辑和自定义登录成功处理逻辑类似，自定义登录失败处理逻辑需要实现org.springframework.security.web.authentication.AuthenticationFailureHandler的onAuthenticationFailure方法：1234567@Componentpublic class MyAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException &#123; &#125;&#125;onAuthenticationFailure方法的AuthenticationException参数是一个抽象类，Spring Security根据登录失败的原因封装了许多对应的实现类，查看AuthenticationException的Hierarchy：不同的失败原因对应不同的异常，比如用户名或密码错误对应的是BadCredentialsException，用户不存在对应的是UsernameNotFoundException，用户被锁定对应的是LockedException等。假如我们需要在登录失败的时候返回失败信息，可以这样处理：1234567891011121314@Componentpublic class MyAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; @Autowired private ObjectMapper mapper; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException &#123; response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); response.setContentType("application/json;charset=utf-8"); response.getWriter().write(mapper.writeValueAsString(exception.getMessage())); &#125;&#125;状态码定义为500（HttpStatus.INTERNAL_SERVER_ERROR.value()），即系统内部异常。同样的，我们需要在BrowserSecurityConfig的configure中配置它：123456789101112131415161718192021222324@Configurationpublic class BrowserSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private MyAuthenticationSucessHandler authenticationSucessHandler; @Autowired private MyAuthenticationFailureHandler authenticationFailureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单登录 // http.httpBasic() // HTTP Basic .loginPage("/authentication/require") // 登录跳转 URL .loginProcessingUrl("/login") // 处理表单登录 URL .successHandler(authenticationSucessHandler) // 处理登录成功 .failureHandler(authenticationFailureHandler) // 处理登录失败 .and() .authorizeRequests() // 授权配置 .antMatchers("/authentication/require", "/login.html").permitAll() // 登录跳转 URL 无需认证 .anyRequest() // 所有请求 .authenticated() // 都需要认证 .and().csrf().disable(); &#125;&#125;重启项目，当输入错误的密码时，页面输出如下：源码链接：https://github.com/wuyouzhuguli/SpringAll/tree/master/35.Spring-Security-Authentication]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中开启Spring Security]]></title>
    <url>%2FSpring-Boot%26Spring-Security.html</url>
    <content type="text"><![CDATA[Spring Security是一款基于Spring的安全框架，主要包含认证和授权两大安全模块，和另外一款流行的安全框架Apache Shiro相比，它拥有更为强大的功能。Spring Security也可以轻松的自定义扩展以满足各种需求，并且对常见的Web安全攻击提供了防护支持。如果你的Web框架选择的是Spring，那么在安全方面Spring Security会是一个不错的选择。这里我们使用Spring Boot来集成Spring Security，Spring Boot版本为1.5.14.RELEASE，Spring Security版本为4.2.7RELEASE。开启Spring Security创建一个Spring Boot项目，然后引入spring-boot-starter-security：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;接下来我们创建一个TestController，对外提供一个/hello服务：1234567@RestControllerpublic class TestController &#123; @GetMapping("hello") public String hello() &#123; return "hello spring security"; &#125;&#125;这时候我们直接启动项目，访问http://localhost:8080/hello，可看到页面弹出了个HTTP Basic认证框：当Spring项目中引入了Spring Security依赖的时候，项目会默认开启如下配置：123security: basic: enabled: true这个配置开启了一个HTTP basic类型的认证，所有服务的访问都必须先过这个认证，默认的用户名为user，密码由Sping Security自动生成，回到IDE的控制台，可以找到密码信息：1Using default security password: e9ed391c-93de-4611-ac87-d871d9e749ac输入用户名user，密码e9ed391c-93de-4611-ac87-d871d9e749ac后，我们便可以成功访问/hello接口。基于表单认证我们可以通过一些配置将HTTP Basic认证修改为基于表单的认证方式。创建一个配置类BrowserSecurityConfig继承org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter这个抽象类并重写configure(HttpSecurity http)方法。WebSecurityConfigurerAdapter是由Spring Security提供的Web应用安全配置的适配器：1234567891011@Configurationpublic class BrowserSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 表单方式 .and() .authorizeRequests() // 授权配置 .anyRequest() // 所有请求 .authenticated(); // 都需要认证 &#125;&#125;Spring Security提供了这种链式的方法调用。上面配置指定了认证方式为表单登录，并且所有请求都需要进行认证。这时候我们重启项目，再次访问http://localhost:8080/hello，可以看到认证方式已经是form表单的方式了：用户名依旧是user，密码由Spring Security自动生成。当输入凭证错误时，页面上将显示错误信息：如果需要换回HTTP Basic的认证方式，我们只需要简单修改configure方法中的配置：123456789@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; // http.formLogin() // 表单方式 http.httpBasic() // HTTP Basic方式 .and() .authorizeRequests() // 授权配置 .anyRequest() // 所有请求 .authenticated(); // 都需要认证&#125;基本原理上面我们开启了一个最简单的Spring Security安全配置，下面我们来了解下Spring Security的基本原理。通过上面的的配置，代码的执行过程可以简化为下图表示：如上图所示，Spring Security包含了众多的过滤器，这些过滤器形成了一条链，所有请求都必须通过这些过滤器后才能成功访问到资源。其中UsernamePasswordAuthenticationFilter过滤器用于处理基于表单方式的登录认证，而BasicAuthenticationFilter用于处理基于HTTP Basic方式的登录验证，后面还可能包含一系列别的过滤器（可以通过相应配置开启）。在过滤器链的末尾是一个名为FilterSecurityInterceptor的拦截器，用于判断当前请求身份认证是否成功，是否有相应的权限，当身份认证失败或者权限不足的时候便会抛出相应的异常。ExceptionTranslateFilter捕获并处理，所以我们在ExceptionTranslateFilter过滤器用于处理了FilterSecurityInterceptor抛出的异常并进行处理，比如需要身份认证时将请求重定向到相应的认证页面，当认证失败或者权限不足时返回相应的提示信息。下面我们通过debug来验证这个过程（登录方式改回表单的方式）。我们在/hello服务上打个断点：在FilterSecurityInterceptor的invoke方法的super.beforeInvocation上打个断点：当这行代码执行通过后，便可以调用下一行的doFilter方法来真正调用/hello服务，否则将抛出相应的异常。当FilterSecurityInterceptor抛出异常时，异常将由ExceptionTranslateFilter捕获并处理，所以我们在ExceptionTranslateFilter的doFilter方法catch代码块第一行打个断点：我们待会模拟的是用户未登录直接访问/hello，所以应该是抛出用户未认证的异常，所以接下来应该跳转到UsernamePasswordAuthenticationFilter处理表单方式的用户认证。在UsernamePasswordAuthenticationFilter的attemptAuthentication方法上打个断点：准备完毕后，我们启动项目，然后访问http://localhost:8080/hello，代码直接跳转到FilterSecurityInteceptor的断点上：往下执行，因为当前请求没有经过身份认证，所以将抛出异常并被ExceptionTranslateFilter捕获：捕获异常后重定向到登录表单登录页面，当我们在表单登录页面输入信息点login后，代码跳转到UsernamePasswordAuthenticationFilter过滤器的attemptAuthentication方法上：判断用户名和密码是否正确之后，代码又跳回FilterSecurityInterceptor的beforeInvocation方法执行上：当认证通过时，FilterSecurityInterceptor代码往下执行doFilter，然后代码最终跳转到/hello上：浏览器页面将显示hello spring security信息。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/34.Start-Spring-Security]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用过滤器和拦截器]]></title>
    <url>%2FSpring-Boot-Filter-Interceptor.html</url>
    <content type="text"><![CDATA[过滤器（Filter）和拦截器（Interceptor）是Web项目中常用的两个功能，本文将简单介绍在Spring Boot中使用过滤器和拦截器来计算Controller中方法的执行时长，并且简单对比两者的区别。现有如下Controller：123456789@RestController@RequestMapping("user")public class UserController &#123; @GetMapping("/&#123;id:\\d+&#125;") public void get(@PathVariable String id) &#123; System.out.println(id); &#125;&#125;下面通过配置过滤器和拦截器来实现对get方法执行时间计算的功能。过滤器定义一个TimeFilter类，实现javax.servlet.Filter：1234567891011121314151617181920public class TimeFilter implements Filter&#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("过滤器初始化"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("开始执行过滤器"); Long start = new Date().getTime(); filterChain.doFilter(servletRequest, servletResponse); System.out.println("【过滤器】耗时 " + (new Date().getTime() - start)); System.out.println("结束执行过滤器"); &#125; @Override public void destroy() &#123; System.out.println("过滤器销毁"); &#125;&#125;TimeFilter重写了Filter的三个方法，方法名称已经很直白的描述了其作用，这里不再赘述。要使该过滤器在Spring Boot中生效，还需要一些配置。这里主要有两种配置方式。配置方式一可通过在TimeFilter上加上如下注解：12345@Component@WebFilter(urlPatterns = &#123;"/*"&#125;)public class TimeFilter implements Filter &#123; ...&#125;@Component注解让TimeFilter成为Spring上下文中的一个Bean，@WebFilter注解的urlPatterns属性配置了哪些请求可以进入该过滤器，/*表示所有请求。启动项目时可以看到控制台输出了过滤器初始化，启动后访问http://localhost:8080/user/1，控制台输出如下：1234开始执行过滤器1【过滤器】耗时 31结束执行过滤器配置方式二除了在过滤器类上加注解外，我们也可以通过FilterRegistrationBean来注册过滤器。定义一个WebConfig类，加上@Configuration注解表明其为配置类，然后通过FilterRegistrationBean来注册过滤器:123456789101112131415@Configurationpublic class WebConfig &#123; @Bean public FilterRegistrationBean timeFilter() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); TimeFilter timeFilter = new TimeFilter(); filterRegistrationBean.setFilter(timeFilter); List&lt;String&gt; urlList = new ArrayList&lt;&gt;(); urlList.add("/*"); filterRegistrationBean.setUrlPatterns(urlList); return filterRegistrationBean; &#125;&#125;FilterRegistrationBean除了注册过滤器TimeFilter外还通过setUrlPatterns方法配置了URL匹配规则。重启项目访问http://localhost:8080/user/1，我们可以看到和上面一样的效果。通过过滤器我们只可以获取到servletRequest对象，所以并不能获取到方法的名称，所属类，参数等额外的信息。拦截器定义一个TimeInterceptor类，实现org.springframework.web.servlet.HandlerInterceptor接口:12345678910111213141516171819202122232425public class TimeInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; System.out.println("处理拦截之前"); httpServletRequest.setAttribute("startTime", new Date().getTime()); System.out.println(((HandlerMethod) o).getBean().getClass().getName()); System.out.println(((HandlerMethod) o).getMethod().getName()); return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println("开始处理拦截"); Long start = (Long) httpServletRequest.getAttribute("startTime"); System.out.println("【拦截器】耗时 " + (new Date().getTime() - start)); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println("处理拦截之后"); Long start = (Long) httpServletRequest.getAttribute("startTime"); System.out.println("【拦截器】耗时 " + (new Date().getTime() - start)); System.out.println("异常信息 " + e); &#125;&#125;TimeInterceptor实现了HandlerInterceptor接口的三个方法。preHandle方法在处理拦截之前执行，postHandle只有当被拦截的方法没有抛出异常成功时才会处理，afterCompletion方法无论被拦截的方法抛出异常与否都会执行。通过这三个方法的参数可以看到，相较于过滤器，拦截器多了Object和Exception对象，所以可以获取的信息比过滤器要多的多。但过滤器仍无法获取到方法的参数等信息，我们可以通过切面编程来实现这个目的，具体可参考https://mrbird.cc/Spring-Boot-AOP%20log.html。要使拦截器在Spring Boot中生效，还需要如下两步配置：1.在拦截器类上加入@Component注解；2.在WebConfig中通过InterceptorRegistry注册过滤器:12345678910@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Autowired private TimeInterceptor timeInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(timeInterceptor); &#125;&#125;启动项目，访问http://localhost:8080/user/1，控制台输出如下：123456789处理拦截之前cc.mrbird.controller.UserControllerget1开始处理拦截【拦截器】耗时 24处理拦截之后【拦截器】耗时 24异常信息 null从输出中我们可以了解到三个方法的执行顺序，并且三个方法都被执行了。我们在UserController的get方法中手动抛出一个异常：12345 @GetMapping("/&#123;id:\\d+&#125;")public void get(@PathVariable String id) &#123; System.out.println(id); throw new RuntimeException("user not exist");&#125;重启项目后，访问http://localhost:8080/user/1，控制台输出如下：1234567处理拦截之前cc.mrbird.controller.UserControllerget1处理拦截之后【拦截器】耗时 0异常信息 java.lang.RuntimeException: user not exist可看到，postHandle方法并没有被执行。执行时机对比我们将过滤器和拦截器都配置上，然后启动项目访问http://localhost:8080/user/1：123456789101112开始执行过滤器处理拦截之前cc.mrbird.controller.UserControllerget1开始处理拦截【拦截器】耗时 25处理拦截之后【拦截器】耗时 25异常信息 null【过滤器】耗时 34结束执行过滤器可看到过滤器要先于拦截器执行，晚于拦截器结束。下图很好的描述了它们的执行时间区别：源码链接https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/26.Spring-Boot-Filter-Interceptor]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot异常处理]]></title>
    <url>%2FSpring-Boot-Exception.html</url>
    <content type="text"><![CDATA[Spring Boot对异常的处理有一套默认的机制：当应用中产生异常时，Spring Boot根据发送请求头中的accept是否包含text/html来分别返回不同的响应信息。当从浏览器地址栏中访问应用接口时，请求头中的accept便会包含text/html信息，产生异常时，Spring Boot通过org.springframework.web.servlet.ModelAndView对象来装载异常信息，并以HTML的格式返回；而当从客户端访问应用接口产生异常时（客户端访问时，请求头中的accept不包含text/html），Spring Boot则以JSON的格式返回异常信息。下面来验证一下。默认异常处理机制假设应用中有如下一个Controller：123456789@RestController@RequestMapping("user")public class UserController &#123; @GetMapping("/&#123;id:\\d+&#125;") public void get(@PathVariable String id) &#123; throw new RuntimeException("user not exist"); &#125;&#125;在代码中我们主动的抛出了一个RuntimeException，使用浏览器访问http://localhost:8080/user/1： 可看到页面返回了一些异常描述，并且请求头的accpet包含了text/html片段。接着使用模拟发送REST请求的Chrome插件Restlet Client发送http://localhost:8080/user/1：可以看到请求头的accept值为*/*，并且返回一段JSON格式的信息。查看Spring Boot的BasicErrorController类便可看到这一默认机制的具体实现：可看到errorHtml和error方法的请求地址和方法是一样的，唯一的区别就是errorHtml通过produces = {&quot;text/html&quot;}判断请求头的accpet属性中是否包含text/html，如果包含，便走该方法。自定义html异常页面我们可以通过在src/main/resources/resources/error路径下定义友好的异常页面，比如定义一个500.html页面：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;500&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 系统内部异常&lt;/body&gt;&lt;/html&gt;然后再次通过浏览器访问:http://localhost:8080/user/1：同样的，我们也可以定义404.html等常见的HTTP状态码对应的异常页面。通过自定义html异常页面并不会影响客户端发送请求异常返回的结果。自定义异常处理除了可以通过自定义html异常页面来改变浏览器访问接口时产生的异常信息，我们也可以自定义异常处理来改表默认的客户端访问接口产生的异常信息。我们手动定义一个UserNotExistException，继承RuntimeException。12345678910111213141516171819public class UserNotExistException extends RuntimeException&#123; private static final long serialVersionUID = -1574716826948451793L; private String id; public UserNotExistException(String id)&#123; super("user not exist"); this.id = id; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125;然后定义一个Controller异常处理类ControllerExceptionHandler：12345678910111213@ControllerAdvicepublic class ControllerExceptionHandler &#123; @ExceptionHandler(UserNotExistException.class) @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public Map&lt;String, Object&gt; handleUserNotExistsException(UserNotExistException e) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("id", e.getId()); map.put("message", e.getMessage()); return map; &#125;&#125;其中注解@ExceptionHandler指定了要处理的异常类型，注解@ResponseStatus指定异常处理方法返回的HTTP状态码为HttpStatus.INTERNAL_SERVER_ERROR，即500。HttpStatus是一个spring自带的枚举类型，封装了常见的HTTP状态码及描述：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public enum HttpStatus &#123; CONTINUE(100, "Continue"), SWITCHING_PROTOCOLS(101, "Switching Protocols"), PROCESSING(102, "Processing"), CHECKPOINT(103, "Checkpoint"), OK(200, "OK"), CREATED(201, "Created"), ACCEPTED(202, "Accepted"), NON_AUTHORITATIVE_INFORMATION(203, "Non-Authoritative Information"), NO_CONTENT(204, "No Content"), RESET_CONTENT(205, "Reset Content"), PARTIAL_CONTENT(206, "Partial Content"), MULTI_STATUS(207, "Multi-Status"), ALREADY_REPORTED(208, "Already Reported"), IM_USED(226, "IM Used"), MULTIPLE_CHOICES(300, "Multiple Choices"), MOVED_PERMANENTLY(301, "Moved Permanently"), FOUND(302, "Found"), /** @deprecated */ @Deprecated MOVED_TEMPORARILY(302, "Moved Temporarily"), SEE_OTHER(303, "See Other"), NOT_MODIFIED(304, "Not Modified"), /** @deprecated */ @Deprecated USE_PROXY(305, "Use Proxy"), TEMPORARY_REDIRECT(307, "Temporary Redirect"), PERMANENT_REDIRECT(308, "Permanent Redirect"), BAD_REQUEST(400, "Bad Request"), UNAUTHORIZED(401, "Unauthorized"), PAYMENT_REQUIRED(402, "Payment Required"), FORBIDDEN(403, "Forbidden"), NOT_FOUND(404, "Not Found"), METHOD_NOT_ALLOWED(405, "Method Not Allowed"), NOT_ACCEPTABLE(406, "Not Acceptable"), PROXY_AUTHENTICATION_REQUIRED(407, "Proxy Authentication Required"), REQUEST_TIMEOUT(408, "Request Timeout"), CONFLICT(409, "Conflict"), GONE(410, "Gone"), LENGTH_REQUIRED(411, "Length Required"), PRECONDITION_FAILED(412, "Precondition Failed"), PAYLOAD_TOO_LARGE(413, "Payload Too Large"), /** @deprecated */ @Deprecated REQUEST_ENTITY_TOO_LARGE(413, "Request Entity Too Large"), URI_TOO_LONG(414, "URI Too Long"), /** @deprecated */ @Deprecated REQUEST_URI_TOO_LONG(414, "Request-URI Too Long"), UNSUPPORTED_MEDIA_TYPE(415, "Unsupported Media Type"), REQUESTED_RANGE_NOT_SATISFIABLE(416, "Requested range not satisfiable"), EXPECTATION_FAILED(417, "Expectation Failed"), I_AM_A_TEAPOT(418, "I'm a teapot"), /** @deprecated */ @Deprecated INSUFFICIENT_SPACE_ON_RESOURCE(419, "Insufficient Space On Resource"), /** @deprecated */ @Deprecated METHOD_FAILURE(420, "Method Failure"), /** @deprecated */ @Deprecated DESTINATION_LOCKED(421, "Destination Locked"), UNPROCESSABLE_ENTITY(422, "Unprocessable Entity"), LOCKED(423, "Locked"), FAILED_DEPENDENCY(424, "Failed Dependency"), UPGRADE_REQUIRED(426, "Upgrade Required"), PRECONDITION_REQUIRED(428, "Precondition Required"), TOO_MANY_REQUESTS(429, "Too Many Requests"), REQUEST_HEADER_FIELDS_TOO_LARGE(431, "Request Header Fields Too Large"), UNAVAILABLE_FOR_LEGAL_REASONS(451, "Unavailable For Legal Reasons"), INTERNAL_SERVER_ERROR(500, "Internal Server Error"), NOT_IMPLEMENTED(501, "Not Implemented"), BAD_GATEWAY(502, "Bad Gateway"), SERVICE_UNAVAILABLE(503, "Service Unavailable"), GATEWAY_TIMEOUT(504, "Gateway Timeout"), HTTP_VERSION_NOT_SUPPORTED(505, "HTTP Version not supported"), VARIANT_ALSO_NEGOTIATES(506, "Variant Also Negotiates"), INSUFFICIENT_STORAGE(507, "Insufficient Storage"), LOOP_DETECTED(508, "Loop Detected"), BANDWIDTH_LIMIT_EXCEEDED(509, "Bandwidth Limit Exceeded"), NOT_EXTENDED(510, "Not Extended"), NETWORK_AUTHENTICATION_REQUIRED(511, "Network Authentication Required"); ...&#125;编写完自定义异常处理逻辑后，我们将UserController中的方法抛出的异常改为UserNotExistException：1234 @GetMapping("/&#123;id:\\d+&#125;")public void get(@PathVariable String id) &#123; throw new UserNotExistException(id);&#125;重启项目，使用Restlet Client再次访问http://localhost:8080/user/1，响应如下： 源码链接 https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/25.Spring-Boot-Exception]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8实战】新的日期和时间API]]></title>
    <url>%2Fjava8-new-time-date-api.html</url>
    <content type="text"><![CDATA[Java 8之前的库对日期和时间的支持并不理想，为了解决这个问题，Java 8引入了一套全新的时间日期API，位于java.time路径下。LocalDateLocalDate类型包含了年月日信息，下面举些LocalDate的使用示例：12345678LocalDate date = LocalDate.of(2018, 4, 20); // 2018-04-20int year = date.getYear(); // 2018int month = date.getMonth().getValue(); // 4int day = date.getDayOfMonth(); // 20// 查看该月有多少天int days = date.lengthOfMonth(); // 30// 是否是闰年boolean isLeap = date.isLeapYear(); // false可以使用LocalDate.now()获取当天的日期信息：12// 查看当天 年月日LocalDate today = LocalDate.now(); // 2018-04-20除了调用LocalDate的getYear方法外，我们也可以使用ChronoField枚举类型来实现相同的功能：12345int year1 = date.get(ChronoField.YEAR); // 2018int month1 = date.get(ChronoField.MONTH_OF_YEAR); // 4int day1 = date.get(ChronoField.DAY_OF_MONTH); // 20// 当前日期属于该月第几周int weekOfMonth = date.get(ChronoField.ALIGNED_WEEK_OF_MONTH); // 3ChronoField枚举类型包含了诸多的属性可供选择： 我们也可以修改LocalDate对象：1234567LocalDate date3 = LocalDate.of(2018, 4, 20); // 2018-04-20LocalDate date4 = date3.withDayOfMonth(22); // 2018-04-22LocalDate date5 = date3.with(ChronoField.DAY_OF_MONTH, 22); // 2018-04-22LocalDate date6 = date3.withYear(2019); // 2019-04-20LocalDate date7 = date3.plusDays(5); // 2018-04-25LocalDate date8 = date3.plus(5, ChronoUnit.DAYS); // 2018-04-25LocalDate date9 = date3.minusYears(10); // 2008-04-20TemporalAdjusters类提供了许多静态方法来修改LocalDate对象。当我们需要获取下一个周天，下一个工作日，本月的最后一天等信息时，TemporalAdjusters类便可派上用场：12345import static java.time.temporal.TemporalAdjusters.*;LocalDate date10 = date3.with(nextOrSame(DayOfWeek.MONDAY)); // 2018-04-23LocalDate date11 = date3.with(lastDayOfMonth()); // 2018-04-30LocalDate date12 = date3.with(previous(DayOfWeek.SATURDAY)); // 2018-04-14可参考4月的日历来理解上面的结果： 我们还可以对LocalDate进行格式化操作：123456String str1 = date.format(DateTimeFormatter.BASIC_ISO_DATE); // 20180420String str2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2018-04-20DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");String str5 = date.format(dtf); // 2018-04-20LocalDate date13 = LocalDate.parse(str5, dtf); // 2018-04-20LocalDate和下面要介绍的LocalTime，LocalDateTime之间共享了许多类似的方法，上面介绍的LocalDate修改、格式化等方法通用适用于LocalTime和LocalDateTime。LocalTimeLocalTime和LocalDate类似，区别在于LocalTime包含的是时分秒（毫秒）信息。举些LocalTime的例子：1234LocalTime time = LocalTime.of(20, 13, 54); // 20:13:54int hour = time.getHour(); // 20int minute = time.getMinute(); // 13int second = time.getSecond(); // 54LocalDate和LocalTime都可以通过字符串来创建：12LocalDate date = LocalDate.parse("2018-04-20");LocalTime time = LocalTime.parse("20:13:54");LocalDateTimeLocalDateTime是LocalDate和LocalTime的组合形式，包含了年月日时分秒信息。举些LocalDateTime的使用示例：12LocalDateTime ldt1 = LocalDateTime.of(2018, 4, 20, 20, 13, 54); // 2018-04-20T20:13:54LocalDateTime ldt2 = LocalDateTime.of(date, time); // 2018-04-20T20:13:54LocalDateTime可以转换为LocalDate和LocalTime，转换后包含的信息减少了：12LocalDate date1 = ldt1.toLocalDate(); // 2018-04-20LocalTime time1 = ldt1.toLocalTime(); // 20:13:54同样的，LocalDate和LocalTime也可以转换为LocalDateTime，只需要补上日期或者时间：123LocalDateTime ldt3 = date.atTime(time); // 2018-04-20T20:13:54LocalDateTime ldt4 = date.atTime(20, 13, 54); // 2018-04-20T20:13:54LocalDateTime ldt5 = time.atDate(date); // 2018-04-20T20:13:54DurationDuration用于计算两个LocalTime或者LocalDateTime的时间差，例如：123LocalTime time2 = LocalTime.of(23, 59, 59);Duration duration = Duration.between(time1, time2);long seconds = duration.getSeconds(); // 13565time1和time2之间相差了13565秒。手动创建Duration对象：12Duration threeMinutes = Duration.ofMinutes(3);threeMinutes = Duration.of(3, ChronoUnit.MINUTES); // 创建了一个3分钟的Duration，两种创建方式等价PeriodPeriod用于计算两个LocalDate之间的时长。举些例子：1234LocalDate date2 = LocalDate.of(2018, 5, 21);Period period = Period.between(date1, date2);int monthsBetween = period.getMonths(); // 1int daysBetween = period.getDays(); // 12018-04-21和2018-04-20之间月份相差1，天数相差1。同样的，我们也可以手动创建Period对象：123Period tenDays = Period.ofDays(10);Period threeWeeks = Period.ofWeeks(3);Period twoYearsSixMonthsOneDay = Period.of(2, 6, 1);其他一些常用的方法比较两个时间的先后1234LocalDate date15 = LocalDate.of(2018,4,21);date.isEqual(date15); // falsedate.isAfter(date15); // falsedate.isBefore(date15); // trueMonthDay类的使用MonthDay只包含月日信息，可以用于存放类似于生日，结婚纪念日等信息。举个使用MonthDay的例子：123456LocalDate birthday = LocalDate.of(1999, 9, 9);MonthDay monthDay = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());MonthDay currentMonthDay = MonthDay.from(LocalDate.now());if (currentMonthDay.equals(monthDay)) &#123; System.out.println("happy birthday!");&#125;假如用户的生日是1999年9月9号，那么可以通过这种方法来判断今天是否是用户的生日，如果是的话便发送生日祝福。同样的也有YearMonth类。Java 8 新的日期时间API还提供了不同时区和历法的获取方法，由于较少使用而且不易于理解，这里不再列出。😕]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8实战】使用Optional取代null]]></title>
    <url>%2Fjava8-optional-null.html</url>
    <content type="text"><![CDATA[在Java中对一个空对象进行操作时，便会抛出最常见的异常NullPointerException。为了改善这个问题，Java 8中提供了一个java.util.Optional&lt;T&gt;类型。Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。下面介绍Optional类的使用方法。 假如有一个像下面这样的类层次结构：1234567891011121314151617181920212223242526272829class Department &#123; private Employee employee; public Department(Employee employee) &#123; this.employee = employee; &#125; Employee getEmployee() &#123; return employee; &#125;&#125;class Employee &#123; private Girl girlFriend; public Employee(Girl girlFriend) &#123; this.girlFriend = girlFriend; &#125; Girl getGirlFriend() &#123; return girlFriend; &#125;&#125;class Girl &#123; private String name; public Girl(String name) &#123; this.name = name; &#125; String getName() &#123; return name; &#125;&#125;部门Department类包含一个员工employee属性，类型为Employee，员工Employee类包含girlFriend属性，类型为Girl。假如现在要获取部门某个员工的女朋友，我们通常是这样获取的：1234567891011121314static String getGirlFriendName(Department department) &#123; if (department != null) &#123; Employee employee = department.getEmployee(); if (employee != null) &#123; Girl girl = employee.getGirlFriend(); if (girl != null) &#123; return girl.getName(); &#125; return "单身汪"; &#125; return "没有员工"; &#125; return "部门为空";&#125;可以看到，在每次引用变量的属性时，都要先判断变量是否为空，如果不做该检查将可能导致NullPointerException。下面我们将使用Optional来改善这种层层嵌套，啰嗦的代码。创建Optional创建一个Optional对象有好几种方式：创建一个空的Optional我们可以使用静态工厂方法Optional.empty，创建一个空的Optional对象：1Optional&lt;Department&gt; department = Optional.empty();根据非空值创建Optional我们也可以使用静态工厂方法Optional.of来创建一个非空对象的Optional对象：1Optional&lt;Employee&gt; optEmployee = Optional.of(employee);如果employee为空，这段代码会立即抛出一个NullPointerException。创建可以为null的Optional使用静态工厂方法Optional.ofNullable，我们可以创建一个允许null值的Optional对象：1Optional&lt;Employee&gt; optEmployee = Optional.ofNullable(employee);如果employee为空，对其调用get方法将抛出NoSuchElementException。Optional方法Optional类包含了许多方法，下面介绍这些方法的使用。isPresent顾名思义，如果值存在返回true，否则返回false。如：1234 Optional&lt;Department&gt; opt = Optional.ofNullable(department);if(opt.isPresent())&#123; System.out.println(opt.get().getEmployee());&#125;get如果Optional有值则将其返回，否则抛出NoSuchElementException。下面举个抛出NoSuchElementException的例子：12345try &#123; Optional.empty().get();&#125; catch (Exception e) &#123; e.printStackTrace();&#125;代码将捕获到 java.util.NoSuchElementException: No value present 异常。ifPresent如果Optional实例有值则为其调用Consumer（函数描述符为T -&gt; void），否则不做处理。如：1girl.ifPresent(g -&gt; System.out.println("我有女朋友，名字是：" + g.getName()));orElse如果Optional实例有值则将其返回，否则返回orElse方法传入的参数。如：1System.out.println(Optional.empty().orElse("There is no value present!"));程序将输出There is no value present!。orElseGetorElseGet与orElse方法类似，orElse方法将传入的字符串作为默认值，而orElseGet方法可以接受Supplier（函数描述符为() -&gt; T）来生成默认值。如：1System.out.println(Optional.empty().orElseGet(() -&gt; "There is no value present!"));程序同样输出There is no value present!。orElseThrow如果有值则将其返回，否则抛出Supplier接口创建的异常。如：12345try &#123; Optional.empty().orElseThrow(NoSuchElementException::new);&#125; catch (Exception e) &#123; e.printStackTrace();&#125;代码将捕获到 java.util.NoSuchElementException: No value present 异常。map如果Optional有值，则对其执行调用Function函数描述符为（T -&gt; R）得到返回值。如果返回值不为null，则创建包含Function回值的Optional作为map方法返回值，否则返回空Optional。12Optional&lt;String&gt; upperName = name.map(String::toUpperCase);System.out.println(upperName.orElse("No value found"));flatMap如果有值，为其执行Function函数返回Optional类型返回值，否则返回空Optional。flatMap与map方法类似，区别在于flatMap中的Function函数返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。如：12upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));System.out.println(upperName.orElse("No value found"));filterfilter个方法通过传入Predicate（函数描述符为T -&gt; Boolean）对Optional实例的值进行过滤。如：123Optional&lt;String&gt; name = Optional.of("Jane");Optional&lt;String&gt; LongName = name.filter((value) -&gt; value.length() &gt;= 3);System.out.println(LongName.orElse("名字长度小于3个字符"));方法输出Jane。实战介绍完Optional类的方法后，我们使用Optional改善一开始的代码：1234567static String getGirlFriendName(Department department) &#123; Optional&lt;Department&gt; opt = Optional.ofNullable(department); return opt.map(Department::getEmployee) .map(Employee::getGirlFriend) .map(Girl::getName) .orElseThrow(NoSuchElementException::new);&#125;整洁而又不失逼格。《Java 8实战》读书笔记]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8实战】使用并行流]]></title>
    <url>%2FJava8-parallelStream.html</url>
    <content type="text"><![CDATA[除了顺序流外，Java 8中也可以对集合对象调用parallelStream方法或者对顺序流调用parallel方法来生成并行流。并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样在使用流处理数据规模较大的集合对象时可以充分的利用多核CPU来提高处理效率。不过在一些情况下，并行流未必会比顺序流快，甚至会慢很多，所以了解如何高效的使用并行流也至关重要。此外，我们也可以调用流的sequential方法，将并行流转换为顺序流。测试并行流的性能举个例子，对1到1000的整数求和，观察顺序流和并行流的处理时间：1234567891011121314public class StreamExample &#123; public static void main(String[] args) &#123; StreamExample.test((n) -&gt; LongStream.rangeClosed(1L, n).reduce(0L, Long::sum), 1000L); StreamExample.test((n) -&gt; LongStream.rangeClosed(1L, n).parallel().reduce(0L, Long::sum), 1000L); &#125; static void test(LongConsumer c, Long n) &#123; long start = System.currentTimeMillis(); c.accept(n); long end = System.currentTimeMillis(); System.out.println("处理时间：" + (end - start) + "msc"); &#125;&#125;运行结果：12处理时间：9msc处理时间：484msc结果和我们预期的不一致，这是因为在处理数据集规模不大的情况下，将流并行化所带来的额外开销比逻辑代码开销还大。我们将数据集扩大：12StreamExample.test((n) -&gt; LongStream.rangeClosed(1L, n).reduce(0L, Long::sum), 1000000000L);StreamExample.test((n) -&gt; LongStream.rangeClosed(1L, n).parallel().reduce(0L, Long::sum), 1000000000L);运行结果：12处理时间：2775msc处理时间：725msc对于较小的数据量，选择并行流不是一个好的决定。并行处理少数几个元素的好处还抵不上并行化造成的额外开销。设N是要处理的元素的总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。接着对比下使用并行流处理包装类型的求和与原始类型的求和运行时间对比：12StreamExample.test((n) -&gt; Stream.iterate(1L, a -&gt; a + 1L).limit(n).reduce(0L, Long::sum), 1000000000L);StreamExample.test((n) -&gt; LongStream.rangeClosed(1L, n).parallel().reduce(0L, Long::sum), 1000000000L);运行结果：12处理时间：21915msc处理时间：920msc因为iterate生成的是包装类型的对象，必须拆箱成原始类型才能求和，而且我们很难把iterate分成多个独立块来并行执行。所以可以看到来两者间的运行效率差了将近24倍！在实际中应避免频繁拆装箱；有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元 素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性 能好，因为它不一定要按顺序来执行。再看一个例子：12345678910111213141516171819202122public class StreamExample &#123; public static void main(String[] args) &#123; ArrayList&lt;Long&gt; arrayList = Stream.iterate(1L, a -&gt; a + 1L).limit(10000000L).collect(toCollection(ArrayList::new)); LinkedList&lt;Long&gt; linkedList = Stream.iterate(1L, a -&gt; a + 1L).limit(10000000L).collect(toCollection(LinkedList::new)); StreamExample.test(() -&gt; arrayList.parallelStream().reduce(0L, Long::sum)); StreamExample.test(() -&gt; linkedList.parallelStream().reduce(0L, Long::sum)); &#125; static void test(Runner r) &#123; long start = System.currentTimeMillis(); r.run(); long end = System.currentTimeMillis(); System.out.println("处理时间：" + (end - start) + "msc"); &#125;&#125;@FunctionalInterfaceinterface Runner &#123; void run();&#125;上面代码对比了使用并行流处理ArrayList和使用并行流处理LinkedList的性能对比，运行结果如下：12处理时间：1258msc处理时间：7933msc之所以出现这个结果，是因为ArrayList的拆分效率比LinkedList高得多，前者用不着遍历就可以平均拆分，而后者则必须遍历。使用并行流要考虑流背后的数据结构是否易于分解。用range方法创建的原始类型流也可以快速分解。下表列出了流的数据源和可分解性：数据源可分解性ArrayList很好LinkedList很差IntStream.range很好Stream.iterate很差HashSet好TreeSet好总结总而言之，使用并行流应该考虑以下几点：留意拆装箱成本；流中依赖于元素顺序的操作，在并行流上执行的代价非常大；考虑流的流水线操作总成本，对于较小的数据量，并不适合使用并行流；考虑流背后的数据结构是否易于分解，不易分解的数据结构不适合使用并行流。《Java 8实战》读书笔记]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8实战】使用流收集数据]]></title>
    <url>%2Fjava8stream2.html</url>
    <content type="text"><![CDATA[在上一节中，我们了解到终端操作collect方法用于收集流中的元素，并放到不同类型的结果中，比如List、Set或者Map。其实collect方法可以接受各种Collectors接口的静态方法作为参数来实现更为强大的规约操作，比如查找最大值最小值，汇总，分区和分组等等。准备工作为了演示Collectors接口中的静态方法使用，这里创建一个Dish类（菜谱类）：12345678910111213141516171819202122232425public class Dish &#123; public enum Type &#123;MEAT, FISH, OTHER&#125; /** 食物名称 */ private final String name; /** 是否是素食 */ private final boolean vegetarian; /** 卡路里 */ private final int calories; /** 类型：肉，海鲜，其他 */ private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) &#123; this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; &#125; @Override public String toString() &#123; return this.getName(); &#125; // get,set略&#125;然后创建一个List，包含各种食材：12345678910List&lt;Dish&gt; list = Arrays.asList( new Dish("pork", false, 800, Dish.Type.MEAT), new Dish("beef", false, 700, Dish.Type.MEAT), new Dish("chicken", false, 400, Dish.Type.MEAT), new Dish("french fries", true, 530, Dish.Type.OTHER), new Dish("rice", true, 350, Dish.Type.OTHER), new Dish("season fruit", true, 120, Dish.Type.OTHER), new Dish("pizza", true, 550, Dish.Type.OTHER), new Dish("prawns", false, 300, Dish.Type.FISH), new Dish("salmon", false, 450, Dish.Type.FISH) );在测试类中导入所有Collectors接口的静态方法：1import static java.util.stream.Collectors.*;规约与汇总最大最小值Collectors.maxBy和Collectors.minBy用来计算流中的最大或最小值，比如按卡路里的大小来筛选出卡路里最高的食材：123list.stream() .collect(maxBy(Comparator.comparingInt(Dish::getCalories))) .ifPresent(System.out::println);输出pork。汇总Collectors.summingInt可以用于求和，参数类型为int类型。相应的基本类型对应的方法还有Collectors.summingLong和Collectors.summingDouble。比如求所有食材的卡路里：1list.stream().collect(summingInt(Dish::getCalories)); // 4200Collectors.averagingInt方法用于求平均值，参数类型为int类型。相应的基本类型对应的方法还有Collectors.averagingLong和Collectors.averagingDouble。比如求所有食材的平均卡路里:1list.stream().collect(averagingInt(Dish::getCalories)); // 466.6666666666667Collectors.summarizingInt方法可以一次性返回元素个数，最大值，最小值，平均值和总和：12IntSummaryStatistics iss = list.stream().collect(summarizingInt(Dish::getCalories));System.out.println(iss); // IntSummaryStatistics&#123;count=9, sum=4200, min=120, average=466.666667, max=800&#125;同样，相应的summarizingLong和summarizingDouble方法有相关的LongSummaryStatistics和DoubleSummaryStatistics类型，适用于收集的属性是原始类型long或double的情况。拼接Collectors.joining方法会把流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。如：12list.stream().map(Dish::getName).collect(joining()); // porkbeefchickenfrench friesriceseason fruitpizzaprawnssalmon内部拼接采用了StringBuilder。除此之外，也可以指定拼接符：12list.stream().map(Dish::getName).collect(joining("，"));// pork，beef，chicken，french fries，rice，season fruit，pizza，prawns，salmonreducingCollectors.reducing方法可以实现求和，最大值最小值筛选，拼接等操作。上面介绍的方法在编程上更方便快捷，但reducing的可读性更高，实际使用哪种我觉得还是看个人喜好。举个使用reducing求最大值的例子：1list.stream().collect(reducing(0, Dish::getCalories, Integer::max)); // 800或者：1list.stream().map(Dish::getCalories).collect(reducing(0, Integer::max)); // 800分组分组功能类似于SQL里的group by，可以对流中的元素按照指定分组规则进行分组。普通分组Collectors.groupingBy方法可以轻松的完成分组操作。比如现在对List中的食材按照类型进行分组：12Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = list.stream().collect(groupingBy(Dish::getType));System.out.println(dishesByType);输出结果{OTHER=[french fries, rice, season fruit, pizza], FISH=[prawns, salmon], MEAT=[pork, beef, chicken]}。我们也可以自定义分组规则，比如按照卡路里的高低分为高热量，正常和低热量：首先定义一个卡路里高低的枚举类型1public enum CaloricLevel &#123; DIET, NORMAL, FAT &#125;;然后编写分组规则：12345678Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCalories = list.stream().collect( groupingBy(d -&gt; &#123; if (d.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (d.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;));System.out.println(dishesByCalories);输出结果：{DIET=[chicken, rice, season fruit, prawns], NORMAL=[beef, french fries, pizza, salmon], FAT=[pork]}。多级分组Collectors.groupingBy支持嵌套实现多级分组，比如将食材按照类型分类，然后再按照卡路里的高低分类：12345678 Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesGroup = list.stream().collect( groupingBy(Dish::getType, groupingBy(d -&gt; &#123; if (d.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (d.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;) ));System.out.println(dishesGroup);返回结果是一个二级Map，输出结果{FISH={DIET=[prawns], NORMAL=[salmon]}, OTHER={DIET=[rice, season fruit], NORMAL=[french fries, pizza]}, MEAT={DIET=[chicken], FAT=[pork], NORMAL=[beef]}}。实际上，第二个参数除了Collectors.groupingBy外，也可以传递其他规约操作，规约的结果类型对应Map里的第二个泛型。举些例子，将食材按照类型分，然后统计各个类型对应的数量：12Map&lt;Dish.Type, Long&gt; dishesCountByType = list.stream().collect(groupingBy(Dish::getType,counting()));System.out.println(dishesCountByType);因为Collectors.counting方法返回Long类型，所以Map第二个泛型也必须指定为Long。输出结果：{OTHER=4, FISH=2, MEAT=3}。或者对食材按照类型分，然后选出卡路里最高的食物：1234Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; map = list.stream().collect(groupingBy( Dish::getType, maxBy(Comparator.comparing(Dish::getCalories))));System.out.println(map);输出结果：{OTHER=Optional[pizza], MEAT=Optional[pork], FISH=Optional[salmon]}。如果不希望输出结果包含Optional，可以使用Collectors.collectingAndThen方法：1234Map&lt;Dish.Type, Dish&gt; map = list.stream().collect(groupingBy( Dish::getType, collectingAndThen(maxBy(Comparator.comparing(Dish::getCalories)), Optional::get)));System.out.println(map);输出结果：{OTHER=pizza, FISH=salmon, MEAT=pork}。常与Collectors.groupingBy组合使用的方法还有Collectors.mapping。Collectors.mapping方法接受两个参数：一个函数对流中的元素做变换，另一个则将变换的结果对象收集起来，比如对食材按照类型分类，然后输出各种类型食材下卡路里等级情况：12345678910Map&lt;Dish.Type, HashSet&lt;CaloricLevel&gt;&gt; map = list.stream().collect(groupingBy( Dish::getType, mapping( d -&gt; &#123; if (d.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (d.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; &#125;, toCollection(HashSet::new) )));System.out.println(map);Collectors.toCollection方法可以方便的构造各种类型的集合。输出结果：{FISH=[DIET, NORMAL], MEAT=[DIET, NORMAL, FAT], OTHER=[DIET, NORMAL]}。分区分区类似于分组，只不过分区最多两种结果。Collectors.partitioningBy方法用于分区操作，接收一个Predicate&lt;T&gt;类型的Lambda表达式作为参数。比如将食材按照素食与否分类：12Map&lt;Boolean, List&lt;Dish&gt;&gt; map = list.stream().collect(partitioningBy(Dish::isVegetarian));System.out.println(map);输出结果：{false=[pork, beef, chicken, prawns, salmon], true=[french fries, rice, season fruit, pizza]}。Collectors.partitioningBy方法还支持传入分组函数或者其他规约操作，比如将食材按照素食与否分类，然后按照食材类型进行分类：123Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; map = list.stream().collect( partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType)));System.out.println(map);输出结果：{false={MEAT=[pork, beef, chicken], FISH=[prawns, salmon]}, true={OTHER=[french fries, rice, season fruit, pizza]}}。再如将食材按照素食与否分类，然后筛选出各自类型中卡路里含量最低的食材：12345Map&lt;Boolean, Dish&gt; map = list.stream().collect( partitioningBy(Dish::isVegetarian, collectingAndThen( minBy(Comparator.comparing(Dish::getCalories)), Optional::get )));System.out.println(map);输出结果：{false=prawns, true=season fruit}。《Java 8实战》读书笔记]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8实战】开始使用流]]></title>
    <url>%2Fjava8stream1.html</url>
    <content type="text"><![CDATA[Java 8 中的 Stream 俗称为流，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作。Stream API 借助于Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。通过下面的例子我们可以初步体会到使用 Stream 处理集合的便利性。初探Stream有如下一个List，现要从中筛选出以J开头的元素，然后转换为大写，最后输出结果。Java 8之前我们是这样做的：12345678910List&lt;String&gt; list = Arrays.asList("Java", "JavaScript", "python", "PHP", "C#", "Golang", "Swift");List&lt;String&gt; filterList = new ArrayList&lt;&gt;();for (String str : list) &#123; if (str.startsWith("J")) &#123; filterList.add(str.toUpperCase()); &#125;&#125;for (String str : filterList) &#123; System.out.println(str);&#125;为了筛选集合我们进行了两次外部迭代，并且还创建了一个用来临时存放筛选元素的集合对象。借助Java 8中的Stream我们可以极大的简化这个处理过程：12345List&lt;String&gt; list = Arrays.asList("Java", "JavaScript", "python", "PHP", "C#", "Golang", "Swift");list.stream() .filter(s -&gt; s.startsWith("J")) .map(String::toUpperCase) .forEach(System.out::println);是不是很方便？上面的例子中，集合使用stream方法创建了一个流，然后使用filter和map方法来处理这个集合，它们统称为中间操作。中间操作都会返回另一个流，以便于将各种对集合的操作连接起来形成一条流水线。最后我们使用了forEach方法迭代筛选结果，这种位于流的末端，对流进行处理并且生成结果的方法称为终端操作。总而言之，流的使用一般包括三件事情：一个数据源（如集合）来执行一个查询；一个中间操作链，形成一条流的流水线；一个终端操作，执行流水线，并能生成结果。下表列出了流中常见的中间操作和终端操作：操作类型返回类型使用的类型/函数式接口函数描述符filter中间Stream&lt;T&gt;Predicate&lt;T&gt;T -&gt; booleandistinct中间Stream&lt;T&gt;skip中间Stream&lt;T&gt;longlimit中间Stream&lt;T&gt;longmap中间Stream&lt;R&gt;Function&lt;T, R&gt;T -&gt; RflatMap中间Stream&lt;R&gt;Function&lt;T, Stream&lt;R&gt;&gt;T -&gt; Stream&lt;R&gt;sorted中间Stream&lt;T&gt;Comparator&lt;T&gt;(T, T) -&gt; intanyMatch终端booleanPredicate&lt;T&gt;T -&gt; booleannoneMatch终端booleanPredicate&lt;T&gt;T -&gt; booleanallMatch终端booleanPredicate&lt;T&gt;T -&gt; booleanfindAny终端Optional&lt;T&gt;findFirst终端Optional&lt;T&gt;forEach终端voidConsumer&lt;T&gt;T -&gt; voidcollect终端RCollector&lt;T, A, R&gt;reduce终端Optional&lt;T&gt;BinaryOperator&lt;T&gt;(T, T) -&gt; Tcount终端long下面详细介绍这些操作的使用。除了特殊说明，默认使用下面这个集合作为演示：1List&lt;String&gt; list = Arrays.asList("Java", "JavaScript", "python", "PHP", "C#", "Golang", "Swift", "C++", "Ruby");中间操作filterStreams接口支持·filter方法，该方法接收一个Predicate&lt;T&gt;，函数描述符为T -&gt; boolean，用于对集合进行筛选，返回所有满足的元素：123list.stream() .filter(s -&gt; s.contains("#")) .forEach(System.out::println);结果输出C#。distinctdistinct方法用于排除流中重复的元素，类似于SQL中的distinct操作。比如筛选中集合中所有的偶数，并排除重复的结果：12345List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);numbers.stream() .filter(i -&gt; i % 2 == 0) .distinct() .forEach(System.out::println);结果输出2 4。skipskip(n)方法用于跳过流中的前n个元素，如果集合元素小于n，则返回空流。比如筛选出以J开头的元素，并排除第一个：1234list.stream() .filter(s -&gt; s.startsWith("J")) .skip(1) .forEach(System.out::println);结果输出JavaScript。limitlimit(n)方法返回一个长度不超过n的流，比如下面的例子将输出Java JavaScript python：123list.stream() .limit(3) .forEach(System.out::println);mapmap方法接收一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。如：123list.stream() .map(String::length) .forEach(System.out::println);结果输出4 10 6 3 2 6 5 3 4。map还支持将流特化为指定原始类型的流，如通过mapToInt，mapToDouble和mapToLong方法，可以将流转换为IntStream，DoubleStream和LongStream。特化后的流支持sum，min和max方法来对流中的元素进行计算。比如：123List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);IntStream intStream = numbers.stream().mapToInt(a -&gt; a);System.out.println(intStream.sum()); // 16也可以通过下面的方法，将IntStream转换为Stream：1Stream&lt;Integer&gt; s = intStream.boxed();flatMapflatMap用于将多个流合并成一个流，俗称流的扁平化。这么说有点抽象，举个例子，比如现在需要将list中的各个元素拆分为一个个字母，并过滤掉重复的结果，你可能会这样做：1234list.stream() .map(s -&gt; s.split("")) .distinct() .forEach(System.out::println);输出如下：123456789[Ljava.lang.String;@e9e54c2[Ljava.lang.String;@65ab7765[Ljava.lang.String;@1b28cdfa[Ljava.lang.String;@eed1f14[Ljava.lang.String;@7229724f[Ljava.lang.String;@4c873330[Ljava.lang.String;@119d7047[Ljava.lang.String;@776ec8df[Ljava.lang.String;@4eec7777这明显不符合我们的预期。实际上在map(s -&gt; s.split(&quot;&quot;))操作后，返回了一个Stream&lt;String[]&gt;类型的流，所以输出结果为每个数组对象的句柄，而我们真正想要的结果是Stream&lt;String&gt;！在Stream中，可以使用Arrays.stream()方法来将数组转换为流，改造上面的方法：12345list.stream() .map(s -&gt; s.split("")) .map(Arrays::stream) .distinct() .forEach(System.out::println);输出如下：123456789java.util.stream.ReferencePipeline$Head@eed1f14java.util.stream.ReferencePipeline$Head@7229724fjava.util.stream.ReferencePipeline$Head@4c873330java.util.stream.ReferencePipeline$Head@119d7047java.util.stream.ReferencePipeline$Head@776ec8dfjava.util.stream.ReferencePipeline$Head@4eec7777java.util.stream.ReferencePipeline$Head@3b07d329java.util.stream.ReferencePipeline$Head@41629346java.util.stream.ReferencePipeline$Head@404b9385因为上面的流经过map(Arrays::stream)处理后，将每个数组变成了一个新的流，返回结果为流的数组Stream&lt;String&gt;[]，所以输出是各个流的句柄。我们还需将这些新的流连接成一个流，使用flatMap来改写上面的例子：12345list.stream() .map(s -&gt; s.split("")) .flatMap(Arrays::stream) .distinct() .forEach(s -&gt; System.out.print(s + " "));输出如下：1J a v S c r i p t y h o n P H C # G l g w f + R u b和map类似，flatMap方法也有相应的原始类型特化方法，如flatMapToInt等。终端操作anyMatchanyMatch方法用于判断流中是否有符合判断条件的元素，返回值为boolean类型。比如判断list中是否含有SQL元素：12list.stream() .anyMatch(s -&gt; "SQL".equals(s)); // falseallMatchallMatch方法用于判断流中是否所有元素都满足给定的判断条件，返回值为boolean类型。比如判断list中是否所有元素长度都不大于10：12list.stream() .allMatch(s -&gt; s.length() &lt;= 10); // truenoneMatchnoneMatch方法用于判断流中是否所有元素都不满足给定的判断条件，返回值为boolean类型。比如判断list中不存在长度大于10的元素：12list.stream() .noneMatch(s -&gt; s.length() &gt; 10); // truefindAnyfindAny方法用于返回流中的任意元素的Optional类型，例如筛选出list中任意一个以J开头的元素，如果存在，则输出它：1234list.stream() .filter(s -&gt; s.startsWith("J")) .findAny() .ifPresent(System.out::println); // JavafindFirstfindFirst方法用于返回流中的第一个元素的Optional类型，例如筛选出list中长度大于5的元素，如果存在，则输出第一个：1234list.stream() .filter(s -&gt; s.length() &gt; 5) .findFirst() .ifPresent(System.out::println); // JavaScriptreducereduce函数从字面上来看就是压缩，缩减的意思，它可以用于数字类型的流的求和，求最大值和最小值。如对numbers中的元素求和：123List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);numbers.stream() .reduce(0, Integer::sum); // 16reduce函数也可以不指定初始值，但这时候将返回一个Optional对象，比如求最大值和最小值：1234567numbers.stream() .reduce(Integer::max) .ifPresent(System.out::println); // 4numbers.stream() .reduce(Integer::min) .ifPresent(System.out::println); // 1forEachforEach用于迭代流中的每个元素，最为常见的就是迭代输出，如：1list.stream().forEach(System.out::println);countcount方法用于统计流中元素的个数，比如：1list.stream().count(); // 9collectcollect方法用于收集流中的元素，并放到不同类型的结果中，比如List、Set或者Map。举个例子：12List&lt;String&gt; filterList = list.stream() .filter(s -&gt; s.startsWith("J")).collect(Collectors.toList());如果需要以Set来替代List，只需要使用Collectors.toSet()就好了。流的构建除了使用集合对象的stream方法构建流之外，我们可以手动构建一些流。数值范围构建IntStream和LongStream对象支持range和rangeClosed方法来构建数值流。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。比如对1到100的整数求和：1IntStream.rangeClosed(1, 100).sum(); // 5050由值构建静态方法Stream.of可以显式值创建一个流。它可以接受任意数量的参数。例如，以下代码直接使用Stream.of创建了一个字符串流:1Stream&lt;String&gt; s = Stream.of("Java", "JavaScript", "C++", "Ruby");也可以使用Stream.empty()构建一个空流：1Stream&lt;Object&gt; emptyStream = Stream.empty();由数组构建静态方法Arrays.stream可以通过数组创建一个流。它接受一个数组作为参数。例如：12int[] arr = &#123;1, 2, 3, 4, 5&#125;;IntStream intStream = Arrays.stream(arr);由文件生成流java.nio.file.Files中的很多静态方法都会返回一个流。例如Files.lines方法会返回一个由指定文件中的各行构成的字符串流。比如统计一个文件中共有多少个字：123456long wordCout = 0L;try (Stream&lt;String&gt; lines = Files.lines(Paths.get("file.txt"), Charset.defaultCharset())) &#123; wordCout = lines.map(l -&gt; l.split("")) .flatMap(Arrays::stream) .count();&#125; catch (Exception ignore) &#123;&#125;由函数构造Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的无限流。比如下面的例子构建了10个偶数：12Stream.iterate(0, n -&gt; n + 2) .limit(10).forEach(System.out::println);iterate方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator类型）。这里，我们使用Lambda n -&gt; n + 2，返回的是前一个元 素加上2。因此，iterate方法生成了一个所有正偶数的流：流的第一个元素是初始值0。然后加上2来生成新的值2，再加上2来得到新的值4，以此类推。与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次对每个新生成的值应用函数，比如下面的例子生成了5个0到1之间的随机双精度数：123Stream.generate(Math::random) .limit(5) .forEach(System.out::println);输出结果如下：123450.63346468505878630.41901476418340090.43619683945154750.69117964568386550.08156838267267075《Java 8实战》读书笔记]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RHEL离线安装Ruby和RubyGems]]></title>
    <url>%2FRHELinstallRuby%26RubyGems.html</url>
    <content type="text"><![CDATA[搭建Redis集群过程中需要安装Ruby环境，这里记录下在RHEL下离线安装Ruby和RubyGems的方法。Ruby的在线下载地址为https://www.ruby-lang.org/en/downloads/，下载好后上传到/usr/loacl目录下。如果之前已经安装过低版本的Ruby的话可以先使用下面的命令卸载:1sudo yum remove ruby ruby-devel这里我们下载的Ruby版本为2.5.1，解压ruby-2.5.1.tar.gz：1tar -zxvf ruby-2.5.1.tar.gz接着使用以下命令安装：1234cd /usr/local/ruby-2.5.1./configuremakesudo make install安装好后查看Ruby的版本：1ruby -v如果提示-bash: /usr/local/bin/ruby: 没有那个文件或目录的话，可以将Ruby目录下的ruby文件拷贝到/usr/local/bin目录下：123cp /usr/local/ruby-2.5.1/ruby /usr/local/bin/ruby -vruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux]安装好Ruby后，我们接着安装RubyGems。RubyGems是Ruby的一个包管理器，它提供一个分发Ruby程序和库的标准格式，还提供一个管理程序包安装的工具。RubyGems旨在方便地管理gem安装的工具，以及用于分发gem的服务器。这类似于Ubuntu下的apt-get，Centos 的yum，Python的pip。RubyGems的下载地址为：https://rubygems.org/pages/download，这里我们下载的版本为2.7.7。下载好后，上传到/usr/local目录下，然后解压：1tar -zxvf rubygems-2.7.7.tgz接着切换到解压后的目录，执行以下命令安装：1ruby setup.rb安装好后，查看RubyGems版本：12gem -v2.7.7安装结束。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下搭建Redis集群]]></title>
    <url>%2Flinux-redis-cluster.html</url>
    <content type="text"><![CDATA[通过Redis的集群，我们可以实现多个Redis节点之间的数据共享，并且支持自动分割数据到不同的节点上。在集群过程中通过主从的分配可以提高Redis的可用性，不会因为某个节点宕掉或者不可达而导致整个集群网络的不可用。Redis 3.0版本后支持使用Redis-Cluster来搭建集群，本文将介绍在Ubuntu 16.04下从零开始搭建Redis集群。因为Redis集群中至少应该有奇数个主节点，所以本文将创建6个Redis节点，其中3个为主节点，3个为从属节点，用于从主节点拉取数据进行备份。安装Redis从https://redis.io/download上获取最新的Stable版本Redis，下载到/usr/local/目录下并解压：12wget http://download.redis.io/releases/redis-4.0.9.tar.gztar -zxvf redis-4.0.9.tar.gz进行编译和安装：12cd redis-4.0.9/make &amp;&amp; make install安装成功后开始进行集群搭建。搭建集群编译安装后，在Reids的src目录下有个redis-trib.rb文件，将其复制到/usr/local/bin/目录下，方便后期搭建集群使用： 接下来开始创建节点。在redis目录下创建一个cluster目录：1mkdir cluster然后在该目录下创建六个目录，分别命名为7000、7001、7002、7003、7004和7005：12cd cluster/mkdir 7000 7001 7002 7003 7004 7005在7000目录下创建一个Redis配置文件redis.conf，内容如下：12345678port 7000bind 172.16.0.4daemonize yespidfile /var/run/redis_7000.pidcluster-enabled yescluster-config-file nodes_7000.confcluster-node-timeout 15000appendonly yes上述配置是开启Redis集群的最简配置，各项配置的含义如下：port 7000：Redis节点的端口号为7000；bind 172.16.0.4：绑定本机的IP地址；daemonize yes：以后台服务的形式开启Redis；pidfile /var/run/redis_7000.pid：以该配置启动Redis后将在/var/run/目录下创建一个redis_port.pid文件；cluster-enabled yes：是否开启集群，yes；cluster-config-file nodes_7000.conf：集群配置文件，启动后自动生成，文件名称为nodes_7000.conf。该文件将保持集群配置信息，以保证重启该Redis节点后能够保持集群状态；cluster-node-timeout 15000：请求超时时间，默认为15秒；appendonly yes：是否开启aof日志，开启后每次写操作都记录一条日志。剩下的7001~7005的配置文件除了端口号改为相应的外，其他配置保持一致。配置好7000~7005端口的Redis配置文件后，启动这些节点：123456redis-server cluster/7000/redis.confredis-server cluster/7001/redis.confredis-server cluster/7002/redis.confredis-server cluster/7003/redis.confredis-server cluster/7004/redis.confredis-server cluster/7005/redis.conf查看是否启动成功：现在我们已经有了6个正在运行中的Redis实例，接下来我们需要使用这些实例来创建集群。接着使用redis-trib.rb创建集群，该文件使用ruby编写，所以使用redis-trib.rb之前得先安装ruby：12apt-get install rubygem install redis安装好ruby后，输入以下命令开启集群：1redis-trib.rb create --replicas 1 172.16.0.4:7000 172.16.0.4:7001 172.16.0.4:7002 172.16.0.4:7003 172.16.0.4:7004 172.16.0.4:7005选项--replicas 1表示我们希望为集群中的每个主节点创建一个从节点，之后跟着的其他参数则是这个集群实例的地址列表：3个主节点（Master，即7000~7002）3个从节点（Slave，即7003~7005）。输入该命令后，终端打印出如下配置：其中M开头的节点为主节点，S开头的为从节点。从从节点的replicates（复制的意思）信息可以看出7000的从节点为7004，7001的从节点为7005，7002的从节点为7003。确认无误后输入yes点击回车继续：可看到7000节点的拥有5461个哈希槽（0 - 6460 slots），7001节点拥有5462个哈希槽（5461 - 10922 slots），7002节点拥有5461个哈希槽（10923 - 16383 slots），而从属节点并没有分配哈希槽。从最后一行的输出信息可以看出，Redis集群总共有16384个哈希槽（slots）。此外，那些一大串的字符称为节点ID。集群测试通过上面的集群配置，这6个Redis节点之间的关系可以用下图表示：颜色深的节点为颜色浅的节点的主节点，所有节点彼此之间互联（ping-pong）。下面对这些集群节点进行一些测试。测试存取使用客户端连接集群后的Redis节点需要带上-c标识，比如现在我们连接端口为7003的从节点：1redis-cli -h 172.16.0.4 -c -p 7003使用set命令往Redis存入一些key-vaue，结果如下图所示：可发现，存值的操作并不是在7003节点完成的，存值的过程只在主节点下完成，并且每次set操作Redis都会输出Redirected to slot [xxxx] located at的提示。Redis集群有16384个哈希槽，每次set key时，Redis内部通过CRC16校验后对16384取模来决定放置哪个哈希槽。正如上面所说的，集群的每个主节点负责一部分哈希槽。比如第一条命令set a 1计算出来的哈希码为15495，介于11001到16384之间，所以便存储在了7002节点中。上面我们提到7000节点的从节点为7004，下面来验证一下：可看到它们存储的key是相同的。尝试从7004节点删除key：发现7000节点的b也被删除。接下来从7000节点获取a的值（a存储在7002节点中）：可看到Redis自己redirected到了7002节点获取a的值，这就是集群的特点，每个节点都是平等的，可以相互间取值。测试主从开头说过，在集群过程中可以通过主从的分配来提高Redis的可用性。比如这个例子，集群有7000、7001和7002 3个主节点，如果这3个节点都没有从节点，假设7001宕机了，那么整个集群就会因为缺少5501-11000这个范围的哈希槽而变得不可用。所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像上面的例子那样，集群包含主节点7000、7001和7002以及从节点7003、7004和7005, 那么即使7001宕系统也可以继续正常工作。当7001这个主节点宕机后，Redis集群将会选择7001的从节点7005作为新的主节点以确保集群正常的工作。当重新启动7001后，其自动变为了7005的从节点，角色完成了转换。为了验证这个理论，下面将7001节点杀死，然后观察：可看到7005已经晋升为了主节点。接着测试从7000节点获取c的值（c存储在7001节点中，7005之前为7001的从节点，所以也存有这个值）：Redis自动redirected到了7005，并成功获取到了c的值。现在重新启动7001节点，然后观察：7001已经成为了7005的从节点了。值得注意的是，假如7005和7001同时宕机，那么集群将不可用。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Redis</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8实战】Lambda表达式（二）]]></title>
    <url>%2Fjava8lambda2.html</url>
    <content type="text"><![CDATA[在上一节中，我们为了使用Lambda表达式不得不创建了各种函数描述符的函数式接口，其实Java 8已经给我们提供了一套能够描述常见函数描述符的函数式接口。比如Predicate&lt;T&gt;、Consumer&lt;T&gt;、Function&lt;T,R&gt;、Supplier&lt;T&gt;等，这些函数式接口位于java.util.function包。这一节主要记录这些函数式接口的应用。Java8中的函数式接口下表列出了Java8中常见的函数式接口：函数式接口函数描述符原始类型特化PredicateT-&gt;booleanIntPredicate,LongPredicate, DoublePredicateConsumerT-&gt;voidIntConsumer,LongConsumer, DoubleConsumerFunction&lt;T,R&gt;T-&gt;RIntFunction, IntToDoubleFunction, IntToLongFunction,LongFunction, LongToDoubleFunction, LongToIntFunction,DoubleFunction, ToIntFunction, ToDoubleFunction, ToLongFunctionSupplier()-&gt;TBooleanSupplier,IntSupplier, LongSupplier,DoubleSupplierUnaryOperatorT-&gt;TIntUnaryOperator, LongUnaryOperator, DoubleUnaryOperatorBinaryOperator(T,T)-&gt;TIntBinaryOperator, LongBinaryOperator, DoubleBinaryOperatorBiPredicate&lt;L,R&gt;(L,R)-&gt;booleanBiConsumer&lt;T,U&gt;(T,U)-&gt;voidObjIntConsumer, ObjLongConsumer, ObjDoubleConsumerBiFunction&lt;T,U,R&gt;(T,U)-&gt;RToIntBiFunction&lt;T,U&gt;, ToLongBiFunction&lt;T,U&gt;, ToDoubleBiFunction&lt;T,U&gt;Predicatepredicate: 英 [ˈpredɪkət] 美 [ˈpredɪkət] 断言，断定的意思。从接口的名称就可以推断出这个函数式接口的主要作用就是用于判断作用，Predicate源码如下所示：123456789101112131415161718192021@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t); default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;&#125;可看到java.util.function.Predicate&lt;T&gt;接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean，函数描述符为(T) -&gt; boolean举几个例子：1234567// 偶数判断Predicate&lt;Integer&gt; isEven = (in) -&gt; in % 2 == 0;isEven.test(17); // false// 判断字符串的长度是否为0Predicate&lt;String&gt; isEmptyString = String::isEmpty;isEmptyString.test(""); // true除了抽象方法外，java.util.function.Predicate&lt;T&gt;接口还定义了三个默认方法：and，negate和or，对应“与”，“非”和“或”操作，这样我们便可以复合Lambda表达式了，比如：12345678// 判断是偶数，并且大于30Predicate&lt;Integer&gt; isEven = (in) -&gt; in % 2 == 0;isEven.and((in) -&gt; in &gt; 30).test(40); // true// 奇数判断Predicate&lt;Integer&gt; isEven = (in) -&gt; in % 2 == 0;Predicate&lt;Integer&gt; isOdd = isEven.negate();isOdd.test(17); // trueConsumer英 [kənˈsju:mə(r)] 美 [kənˈsu:mə(r)] n.消费者。该函数式接口用于消费一个对象，即接收一个对象，对其执行某些操作，然后没有返回值。Consumer源码如下所示：12345678@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;; &#125;&#125;可看到java.util.function.Consumer&lt;T&gt;定义了一个名叫accept的抽象方法，它接受泛型T的对象，没有返回(void)，函数描述符为(T) -&gt; void。其还提供了一个默认方法andThen。举个例子：1234Consumer&lt;Apple&gt; printAppleColor = (a)-&gt; System.out.println(a.getColor());printAppleColor.accept(new Apple("red",17)); // redprintAppleColor.andThen((a) -&gt; System.out.println(a.getWeight())).accept(new Apple("red", 17)); // red 17.0Suppliersupplier 英 [səˈplaɪə(r)] 美 [səˈplaɪər] n.供应商;供应者;供给者。其源码如下：1234@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; T get();&#125;可看到java.util.function.Supplier&lt;T&gt;定义了一个名叫get的抽象方法，它不接收参数，返回泛型T的对象，函数描述符为() -&gt; T。举个例子：12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new PersonFunctionsFunctions源码如下：123456789101112131415161718@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t); default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125;java.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象，函数描述符为(T) -&gt; R。举个例子：1234Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123; return a.getWeight();&#125;;getAppleWeight.apply(new Apple(17)); // 17.0Functions接口还提供了两个抽象方法compose和andThen，从源码可以看出两者的根本区别。举个compose例子：123Function&lt;Integer, Integer&gt; f = (x) -&gt; x + 1;Function&lt;Integer, Integer&gt; g = (x) -&gt; x * 2;f.compose(g).apply(2); // 5过程为：f(g(2))，也就是1+(2*2)。举个andThen的例子：123Function&lt;Integer, Integer&gt; f = (x) -&gt; x + 1;Function&lt;Integer, Integer&gt; g = (x) -&gt; x * 2;f.andThen(g).apply(2); // 6过程为：g(f(2))，也就是(2+1)*2。原始类型特化在学习Function接口的时候，我们定义了f函数：1Function&lt;Integer, Integer&gt; f = (x) -&gt; x + 1;x的类型为Integer类型，1为int类型，返回值为Integer类型，整个过程实际上为Integer.valueOf(x.intValue() + 1)。虽然编译器可以自动帮我们完成拆装箱，但这会造成不必要的性能消耗。考虑到了这一点，Java8为我们提供了int类型的Function接口：IntFunction:1234@FunctionalInterfacepublic interface IntFunction&lt;R&gt; &#123; R apply(int value);&#125;所以f最好重构为：1IntFunction&lt;Integer&gt; f = (x) -&gt; x + 1;剩余的原始类型特化函数式接口可参考上面的表格。Java8中增强的Comparator在Java8之前，Comparator接口用于实现简单的比较排序算法。比如有如下List：123456List&lt;Double&gt; list = new ArrayList&lt;&gt;();list.add(12.3);list.add(100.2);list.add(3.14);list.add(27.7);list.add(-9.8);使用Comparator接口对其从小到大排序：123456Collections.sort(list, new Comparator&lt;Double&gt;() &#123; @Override public int compare(Double o1, Double o2) &#123; return o1.compareTo(o2); &#125;&#125;);Comparator接口也是一个函数式接口，函数描述符为(T,T) -&gt; int，Java8中可以使用Lambda改造上面的排序方法：1Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));Java8对List提供了sort方法，可以替代Collections.sort，所以上面的代码可以简化为：1list.sort((o1, o2) -&gt; o1.compareTo(o2));使用方法的引用来进一步简化：1list.sort(Double::compareTo);Java8对Comparator进行了增强，加入了一些实用的默认方法，比如对排序结果反转：12Comparator&lt;Double&gt; comparator = Double::compareTo;list.sort(comparator.reversed());更多方法可以参考Comparator接口的JavaDoc。查看Comparator的时候发现其虽然是函数式接口，但是却包含了compare和equals这两个抽象方法，顿时有点懵逼，函数式接口不是只能有一个抽象方法么？查找资料后发现：函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和Object的public方法一样，接口最终有确定的类实现，而类的最终父类是Object。因此函数式接口可以定义Object的public方法。《Java 8实战》读书笔记]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java8实战】Lambda表达式（一）]]></title>
    <url>%2Fjava8lambda1.html</url>
    <content type="text"><![CDATA[Java 8的Lambda表达式借鉴了C#和Scala等语言中的类似特性，简化了匿名函数的表达方式。Lambda表达式可以直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。什么是函数式接口？简单来说就是只包含一个抽象方法的接口，允许有默认的实现（使用default关键字描述方法）。函数式接口建议使用@FunctionalInterface注解标注，虽然这不是必须的，但是这样做更符合规范。在Java 8之前，实现Runnable常用方式是编写一个匿名类：1234567Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("hello"); &#125;&#125;);thread.start();使用Lambda表达式后，上面的代码可以改造为：12Thread thread = new Thread(() -&gt; System.out.println("hello"));thread.start();是不是很神奇？！很简洁？！Lambda表达式解析Lambda表达式的基本语法如下：123(parameters) -&gt; expression or(parameters) -&gt; &#123; statements; &#125;由语法可以看到，Lambda表达式包含了三个部分：参数列表；箭头-&gt;把参数列表与Lambda主体分隔开；Lambda主体，只有一行代码的时候可以省略大括号和return关键字。比如下面这些Lambda表达式都是合法的：123456789101112(String str) -&gt; str.length()(String str) -&gt; &#123; return str.length(); &#125;() -&gt; System.out.println("hello")() -&gt; &#123;&#125;() -&gt; 17(int x, int y) -&gt; &#123; System.out.println(x); System.out.println(y);&#125;Lambda的使用场合什么时候可以使用Lambda表达式？使用Lambda必须满足以下两个条件：实现的对象是函数式接口的抽象方法；函数式接口的抽象方法的函数描述符和Lambda表达式的函数描述符一致。函数式接口函数式接口的定义开头已经说了，这里就不再赘述。在Java 8之前，常见的函数式接口有java.util.Comparator，java.lang.Runnable等。拿java.util.Runnable来说，查看其源码如下：1234@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;这个接口只有一个抽象方法，并且使用@FunctionalInterface注解标注。接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。函数描述符函数描述符其实也可以理解为方法的签名。比如上述的Runnable抽象方法不接受参数，并且返回void，所以其函数描述符为() -&gt; void。而() -&gt; System.out.println(&quot;hello&quot;)Lambda表达式也是不接受参数，并且返回void，即其函数描述符也是() -&gt; void。所以代码Runnable r = () -&gt; System.out.println(&quot;hello&quot;);是合法的。特殊的void兼容规则如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下Lambda是合法的，尽管List的add方法返回了一个 boolean，而不是Runnable抽象方法函数描述符() -&gt; void所要求的void：12List&lt;String&gt; list = new ArrayList&lt;&gt;();Runnable r = () -&gt; list.add(&quot;hello&quot;);更简洁的Lambda编写一个类型转换的函数式接口：1234@FunctionalInterfacepublic interface TransForm&lt;T, R&gt; &#123; R transForm(T t);&#125;编写一个Lambda表达式实现该函数式接口，用于实现String转换为Integer，代码如下：12TransForm&lt;String, Integer&gt; t = (String str) -&gt; Integer.valueOf(str);System.out.println(t.transForm("123"));上面的Lambda表达式可以进一步简化为如下方式：12TransForm&lt;String, Integer&gt; t = (str) -&gt; Integer.valueOf(str);System.out.println(t.transForm("123"));因为Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名。就拿这个例子来说，TransForm的抽象方法transForm在本例中的函数描述符为(String) -&gt; Integer，所以对应的Lambda的签名也是如此，即Lambda的参数即使不声名类型，Java编译器可以知道其参数实际上为String类型。其实，上面的Labmda表达式还不是最简洁的，其还可以更进一步地简化为如下写法：12TransForm&lt;String, Integer&gt; t = Integer::valueOf;System.out.println(t.transForm("123"));你肯定很困惑，这还是Lambda表达式吗，箭头去哪里了？双冒号又是什么鬼？其实这种写法有一个新的名称，叫做方法的引用。方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它，这样代码可读性更好。基本写法就是目标引用放在分隔符::前，方法的名称放在后面。举几个Lambda及其等效方法引用的例子：Lambda表达式等效方法引用(String s) -&gt; System.out.println(s)System.out::println(str, i) -&gt; str.substring(i)String::substring() -&gt; Thread.currentThread().dumpStack()Thread.currentThread()::dumpStack符号::除了出现在方法的引用外，它还常见于构造函数的引用中。为了演示什么是构造函数的引用，我们创建一个新的函数式接口：1234@FunctionalInterfacepublic interface Generator&lt;T, R&gt; &#123; R create(T t);&#125;创建一个Apple类：12345678910111213public class Apple &#123; public Apple(String color) &#123; this.color = color; &#125; private String color; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125;&#125;现在我们可以使用如下方式来创造一个Apple实例：12Generator&lt;String, Apple&gt; g = Apple::new;Apple apple = g.create("red");这种通过ClassName::new的写法就是构造函数的引用。在这里Generator的抽象方法接收一个String类型参数，返回值类型为Apple，这和Apple类的构造函数相符合，所以这里编译可以通过。它等价于下面的写法：12Generator&lt;String, Apple&gt; g = (color) -&gt; new Apple(color);Apple apple = g.create("red");Lambda表达式访问变量Lambda表达式可以访问局部final变量，成员变量和静态变量。这里主要说下局部final变量。有无final关键字不重要，重要的是确保该变量的值不会被改变就行了。比如下面的例子可以编译通过：12String hello = "hello lambda";Runnable r = () -&gt; System.out.println(hello);而下面的这个就会编译出错，因为变量hello的值被改变了：Lambda表达式实战假如现在有如下需求：现有一个包含了各种颜色不同重量的苹果的List，编写一个方法，从中筛选出满足要求的苹果。比如筛选出红色的苹果、红色并且重量大于1kg的苹果、绿色重量小于0.5kg的苹果或者红色大于0.5kg的苹果等等。不使用Lambda在没有接触Lambda之前，我们一般会这样做：定义一个筛选的接口12345import cc.mrbird.java8.domain.Apple;public interface AppleFilter &#123; boolean test(Apple apple);&#125;然后根据筛选的条件来编写各个不同的实现类：筛选出红色苹果的实现方法：12345678import cc.mrbird.java8.domain.Apple;public class RedApple implements AppleFilter &#123; @Override public boolean test(Apple apple) &#123; return "red".equalsIgnoreCase(apple.getColor()); &#125;&#125;筛选出红色并且重量大于1kg的苹果的实现方法：12345678import cc.mrbird.java8.domain.Apple;public class RedAndMoreThan1kgApple implements AppleFilter &#123; @Override public boolean test(Apple apple) &#123; return "red".equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 1.0; &#125;&#125;筛选出绿色重量小于0.5kg的苹果或者红色大于0.5kg的苹果的实现方法：123456789import cc.mrbird.java8.domain.Apple;public class GreenAndLessThan05OrRedAndMoreThan05Apple implements AppleFilter &#123; @Override public boolean test(Apple apple) &#123; return ("green".equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &lt; 0.5) || ("red".equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 0.5); &#125;&#125;筛选苹果的方法：123456789101112131415import cc.mrbird.java8.domain.Apple;import java.util.ArrayList;import java.util.List;public class AppleFilterMethod &#123; public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; list, AppleFilter filter) &#123; List&lt;Apple&gt; filterList = new ArrayList&lt;&gt;(); for (Apple apple : list) &#123; if (filter.test(apple)) &#123; filterList.add(apple); &#125; &#125; return filterList; &#125;&#125;开始筛选苹果：123456789101112List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();appleList.add(new Apple("red", 0.4));appleList.add(new Apple("red", 0.6));appleList.add(new Apple("red", 1.3));appleList.add(new Apple("green", 0.2));appleList.add(new Apple("green", 0.35));appleList.add(new Apple("green", 1.1));List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList, new RedApple());for (Apple apple : appleFilterList) &#123; System.out.println(apple.getColor() + " apple,weight:" + apple.getWeight());&#125;输出：123red apple,weight:0.4red apple,weight:0.6red apple,weight:1.3剩下的略。可以看到，我们为了满足各种筛选条件创造了各种筛选接口的实现类，真正起作用的只有筛选方法中return那一行代码，剩下的都是一些重复的模板代码。使用Java 8中的Lambda可以很好的消除这些模板代码。使用LambdaAppleFilter接口实际上就是一个函数式接口，所以它的各种实现可以用Lambda表达式来替代，而无需真正的去写实现方法。定义筛选接口：12345import cc.mrbird.java8.domain.Apple;public interface AppleFilter &#123; boolean test(Apple apple);&#125;筛选苹果的方法：123456789101112131415import cc.mrbird.java8.domain.Apple;import java.util.ArrayList;import java.util.List;public class AppleFilterMethod &#123; public static List&lt;Apple&gt; filterApple(List&lt;Apple&gt; list, AppleFilter filter) &#123; List&lt;Apple&gt; filterList = new ArrayList&lt;&gt;(); for (Apple apple : list) &#123; if (filter.test(apple)) &#123; filterList.add(apple); &#125; &#125; return filterList; &#125;&#125;接下来便可以开始筛选了：筛选红色的苹果：12345List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList, (apple) -&gt; "red".equalsIgnoreCase(apple.getColor()));for (Apple apple : appleFilterList) &#123; System.out.println(apple.getColor() + " apple,weight:" + apple.getWeight());&#125;输出：123red apple,weight:0.4red apple,weight:0.6red apple,weight:1.3筛选出红色并且重量大于1kg的苹果:12345 List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList, (apple) -&gt; "red".equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 1.0);for (Apple apple : appleFilterList) &#123; System.out.println(apple.getColor() + " apple,weight:" + apple.getWeight());&#125;输出：1red apple,weight:1.3筛选出绿色重量小于0.5kg的苹果或者红色大于0.5kg的苹果:123456List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList, (apple) -&gt; ("green".equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &lt; 0.5) || ("red".equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; 0.5));for (Apple apple : appleFilterList) &#123; System.out.println(apple.getColor() + " apple,weight:" + apple.getWeight());&#125;输出：1234red apple,weight:0.6red apple,weight:1.3green apple,weight:0.2green apple,weight:0.35使用Lambda表达式消除了大量的样板代码，并且可以灵活的构造筛选条件！《Java 8实战》读书笔记]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Spring Cloud与微服务]]></title>
    <url>%2FSpring-Cloud%20and%20MicroService.html</url>
    <content type="text"><![CDATA[在传统的软件架构中，我们通常采用的是单体应用来构建一个系统，一个单体应用糅合了各种业务模块。起初在业务规模不是很大的情况下，对于单体应用的开发维护也相对容易。但随着企业的发展，业务规模与日递增，单体应用变得愈发臃肿。由于单体应用将各种业务模块聚合在一起，并且部署在一个进程内，所以通常我们对其中一个业务模块的修改也必须将整个应用重新打包上线。为了解决单体应用变得庞大脯肿之后产生的难以维护的问题，微服务架构便出现在了大家的视线里。什么是微服务微服务 (Microservices) 是一种软件架构风格，起源于Peter Rodgers博士于 2005 年度云端运算博览会提出的微 Web 服务 (Micro-Web-Service) 。微服务主旨是将一个原本独立的系统 拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于HTTP的RESTful API进行通信协作。下图展示了单体应用和微服务之间的区别：在微服务的架构下，单体应用的各个业务模块被拆分为一个个单独的服务并部署在单独的进程里，每个服务都可以单独的部署和升级。这种去中心化的模式使得后期维护和开发变得更加灵活和方便。由于各个服务单独部署，所以可以使用不同的语句来开发各个业务服务模块。什么是Spring CloudSpring Cloud是一个基千Spring Boot实现的微服务架构开发工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud的诞生并不是为了解决微服务中的某一个问题，而是提供了一套解决微服务架构实施的综合性解决方案。Spring Cloud是一个由各个独立项目组成的综合项目，每个独立项目有着不同的发布节奏，为了管理每个版本的子项目清单，避免Spring Cloud的版本号与其子项目的版本号相混淆，没有采用版本号的方式，而是通过命名的方式。这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序。比如”Angel”是Spring Cloud的第一个发行版名称, “Brixton”是Spring Cloud的第二个发行版名称。当一个版本的Spring Cloud项目的发布内容积累到临界点或者一个严重bug解决可用后，就会发布一个”service releases”版本，简称SRX版本，其中X是一个递增的数字，所以Brixton.SR5就是Brixton的第5个Release版本。截至2018年4月02日，Spring Cloud已经发布了代号为Finchley的快照版本，采用的Spring Boot版本为2.0.1.RELEASE。Spring Cloud的版本和Spring Boot的版本关系可以查看官网给的例子。以下是Spring Cloud版本与各个独立项目版本对应关系表：ComponentEdgware.SR3Finchley.RC1Finchley.BUILD-SNAPSHOTspring-cloud-aws1.2.2.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-bus1.3.2.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-cli1.4.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-commons1.3.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-contract1.2.4.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-config1.4.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-netflix1.4.4.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-security1.2.2.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-cloudfoundry1.1.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-consul1.3.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-sleuth1.3.3.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-streamDitmars.SR3Elmhurst.RELEASEElmhurst.BUILD-SNAPSHOTspring-cloud-zookeeper1.2.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-boot1.5.10.RELEASE2.0.1.RELEASE2.0.0.BUILD-SNAPSHOTspring-cloud-task1.2.2.RELEASE2.0.0.RC12.0.0.RELEASEspring-cloud-vault1.1.0.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-gateway1.0.1.RELEASE2.0.0.RC12.0.0.BUILD-SNAPSHOTspring-cloud-openfeign&nbsp;2.0.0.RC12.0.0.BUILD-SNAPSHOTFinchley使用Spring Boot 2.0.x构建，不建议与Spring Boot 1.5.x一起使用。Dalston和Edgware发行版建立在Spring Boot 1.5.x之上，不建议与Spring Boot 2.0.x一起使用。之后博文的例子将采用Spring Cloud Edgware SR3版本，对应的Spring Boot版本为1.5.13.RELEASE。参考文章http://blog.cuicc.com/blog/2015/07/22/microservices/https://www.ibm.com/developerworks/community/blogs/https://projects.spring.io/spring-cloud/《Spring Cloud微服务实战》]]></content>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Devtools热部署]]></title>
    <url>%2FSpring-Boot-Devtools.html</url>
    <content type="text"><![CDATA[平日里开发项目中，修改了Java代码或者配置文件的时候，必须手动重启项目才能生效。所谓的热部署就是在你修改了后端代码后不需要手动重启，工具会帮你快速的自动重启是修改生效。其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为restart ClassLoader，这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。本文将介绍如何通过使用Spring-Boot-devtools来实现Spring Boot项目的热部署。IDE使用的是Eclipse Oxygen，并且使用Maven构建。引入Devtools搭建一个简单的Spring Boot项目，然后引入Spring-Boot-devtools：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），因为其采用的虚拟机机制，该项重启是很快的。在Eclipse中生效还需要修改spring-boot-maven-plugin插件：1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;并且开启Build Automatically：测试热部署在入口类中添加一个方法，用于热部署测试：12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class DemoApplication &#123; @RequestMapping("/") String index() &#123; return "hello spring boot"; &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;启动项目访问http://localhost:8080/，页面输出hello spring boot。将方法的返回值修改为hello world并在保存的瞬间，应用便重启好了，刷新页面，内容也将得到更改。所有配置下面是所有Devtools在Spring Boot中的可选配置:1234567891011121314151617181920212223242526272829# Whether to enable a livereload.com-compatible server.spring.devtools.livereload.enabled=true # Server port.spring.devtools.livereload.port=35729 # Additional patterns that should be excluded from triggering a full restart.spring.devtools.restart.additional-exclude= # Additional paths to watch for changes.spring.devtools.restart.additional-paths= # Whether to enable automatic restart.spring.devtools.restart.enabled=true# Patterns that should be excluded from triggering a full restart.spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties# Whether to log the condition evaluation delta upon restart.spring.devtools.restart.log-condition-evaluation-delta=true # Amount of time to wait between polling for classpath changes.spring.devtools.restart.poll-interval=1s # Amount of quiet time required without any classpath changes before a restart is triggered.spring.devtools.restart.quiet-period=400ms # Name of a specific file that, when changed, triggers the restart check. If not specified, any classpath file change triggers the restart.spring.devtools.restart.trigger-file=源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/24.Spring-Boot-Devtools参考自： http://412887952-qq-com.iteye.com/blog/2300313]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring Boot Admin监控服务]]></title>
    <url>%2FSpring-Boot-Admin.html</url>
    <content type="text"><![CDATA[在使用Actuator监控Spring Boot应用一节中我们介绍了使用Actuator来监控Spring Boot应用，其提供了许多REST接口来查看应用的信息。但其返回的是大量的JSON格式数据，信息看上去不直观也不易于理解。而Spring Boot Admin（SBA）是一款基于Actuator开发的开源软件：https://github.com/codecentric/spring-boot-admin，以图形化界面的方式展示Spring Boot应用的配置信息、Beans信息、环境属性、线程信息、JVM状况等。本文使用的Spring Boot Admin版本为1.5.7，有能力的朋友可以直接阅读官方文档：http://codecentric.github.io/spring-boot-admin/1.5.7。搭建SBA服务端搭建一个SBA服务端（Server），其他被监控的Spring Boot应用作为客户端（Client），客户端通过HTTP的方式将自己注册到服务端，以供服务端进行监控服务。大致关系如下图所示：引入SBA Server依赖使用http://start.spring.io/开启一个简单的Spring Boot项目，然后引入spring-boot-admin-server相关依赖：12345678910&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server&lt;/artifactId&gt; &lt;version&gt;1.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt; &lt;version&gt;1.5.7&lt;/version&gt;·&lt;/dependency&gt;开启Admin监控在Spring Boot入口类中加入@EnableAutoConfiguration，@EnableAdminServer注解开启监控功能：1234567891011121314import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.autoconfigure.SpringBootApplication;import de.codecentric.boot.admin.config.EnableAdminServer;@SpringBootApplication@EnableAutoConfiguration@EnableAdminServerpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;然后在yml中对项目进行简单的配置：123server: port: 8080 context-path: /admin-server启动项目，访问http://localhost:8080/admin-server：因为还没添加客户端，所以监控列表里是空的，接下来创建一个Spring Boot应用作为客户端。SBA客户端引入SBA Client依赖同样的，使用http://start.spring.io/搭建一个简单的Spring Boot项目作为SBA客户端，然后引入Client依赖：12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;1.5.7&lt;/version&gt;&lt;/dependency&gt;yml配置：1234567891011management: security: enabled: false server: port: 8081 spring: boot: admin: url: http://localhost:8080/admin-serverspring.boot.admin.url配置的是SBA服务端的地址，management.security.enabled: false这里先关闭安全验证。启动客户端后查看http://localhost:8080/admin-server地址：可看到SBA客户端已经被注册到SBA服务端了，接下来便可以在SBA服务端页面上查看各种SBA客户端信息：客户端额外信息默认客户端在服务端监控列表呈现的信息并不多：我们可以在SBA客户端yml里配置更为详细的信息：123456info: app: name: "@project.name@" description: "@project.description@" version: "@project.version@" spring-boot-version: "@project.parent.version@"然后便可以在SBA服务端看到较为详细的客户端信息： 添加邮件预警SBA服务端也可以配置邮件预警服务，默认情况下对于被检测的应用启动或者停止的时候会触发预警。首先添加邮件依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;然后在SBA服务端的yml中配置邮件预警：12345678910111213141516171819spring: mail: host: smtp.163.com username: xxx@163.com password: xxx properties: mail: smtp: auth: true starttls: enable: true required: true boot: admin: notify: mail: from: xxx@163.com to: xxx@qq.com邮件的具体使用方法可参考https://mrbird.cc/Spring-Boot-Email.html。当被检测的应用关停的时候，收到如下邮件：附录SBA Server配置说明Property nameDescriptionDefault value中文说明spring.boot.admin.context-pathThe context-path prefixes the path where the Admin Server’s statics assets and API should be served. Relative to the Dispatcher-Servlet.Admin Server 保留的静态访问和API的前缀（当你在业务应用中使用而不是单独使用时就很有必要了）spring.boot.admin.monitor.periodTime interval in ms to update the status of applications with expired status-informations.10.000更新应用信息的频率，单位毫秒spring.boot.admin.monitor.status-lifetimeLifetime of application statuses in ms. The applications /health-endpoint will not be queried until the lifetime has expired.10.000被监控的应用信息的过期时间，单位毫秒SBA Client配置说明Property nameDescriptionDefault value中文说明spring.boot.admin.client.enabledEnables the Spring Boot Admin Client.true默认开启spring.boot.admin.urlList of URLs of the Spring Boot Admin server to register at. This triggers the AutoConfiguration. Mandatory.admin server 的地址列表，此设置会触发自动配置，必须spring.boot.admin.api-pathHttp-path of registration endpoint at your admin server.“api/applications”注册到 admin server 端点的 Http-pathspring.boot.admin.username spring.boot.admin.passwordUsername and password for http-basic authentication. If set the registration uses http-basic-authentication when registering at the admin server.注册到 admin server 的账号密码spring.boot.admin.periodInterval for repeating the registration (in ms).10.000重试注册的间隔时间spring.boot.admin.auto-registrationIf set to true the periodic task to register the application is automatically scheduled after the application is ready.true应用启动后自动执行周期性的注册任务spring.boot.admin.auto-deregistrationSwitch to enable auto-deregistration at Spring Boot Admin server when context is closed.false当应用关闭时，自动取消注册spring.boot.admin.client.health-urlClient-health-url to register with. Can be overridden in case the reachable URL is different (e.g. Docker). Must be unique in registry.Guessed based on management-url and endpoints.health.id.spring.boot.admin.client.management-urlClient-management-url to register with. Can be overridden in case the reachable url is different (e.g. Docker).Guessed based on service-url, server.servlet-path, management.port and management.context-path.spring.boot.admin.client.service-urlClient-service-url to register with. Can be overridden in case the reachable url is different (e.g. Docker).Guessed based on hostname, server.port and server.context-path.spring.boot.admin.client.nameName to register with.${spring.application.name} if set, “spring-boot-application” otherwise.注册时的名字spring.boot.admin.client.prefer-ipUse the ip-address rather then the hostname in the guessed urls. If server.address / management.address is set, it get used. Otherwise the IP address returned from InetAddress.getLocalHost() gets used.false邮件配置选项Property nameDescriptionDefault value中文说明spring.boot.admin.notify.mail.enabledEnable mail notificationstrue默认启用spring.boot.admin.notify.mail.ignore-changesComma-delimited list of status changes to be ignored. Format: “:”. Wildcards allowed.“UNKNOWN:UP”需要忽略的状态改变通知，逗号分隔spring.boot.admin.notify.mail.toComma-delimited list of mail recipients“root@localhost”接收通知的邮箱地址，逗号分隔spring.boot.admin.notify.mail.ccComma-delimited list of carbon-copy recipients抄送spring.boot.admin.notify.mail.fromMail sender发送人spring.boot.admin.notify.mail.subjectMail subject. SpEL-expressions are supported“#{application.name} (#{application.id}) is #{to.status}”主题spring.boot.admin.notify.mail.textMail body. SpEL-expressions are supported“#{application.name} (#{application.id})\nstatus changed from #{from.status} to #{to.status}\n\n#{application.healthUrl}”内容参考博文：https://blog.csdn.net/kinginblue/article/details/52132113#t26源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/23.Spring-Boot-Admin。]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring Boot发送邮件]]></title>
    <url>%2FSpring-Boot-Email.html</url>
    <content type="text"><![CDATA[在项目的维护过程中，我们通常会在应用中加入短信或者邮件预警功能，比如当应用出现异常宕机时应该及时地将预警信息发送给运维或者开发人员，本文将介绍如何在Spring Boot中发送邮件。在Spring Boot中发送邮件使用的是Spring提供的org.springframework.mail.javamail.JavaMailSender，其提供了许多简单易用的方法，可发送简单的邮件、HTML格式的邮件、带附件的邮件，并且可以创建邮件模板。引入依赖在Spring Boot中发送邮件，需要用到spring-boot-starter-mail，引入spring-boot-starter-mail：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;邮件配置在application.yml中进行简单的配置（以163邮件为例）：123456789101112131415server: port: 80spring: mail: host: smtp.163.com username: 你的账号 password: 你的密码 properties: mail: smtp: auth: true starttls: enable: true required: truespring.mail.username，spring.mail.password填写自己的邮箱账号密码即可。发送简单的邮件编写EmailController，注入JavaMailSender:123456789101112131415161718192021222324252627282930313233import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/email")public class EmailController &#123; @Autowired private JavaMailSender jms; @Value("$&#123;spring.mail.username&#125;") private String from; @RequestMapping("sendSimpleEmail") public String sendSimpleEmail() &#123; try &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo("888888@qq.com"); // 接收地址 message.setSubject("一封简单的邮件"); // 标题 message.setText("使用Spring Boot发送简单邮件。"); // 内容 jms.send(message); return "发送成功"; &#125; catch (Exception e) &#123; e.printStackTrace(); return e.getMessage(); &#125; &#125;&#125;启动项目访问http://localhost/email/sendSimpleEmail，提示发送成功：发送HTML格式的邮件改造EmailController，SimpleMailMessage替换为MimeMessage：12345678910111213141516171819202122232425262728293031323334353637383940import javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/email")public class EmailController &#123; @Autowired private JavaMailSender jms; @Value("$&#123;spring.mail.username&#125;") private String from; @RequestMapping("sendHtmlEmail") public String sendHtmlEmail() &#123; MimeMessage message = null; try &#123; message = jms.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo("888888@qq.com"); // 接收地址 helper.setSubject("一封HTML格式的邮件"); // 标题 // 带HTML格式的内容 StringBuffer sb = new StringBuffer("&lt;p style='color:#6db33f'&gt;使用Spring Boot发送HTML格式邮件。&lt;/p&gt;"); helper.setText(sb.toString(), true); jms.send(message); return "发送成功"; &#125; catch (Exception e) &#123; e.printStackTrace(); return e.getMessage(); &#125; &#125;&#125;helper.setText(sb.toString(), true);中的true表示发送HTML格式邮件。启动项目，访问http://localhost/email/sendHtmlEmail，提示发送成功，可看到文本已经加上了颜色#6db33f：发送带附件的邮件发送带附件的邮件和普通邮件相比，其实就只是多了个传入附件的过程。不过使用的仍是MimeMessage：12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.springboot.demo.controller;import java.io.File;import javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/email")public class EmailController &#123; @Autowired private JavaMailSender jms; @Value("$&#123;spring.mail.username&#125;") private String from; @RequestMapping("sendAttachmentsMail") public String sendAttachmentsMail() &#123; MimeMessage message = null; try &#123; message = jms.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo("888888@qq.com"); // 接收地址 helper.setSubject("一封带附件的邮件"); // 标题 helper.setText("详情参见附件内容！"); // 内容 // 传入附件 FileSystemResource file = new FileSystemResource(new File("src/main/resources/static/file/项目文档.docx")); helper.addAttachment("项目文档.docx", file); jms.send(message); return "发送成功"; &#125; catch (Exception e) &#123; e.printStackTrace(); return e.getMessage(); &#125; &#125;&#125;启动项目访问http://localhost/email/sendAttachmentsMail，提示发送成功：发送带静态资源的邮件发送带静态资源的邮件其实就是在发送HTML邮件的基础上嵌入静态资源（比如图片），嵌入静态资源的过程和传入附件类似，唯一的区别在于需要标识资源的cid：12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.springboot.demo.controller;import java.io.File;import javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/email")public class EmailController &#123; @Autowired private JavaMailSender jms; @Value("$&#123;spring.mail.username&#125;") private String from; @RequestMapping("sendInlineMail") public String sendInlineMail() &#123; MimeMessage message = null; try &#123; message = jms.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo("888888@qq.com"); // 接收地址 helper.setSubject("一封带静态资源的邮件"); // 标题 helper.setText("&lt;html&gt;&lt;body&gt;博客图：&lt;img src='cid:img'/&gt;&lt;/body&gt;&lt;/html&gt;", true); // 内容 // 传入附件 FileSystemResource file = new FileSystemResource(new File("src/main/resources/static/img/sunshine.png")); helper.addInline("img", file); jms.send(message); return "发送成功"; &#125; catch (Exception e) &#123; e.printStackTrace(); return e.getMessage(); &#125; &#125;&#125;helper.addInline(&quot;img&quot;, file);中的img和图片标签里cid后的名称相对应。启动项目访问http://localhost/email/sendInlineMail，提示发送成功：使用模板发送邮件在发送验证码等情况下可以创建一个邮件的模板，唯一的变量为验证码。这个例子中使用的模板解析引擎为Thymeleaf，所以首先引入Thymeleaf依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;在template目录下创建一个emailTemplate.html模板：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;模板&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 您好，您的验证码为&#123;code&#125;，请在两分钟内使用完成操作。&lt;/body&gt;&lt;/html&gt;发送模板邮件，本质上还是发送HTML邮件，只不过多了绑定变量的过程，详细如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.springboot.demo.controller;import java.io.File;import javax.mail.internet.MimeMessage;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;@RestController@RequestMapping("/email")public class EmailController &#123; @Autowired private JavaMailSender jms; @Value("$&#123;spring.mail.username&#125;") private String from; @Autowired private TemplateEngine templateEngine; @RequestMapping("sendTemplateEmail") public String sendTemplateEmail(String code) &#123; MimeMessage message = null; try &#123; message = jms.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo("888888@qq.com"); // 接收地址 helper.setSubject("邮件摸板测试"); // 标题 // 处理邮件模板 Context context = new Context(); context.setVariable("code", code); String template = templateEngine.process("emailTemplate", context); helper.setText(template, true); jms.send(message); return "发送成功"; &#125; catch (Exception e) &#123; e.printStackTrace(); return e.getMessage(); &#125; &#125;&#125;其中code对应模板里的${code}变量。启动项目，访问http://localhost/email/sendTemplateEmail?code=EOS9，页面提示发送成功：源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/22.Spring-Boot-Email]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Actuator监控Spring Boot应用]]></title>
    <url>%2FAcutator-Spring-Boot.html</url>
    <content type="text"><![CDATA[我们都知道Spring Boot是一个用于快速开发Java Web的框架，不需要太多的配置即可使用Spring的大量功能。Spring Boot遵循着“约定大于配置”的原则，许多功能使用默认的配置即可。这样的做法好处在于我们不需要像使用Spring那样编写一大堆的XML配置代码，但过于简单的配置过程会让我们在了解各种依赖，配置之间的关系过程上带来一些困难。不过没关系，在Spring Boot中，我们可以使用Actuator来监控应用，Actuator提供了一系列的RESTful API让我们可以更为细致的了解各种信息。引入Actuator1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;配置Actuator1234567891011server: port: 80management: security: enabled: false #关掉安全认证 port: 80 context-path: /monitor #actuator的访问路径endpoints: shutdown: enabled: true配置中关闭了安全认证的功能，如果需要开启这个功能的话还需引入spring-boot-starter-security依赖。除了使用Spring Security来开启监控路径安全认证外，还可以使用Shiro对监控路径进行权限控制。监控的端口和应用一致，配置context-path为/monitor，这样可以避免和自己应用的路径映射地址重复。endpoints.shutdown.enabled: true提供了使用post请求来关闭Spring Boot应用的功能。Actuator接口列表Actuator提供了13个接口，可以分为三大类：配置接口、度量接口和其它接口，具体如下表所示：HTTP 方法路径描述GET/autoconfig提供了一份自动配置报告，记录哪些自动配置条件通过了，哪些没通过GET/configprops描述配置属性(包含默认值)如何注入BeanGET/beans描述应用程序上下文里全部的Bean，以及它们的关系GET/dump获取线程活动的快照GET/env获取全部环境属性GET/env/{name}根据名称获取特定的环境属性值GET/health报告应用程序的健康指标，这些值由HealthIndicator的实现类提供GET/info获取应用程序的定制信息，这些信息由info打头的属性提供GET/mappings描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系GET/metrics报告各种应用程序度量信息，比如内存用量和HTTP请求计数GET/metrics/{name}报告指定名称的应用程序度量值POST/shutdown关闭应用程序，要求endpoints.shutdown.enabled设置为trueGET/trace提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)接口使用示例autoconfig显示所有自动装配类的报告，以及是什么原因导致自动装配成功或者不成功。在浏览器输入：http://localhost/monitor/autoconfig，输出如下（截取部分）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; "positiveMatches": &#123; "AuditAutoConfiguration#auditListener": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.audit.listener.AbstractAuditListener; SearchStrategy: all) did not find any beans" &#125;], "AuditAutoConfiguration.AuditEventRepositoryConfiguration": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.audit.AuditEventRepository; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#autoConfigurationReportEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnBean (types: org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport; SearchStrategy: all) found bean 'autoConfigurationReport'; @ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.AutoConfigurationReportEndpoint; SearchStrategy: current) did not find any beans" &#125;], "EndpointAutoConfiguration#beansEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.BeansEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#configurationPropertiesReportEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.ConfigurationPropertiesReportEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#dumpEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.DumpEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#environmentEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.EnvironmentEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#healthEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.HealthEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#infoEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.InfoEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#loggersEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnBean (types: org.springframework.boot.logging.LoggingSystem; SearchStrategy: all) found bean 'springBootLoggingSystem'; @ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.LoggersEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#metricsEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.MetricsEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#shutdownEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.ShutdownEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration#traceEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.TraceEndpoint; SearchStrategy: all) did not find any beans" &#125;], "EndpointAutoConfiguration.RequestMappingEndpointConfiguration": [&#123; "condition": "OnClassCondition", "message": "@ConditionalOnClass found required class 'org.springframework.web.servlet.handler.AbstractHandlerMethodMapping'; @ConditionalOnMissingClass did not find unwanted class" &#125;], "EndpointAutoConfiguration.RequestMappingEndpointConfiguration#requestMappingEndpoint": [&#123; "condition": "OnBeanCondition", "message": "@ConditionalOnMissingBean (types: org.springframework.boot.actuate.endpoint.RequestMappingEndpoint; SearchStrategy: all) did not find any beans" &#125;],...&#125;beans查看Spring 容器管理的Bean,访问http://localhost/monitor/beans，输出如下（截取部分）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238[&#123; "context": "application:80", "parent": null, "beans": [&#123; "bean": "demoApplication", "aliases": [], "scope": "singleton", "type": "com.springboot.demo.DemoApplication$$EnhancerBySpringCGLIB$$77e6b2b4", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory", "aliases": [], "scope": "singleton", "type": "org.springframework.core.type.classreading.CachingMetadataReaderFactory", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration$$EnhancerBySpringCGLIB$$dc9af024", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.condition.BeanTypeRegistry", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.condition.BeanTypeRegistry", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "propertySourcesPlaceholderConfigurer", "aliases": [], "scope": "singleton", "type": "org.springframework.context.support.PropertySourcesPlaceholderConfigurer", "resource": "class path resource [org/springframework/boot/autoconfigure/context/PropertyPlaceholderAutoConfiguration.class]", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration$$EnhancerBySpringCGLIB$$a4dba584", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "standardJacksonObjectMapperBuilderCustomizer", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration$StandardJackson2ObjectMapperBuilderCustomizer", "resource": "class path resource [org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration$Jackson2ObjectMapperBuilderCustomizerConfiguration.class]", "dependencies": ["org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@78f30883", "spring.jackson-org.springframework.boot.autoconfigure.jackson.JacksonProperties"] &#125;, &#123; "bean": "spring.jackson-org.springframework.boot.autoconfigure.jackson.JacksonProperties", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.jackson.JacksonProperties", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor", "resource": "null", "dependencies": ["org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.store"] &#125;, &#123; "bean": "org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.store", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.context.properties.ConfigurationBeanFactoryMetaData", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration$$EnhancerBySpringCGLIB$$e9c4bf95", "resource": "null", "dependencies": ["org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@78f30883"] &#125;, &#123; "bean": "jacksonObjectMapperBuilder", "aliases": [], "scope": "singleton", "type": "org.springframework.http.converter.json.Jackson2ObjectMapperBuilder", "resource": "class path resource [org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration$JacksonObjectMapperBuilderConfiguration.class]", "dependencies": ["standardJacksonObjectMapperBuilderCustomizer"] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration$$EnhancerBySpringCGLIB$$3777fd7c", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "jacksonObjectMapper", "aliases": [], "scope": "singleton", "type": "com.fasterxml.jackson.databind.ObjectMapper", "resource": "class path resource [org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration$JacksonObjectMapperConfiguration.class]", "dependencies": ["jacksonObjectMapperBuilder"] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$$EnhancerBySpringCGLIB$$19839b0b", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "jsonComponentModule", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.jackson.JsonComponentModule", "resource": "class path resource [org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.class]", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration$TomcatWebSocketConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration$TomcatWebSocketConfiguration$$EnhancerBySpringCGLIB$$ab6fe14", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "websocketContainerCustomizer", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.websocket.TomcatWebSocketContainerCustomizer", "resource": "class path resource [org/springframework/boot/autoconfigure/websocket/WebSocketAutoConfiguration$TomcatWebSocketConfiguration.class]", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration$$EnhancerBySpringCGLIB$$ee951243", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration$EmbeddedTomcat", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration$EmbeddedTomcat$$EnhancerBySpringCGLIB$$8f67c107", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "tomcatEmbeddedServletContainerFactory", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory", "resource": "class path resource [org/springframework/boot/autoconfigure/web/EmbeddedServletContainerAutoConfiguration$EmbeddedTomcat.class]", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration$$EnhancerBySpringCGLIB$$48514e2b", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "embeddedServletContainerCustomizerBeanPostProcessor", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizerBeanPostProcessor", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "errorPageRegistrarBeanPostProcessor", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.web.servlet.ErrorPageRegistrarBeanPostProcessor", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration$$EnhancerBySpringCGLIB$$824a2d3d", "resource": "null", "dependencies": ["spring.mvc-org.springframework.boot.autoconfigure.web.WebMvcProperties"] &#125;, &#123; "bean": "dispatcherServlet", "aliases": [], "scope": "singleton", "type": "org.springframework.web.servlet.DispatcherServlet", "resource": "class path resource [org/springframework/boot/autoconfigure/web/DispatcherServletAutoConfiguration$DispatcherServletConfiguration.class]", "dependencies": [] &#125;, &#123; "bean": "spring.mvc-org.springframework.boot.autoconfigure.web.WebMvcProperties", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.web.WebMvcProperties", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration$$EnhancerBySpringCGLIB$$fd39bc64", "resource": "null", "dependencies": ["serverProperties", "spring.mvc-org.springframework.boot.autoconfigure.web.WebMvcProperties"] &#125;, &#123; "bean": "dispatcherServletRegistration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.web.servlet.ServletRegistrationBean", "resource": "class path resource [org/springframework/boot/autoconfigure/web/DispatcherServletAutoConfiguration$DispatcherServletRegistrationConfiguration.class]", "dependencies": ["dispatcherServlet"] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$$EnhancerBySpringCGLIB$$d158c03f", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration$$EnhancerBySpringCGLIB$$4ce40e75", "resource": "null", "dependencies": [] &#125;, &#123; "bean": "methodValidationPostProcessor", "aliases": [], "scope": "singleton", "type": "org.springframework.validation.beanvalidation.MethodValidationPostProcessor", "resource": "class path resource [org/springframework/boot/autoconfigure/validation/ValidationAutoConfiguration.class]", "dependencies": ["environment"] &#125;, ...... &#123; "bean": "org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration", "aliases": [], "scope": "singleton", "type": "org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration$$EnhancerBySpringCGLIB$$ec83a29e", "resource": "null", "dependencies": [] &#125;]&#125;]configprops所有＠ConfigurationProperties注解的配置信息，如文件上传的最大允许配置等。访问http://localhost/monitor/configprops，输出如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440&#123; "environmentMvcEndpoint": &#123; "prefix": "endpoints.env", "properties": &#123; "path": "/env" &#125; &#125;, "heapdumpMvcEndpoint": &#123; "prefix": "endpoints.heapdump", "properties": &#123; "enabled": true, "path": "/heapdump", "sensitive": true &#125; &#125;, "managementServerProperties": &#123; "prefix": "management", "properties": &#123; "port": 80, "addApplicationContextHeader": true, "address": null, "contextPath": "/monitor", "ssl": null, "security": &#123; "enabled": false, "roles": ["ACTUATOR"], "sessions": "STATELESS" &#125; &#125; &#125;, "spring.mvc-org.springframework.boot.autoconfigure.web.WebMvcProperties": &#123; "prefix": "spring.mvc", "properties": &#123; "locale": null, "mediaTypes": &#123;&#125;, "localeResolver": "ACCEPT_HEADER", "messageCodesResolverFormat": null, "async": &#123; "requestTimeout": null &#125;, "dispatchOptionsRequest": true, "servlet": &#123; "loadOnStartup": -1 &#125;, "ignoreDefaultModelOnRedirect": true, "dispatchTraceRequest": false, "staticPathPattern": "/**", "dateFormat": null, "view": &#123; "prefix": null, "suffix": null &#125;, "logResolvedException": false, "throwExceptionIfNoHandlerFound": false &#125; &#125;, "spring.http.multipart-org.springframework.boot.autoconfigure.web.MultipartProperties": &#123; "prefix": "spring.http.multipart", "properties": &#123; "enabled": true, "maxRequestSize": "10MB", "location": null, "resolveLazily": false, "fileSizeThreshold": "0", "maxFileSize": "1MB" &#125; &#125;, "spring.http.encoding-org.springframework.boot.autoconfigure.web.HttpEncodingProperties": &#123; "prefix": "spring.http.encoding", "properties": &#123; "charset": "UTF-8", "mapping": null, "force": false, "forceResponse": false, "forceRequest": false &#125; &#125;, "endpoints.health-org.springframework.boot.actuate.autoconfigure.HealthMvcEndpointProperties": &#123; "prefix": "endpoints.health", "properties": &#123; "mapping": &#123;&#125; &#125; &#125;, "spring.resources-org.springframework.boot.autoconfigure.web.ResourceProperties": &#123; "prefix": "spring.resources", "properties": &#123; "staticLocations": ["/", "classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"], "addMappings": true, "chain": &#123; "cache": true, "htmlApplicationCache": false, "gzipped": false, "strategy": &#123; "fixed": &#123; "enabled": false, "paths": ["/**"], "version": null &#125;, "content": &#123; "enabled": false, "paths": ["/**"] &#125; &#125; &#125;, "cachePeriod": null &#125; &#125;, "shutdownMvcEndpoint": &#123; "prefix": "endpoints.shutdown", "properties": &#123; "path": "/shutdown" &#125; &#125;, "requestMappingEndpoint": &#123; "prefix": "endpoints.mappings", "properties": &#123; "id": "mappings", "enabled": true, "sensitive": true &#125; &#125;, "autoConfigurationReportEndpoint": &#123; "prefix": "endpoints.autoconfig", "properties": &#123; "id": "autoconfig", "enabled": true, "sensitive": true &#125; &#125;, "management.trace-org.springframework.boot.actuate.trace.TraceProperties": &#123; "prefix": "management.trace", "properties": &#123; "include": ["TIME_TAKEN", "ERRORS", "REQUEST_HEADERS", "COOKIES", "RESPONSE_HEADERS"] &#125; &#125;, "management.info-org.springframework.boot.actuate.autoconfigure.InfoContributorProperties": &#123; "prefix": "management.info", "properties": &#123; "git": &#123; "mode": "SIMPLE" &#125; &#125; &#125;, "loggersEndpoint": &#123; "prefix": "endpoints.loggers", "properties": &#123; "id": "loggers", "enabled": true, "sensitive": true &#125; &#125;, "spring.jackson-org.springframework.boot.autoconfigure.jackson.JacksonProperties": &#123; "prefix": "spring.jackson", "properties": &#123; "deserialization": &#123;&#125;, "defaultPropertyInclusion": null, "propertyNamingStrategy": null, "locale": null, "serialization": &#123;&#125;, "jodaDateTimeFormat": null, "mapper": &#123;&#125;, "generator": &#123;&#125;, "timeZone": null, "dateFormat": null, "parser": &#123;&#125; &#125; &#125;, "shutdownEndpoint": &#123; "prefix": "endpoints.shutdown", "properties": &#123; "id": "shutdown", "enabled": true, "sensitive": true &#125; &#125;, "endpoints.metrics.filter-org.springframework.boot.actuate.autoconfigure.MetricFilterProperties": &#123; "prefix": "endpoints.metrics.filter", "properties": &#123; "counterSubmissions": ["MERGED"], "gaugeSubmissions": ["MERGED"] &#125; &#125;, "loggersMvcEndpoint": &#123; "prefix": "endpoints.loggers", "properties": &#123; "path": "/loggers" &#125; &#125;, "dumpEndpoint": &#123; "prefix": "endpoints.dump", "properties": &#123; "id": "dump", "enabled": true, "sensitive": true &#125; &#125;, "endpoints-org.springframework.boot.actuate.endpoint.EndpointProperties": &#123; "prefix": "endpoints", "properties": &#123; "enabled": true, "sensitive": null &#125; &#125;, "metricsMvcEndpoint": &#123; "prefix": "endpoints.metrics", "properties": &#123; "path": "/metrics" &#125; &#125;, "metricsEndpoint": &#123; "prefix": "endpoints.metrics", "properties": &#123; "id": "metrics", "enabled": true, "sensitive": true &#125; &#125;, "healthEndpoint": &#123; "prefix": "endpoints.health", "properties": &#123; "id": "health", "enabled": true, "timeToLive": 1000, "sensitive": false &#125; &#125;, "auditEventMvcEndpoint": &#123; "prefix": "endpoints.auditevents", "properties": &#123; "enabled": true, "path": "/auditevents", "sensitive": true &#125; &#125;, "healthMvcEndpoint": &#123; "prefix": "endpoints.health", "properties": &#123; "path": "/health" &#125; &#125;, "endpoints.cors-org.springframework.boot.actuate.autoconfigure.EndpointCorsProperties": &#123; "prefix": "endpoints.cors", "properties": &#123; "maxAge": 1800, "exposedHeaders": [], "allowedHeaders": [], "allowedOrigins": [], "allowedMethods": [], "allowCredentials": null &#125; &#125;, "diskSpaceHealthIndicatorProperties": &#123; "prefix": "management.health.diskspace", "properties": &#123; "path": "C:\\Users\\Administrator\\Desktop\\01.Start-Spring-Boot\\.", "threshold": 10485760 &#125; &#125;, "beansEndpoint": &#123; "prefix": "endpoints.beans", "properties": &#123; "id": "beans", "enabled": true, "sensitive": true &#125; &#125;, "traceEndpoint": &#123; "prefix": "endpoints.trace", "properties": &#123; "id": "trace", "enabled": true, "sensitive": true &#125; &#125;, "auditEventsEndpoint": &#123; "prefix": "endpoints.auditevents", "properties": &#123; "enabled": true &#125; &#125;, "endpoints.jmx-org.springframework.boot.actuate.autoconfigure.EndpointMBeanExportProperties": &#123; "prefix": "endpoints.jmx", "properties": &#123; "enabled": true, "uniqueNames": false, "domain": "", "staticNames": &#123;&#125; &#125; &#125;, "spring.metrics.export-org.springframework.boot.actuate.metrics.export.MetricExportProperties": &#123; "prefix": "spring.metrics.export", "properties": &#123; "enabled": true, "redis": &#123; "prefix": "spring.metrics.application.7f8f2ef33a0f173c075f96c8f5c5b4fd", "key": "******" &#125;, "aggregate": &#123; "prefix": "application.7f8f2ef33a0f173c075f96c8f5c5b4fd", "keyPattern": "k.d" &#125;, "excludes": null, "statsd": &#123; "host": null, "port": 8125, "prefix": null &#125;, "triggers": &#123;&#125;, "includes": null &#125; &#125;, "configurationPropertiesReportEndpoint": &#123; "prefix": "endpoints.configprops", "properties": &#123; "id": "configprops", "enabled": true, "sensitive": true &#125; &#125;, "spring.info-org.springframework.boot.autoconfigure.info.ProjectInfoProperties": &#123; "prefix": "spring.info", "properties": &#123; "git": &#123; "location": &#123;&#125; &#125;, "build": &#123; "location": &#123;&#125; &#125; &#125; &#125;, "infoEndpoint": &#123; "prefix": "endpoints.info", "properties": &#123; "id": "info", "enabled": true, "sensitive": false &#125; &#125;, "serverProperties": &#123; "prefix": "server", "properties": &#123; "undertow": &#123; "maxHttpPostSize": 0, "bufferSize": null, "buffersPerRegion": null, "ioThreads": null, "workerThreads": null, "directBuffers": null, "accesslog": &#123; "enabled": null, "pattern": "common", "prefix": "access_log.", "suffix": "log", "dir": "C:\\Users\\Administrator\\Desktop\\01.Start-Spring-Boot\\logs", "rotate": true &#125; &#125;, "port": 80, "error": &#123; "path": "/error", "includeStacktrace": "NEVER" &#125;, "maxHttpHeaderSize": 0, "jspServlet": null, "ssl": null, "maxHttpPostSize": 0, "jetty": &#123; "maxHttpPostSize": 0, "acceptors": null, "selectors": null &#125;, "servletPath": "/", "tomcat": &#123; "accesslog": &#123; "enabled": false, "pattern": "common", "directory": "logs", "prefix": "access_log", "suffix": ".log", "rotate": true, "renameOnRotate": false, "fileDateFormat": ".yyyy-MM-dd", "requestAttributesEnabled": false, "buffered": true &#125;, "internalProxies": "10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;", "protocolHeader": null, "protocolHeaderHttpsValue": "https", "portHeader": "X-Forwarded-Port", "remoteIpHeader": null, "basedir": null, "backgroundProcessorDelay": 30, "maxThreads": 0, "minSpareThreads": 0, "maxHttpPostSize": 0, "redirectContextRoot": null, "uriEncoding": null, "maxConnections": 0, "acceptCount": 0, "additionalTldSkipPatterns": [] &#125;, "connectionTimeout": null, "session": &#123; "timeout": null, "trackingModes": null, "persistent": false, "storeDir": null, "cookie": &#123; "name": null, "domain": null, "path": null, "comment": null, "httpOnly": null, "secure": null, "maxAge": null &#125; &#125;, "address": null, "contextParameters": &#123;&#125;, "serverHeader": null, "useForwardHeaders": null, "contextPath": null, "displayName": "application" &#125; &#125;, "management.health.status-org.springframework.boot.actuate.autoconfigure.HealthIndicatorProperties": &#123; "prefix": "management.health.status", "properties": &#123; "order": null &#125; &#125;, "environmentEndpoint": &#123; "prefix": "endpoints.env", "properties": &#123; "id": "env", "enabled": true, "sensitive": true &#125; &#125;&#125;trace/trace接口能查看最近的HTTP 请求和响应，在浏览器输入：http://localhost/monitor/trace，输出如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105[&#123; "timestamp": 1525657638444, "info": &#123; "method": "GET", "path": "/login;JSESSIONID=c1d0a83c-05fd-479c-ae6b-2ecc9b878a4a", "headers": &#123; "request": &#123; "host": "localhost", "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0", "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "accept-language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", "accept-encoding": "gzip, deflate", "connection": "keep-alive", "upgrade-insecure-requests": "1", "pragma": "no-cache", "cache-control": "no-cache" &#125;, "response": &#123; "X-Application-Context": "application:80", "status": "404" &#125; &#125;, "timeTaken": "11" &#125;&#125;, &#123; "timestamp": 1525657495017, "info": &#123; "method": "GET", "path": "/monitor/beans", "headers": &#123; "request": &#123; "host": "localhost", "connection": "keep-alive", "upgrade-insecure-requests": "1", "user-agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.10 Safari/537.36", "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "accept-encoding": "gzip, deflate, br", "accept-language": "zh-CN,zh;q=0.9,en;q=0.8" &#125;, "response": &#123; "X-Application-Context": "application:80", "Content-Type": "application/vnd.spring-boot.actuator.v1+json;charset=UTF-8", "Transfer-Encoding": "chunked", "Date": "Mon, 07 May 2018 01:44:55 GMT", "status": "200" &#125; &#125;, "timeTaken": "609" &#125;&#125;, &#123; "timestamp": 1525657402454, "info": &#123; "method": "GET", "path": "/favicon.ico", "headers": &#123; "request": &#123; "host": "localhost", "connection": "keep-alive", "pragma": "no-cache", "cache-control": "no-cache", "user-agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.10 Safari/537.36", "accept": "image/webp,image/apng,image/*,*/*;q=0.8", "referer": "http://localhost/monitor/autoconfig", "accept-encoding": "gzip, deflate, br", "accept-language": "zh-CN,zh;q=0.9,en;q=0.8" &#125;, "response": &#123; "X-Application-Context": "application:80", "Last-Modified": "Wed, 29 Nov 2017 01:54:48 GMT", "Accept-Ranges": "bytes", "Content-Type": "application/octet-stream", "Content-Length": "946", "Date": "Mon, 07 May 2018 01:43:22 GMT", "status": "200" &#125; &#125;, "timeTaken": "21" &#125;&#125;, &#123; "timestamp": 1525657402076, "info": &#123; "method": "GET", "path": "/monitor/autoconfig", "headers": &#123; "request": &#123; "host": "localhost", "connection": "keep-alive", "cache-control": "max-age=0", "upgrade-insecure-requests": "1", "user-agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.10 Safari/537.36", "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "accept-encoding": "gzip, deflate, br", "accept-language": "zh-CN,zh;q=0.9,en;q=0.8" &#125;, "response": &#123; "X-Application-Context": "application:80", "Content-Type": "application/vnd.spring-boot.actuator.v1+json;charset=UTF-8", "Transfer-Encoding": "chunked", "Date": "Mon, 07 May 2018 01:43:22 GMT", "status": "200" &#125; &#125;, "timeTaken": "300" &#125;&#125;]dump获取某一时刻虚拟机线程栈信息。线程栈表示某一时刻虚拟机正在做的事情，访问http://localhost/monitor/dump，输出如下（截取部分）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249[&#123; "threadName": "DestroyJavaVM", "threadId": 32, "blockedTime": -1, "blockedCount": 0, "waitedTime": -1, "waitedCount": 0, "lockName": null, "lockOwnerId": -1, "lockOwnerName": null, "inNative": false, "suspended": false, "threadState": "RUNNABLE", "stackTrace": [], "lockedMonitors": [], "lockedSynchronizers": [], "lockInfo": null&#125;, &#123; "threadName": "http-nio-80-AsyncTimeout", "threadId": 30, "blockedTime": -1, "blockedCount": 0, "waitedTime": -1, "waitedCount": 14903, "lockName": null, "lockOwnerId": -1, "lockOwnerName": null, "inNative": false, "suspended": false, "threadState": "TIMED_WAITING", "stackTrace": [&#123; "methodName": "sleep", "fileName": "Thread.java", "lineNumber": -2, "className": "java.lang.Thread", "nativeMethod": true &#125;, &#123; "methodName": "run", "fileName": "AbstractProtocol.java", "lineNumber": 1211, "className": "org.apache.coyote.AbstractProtocol$AsyncTimeout", "nativeMethod": false &#125;, &#123; "methodName": "run", "fileName": "Thread.java", "lineNumber": 745, "className": "java.lang.Thread", "nativeMethod": false &#125;], "lockedMonitors": [], "lockedSynchronizers": [], "lockInfo": null&#125;, &#123; "threadName": "http-nio-80-Acceptor-0", "threadId": 29, "blockedTime": -1, "blockedCount": 0, "waitedTime": -1, "waitedCount": 0, "lockName": null, "lockOwnerId": -1, "lockOwnerName": null, "inNative": true, "suspended": false, "threadState": "RUNNABLE", "stackTrace": [&#123; "methodName": "accept0", "fileName": "ServerSocketChannelImpl.java", "lineNumber": -2, "className": "sun.nio.ch.ServerSocketChannelImpl", "nativeMethod": true &#125;, &#123; "methodName": "accept", "fileName": "ServerSocketChannelImpl.java", "lineNumber": 250, "className": "sun.nio.ch.ServerSocketChannelImpl", "nativeMethod": false &#125;, &#123; "methodName": "run", "fileName": "NioEndpoint.java", "lineNumber": 455, "className": "org.apache.tomcat.util.net.NioEndpoint$Acceptor", "nativeMethod": false &#125;, &#123; "methodName": "run", "fileName": "Thread.java", "lineNumber": 745, "className": "java.lang.Thread", "nativeMethod": false &#125;], "lockedMonitors": [&#123; "className": "java.lang.Object", "identityHashCode": 1985974129, "lockedStackDepth": 1, "lockedStackFrame": &#123; "methodName": "accept", "fileName": "ServerSocketChannelImpl.java", "lineNumber": 250, "className": "sun.nio.ch.ServerSocketChannelImpl", "nativeMethod": false &#125; &#125;], "lockedSynchronizers": [], "lockInfo": null&#125;, &#123; "threadName": "http-nio-80-ClientPoller-1", "threadId": 28, "blockedTime": -1, "blockedCount": 6, "waitedTime": -1, "waitedCount": 0, "lockName": null, "lockOwnerId": -1, "lockOwnerName": null, "inNative": true, "suspended": false, "threadState": "RUNNABLE", "stackTrace": [&#123; "methodName": "poll0", "fileName": "WindowsSelectorImpl.java", "lineNumber": -2, "className": "sun.nio.ch.WindowsSelectorImpl$SubSelector", "nativeMethod": true &#125;, &#123; "methodName": "poll", "fileName": "WindowsSelectorImpl.java", "lineNumber": 296, "className": "sun.nio.ch.WindowsSelectorImpl$SubSelector", "nativeMethod": false &#125;, &#123; "methodName": "access$400", "fileName": "WindowsSelectorImpl.java", "lineNumber": 278, "className": "sun.nio.ch.WindowsSelectorImpl$SubSelector", "nativeMethod": false &#125;, &#123; "methodName": "doSelect", "fileName": "WindowsSelectorImpl.java", "lineNumber": 159, "className": "sun.nio.ch.WindowsSelectorImpl", "nativeMethod": false &#125;, &#123; "methodName": "lockAndDoSelect", "fileName": "SelectorImpl.java", "lineNumber": 87, "className": "sun.nio.ch.SelectorImpl", "nativeMethod": false &#125;, &#123; "methodName": "select", "fileName": "SelectorImpl.java", "lineNumber": 98, "className": "sun.nio.ch.SelectorImpl", "nativeMethod": false &#125;, &#123; "methodName": "run", "fileName": "NioEndpoint.java", "lineNumber": 793, "className": "org.apache.tomcat.util.net.NioEndpoint$Poller", "nativeMethod": false &#125;, &#123; "methodName": "run", "fileName": "Thread.java", "lineNumber": 745, "className": "java.lang.Thread", "nativeMethod": false &#125;], "lockedMonitors": [&#123; "className": "sun.nio.ch.Util$2", "identityHashCode": 511554453, "lockedStackDepth": 4, "lockedStackFrame": &#123; "methodName": "lockAndDoSelect", "fileName": "SelectorImpl.java", "lineNumber": 87, "className": "sun.nio.ch.SelectorImpl", "nativeMethod": false &#125; &#125;, &#123; "className": "java.util.Collections$UnmodifiableSet", "identityHashCode": 563515370, "lockedStackDepth": 4, "lockedStackFrame": &#123; "methodName": "lockAndDoSelect", "fileName": "SelectorImpl.java", "lineNumber": 87, "className": "sun.nio.ch.SelectorImpl", "nativeMethod": false &#125; &#125;, &#123; "className": "sun.nio.ch.WindowsSelectorImpl", "identityHashCode": 761235575, "lockedStackDepth": 4, "lockedStackFrame": &#123; "methodName": "lockAndDoSelect", "fileName": "SelectorImpl.java", "lineNumber": 87, "className": "sun.nio.ch.SelectorImpl", "nativeMethod": false &#125; &#125;], "lockedSynchronizers": [], "lockInfo": null&#125;,...... &#123; "threadName": "Finalizer", "threadId": 3, "blockedTime": -1, "blockedCount": 202, "waitedTime": -1, "waitedCount": 51, "lockName": "java.lang.ref.ReferenceQueue$Lock@bd5f3f3", "lockOwnerId": -1, "lockOwnerName": null, "inNative": false, "suspended": false, "threadState": "WAITING", "stackTrace": [&#123; "methodName": "wait", "fileName": "Object.java", "lineNumber": -2, "className": "java.lang.Object", "nativeMethod": true &#125;, &#123; "methodName": "remove", "fileName": "ReferenceQueue.java", "lineNumber": 135, "className": "java.lang.ref.ReferenceQueue", "nativeMethod": false &#125;, &#123; "methodName": "remove", "fileName": "ReferenceQueue.java", "lineNumber": 151, "className": "java.lang.ref.ReferenceQueue", "nativeMethod": false &#125;, &#123; "methodName": "run", "fileName": "Finalizer.java", "lineNumber": 209, "className": "java.lang.ref.Finalizer$FinalizerThread", "nativeMethod": false &#125;], "lockedMonitors": [], "lockedSynchronizers": [], "lockInfo": &#123; "className": "java.lang.ref.ReferenceQueue$Lock", "identityHashCode": 198570995 &#125;&#125;]env显示Spring Boot环境变量，如使用的JDK版本、加载的jar包、配置文件信息、日志文件信息。访问，输出如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&#123; "profiles": [], "server.ports": &#123; "local.server.port": 80 &#125;, "servletContextInitParams": &#123;&#125;, "systemProperties": &#123; "java.runtime.name": "Java(TM) SE Runtime Environment", "sun.boot.library.path": "C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\bin", "java.vm.version": "24.80-b11", "java.vm.vendor": "Oracle Corporation", "java.vendor.url": "http://java.oracle.com/", "path.separator": ";", "java.vm.name": "Java HotSpot(TM) 64-Bit Server VM", "file.encoding.pkg": "sun.io", "user.country": "CN", "user.script": "", "sun.java.launcher": "SUN_STANDARD", "sun.os.patch.level": "", "PID": "15184", "java.vm.specification.name": "Java Virtual Machine Specification", "user.dir": "C:\\Users\\Administrator\\Desktop\\01.Start-Spring-Boot", "java.runtime.version": "1.7.0_80-b15", "java.awt.graphicsenv": "sun.awt.Win32GraphicsEnvironment", "org.jboss.logging.provider": "slf4j", "java.endorsed.dirs": "C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\endorsed", "os.arch": "amd64", "java.io.tmpdir": "C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\", "line.separator": "\r\n", "java.vm.specification.vendor": "Oracle Corporation", "user.variant": "", "os.name": "Windows 8.1", "sun.jnu.encoding": "GBK", "spring.beaninfo.ignore": "true", "java.library.path": "C:\\Program Files\\Java\\jdk1.7.0_80\\bin;C:\\Windows\\Sun\\Java\\bin;C:\\Windows\\system32;C:\\Windows;C:/Program Files/Java/jre1.8.0_31/bin/server;C:/Program Files/Java/jre1.8.0_31/bin;C:/Program Files/Java/jre1.8.0_31/lib/amd64;f:\\app\\Administrator\\product\\11.2.0\\client_1\\bin;f:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\bin;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\nodejs\\;C:\\Program Files\\Git\\cmd;\"%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin\";%M2_HOME%\\bin;C:\\Program Files\\TortoiseSVN\\bin;C:\\Program Files\\PuTTY\\;C:\\ProgramData\\chocolatey\\bin;C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Administrator\\AppData\\Roaming\\npm;\"C:\\Program Files\\Java\\jdk1.8.0_31\\bin;C:\\Program Files\\Java\\jdk1.8.0_31\\jre\\bin\";D:\\Program Files\\apache-maven-3.3.9-bin\\apache-maven-3.3.9\\bin;C:\\Program Files\\cmder;;D:\\Program Files\\Oxygen;;.", "java.specification.name": "Java Platform API Specification", "java.class.version": "51.0", "sun.management.compiler": "HotSpot 64-Bit Tiered Compilers", "os.version": "6.3", "user.home": "C:\\Users\\Administrator", "catalina.useNaming": "false", "user.timezone": "Asia/Shanghai", "java.awt.printerjob": "sun.awt.windows.WPrinterJob", "file.encoding": "UTF-8", "java.specification.version": "1.7", "catalina.home": "C:\\Users\\Administrator\\AppData\\Local\\Temp\\tomcat.2042919348800278549.80", "java.class.path": "C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\rt.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\zipfs.jar;C:\\Users\\Administrator\\Desktop\\01.Start-Spring-Boot\\target\\classes;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot-starter-web\\1.5.9.RELEASE\\spring-boot-starter-web-1.5.9.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot-starter\\1.5.9.RELEASE\\spring-boot-starter-1.5.9.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot\\1.5.9.RELEASE\\spring-boot-1.5.9.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot-autoconfigure\\1.5.9.RELEASE\\spring-boot-autoconfigure-1.5.9.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot-starter-logging\\1.5.9.RELEASE\\spring-boot-starter-logging-1.5.9.RELEASE.jar;D:\\m2\\repository\\ch\\qos\\logback\\logback-classic\\1.1.11\\logback-classic-1.1.11.jar;D:\\m2\\repository\\ch\\qos\\logback\\logback-core\\1.1.11\\logback-core-1.1.11.jar;D:\\m2\\repository\\org\\slf4j\\jcl-over-slf4j\\1.7.25\\jcl-over-slf4j-1.7.25.jar;D:\\m2\\repository\\org\\slf4j\\jul-to-slf4j\\1.7.25\\jul-to-slf4j-1.7.25.jar;D:\\m2\\repository\\org\\slf4j\\log4j-over-slf4j\\1.7.25\\log4j-over-slf4j-1.7.25.jar;D:\\m2\\repository\\org\\yaml\\snakeyaml\\1.17\\snakeyaml-1.17.jar;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot-starter-tomcat\\1.5.9.RELEASE\\spring-boot-starter-tomcat-1.5.9.RELEASE.jar;D:\\m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-core\\8.5.23\\tomcat-embed-core-8.5.23.jar;D:\\m2\\repository\\org\\apache\\tomcat\\tomcat-annotations-api\\8.5.23\\tomcat-annotations-api-8.5.23.jar;D:\\m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-el\\8.5.23\\tomcat-embed-el-8.5.23.jar;D:\\m2\\repository\\org\\apache\\tomcat\\embed\\tomcat-embed-websocket\\8.5.23\\tomcat-embed-websocket-8.5.23.jar;D:\\m2\\repository\\org\\hibernate\\hibernate-validator\\5.3.6.Final\\hibernate-validator-5.3.6.Final.jar;D:\\m2\\repository\\javax\\validation\\validation-api\\1.1.0.Final\\validation-api-1.1.0.Final.jar;D:\\m2\\repository\\org\\jboss\\logging\\jboss-logging\\3.3.1.Final\\jboss-logging-3.3.1.Final.jar;D:\\m2\\repository\\com\\fasterxml\\classmate\\1.3.4\\classmate-1.3.4.jar;D:\\m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-databind\\2.8.10\\jackson-databind-2.8.10.jar;D:\\m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-annotations\\2.8.0\\jackson-annotations-2.8.0.jar;D:\\m2\\repository\\com\\fasterxml\\jackson\\core\\jackson-core\\2.8.10\\jackson-core-2.8.10.jar;D:\\m2\\repository\\org\\springframework\\spring-web\\4.3.13.RELEASE\\spring-web-4.3.13.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\spring-aop\\4.3.13.RELEASE\\spring-aop-4.3.13.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\spring-beans\\4.3.13.RELEASE\\spring-beans-4.3.13.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\spring-context\\4.3.13.RELEASE\\spring-context-4.3.13.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\spring-webmvc\\4.3.13.RELEASE\\spring-webmvc-4.3.13.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\spring-expression\\4.3.13.RELEASE\\spring-expression-4.3.13.RELEASE.jar;D:\\m2\\repository\\org\\slf4j\\slf4j-api\\1.7.25\\slf4j-api-1.7.25.jar;D:\\m2\\repository\\org\\springframework\\spring-core\\4.3.13.RELEASE\\spring-core-4.3.13.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot-starter-actuator\\1.5.9.RELEASE\\spring-boot-starter-actuator-1.5.9.RELEASE.jar;D:\\m2\\repository\\org\\springframework\\boot\\spring-boot-actuator\\1.5.9.RELEASE\\spring-boot-actuator-1.5.9.RELEASE.jar", "user.name": "Administrator", "java.vm.specification.version": "1.7", "sun.java.command": "com.springboot.demo.DemoApplication", "java.home": "C:\\Program Files\\Java\\jdk1.7.0_80\\jre", "sun.arch.data.model": "64", "user.language": "zh", "java.specification.vendor": "Oracle Corporation", "awt.toolkit": "sun.awt.windows.WToolkit", "java.vm.info": "mixed mode", "java.version": "1.7.0_80", "java.ext.dirs": "C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext;C:\\Windows\\Sun\\Java\\lib\\ext", "sun.boot.class.path": "C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\rt.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\sunrsasign.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\classes", "java.awt.headless": "true", "java.vendor": "Oracle Corporation", "catalina.base": "C:\\Users\\Administrator\\AppData\\Local\\Temp\\tomcat.2042919348800278549.80", "file.separator": "\\", "java.vendor.url.bug": "http://bugreport.sun.com/bugreport/", "sun.io.unicode.encoding": "UnicodeLittle", "sun.cpu.endian": "little", "sun.desktop": "windows", "sun.cpu.isalist": "amd64" &#125;, "systemEnvironment": &#123; "USERPROFILE": "C:\\Users\\Administrator", "ProgramData": "C:\\ProgramData", "PATHEXT": ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC", "JAVA_HOME": "C:\\Program Files\\Java\\jdk1.8.0_31", "ProgramFiles(x86)": "C:\\Program Files (x86)", "ChocolateyLastPathUpdate": "周四 4月 26 09:03:47 2018", "TEMP": "C:\\Users\\ADMINI~1\\AppData\\Local\\Temp", "SystemDrive": "C:", "ProgramFiles": "C:\\Program Files", "Path": "C:/Program Files/Java/jre1.8.0_31/bin/server;C:/Program Files/Java/jre1.8.0_31/bin;C:/Program Files/Java/jre1.8.0_31/lib/amd64;f:\\app\\Administrator\\product\\11.2.0\\client_1\\bin;f:\\app\\Administrator\\product\\11.2.0\\dbhome_1\\bin;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\nodejs\\;C:\\Program Files\\Git\\cmd;\"%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin\";%M2_HOME%\\bin;C:\\Program Files\\TortoiseSVN\\bin;C:\\Program Files\\PuTTY\\;C:\\ProgramData\\chocolatey\\bin;C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Administrator\\AppData\\Roaming\\npm;\"C:\\Program Files\\Java\\jdk1.8.0_31\\bin;C:\\Program Files\\Java\\jdk1.8.0_31\\jre\\bin\";D:\\Program Files\\apache-maven-3.3.9-bin\\apache-maven-3.3.9\\bin;C:\\Program Files\\cmder;;D:\\Program Files\\Oxygen;", "HOMEDRIVE": "C:", "PROCESSOR_REVISION": "4e03", "=C:": "C:\\", "USERDOMAIN": "SC-201802012049", "ALLUSERSPROFILE": "C:\\ProgramData", "ProgramW6432": "C:\\Program Files", "PROCESSOR_IDENTIFIER": "Intel64 Family 6 Model 78 Stepping 3, GenuineIntel", "SESSIONNAME": "Console", "FPS_BROWSER_USER_PROFILE_STRING": "Default", "TMP": "C:\\Users\\ADMINI~1\\AppData\\Local\\Temp", "PROCESSOR_ARCHITECTURE": "AMD64", "CommonProgramFiles": "C:\\Program Files\\Common Files", "CLASSPATH": ".;C:\\Program Files\\Java\\jdk1.8.0_31\\lib;C:\\Program Files\\Java\\jdk1.8.0_31\\lib\\tools.jar", "=::": "::\\", "LOGONSERVER": "\\\\SC-201802012049", "M2_HOME": "D:\\Program Files\\apache-maven-3.3.9-bin\\apache-maven-3.3.9", "OS": "Windows_NT", "HOMEPATH": "\\Users\\Administrator", "PROCESSOR_LEVEL": "6", "FPS_BROWSER_APP_PROFILE_STRING": "Internet Explorer", "CommonProgramW6432": "C:\\Program Files\\Common Files", "USERDOMAIN_ROAMINGPROFILE": "SC-201802012049", "LOCALAPPDATA": "C:\\Users\\Administrator\\AppData\\Local", "COMPUTERNAME": "SC-201802012049", "windir": "C:\\Windows", "SystemRoot": "C:\\Windows", "asl.log": "Destination=file", "NUMBER_OF_PROCESSORS": "4", "USERNAME": "Administrator", "PUBLIC": "C:\\Users\\Public", "PSModulePath": "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", "ComSpec": "C:\\Windows\\system32\\cmd.exe", "ChocolateyInstall": "C:\\ProgramData\\chocolatey", "APPDATA": "C:\\Users\\Administrator\\AppData\\Roaming" &#125;, "applicationConfig: [classpath:/application.yml]": &#123; "server.port": 80, "management.security.enabled": false, "management.port": 80, "management.context-path": "/monitor", "endpoints.shutdown.enabled": true &#125;&#125;health查看所在应用的健康状态， 如磁盘、数据源、Redis 、Elasticsearch等。健康状态分为UP（正常）和DOWN（故障）状态。访问http://localhost/monitor/health，显示如下：123456789&#123; "status": "UP", "diskSpace": &#123; "status": "UP", "total": 107380994048, "free": 63853707264, "threshold": 10485760 &#125;&#125;mappings输出所有通过注解＠RequestMapping设置的URL映射，可以通过此来查看URL对应的Controller。访问http://localhost/monitor/mappings，显示如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&#123; "/webjars/**": &#123; "bean": "resourceHandlerMapping" &#125;, "/**": &#123; "bean": "resourceHandlerMapping" &#125;, "/**/favicon.ico": &#123; "bean": "faviconHandlerMapping" &#125;, "&#123;[/]&#125;": &#123; "bean": "requestMappingHandlerMapping", "method": "java.lang.String com.springboot.demo.DemoApplication.index()" &#125;, "&#123;[/error]&#125;": &#123; "bean": "requestMappingHandlerMapping", "method": "public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)" &#125;, "&#123;[/error],produces=[text/html]&#125;": &#123; "bean": "requestMappingHandlerMapping", "method": "public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)" &#125;, "&#123;[/monitor/loggers/&#123;name:.*&#125;],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.LoggersMvcEndpoint.get(java.lang.String)" &#125;, "&#123;[/monitor/loggers/&#123;name:.*&#125;],methods=[POST],consumes=[application/vnd.spring-boot.actuator.v1+json || application/json],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.LoggersMvcEndpoint.set(java.lang.String,java.util.Map&lt;java.lang.String, java.lang.String&gt;)" &#125;, "&#123;[/monitor/loggers || /monitor/loggers.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/shutdown || /monitor/shutdown.json],methods=[POST],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.ShutdownMvcEndpoint.invoke()" &#125;, "&#123;[/monitor/trace || /monitor/trace.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/heapdump || /monitor/heapdump.json],methods=[GET],produces=[application/octet-stream]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public void org.springframework.boot.actuate.endpoint.mvc.HeapdumpMvcEndpoint.invoke(boolean,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) throws java.io.IOException,javax.servlet.ServletException" &#125;, "&#123;[/monitor/autoconfig || /monitor/autoconfig.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/beans || /monitor/beans.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/mappings || /monitor/mappings.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/health || /monitor/health.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.HealthMvcEndpoint.invoke(javax.servlet.http.HttpServletRequest,java.security.Principal)" &#125;, "&#123;[/monitor/metrics/&#123;name:.*&#125;],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint.value(java.lang.String)" &#125;, "&#123;[/monitor/metrics || /monitor/metrics.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/dump || /monitor/dump.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/env/&#123;name:.*&#125;],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint.value(java.lang.String)" &#125;, "&#123;[/monitor/env || /monitor/env.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/info || /monitor/info.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/configprops || /monitor/configprops.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()" &#125;, "&#123;[/monitor/auditevents || /monitor/auditevents.json],methods=[GET],produces=[application/vnd.spring-boot.actuator.v1+json || application/json]&#125;": &#123; "bean": "endpointHandlerMapping", "method": "public org.springframework.http.ResponseEntity&lt;?&gt; org.springframework.boot.actuate.endpoint.mvc.AuditEventsMvcEndpoint.findByPrincipalAndAfterAndType(java.lang.String,java.util.Date,java.lang.String)" &#125;&#125;metrics显示Spring Boot的性能指标，如己有内存、未占用内存、垃圾回收次数、类信息等。访问http://localhost/monitor/metrics，输出如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; "mem": 245361, "mem.free": 76255, "processors": 4, "instance.uptime": 15927377, "uptime": 15932920, "systemload.average": -1.0, "heap.committed": 209408, "heap.init": 122659, "heap.used": 133152, "heap": 1745920, "nonheap.committed": 36480, "nonheap.init": 24000, "nonheap.used": 35953, "nonheap": 133120, "threads.peak": 24, "threads.daemon": 20, "threads.totalStarted": 27, "threads": 22, "classes": 6107, "classes.loaded": 6107, "classes.unloaded": 0, "gc.ps_scavenge.count": 5, "gc.ps_scavenge.time": 73, "gc.ps_marksweep.count": 0, "gc.ps_marksweep.time": 0, "httpsessions.max": -1, "httpsessions.active": 0, "counter.status.200.monitor.autoconfig": 2, "counter.status.200.monitor.beans": 2, "counter.status.200.monitor.configprops": 1, "counter.status.200.monitor.dump": 4, "counter.status.200.monitor.env": 1, "counter.status.200.monitor.health": 1, "counter.status.200.monitor.info": 1, "counter.status.200.monitor.loggers": 1, "counter.status.200.monitor.mappings": 1, "counter.status.200.monitor.trace": 3, "counter.status.200.star-star.favicon.ico": 3, "counter.status.404.star-star": 2, "gauge.response.monitor.autoconfig": 14.0, "gauge.response.monitor.beans": 42.0, "gauge.response.monitor.configprops": 440.0, "gauge.response.monitor.dump": 62.0, "gauge.response.monitor.env": 14.0, "gauge.response.monitor.health": 22.0, "gauge.response.monitor.info": 26.0, "gauge.response.monitor.loggers": 237.0, "gauge.response.monitor.mappings": 7.0, "gauge.response.monitor.trace": 8.0, "gauge.response.star-star": 12.0, "gauge.response.star-star.favicon.ico": 6.0&#125;对/metrics接口提供的信息进行简单分类如下表：分类前缀报告内容垃圾收集器gc.已经发生过的垃圾收集次数，以及垃圾收集所耗费的时间，适用于标记-清理垃圾收集器和并行垃圾收集器(数据源自java.lang.management. GarbageCollectorMXBean)内存mem.分配给应用程序的内存数量和空闲的内存数量(数据源自java.lang. Runtime)堆heap.当前内存用量(数据源自java.lang.management.MemoryUsage)类加载器classes.JVM类加载器加载与卸载的类的数量(数据源自java.lang. management.ClassLoadingMXBean)系统processors、instance.uptime、uptime、systemload.average系统信息，例如处理器数量(数据源自java.lang.Runtime)、运行时间(数据源自java.lang.management.RuntimeMXBean)、平均负载(数据源自java.lang.management.OperatingSystemMXBean)线程池thread.线程、守护线程的数量，以及JVM启动后的线程数量峰值(数据源自 java.lang .management.ThreadMXBean)数据源datasource.数据源连接的数量(源自数据源的元数据，仅当Spring应用程序上下文里存在 DataSource Bean 的时候才会有这个信息)Tomcat 会话httpsessions.*Tomcat的活跃会话数和最大会话数(数据源自嵌入式Tomcat的Bean，仅在使用嵌入式Tomcat服务器运行应用程序时才有这个信息)HTTPcounter.status.、gauge.response.多种应用程序服务HTTP请求的度量值与计数器HTTP的计数器和度量值需要做一点说明。counter.status后的值是HTTP状态码，随后是所请求的路径。举个例子，counter.status.200.metrics 表明/metrics端点返回 200(OK) 状态码的次数。HTTP的度量信息在结构上也差不多，却在报告另一类信息。它们全部以gauge.response开头，表明这是HTTP响应的度量信息。前缀后是对应的路径。度量值是以毫秒为单位的时间，反映了最近处理该路径请求的耗时。这里还有几个特殊的值需要注意。root路径指向的是根路径或/。star-star代表了那些Spring认为是静态资源的路径，包括图片、JavaScript和样式表，其中还包含了那些找不到的资源。这就是为什么你经常会看到counter.status.404.star-star，这是返回了HTTP 404 (NOT FOUND)状态的请求数。/metrics接口会返回所有的可用度量值，但你也可能只对某个值感兴趣。要获取单个值，请求时可以在URL后加上对应的键名。例如，要查看空闲内存大小,可以向/metrics/mem.free发一个GET请求。定制Actuator修改接口ID每个Actuator接口都有一个ID用来决定接口的路径，比方说，/beans接口的默认ID就是beans。比如要修改/beans为 /instances，则设置如下：123endpoints: beans: id: instances启用和禁用接口虽然Actuator的接口都很有用，但你不一定需要全部这些接口。默认情况下，所有接口（除了/shutdown）都启用。比如要禁用 /metrics 接口，则可以设置如下：123endpoints: metrics: enabled: false如果你只想打开一两个接口，那就先禁用全部接口，然后启用那几个你要的，这样更方便。1234endpoints: enabled: false metrics: enabled: true参考文章：https://www.jianshu.com/p/af9738634a21。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/21.Spring-Boot-Actuator。]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Swagger2构建RESTful API]]></title>
    <url>%2FSpring-Boot-Swagger2-RESTful-API.html</url>
    <content type="text"><![CDATA[Swagger是一款可以快速生成符合RESTful风格API并进行在线调试的插件。本文将介绍如何在Spring Boot中整合Swagger。在此之前，我们先聊聊什么是REST。REST实际上为Representational State Transfer的缩写，翻译为“表现层状态转化” 。如果一个架构符合REST 原则，就称它为RESTful架构。实际上，“表现层状态转化”省略了主语，完整的说应该是“资源表现层状态转化”。什么是资源（Resource）？资源指的是网络中信息的表现形式，比如一段文本，一首歌，一个视频文件等等；什么是表现层（Reresentational）？表现层即资源的展现在你面前的形式，比如文本可以是JSON格式的，也可以是XML形式的，甚至为二进制形式的。图片可以是gif，也可以是PNG；什么是状态转换（State Transfer）？用户可使用URL通过HTTP协议来获取各种资源，HTTP协议包含了一些操作资源的方法，比如：GET 用来获取资源， POST 用来新建资源 , PUT 用来更新资源， DELETE 用来删除资源， PATCH 用来更新资源的部分属性。通过这些HTTP协议的方法来操作资源的过程即为状态转换。下面对比下传统URL请求和RESTful风格请求的区别：描述传统请求方法RESTful请求方法查询/user/query?name=mrbirdGET/user?name=mrbirdGET详情/user/getInfo?id=1GET/user/1GET创建/user/create?name=mrbirdPOST/userPOST修改/user/update?name=mrbird&amp;id=1POST/user/1PUT删除/user/delete?id=1GET/user/1DELETE从上面这张表，我们大致可以总结下传统请求和RESTful请求的几个区别：传统请求通过URL来描述行为，如create，delete等；RESTful请求通过URL来描述资源。RESTful请求通过HTTP请求的方法来描述行为，比如DELETE，POST，PUT等，并且使用HTTP状态码来表示不同的结果。RESTful请求通过JSON来交换数据。RESTful只是一种风格，并不是一种强制性的标准。引入Swagger依赖本文使用的Swagger版本为2.6.1：12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;配置SwaggerConfig使用JavaConfig的形式配置Swagger：1234567891011121314151617181920212223242526272829303132import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket buildDocket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(buildApiInf()) .select() .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo buildApiInf() &#123; return new ApiInfoBuilder() .title("系统RESTful API文档") .contact(new Contact("mrbird", "https://mrbird.cc", "852252810@qq.com")) .version("1.0") .build(); &#125;&#125;在配置类中添加@EnableSwagger2注解来启用Swagger2，apis()定义了扫描的包路径。配置较为简单，其他不做过多说明。Swagger常用注解@Api：修饰整个类，描述Controller的作用；@ApiOperation：描述一个类的一个方法，或者说一个接口；@ApiParam：单个参数描述；@ApiModel：用对象来接收参数；@ApiProperty：用对象接收参数时，描述对象的一个字段；@ApiResponse：HTTP响应其中1个描述；@ApiResponses：HTTP响应整体描述；@ApiIgnore：使用该注解忽略这个API；@ApiError ：发生错误返回的信息；@ApiImplicitParam：一个请求参数；@ApiImplicitParams：多个请求参数。编写RESTful API接口Spring Boot中包含了一些注解，对应于HTTP协议中的方法：@GetMapping对应HTTP中的GET方法；@PostMapping对应HTTP中的POST方法；@PutMapping对应HTTP中的PUT方法；@DeleteMapping对应HTTP中的DELETE方法；@PatchMapping对应HTTP中的PATCH方法。我们使用这些注解来编写一个RESTful测试Controller：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.example.demo.domain.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import springfox.documentation.annotations.ApiIgnore;@Api(value = "用户Controller")@Controller@RequestMapping("user")public class UserController &#123; @ApiIgnore @GetMapping("hello") public @ResponseBody String hello() &#123; return "hello"; &#125; @ApiOperation(value = "获取用户信息", notes = "根据用户id获取用户信息") @ApiImplicitParam(name = "id", value = "用户id", required = true, dataType = "Long", paramType = "path") @GetMapping("/&#123;id&#125;") public @ResponseBody User getUserById(@PathVariable(value = "id") Long id) &#123; User user = new User(); user.setId(id); user.setName("mrbird"); user.setAge(25); return user; &#125; @ApiOperation(value = "获取用户列表", notes = "获取用户列表") @GetMapping("/list") public @ResponseBody List&lt;User&gt; getUserList() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); User user1 = new User(); user1.setId(1l); user1.setName("mrbird"); user1.setAge(25); list.add(user1); User user2 = new User(); user2.setId(2l); user2.setName("scott"); user2.setAge(29); list.add(user2); return list; &#125; @ApiOperation(value = "新增用户", notes = "根据用户实体创建用户") @ApiImplicitParam(name = "user", value = "用户实体", required = true, dataType = "User") @PostMapping("/add") public @ResponseBody Map&lt;String, Object&gt; addUser(@RequestBody User user) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("result", "success"); return map; &#125; @ApiOperation(value = "删除用户", notes = "根据用户id删除用户") @ApiImplicitParam(name = "id", value = "用户id", required = true, dataType = "Long", paramType = "path") @DeleteMapping("/&#123;id&#125;") public @ResponseBody Map&lt;String, Object&gt; deleteUser(@PathVariable(value = "id") Long id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("result", "success"); return map; &#125; @ApiOperation(value = "更新用户", notes = "根据用户id更新用户") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户id", required = true, dataType = "Long", paramType = "path"), @ApiImplicitParam(name = "user", value = "用户实体", required = true, dataType = "User") &#125;) @PutMapping("/&#123;id&#125;") public @ResponseBody Map&lt;String, Object&gt; updateUser(@PathVariable(value = "id") Long id, @RequestBody User user) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("result", "success"); return map; &#125;&#125;对于不需要生成API的方法或者类，只需要在上面添加@ApiIgnore注解即可。启动&amp;测试启动项目，访问http://localhost:8080/swagger-ui.html即可看到Swagger给我们生成的API页面：点击接口下的“Try it out”Swagger会用curl命令发送请求，并且返回响应信息，如下所示:源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/20.Spring-Boot-Swagger2]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Swagger</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中编写单元测试]]></title>
    <url>%2FSpring-Boot%20TESTing.html</url>
    <content type="text"><![CDATA[编写单元测试可以帮助开发人员编写高质量的代码，提升代码质量，减少Bug，便于重构。Spring Boot提供了一些实用程序和注解，用来帮助我们测试应用程序，在Spring Boot中开启单元测试只需引入spring-boot-starter-test即可，其包含了一些主流的测试库。本文主要介绍基于 Service和Controller的单元测试。引入spring-boot-starter-test：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;运行Maven命令dependency:tree可看到其包含了以下依赖：123456789101112131415161718[INFO] +- org.springframework.boot:spring-boot-starter-test:jar:1.5.9.RELEASE:test[INFO] | +- org.springframework.boot:spring-boot-test:jar:1.5.9.RELEASE:test[INFO] | +- org.springframework.boot:spring-boot-test-autoconfigure:jar:1.5.9.RELEASE:test[INFO] | +- com.jayway.jsonpath:json-path:jar:2.2.0:test[INFO] | | +- net.minidev:json-smart:jar:2.2.1:test[INFO] | | | \- net.minidev:accessors-smart:jar:1.1:test[INFO] | | | \- org.ow2.asm:asm:jar:5.0.3:test[INFO] | | \- org.slf4j:slf4j-api:jar:1.7.25:compile[INFO] | +- junit:junit:jar:4.12:test[INFO] | +- org.assertj:assertj-core:jar:2.6.0:test[INFO] | +- org.mockito:mockito-core:jar:1.10.19:test[INFO] | | \- org.objenesis:objenesis:jar:2.1:test[INFO] | +- org.hamcrest:hamcrest-core:jar:1.3:test[INFO] | +- org.hamcrest:hamcrest-library:jar:1.3:test[INFO] | +- org.skyscreamer:jsonassert:jar:1.4.0:test[INFO] | | \- com.vaadin.external.google:android-json:jar:0.0.20131108.vaadin1:test[INFO] | +- org.springframework:spring-core:jar:4.3.13.RELEASE:compile[INFO] | \- org.springframework:spring-test:jar:4.3.13.RELEASE:testJUnit，标准的单元测试Java应用程序；Spring Test &amp; Spring Boot Test，对Spring Boot应用程序的单元测试提供支持；Mockito, Java mocking框架，用于模拟任何Spring管理的Bean，比如在单元测试中模拟一个第三方系统Service接口返回的数据，而不会去真正调用第三方系统；AssertJ，一个流畅的assertion库，同时也提供了更多的期望值与测试返回值的比较方式；Hamcrest，库的匹配对象（也称为约束或谓词）；JsonPath，提供类似XPath那样的符号来获取JSON数据片段；JSONassert，对JSON对象或者JSON字符串断言的库。一个标准的Spring Boot测试单元应有如下的代码结构：123456789import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTest &#123; &#125;知识准备JUnit4注解JUnit4中包含了几个比较重要的注解：@BeforeClass、@AfterClass、@Before、@After和@Test。其中， @BeforeClass和@AfterClass在每个类加载的开始和结束时运行，必须为静态方法；而@Before和@After则在每个测试方法开始之前和结束之后运行。见如下例子：123456789101112131415161718192021222324252627282930313233343536@RunWith(SpringRunner.class)@SpringBootTestpublic class TestApplicationTests &#123; @BeforeClass public static void beforeClassTest() &#123; System.out.println("before class test"); &#125; @Before public void beforeTest() &#123; System.out.println("before test"); &#125; @Test public void Test1() &#123; System.out.println("test 1+1=2"); Assert.assertEquals(2, 1 + 1); &#125; @Test public void Test2() &#123; System.out.println("test 2+2=4"); Assert.assertEquals(4, 2 + 2); &#125; @After public void afterTest() &#123; System.out.println("after test"); &#125; @AfterClass public static void afterClassTest() &#123; System.out.println("after class test"); &#125;&#125;运行输出如下：12345678910...before class testbefore testtest 1+1=2after testbefore testtest 2+2=4after testafter class test...从上面的输出可以看出各个注解的运行时机。Assert上面代码中，我们使用了Assert类提供的assert口方法，下面列出了一些常用的assert方法：assertEquals(&quot;message&quot;,A,B)，判断A对象和B对象是否相等，这个判断在比较两个对象时调用了equals()方法。assertSame(&quot;message&quot;,A,B)，判断A对象与B对象是否相同，使用的是==操作符。assertTrue(&quot;message&quot;,A)，判断A条件是否为真。assertFalse(&quot;message&quot;,A)，判断A条件是否不为真。assertNotNull(&quot;message&quot;,A)，判断A对象是否不为null。assertArrayEquals(&quot;message&quot;,A,B)，判断A数组与B数组是否相等。MockMvc下文中，对Controller的测试需要用到MockMvc技术。MockMvc，从字面上来看指的是模拟的MVC，即其可以模拟一个MVC环境，向Controller发送请求然后得到响应。在单元测试中，使用MockMvc前需要进行初始化，如下所示：123456789private MockMvc mockMvc;@Autowiredprivate WebApplicationContext wac;@Beforepublic void setupMockMvc()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();&#125;MockMvc模拟MVC请求模拟一个get请求：1mockMvc.perform(MockMvcRequestBuilders.get("/hello?name=&#123;name&#125;","mrbird"));模拟一个post请求：1mockMvc.perform(MockMvcRequestBuilders.post("/user/&#123;id&#125;", 1));模拟文件上传：1mockMvc.perform(MockMvcRequestBuilders.fileUpload("/fileupload").file("file", "文件内容".getBytes("utf-8")));模拟请求参数：1234// 模拟发送一个message参数，值为hellomockMvc.perform(MockMvcRequestBuilders.get("/hello").param("message", "hello"));// 模拟提交一个checkbox值，name为hobby，值为sleep和eatmockMvc.perform(MockMvcRequestBuilders.get("/saveHobby").param("hobby", "sleep", "eat"));也可以直接使用MultiValueMap构建参数：12345MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;String, String&gt;();params.add("name", "mrbird");params.add("hobby", "sleep");params.add("hobby", "eat");mockMvc.perform(MockMvcRequestBuilders.get("/hobby/save").params(params));模拟发送JSON参数：12String jsonStr = "&#123;\"username\":\"Dopa\",\"passwd\":\"ac3af72d9f95161a502fd326865c2f15\",\"status\":\"1\"&#125;";mockMvc.perform(MockMvcRequestBuilders.post("/user/save").content(jsonStr.getBytes()));实际测试中，要手动编写这么长的JSON格式字符串很繁琐也很容易出错，可以借助Spring Boot自带的Jackson技术来序列化一个Java对象（可参考Spring Boot中的JSON技术），如下所示：1234567User user = new User();user.setUsername("Dopa");user.setPasswd("ac3af72d9f95161a502fd326865c2f15");user.setStatus("1");String userJson = mapper.writeValueAsString(user);mockMvc.perform(MockMvcRequestBuilders.post("/user/save").content(userJson.getBytes()));其中，mapper为com.fasterxml.jackson.databind.ObjectMapper对象。模拟Session和Cookie：12mockMvc.perform(MockMvcRequestBuilders.get("/index").sessionAttr(name, value));mockMvc.perform(MockMvcRequestBuilders.get("/index").cookie(new Cookie(name, value)));设置请求的Content-Type：1mockMvc.perform(MockMvcRequestBuilders.get("/index").contentType(MediaType.APPLICATION_JSON_UTF8));设置返回格式为JSON：1mockMvc.perform(MockMvcRequestBuilders.get("/user/&#123;id&#125;", 1).accept(MediaType.APPLICATION_JSON));模拟HTTP请求头：1mockMvc.perform(MockMvcRequestBuilders.get("/user/&#123;id&#125;", 1).header(name, values));MockMvc处理返回结果期望成功调用，即HTTP Status为200：12mockMvc.perform(MockMvcRequestBuilders.get("/user/&#123;id&#125;", 1)) .andExpect(MockMvcResultMatchers.status().isOk());期望返回内容是application/json：12mockMvc.perform(MockMvcRequestBuilders.get("/user/&#123;id&#125;", 1)) .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON));检查返回JSON数据中某个值的内容：12mockMvc.perform(MockMvcRequestBuilders.get("/user/&#123;id&#125;", 1)) .andExpect(MockMvcResultMatchers.jsonPath("$.username").value("mrbird"));这里使用到了jsonPath，$代表了JSON的根节点。更多关于jsonPath的介绍可参考 https://github.com/json-path/JsonPath。判断Controller方法是否返回某视图：12mockMvc.perform(MockMvcRequestBuilders.post("/index")) .andExpect(MockMvcResultMatchers.view().name("index.html"));比较Model：1234mockMvc.perform(MockMvcRequestBuilders.get("/user/&#123;id&#125;", 1)) .andExpect(MockMvcResultMatchers.model().size(1)) .andExpect(MockMvcResultMatchers.model().attributeExists("password")) .andExpect(MockMvcResultMatchers.model().attribute("username", "mrbird"));比较forward或者redirect：12345mockMvc.perform(MockMvcRequestBuilders.get("/index")) .andExpect(MockMvcResultMatchers.forwardedUrl("index.html"));// 或者mockMvc.perform(MockMvcRequestBuilders.get("/index")) .andExpect(MockMvcResultMatchers.redirectedUrl("index.html"));比较返回内容，使用content()：1234567891011// 返回内容为hellomockMvc.perform(MockMvcRequestBuilders.get("/index")) .andExpect(MockMvcResultMatchers.content().string("hello"));// 返回内容是XML，并且与xmlCotent一样mockMvc.perform(MockMvcRequestBuilders.get("/index")) .andExpect(MockMvcResultMatchers.content().xml(xmlContent));// 返回内容是JSON ，并且与jsonContent一样mockMvc.perform(MockMvcRequestBuilders.get("/index")) .andExpect(MockMvcResultMatchers.content().json(jsonContent));输出响应结果：12mockMvc.perform(MockMvcRequestBuilders.get("/index")) .andDo(MockMvcResultHandlers.print());测试Service现有如下Service：1234567891011121314@Repository("userService")public class UserServiceImpl extends BaseService&lt;User&gt; implements UserService &#123; @Override public User findByName(String userName) &#123; Example example = new Example(User.class); example.createCriteria().andCondition("username=", userName); List&lt;User&gt; userList = this.selectByExample(example); if (userList.size() != 0) return userList.get(0); else return null; &#125;&#125;编写一个该Service的单元测试，测试findByName方法是否有效：12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class UserServiceTest &#123; @Autowired UserService userService; @Test public void test() &#123; User user = this.userService.findByName("scott"); Assert.assertEquals("用户名为scott", "scott", user.getUsername()); &#125;&#125;运行后，JUnit没有报错说明测试通过，即UserService的findByName方法可行。 此外，和在Controller中引用Service相比，在测试单元中对Service测试完毕后，数据能自动回滚，只需要在测试方法上加上@Transactional注解，比如:1234567891011@Test@Transactionalpublic void test() &#123; User user = new User(); user.setId(this.userService.getSequence("seq_user")); user.setUsername("JUnit"); user.setPasswd("123456"); user.setStatus("1"); user.setCreateTime(new Date()); this.userService.save(user);&#125;运行，测试通过，查看数据库发现数据并没有被插入，这样很好的避免了不必要的数据污染。测试Controller现有如下Controller：123456789101112131415@RestControllerpublic class UserController &#123; @Autowired UserService userService; @GetMapping("user/&#123;userName&#125;") public User getUserByName(@PathVariable(value = "userName") String userName) &#123; return this.userService.findByName(userName); &#125; @PostMapping("user/save") public void saveUser(@RequestBody User user) &#123; this.userService.saveUser(user); &#125;&#125;现在编写一个针对于该ControllergetUserByName(@PathVariable(value = &quot;userName&quot;) String userName)方法的测试类：123456789101112131415161718192021222324@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTest &#123; private MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setupMockMvc()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; @Test public void test() throws Exception &#123; mockMvc.perform( MockMvcRequestBuilders.get("/user/&#123;userName&#125;", "scott") .contentType(MediaType.APPLICATION_JSON_UTF8)) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.jsonPath("$.username").value("scott")) .andDo(MockMvcResultHandlers.print()); &#125;&#125;运行后，JUnit通过，控制台输出过程如下所示：12345678910111213141516171819202122232425262728293031323334MockHttpServletRequest: HTTP Method = GET Request URI = /user/scott Parameters = &#123;&#125; Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;Handler: Type = demo.springboot.test.controller.UserController Method = public demo.springboot.test.domain.User demo.springboot.test.controller.UserController.getUserByName(java.lang.String)Async: Async started = false Async result = nullResolved Exception: Type = nullModelAndView: View name = null View = null Model = nullFlashMap: Attributes = nullMockHttpServletResponse: Status = 200 Error message = null Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125; Content type = application/json;charset=UTF-8 Body = &#123;&quot;id&quot;:23,&quot;username&quot;:&quot;scott&quot;,&quot;passwd&quot;:&quot;ac3af72d9f95161a502fd326865c2f15&quot;,&quot;createTime&quot;:1514535399000,&quot;status&quot;:&quot;1&quot;&#125; Forwarded URL = null Redirected URL = null Cookies = []继续编写一个针对于该ControllersaveUser(@RequestBody User user)方法的测试类：1234567891011121314151617181920212223242526272829303132333435@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTest &#123; private MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Autowired ObjectMapper mapper; @Before public void setupMockMvc()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; @Test @Transactional public void test() throws Exception &#123; User user = new User(); user.setUsername("Dopa"); user.setPasswd("ac3af72d9f95161a502fd326865c2f15"); user.setStatus("1"); String userJson = mapper.writeValueAsString(user); mockMvc.perform( MockMvcRequestBuilders.post("/user/save") .contentType(MediaType.APPLICATION_JSON_UTF8) .content(userJson.getBytes())) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()); &#125;&#125;运行过程如下所示：12345678910111213141516171819202122232425262728293031323334MockHttpServletRequest: HTTP Method = POST Request URI = /user/save Parameters = &#123;&#125; Headers = &#123;Content-Type=[application/json;charset=UTF-8]&#125;Handler: Type = demo.springboot.test.controller.UserController Method = public void demo.springboot.test.controller.UserController.saveUser(demo.springboot.test.domain.User)Async: Async started = false Async result = nullResolved Exception: Type = nullModelAndView: View name = null View = null Model = nullFlashMap: Attributes = nullMockHttpServletResponse: Status = 200 Error message = null Headers = &#123;&#125; Content type = null Body = Forwarded URL = null Redirected URL = null Cookies = []值得注意的是，在一个完整的系统中编写测试单元时，可能需要模拟一个登录用户信息Session，MockMvc也提供了解决方案，可在初始化的时候模拟一个HttpSession：123456789101112131415private MockMvc mockMvc;private MockHttpSession session;@Autowiredprivate WebApplicationContext wac;@Beforepublic void setupMockMvc()&#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); session = new MockHttpSession(); User user =new User(); user.setUsername("Dopa"); user.setPasswd("ac3af72d9f95161a502fd326865c2f15"); session.setAttribute("user", user); &#125;源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/19.Spring-Boot-Testing]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中的JSON技术]]></title>
    <url>%2FSpring-Boot%20JSON.html</url>
    <content type="text"><![CDATA[平日里在项目中处理JSON一般用的都是阿里巴巴的Fastjson，后来发现使用Spring Boot内置的Jackson来完成JSON的序列化和反序列化操作也挺方便。Jackson不但可以完成简单的序列化和反序列化操作，也能实现复杂的个性化的序列化和反序列化操作。自定义ObjectMapper我们都知道，在Spring中使用@ResponseBody注解可以将方法返回的对象序列化成JSON，比如：12345678@RequestMapping("getuser")@ResponseBodypublic User getUser() &#123; User user = new User(); user.setUserName("mrbird"); user.setBirthday(new Date()); return user;&#125;User类：123456789public class User implements Serializable &#123; private static final long serialVersionUID = 6222176558369919436L; private String userName; private int age; private String password; private Date birthday; ...&#125;访问getuser页面输出：1&#123;"userName":"mrbird","age":0,"password":null,"birthday":1522634892365&#125;可看到时间默认以时间戳的形式输出，如果想要改变这个默认行为，我们可以自定义一个ObjectMapper来替代：12345678910111213141516import java.text.SimpleDateFormat;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.fasterxml.jackson.databind.ObjectMapper;@Configurationpublic class JacksonConfig &#123; @Bean public ObjectMapper getObjectMapper()&#123; ObjectMapper mapper = new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); return mapper; &#125;&#125;上面配置获取了ObjectMapper对象，并且设置了时间格式。再次访问getuser，页面输出：1&#123;"userName":"mrbird","age":0,"password":null,"birthday":"2018-04-02 10:14:24"&#125;序列化Jackson通过使用mapper的writeValueAsString方法将Java对象序列化为JSON格式字符串：1234567891011121314151617@AutowiredObjectMapper mapper;@RequestMapping("serialization")@ResponseBodypublic String serialization() &#123; try &#123; User user = new User(); user.setUserName("mrbird"); user.setBirthday(new Date()); String str = mapper.writeValueAsString(user); return str; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;反序列化使用@ResponseBody注解可以使对象序列化为JSON格式字符串，除此之外，Jackson也提供了反序列化方法。树遍历当采用树遍历的方式时，JSON被读入到JsonNode对象中，可以像操作XML DOM那样读取JSON。比如：1234567891011121314151617@AutowiredObjectMapper mapper;@RequestMapping("readjsonstring")@ResponseBodypublic String readJsonString() &#123; try &#123; String json = "&#123;\"name\":\"mrbird\",\"age\":26&#125;"; JsonNode node = this.mapper.readTree(json); String name = node.get("name").asText(); int age = node.get("age").asInt(); return name + " " + age; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;readTree方法可以接受一个字符串或者字节数组、文件、InputStream等， 返回JsonNode作为根节点，你可以像操作XML DOM那样操作遍历JsonNode以获取数据。解析多级JSON例子：1234String json = "&#123;\"name\":\"mrbird\",\"hobby\":&#123;\"first\":\"sleep\",\"second\":\"eat\"&#125;&#125;";;JsonNode node = this.mapper.readTree(json);JsonNode hobby = node.get("hobby");String first = hobby.get("first").asText();绑定对象我们也可以将Java对象和JSON数据进行绑定，如下所示：1234567891011121314151617@AutowiredObjectMapper mapper;@RequestMapping("readjsonasobject")@ResponseBodypublic String readJsonAsObject() &#123; try &#123; String json = "&#123;\"name\":\"mrbird\",\"age\":26&#125;"; User user = mapper.readValue(json, User.class); String name = user.getUserName(); int age = user.getAge(); return name + " " + age; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;Jackson注解Jackson包含了一些实用的注解：@JsonProperty@JsonProperty，作用在属性上，用来为JSON Key指定一个别名。12@JsonProperty("bth")private Date birthday;再次访问getuser页面输出：1&#123;"userName":"mrbird","age":0,"password":null,"bth":"2018-04-02 10:38:37"&#125;key birthday已经被替换为了bth。@Jsonlgnore@Jsonlgnore，作用在属性上，用来忽略此属性。12@JsonIgnoreprivate String password;再次访问getuser页面输出：1&#123;"userName":"mrbird","age":0,"bth":"2018-04-02 10:40:45"&#125;password属性已被忽略。@JsonIgnoreProperties@JsonIgnoreProperties，忽略一组属性，作用于类上，比如JsonIgnoreProperties({ &quot;password&quot;, &quot;age&quot; })。1234@JsonIgnoreProperties(&#123; "password", "age" &#125;)public class User implements Serializable &#123; ...&#125;再次访问getuser页面输出：1&#123;"userName":"mrbird","bth":"2018-04-02 10:45:34"&#125;@JsonFormat@JsonFormat，用于日期格式化，如：12@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")private Date birthday;@JsonNaming@JsonNaming，用于指定一个命名策略，作用于类或者属性上。Jackson自带了多种命名策略，你可以实现自己的命名策略，比如输出的key 由Java命名方式转为下面线命名方法 —— userName转化为user-name。1234@JsonNaming(PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy.class)public class User implements Serializable &#123; ...&#125;再次访问getuser页面输出：1&#123;"user_name":"mrbird","bth":"2018-04-02 10:52:12"&#125;@JsonSerialize@JsonSerialize，指定一个实现类来自定义序列化。类必须实现JsonSerializer接口，代码如下：123456789101112131415161718import java.io.IOException;import com.example.pojo.User;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.JsonSerializer;import com.fasterxml.jackson.databind.SerializerProvider;public class UserSerializer extends JsonSerializer&lt;User&gt; &#123; @Override public void serialize(User user, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException &#123; generator.writeStartObject(); generator.writeStringField("user-name", user.getUserName()); generator.writeEndObject(); &#125;&#125;上面的代码中我们仅仅序列化userName属性，且输出的key是user-name。 使用注解@JsonSerialize来指定User对象的序列化方式：1234@JsonSerialize(using = UserSerializer.class)public class User implements Serializable &#123; ...&#125;再次访问getuser页面输出：1&#123;"user-name":"mrbird"&#125;@JsonDeserialize@JsonDeserialize，用户自定义反序列化，同@JsonSerialize ，类需要实现JsonDeserializer接口。123456789101112131415161718192021import java.io.IOException;import com.example.pojo.User;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.JsonDeserializer;import com.fasterxml.jackson.databind.JsonNode;public class UserDeserializer extends JsonDeserializer&lt;User&gt; &#123; @Override public User deserialize(JsonParser parser, DeserializationContext context) throws IOException, JsonProcessingException &#123; JsonNode node = parser.getCodec().readTree(parser); String userName = node.get("user-name").asText(); User user = new User(); user.setUserName(userName); return user; &#125;&#125;使用注解@JsonDeserialize来指定User对象的序列化方式：1234@JsonDeserialize (using = UserDeserializer.class)public class User implements Serializable &#123; ...&#125;测试：12345678910111213141516@AutowiredObjectMapper mapper;@RequestMapping("readjsonasobject")@ResponseBodypublic String readJsonAsObject() &#123; try &#123; String json = "&#123;\"user-name\":\"mrbird\"&#125;"; User user = mapper.readValue(json, User.class); String name = user.getUserName(); return name; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;访问readjsonasobject，页面输出：1mrbird@JsonView@JsonView，作用在类或者属性上，用来定义一个序列化组。 比如对于User对象，某些情况下只返回userName属性就行，而某些情况下需要返回全部属性。 因此User对象可以定义成如下：12345678910111213141516171819public class User implements Serializable &#123; private static final long serialVersionUID = 6222176558369919436L; public interface UserNameView &#123;&#125;; public interface AllUserFieldView extends UserNameView &#123;&#125;; @JsonView(UserNameView.class) private String userName; @JsonView(AllUserFieldView.class) private int age; @JsonView(AllUserFieldView.class) private String password; @JsonView(AllUserFieldView.class) private Date birthday; ... &#125;User定义了两个接口类，一个为userNameView，另外一个为AllUserFieldView继承了userNameView接口。这两个接口代表了两个序列化组的名称。属性userName使用了@JsonView(UserNameView.class)，而剩下属性使用了@JsonView(AllUserFieldView.class)。Spring中Controller方法允许使用@JsonView指定一个组名，被序列化的对象只有在这个组的属性才会被序列化，代码如下：1234567891011@JsonView(User.UserNameView.class)@RequestMapping("getuser")@ResponseBodypublic User getUser() &#123; User user = new User(); user.setUserName("mrbird"); user.setAge(26); user.setPassword("123456"); user.setBirthday(new Date()); return user;&#125;访问getuser页面输出：1&#123;"userName":"mrbird"&#125;如果将@JsonView(User.UserNameView.class)替换为@JsonView(User.AllUserFieldView.class)，输出：1&#123;"userName":"mrbird","age":26,"password":"123456","birthday":"2018-04-02 11:24:00"&#125;因为接口AllUserFieldView继承了接口UserNameView所以userName也会被输出。集合的反序列化在Controller方法中，可以使用＠RequestBody将提交的JSON自动映射到方法参数上，比如：12345@RequestMapping("updateuser")@ResponseBodypublic int updateUser(@RequestBody List&lt;User&gt; list)&#123; return list.size();&#125;上面方法可以接受如下一个JSON请求，并自动映射到User对象上：1[&#123;"userName":"mrbird","age":26&#125;,&#123;"userName":"scott","age":27&#125;]Spring Boot 能自动识别出List对象包含的是User类，因为在方法中定义的泛型的类型会被保留在字节码中，所以Spring Boot能识别List包含的泛型类型从而能正确反序列化。有些情况下，集合对象并没有包含泛型定义，如下代码所示，反序列化并不能得到期望的结果。1234567891011121314@AutowiredObjectMapper mapper;@RequestMapping("customize")@ResponseBodypublic String customize() throws JsonParseException, JsonMappingException, IOException &#123; String jsonStr = "[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"; List&lt;User&gt; list = mapper.readValue(jsonStr, List.class); String msg = ""; for (User user : list) &#123; msg += user.getUserName(); &#125; return msg;&#125;访问customize，控制台抛出异常：java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.example.pojo.User这是因为在运行时刻，泛型己经被擦除了（不同于方法参数定义的泛型，不会被擦除）。为了提供泛型信息，Jackson提供了JavaType ，用来指明集合类型，将上述方法改为：123456789101112131415@AutowiredObjectMapper mapper;@RequestMapping("customize")@ResponseBodypublic String customize() throws JsonParseException, JsonMappingException, IOException &#123; String jsonStr = "[&#123;\"userName\":\"mrbird\",\"age\":26&#125;,&#123;\"userName\":\"scott\",\"age\":27&#125;]"; JavaType type = mapper.getTypeFactory().constructParametricType(List.class, User.class); List&lt;User&gt; list = mapper.readValue(jsonStr, type); String msg = ""; for (User user : list) &#123; msg += user.getUserName(); &#125; return msg;&#125;访问customize，页面输出：mrbirdscott。源码连接https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/18.Spring-Boot-Jackson]]></content>
      <tags>
        <tag>JSON</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jsoup防御XSS攻击]]></title>
    <url>%2FJsoup%20XSS.html</url>
    <content type="text"><![CDATA[跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。使用Jsoup可以有效的过滤不安全的代码。Jsoup使用白名单的机制来预防XSS攻击，比如白名单中规定只允许&lt;span&gt;标签的存在，那么其他标签都会被过滤掉。常见的XSS攻击比如页面的某个表单允许用户输入任意内容，当某个调皮的用户输入如下内容： 保存后，你会发现页面文字都变成了红色！或者输入&lt;script&gt;for(var i=0;i&lt;10;i++){alert(&quot;fuck you&quot;);}&lt;/script&gt;，保存后页面将弹窗10次！引入Jsoup使用Maven构建一个简单的Spring Boot项目，在pom中引入：12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;JsoupUtil创建一个JsoupUtil工具类：1234567891011121314151617181920212223242526272829import java.io.FileNotFoundException;import java.io.IOException;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.safety.Whitelist;/** * Xss过滤工具 * */public class JsoupUtil &#123; private static final Whitelist whitelist = Whitelist.basicWithImages(); /* * 配置过滤化参数,不对代码进行格式化 */ private static final Document.OutputSettings outputSettings = new Document.OutputSettings().prettyPrint(false); static &#123; /* * 富文本编辑时一些样式是使用style来进行实现的 比如红色字体 style="color:red;" 所以需要给所有标签添加style属性 */ whitelist.addAttributes(":all", "style"); &#125; public static String clean(String content) &#123; return Jsoup.clean(content, "", whitelist, outputSettings); &#125;&#125;这里采用的白名单为basicWithImages，Jsoup内置了几种常见的白名单供我们选择，如下表所示：白名单对象标签说明none无只保留标签内文本内容simpleTextb,em,i,strong,u简单的文本标签basica,b,blockquote,br,cite,code,dd,dl,dt,em,i,li,ol,p,pre,q,small,span,strike,strong,sub,sup,u,ul基本使用的标签basicWithImagesbasic 的基础上添加了 img 标签及 img 标签的 src,align,alt,height,width,title 属性基本使用的加上 img 标签relaxeda,b,blockquote,br,caption,cite,code,col,colgroup,dd,div,dl,dt,em,h1,h2,h3,h4,h5,h6,i,img,li,ol,p,pre,q,small,span,strike,strong,sub,sup,table,tbody,td,tfoot,th,thead,tr,u,ul在 basicWithImages 的基础上又增加了一部分部分标签XssHttpServletRequestWrapper创建一个XssHttpServletRequestWrapper，同过重写getParameter()，getParameterValues()和getHeader()方法来过滤HTTP请求中参数包含的恶意字符：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import org.apache.commons.lang.StringUtils;import cc.mrbird.common.util.JsoupUtil;/** * Jsoup过滤http请求，防止Xss攻击 * */public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; HttpServletRequest orgRequest = null; private boolean isIncludeRichText = false; public XssHttpServletRequestWrapper(HttpServletRequest request, boolean isIncludeRichText) &#123; super(request); orgRequest = request; this.isIncludeRichText = isIncludeRichText; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss过滤如果需要获得原始的值，则通过super.getParameterValues(name)来获取 * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ @Override public String getParameter(String name) &#123; if (("content".equals(name) || name.endsWith("WithHtml")) &amp;&amp; !isIncludeRichText) &#123; return super.getParameter(name); &#125; name = JsoupUtil.clean(name); String value = super.getParameter(name); if (StringUtils.isNotBlank(value)) &#123; value = JsoupUtil.clean(value); &#125; return value; &#125; @Override public String[] getParameterValues(String name) &#123; String[] arr = super.getParameterValues(name); if (arr != null) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = JsoupUtil.clean(arr[i]); &#125; &#125; return arr; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss过滤如果需要获得原始的值，则通过super.getHeaders(name)来获取 * getHeaderNames 也可能需要覆盖 */ @Override public String getHeader(String name) &#123; name = JsoupUtil.clean(name); String value = super.getHeader(name); if (StringUtils.isNotBlank(value)) &#123; value = JsoupUtil.clean(value); &#125; return value; &#125; /** * 获取原始的request */ public HttpServletRequest getOrgRequest() &#123; return orgRequest; &#125; /** * 获取原始的request的静态方法 */ public static HttpServletRequest getOrgRequest(HttpServletRequest req) &#123; if (req instanceof XssHttpServletRequestWrapper) &#123; return ((XssHttpServletRequestWrapper) req).getOrgRequest(); &#125; return req; &#125;&#125;XssFilter创建XssFilter，同过使用上面定义的XssHttpServletRequestWrapper类中的getParameter()等方法来保证参数得到了过滤：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang.BooleanUtils;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Xss攻击拦截器 * */public class XssFilter implements Filter &#123; private static Logger logger = LoggerFactory.getLogger(XssFilter.class); // 是否过滤富文本内容 private static boolean IS_INCLUDE_RICH_TEXT = false; public List&lt;String&gt; excludes = new ArrayList&lt;String&gt;(); @Override public void init(FilterConfig filterConfig) throws ServletException &#123; logger.info("------------ xss filter init ------------"); String isIncludeRichText = filterConfig.getInitParameter("isIncludeRichText"); if (StringUtils.isNotBlank(isIncludeRichText)) &#123; IS_INCLUDE_RICH_TEXT = BooleanUtils.toBoolean(isIncludeRichText); &#125; String temp = filterConfig.getInitParameter("excludes"); if (temp != null) &#123; String[] url = temp.split(","); for (int i = 0; url != null &amp;&amp; i &lt; url.length; i++) &#123; excludes.add(url[i]); &#125; &#125; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if (handleExcludeURL(req, resp)) &#123; chain.doFilter(request, response); return; &#125; XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request, IS_INCLUDE_RICH_TEXT); chain.doFilter(xssRequest, response); &#125; @Override public void destroy() &#123; &#125; private boolean handleExcludeURL(HttpServletRequest request, HttpServletResponse response) &#123; if (excludes == null || excludes.isEmpty()) &#123; return false; &#125; String url = request.getServletPath(); for (String pattern : excludes) &#123; Pattern p = Pattern.compile("^" + pattern); Matcher m = p.matcher(url); if (m.find()) return true; &#125; return false; &#125;&#125;Spring Boot中配置XssFilter使用JavaConfig的形式配置：12345678910111213@Beanpublic FilterRegistrationBean xssFilterRegistrationBean() &#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new XssFilter()); filterRegistrationBean.setOrder(1); filterRegistrationBean.setEnabled(true); filterRegistrationBean.addUrlPatterns("/*"); Map&lt;String, String&gt; initParameters = new HashMap&lt;String, String&gt;(); initParameters.put("excludes", "/favicon.ico,/img/*,/js/*,/css/*"); initParameters.put("isIncludeRichText", "true"); filterRegistrationBean.setInitParameters(initParameters); return filterRegistrationBean;&#125;参考文章：https://blog.csdn.net/u014411966/article/details/78164752https://www.jianshu.com/p/32abc12a175a?nomobile=yes]]></content>
      <tags>
        <tag>Security</tag>
        <tag>Jsoup</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯云部署Java Web项目小记]]></title>
    <url>%2Ftecent%20cloud%20Java-Web.html</url>
    <content type="text"><![CDATA[近期腾讯云推出云服务器团购优惠，刚好打算搭建个FEBS的演示环境，于是买了台120/年的云服务器，配置为1核2G、1M带宽，加赠50GB对象存储空间，系统为Ubuntu 16.04。部署过程中遇到一些新的问题，在这记录一下。工具准备搭建前先准备好远程登录软件，这类软件很多，这里推荐的是MobaXterm；文件的上传下载推荐使用FileZilla；数据库连接推荐使用Navicat Premium。Java环境搭建Java环境的搭建可参考（包括安装JDK，MySQL）：ubuntu16-04搭建Java开发环境。Tomcat下载后解压即可。远程连接MySQL开启MySQL远程连接的前提是在安装MySQL初始化的时候允许远程连接，然后输入以下命令：1mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY '123456' WITH GRANT OPTION;这段话的意思是允许任何IP以root账户远程访问，密码为123456。这里的密码设定只是为了演示，实际必须满足在初始化MySQL时密码强度的设定，即validate_password_policy：PolicyTests Performed0&nbsp;or&nbsp;LOWLength1&nbsp;or&nbsp;MEDIUMLength; numeric, lowercase/uppercase, and special characters2&nbsp;or&nbsp;STRONGLength; numeric, lowercase/uppercase, and special characters; dictionary file当密码强度和设定的不一致时，MySQL提示 Your password does not satisfy the current policy requirements错误。然后执行一下语句，使得设定生效：1mysql&gt; FLUSH PRIVILEGES;接下来使用Navicat远程连接MySQL，打开Navicat，新建MySQL连接：IP填云服务器的公网IP地址，用户名和密码为上面设定的root和123456。除此之外，还得填写SSH连接信息：IP填云服务器的公网IP地址，用户名和密码为云服务器的用户名和密码。点击连接测试后发现Navicat报错：Lost connection to MySQL server at &#39;reading initial communication packet&#39;, system error: 0打开MySQL配置：1vim /etc/mysql/mysql.conf.d/mysqld.cnf找到[mysqld]，添加skip-name-resolve，并将bind-address= 127.0.0.1配置注释掉即可，如下所示：然后再次点击Navicat连接测试即可成功。项目部署在本地将项目打包后，使用FileZilla将项目上传到Tomcat的webapp目录下，运行bin目录下的startup.sh脚本即可。域名绑定如下新增域名解析：记录值为云服务器的公网IP地址。配置解析后，就可使用 域名:端口号/项目名 的形式访问了。比如http://demo.mrbird.cc:80/febs/login，端口号默认就是80，所以可以简写为http://demo.mrbird.cc/febs/login。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Spring Boot和Shiro的后台管理系统FEBS]]></title>
    <url>%2FSpring-Boot%20Shiro%20FEBS.html</url>
    <content type="text"><![CDATA[FEBS是一个简单高效的后台权限管理系统。项目基础框架采用全新的Java Web开发框架 —— Spring Boot2.0.3，消除了繁杂的XML配置，使得二次开发更为简单；数据访问层采用Mybatis，同时引入了通用Mapper和PageHelper插件，可快速高效的对单表进行增删改查操作，消除了大量传统XML配置SQL的代码；安全框架采用时下流行的Apache Shiro，可实现对按钮级别的权限控制；前端页面使用Bootstrap构建，主题风格为时下Google最新设计语言Material Design，并提供多套配色以供选择。FEBS意指：Fast，Easy use，Beautiful和Safe。功能模块系统功能模块组成如下所示：1234567891011121314151617181920212223242526272829303132|-------------------------------------------|| ______ ______ ____ _____ || | ____| ____| _ \ / ____| || | |__ | |__ | |_) | (___ || | __| | __| | _ &lt; \___ \ || | | | |____| |_) |____) | || |_| |______|____/|_____/ || Spring-Boot-Version: 2.0.3.RELEASE ||-------------------------------------------|├─系统管理│ ├─字典管理│ ├─用户管理│ ├─菜单管理│ ├─角色管理│ └─部门管理├─系统监控│ ├─在线用户│ └─系统日志├─任务调度│ ├─定时任务│ └─调度日志└─网络资源 ├─One一个 │ ├─散文 │ ├─绘画 │ └─语文 ├─天气查询 ├─影视资讯 │ ├─即将上映 │ └─正在热映 └─每日一文技术选型后端基础框架：Spring Boot 2.0.3.RELEASE持久层框架：Mybatis 3.4.5安全框架：Apache Shiro 1.4.0摸板引擎：Thymeleaf 3.0.9.RELEASE数据库连接池：阿里巴巴Druid 1.1.10缓存框架：Ehcache日志打印：logback其他：fastjson，poi，javacsv，quartz等。前端基础框架：Bootstrap 4JavaScript框架：jQuery消息组件：Bootstrap notify提示框插件：SweetAlert2树形插件：jsTree树形表格插件：jqTreeGrid表格插件：BootstrapTable表单校验插件：jQuery-validate多选下拉框插件：multiple-select图表插件：Highcharts时间插件：daterangepicker开发环境语言：Java 8IDE：Eclipse Oxygen &amp; IDEA 2018.1.4(Ultimate Edition)依赖管理：Maven数据库：Oracle 11g &amp; MySQL5.7版本管理：SVN，git系统预览主题预览下载部署码云地址： https://gitee.com/github-16661027/projectGitHub 地址： https://github.com/wuyouzhuguli/FEBS下载后以Maven项目的方式导入Eclipse或者IDEA。开发时直接使用Spring Boot的入口类cc.mrbird.Application启动即可，访问地址localhost:8080，账号mrbird，密码123456。部署时，使用Maven将项目打包成febs.jar，然后使用命令java -jar febs.jar启动即可。在Linux下部署Spring Boot jar，并编写启停脚本可参考链接https://mrbird.cc/Linux%20Spring-Boot-jar.html。常见问题如何下载代码手动下载下载Oracle版本：分支选择master，然后点击 download zip即可，如下图所示：下载MySQL版本：分支选择mysql，然后点击 download zip即可，如下图所示：Git命令下载oracle版本：1git clone https://github.com/wuyouzhuguli/FEBS.git下载mysql版本：1git clone -b mysql https://github.com/wuyouzhuguli/FEBS.gitServlet依赖问题启动项目后报Servlet依赖未找到，比如：Post-processing of merged bean definition failed; nested exception is java.lang.NoClassDefFoundError: javax/servlet/ServletRequest出现这个问题一般是使用IDEA的同学，解决办法：打开pom文件，然后下图中的&lt;scope&gt;provided&lt;/scope&gt;去掉：表不存在这个问题一般出现在Linux环境下的MySQL数据库中，Linux下的MySQL数据库默认开启了大小写敏感，即t_user和T_USER是两个完全不同的表。解决办法：将代码中的表名大小写改为和数据库一致（不推荐！繁琐又容易出错）；关闭MySQL大小写敏感，可参考：https://blog.csdn.net/fdipzone/article/details/73692929。Oracle驱动依赖问题以ojdbc6为例，由于版权的原因，我们需要将ojdbc6.jar依赖安装到本地的maven仓库，然后才可以在pom中进行配置。下载ojdbc6.jar文件后，将其放到比较好找的目录下，比如D盘根目录。然后运行以下命令：1234567891011121314C:\Users\Administrator&gt;mvn install:install-file -Dfile=D:/ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=6.0 -Dpackaging=jar -DgeneratePom=true...[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---[INFO] Installing D:\ojdbc6.jar to D:\m2\repository\com\oracle\ojdbc6\6.0\ojdbc6-6.0.jar[INFO] Installing C:\Users\ADMINI~1\AppData\Local\Temp\mvninstall9103688544010617483.pom to D:\m2\repository\com\oracle\ojdbc6\6.0\ojdbc6-6.0.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.940 s[INFO] Finished at: 2017-08-13T15:06:38+08:00[INFO] Final Memory: 6M/145M[INFO] ------------------------------------------------------------------------接着在pom中引入：12345&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt;&lt;/dependency&gt;这里的groupid就是你之前安装时指定的-Dgroupid的值，artifactid就是你安装时指定的-Dartifactid的值，version也一样。]]></content>
      <tags>
        <tag>Shiro</tag>
        <tag>Java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形插件jsTree]]></title>
    <url>%2F%E6%A0%91%E5%BD%A2%E6%8F%92%E4%BB%B6jsTree.html</url>
    <content type="text"><![CDATA[jsTree是一款基于jQuery的树形控件，具有扩展性强，可编辑和可配置的特性，支持HTML，JSON和Ajax数据加载。jsTree官网地址：https://www.jstree.com/。这里主要介绍的是基于Ajax从数据库获取数据，然后生成树形菜单的用法。jsTree的皮肤可以自由定制，本文使用的是一款第三方jsTree皮肤。引入依赖因为其基于jQuery，所以引入jsTree依赖前得先引入jQuery：1234&lt;!-- jQuery --&gt;&lt;script src="https://cdn.bootcss.com/jquery/2.2.0/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- jsTree --&gt;&lt;script src="https://cdn.bootcss.com/jstree/3.3.5/jstree.min.js"&gt;&lt;/script&gt;由于第三方皮肤没有CDN地址，所以我们下载到本地后手动引入（可在文末得源码中获取）：1&lt;link rel="stylesheet" data-th-href="@&#123;css/jsTree/style.min.css&#125;"&gt;皮肤预览： 数据准备本文用到的数据表：12345678910111213141516171819202122-- ------------------------------ Table structure for T_DEPT-- ----------------------------DROP TABLE "MRBIRD"."T_DEPT";CREATE TABLE "MRBIRD"."T_DEPT" ("DEPT_ID" NUMBER NOT NULL ,"PARENT_ID" NUMBER NOT NULL ,"DEPT_NAME" VARCHAR2(100 BYTE) NOT NULL ,"ORDER_NUM" NUMBER NULL ,"CREATE_TIME" DATE NULL );-- ------------------------------ Records of T_DEPT-- ----------------------------INSERT INTO "MRBIRD"."T_DEPT" VALUES ('1', '0', '开发部', null, TO_DATE('2018-01-04 15:42:26', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('3', '1', '开发二部', null, TO_DATE('2018-01-04 15:42:29', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('5', '0', '人事部', null, TO_DATE('2018-01-04 15:42:32', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('2', '1', '开发一部', null, TO_DATE('2018-01-04 15:42:34', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('4', '0', '市场部', null, TO_DATE('2018-01-04 15:42:36', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('6', '0', '测试部', null, TO_DATE('2018-01-04 15:42:38', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('7', '2', '一部分部', null, TO_DATE('2018-03-16 10:46:31', 'YYYY-MM-DD HH24:MI:SS'));后端框架为Spring Boot + Mybatis（通用mapper），由于本文的重点是jsTree的使用，所以获取数据的细节和数据格式的处理这里不做阐述，具体可参考文末的源码。最终通过Ajax获取到的JSON数据如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&#123; "code": 0, "msg": &#123; "id": "0", "icon": null, "url": null, "text": "根节点", "state": &#123; "opened": true &#125;, "checked": true, "attributes": null, "children": [&#123; "id": "1", "icon": null, "url": null, "text": "开发部", "state": null, "checked": false, "attributes": null, "children": [&#123; "id": "3", "icon": null, "url": null, "text": "开发二部", "state": null, "checked": false, "attributes": null, "children": [], "parentId": "1", "hasParent": true, "hasChildren": false &#125;, &#123; "id": "2", "icon": null, "url": null, "text": "开发一部", "state": null, "checked": false, "attributes": null, "children": [&#123; "id": "7", "icon": null, "url": null, "text": "一部分部", "state": null, "checked": false, "attributes": null, "children": [], "parentId": "2", "hasParent": true, "hasChildren": false &#125;], "parentId": "1", "hasParent": true, "hasChildren": true &#125;], "parentId": "0", "hasParent": false, "hasChildren": true &#125;, &#123; "id": "5", "icon": null, "url": null, "text": "人事部", "state": null, "checked": false, "attributes": null, "children": [], "parentId": "0", "hasParent": false, "hasChildren": false &#125;, &#123; "id": "4", "icon": null, "url": null, "text": "市场部", "state": null, "checked": false, "attributes": null, "children": [], "parentId": "0", "hasParent": false, "hasChildren": false &#125;, &#123; "id": "6", "icon": null, "url": null, "text": "测试部", "state": null, "checked": false, "attributes": null, "children": [], "parentId": "0", "hasParent": false, "hasChildren": false &#125;], "parentId": "", "hasParent": false, "hasChildren": true &#125;&#125;基本使用方法使用Ajax从后台获取到如上所示格式的JSON数据（也就是r.msg）,然后使用jsTree生成树形控件：HTML:1&lt;div id="deptTree"&gt;&lt;/div&gt;JavaScript:1234567891011121314151617&lt;script data-th-inline="javascript"&gt;var ctx = [[@&#123;/&#125;]];$(function() &#123; createDeptTree();&#125;);function createDeptTree() &#123; $.post(ctx + "dept/tree", &#123;&#125;, function(r) &#123; var data = r.msg; $('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125; &#125;); &#125;)&#125;&lt;/script&gt;效果如下所示：div.deptTree{padding:1rem;width:25%;border:1px solid #efefef}$("#deptTree1").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]}})常用操作上面介绍了最基本的jsTree使用方法，下面开始介绍一些常用的jsTree操作。显示CheckboxJavaScript代码如下所示：123456$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox" ]&#125;);显示效果如下：$("#deptTree2").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]},plugins:["checkbox"]})此时，被选中的选项默认会有浅蓝色的背景，如果想要去除，只需将js代码改为：123456789$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox" ], "checkbox" : &#123; "keep_selected_style" : false &#125;&#125;);效果如下所示：$("#deptTree3").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]},plugins:["checkbox"],checkbox:{keep_selected_style:!1}})Wholerow插件该插件可以给选中的项目或者hover的项目添加一个行级别的背景色，js代码如下所示：123456$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox", "wholerow" ]&#125;);效果如下所示：$("#deptTree4").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]},plugins:["checkbox","wholerow"]})添加该插件后，控件前的虚线没了，具体原因未知=。=取消父子关联默认情况下，选中父节点后，其下的所有子节点也会跟着被选中，取消父子节点关联只需添加&quot;checkbox&quot;: {&quot;three_state&quot;: false}即可：123456789$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox" ], "checkbox": &#123; "three_state": false // 取消选择父节点后选中所有子节点 &#125;,&#125;);效果如下所示：$("#deptTree5").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]},plugins:["checkbox"],checkbox:{three_state:!1}})设置单选设置单选的前提是必须先取消父子关联，然后在core里添加：12345678910$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children, 'multiple': false // 取消多选 &#125;, "plugins" : [ "checkbox" ], "checkbox": &#123; "three_state": false // 取消选择父节点后选中所有子节点 &#125;,&#125;);效果如下所示：$("#deptTree6").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}],multiple:!1},plugins:["checkbox"],checkbox:{three_state:!1}})全部展开如果需要初始化控件的时候展开树，可调用jsTree的open_all()方法：12345678$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox" ]&#125;).on("loaded.jstree", function (event, data) &#123; $('#deptTree').jstree().open_all();&#125;);或者设置state：123456789$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox", "state" ], 'state': &#123; "opened": true, &#125;&#125;);效果如下所示：$("#deptTree7").jstree({core:{state:{opened:!0},data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]},plugins:["checkbox"]}).on("loaded.jstree",function(e,l){$("#deptTree7").jstree().open_all()})默认选中jsTree可以在初始化后默认选中某些节点：12345678910111213$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox" ], "checkbox": &#123; "three_state": false &#125;,&#125;).on("loaded.jstree", function (event, data) &#123; $('#deptTree').jstree().open_all(); $('#deptTree').jstree('select_node', [5, 7], true); console.log($('#deptTree').jstree(true).get_selected()); // ["5", "7"]&#125;);效果如下所示：$("#deptTree8").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]},plugins:["checkbox"],checkbox:{three_state:!1}}).on("loaded.jstree",function(e,l){$("#deptTree8").jstree().open_all(),$("#deptTree8").jstree("select_node",[5,7],!0)})绑定选取监听jsTree可以在选中和取消选中的时候绑定监听事件：123456789$('#deptTree').jstree(&#123; "core": &#123; 'data': data.children &#125;, "plugins" : [ "checkbox" ]&#125;).on("changed.jstree", function (e, data) &#123; console.log(data.changed.selected); // newly selected console.log(data.changed.deselected); // newly deselected&#125;);效果如下所示：$("#deptTree9").jstree({core:{data:[{id:"1",icon:null,url:null,text:"开发部",state:null,checked:!1,attributes:null,children:[{id:"3",icon:null,url:null,text:"开发二部",state:null,checked:!1,attributes:null,children:[],parentId:"1",hasParent:!0,hasChildren:!1},{id:"2",icon:null,url:null,text:"开发一部",state:null,checked:!1,attributes:null,children:[{id:"7",icon:null,url:null,text:"一部分部",state:null,checked:!1,attributes:null,children:[],parentId:"2",hasParent:!0,hasChildren:!1}],parentId:"1",hasParent:!0,hasChildren:!0}],parentId:"0",hasParent:!1,hasChildren:!0},{id:"5",icon:null,url:null,text:"人事部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"4",icon:null,url:null,text:"市场部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1},{id:"6",icon:null,url:null,text:"测试部",state:null,checked:!1,attributes:null,children:[],parentId:"0",hasParent:!1,hasChildren:!1}]},plugins:["checkbox","changed"],checkbox:{three_state:!1}}).on("loaded.jstree",function(e,l){$("#deptTree9").jstree().open_all()}).on("changed.jstree",function(e,l){l.changed.selected.length&&alert("选中节点ID："+l.changed.selected),l.changed.deselected.length&&alert("取消选中节点ID："+l.changed.deselected)})附录其他方法和属性可参考官方文档（官方文档写的比较抽象=。=）：https://www.jstree.com/api/。源码链接：https://drive.google.com/open?id=17rdibWmH9CunPP9vs9sQrJPj5FefzoHj]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery Validate表单校验插件]]></title>
    <url>%2FjQuery-Validate.html</url>
    <content type="text"><![CDATA[jQuery Validate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。官网地址为：https://jqueryvalidation.org/。引入依赖引入Bootstrap（jQuery Validate并不依赖于Bootstap，这里引入Bootstrap是为了用于构建表单）：1234567&lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css"&gt;&lt;!-- jQuery --&gt;&lt;script src="http://ajax.aspnetcdn.com/ajax/jquery/jquery-2.0.0.min.js"&gt;&lt;/script&gt;&lt;!-- popper --&gt;&lt;script src="https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js"&gt;&lt;/script&gt;&lt;!-- bootstrap --&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt;引入jQuery Validate依赖：1234&lt;!-- jquery-validate --&gt;&lt;script src="https://cdn.bootcss.com/jquery-validate/1.17.0/jquery.validate.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/jquery-validate/1.17.0/additional-methods.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/jquery-validate/1.17.0/localization/messages_zh.js"&gt;&lt;/script&gt;jquery.validate.js为核心代码；additional-methods.js为扩展的校验方法，一般我们自定义的校验方法都放到这个文件里；messages_zh.js为中文汉化包。默认校验规则jquery.validate.js为我们提供了一系列的默认校验规则：序号规则描述1required:true必须输入的字段。2remote:”check.php”使用 ajax 方法调用 check.php 验证输入值。3email:true必须输入正确格式的电子邮件。4url:true必须输入正确格式的网址。5date:true必须输入正确格式的日期。日期校验 ie6 出错，慎用。6dateISO:true必须输入正确格式的日期（ISO），例如：2009-06-23，1998/01/22。只验证格式，不验证有效性。7number:true必须输入合法的数字（负数，小数）。8digits:true必须输入整数。9creditcard:必须输入合法的信用卡号。10equalTo:”#field”输入值必须和 #field 相同。11accept:输入拥有合法后缀名的字符串（上传文件的后缀）。12maxlength:5输入长度最多是 5 的字符串（汉字算一个字符）。当为checkbox时，指选中个数。13minlength:10输入长度最小是 10 的字符串（汉字算一个字符）。当为checkbox时，指选中个数。14rangelength:[5,10]输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符）。当为checkbox时，指选中个数。15range:[5,10]输入值必须介于 5 和 10 之间。16max:5输入值不能大于 5。17min:10输入值不能小于 10。默认的提示（messages_zh.js）：12345678910111213141516171819$.extend($.validator.messages, &#123; required: "这是必填字段", remote: "请修正此字段", email: "请输入有效的电子邮件地址", url: "请输入有效的网址", date: "请输入有效的日期", dateISO: "请输入有效的日期 (YYYY-MM-DD)", number: "请输入有效的数字", digits: "只能输入数字", creditcard: "请输入有效的信用卡号码", equalTo: "你的输入不相同", extension: "请输入有效的后缀", maxlength: $.validator.format("最多可以输入 &#123;0&#125; 个字符"), minlength: $.validator.format("最少要输入 &#123;0&#125; 个字符"), rangelength: $.validator.format("请输入长度在 &#123;0&#125; 到 &#123;1&#125; 之间的字符串"), range: $.validator.format("请输入范围在 &#123;0&#125; 到 &#123;1&#125; 之间的数值"), max: $.validator.format("请输入不大于 &#123;0&#125; 的数值"), min: $.validator.format("请输入不小于 &#123;0&#125; 的数值")&#125;);自定义校验除了使用自带的校验方法外，我们也可以添加自己的校验方法，比如添加手机号码格式的校验方法：1234jQuery.validator.addMethod("checkPhone", function(value, element, params) &#123; var checkPhone = /^0?(13[0-9]|15[012356789]|17[013678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/; return this.optional(element) || (checkPhone.test(value));&#125;, "请输入正确的手机号");value值当前校验的值，element为校验的元素，params为校验参数。自定义的校验方法一般都添加到additional-methods.js。错误信息提示当校验不通过时，默认错误信息会插入到校验元素的后面，但当校验元素是radio或者checkbox的时候，错误信息的位置需要进行调整：调整方法：12345678errorPlacement: function(error, element) &#123; //指定错误信息位置 if (element.is(':radio') || element.is(':checkbox')) &#123; //如果是radio或checkbox var eid = element.attr('name'); //获取元素的name属性 error.appendTo(element.parent().parent()); //将错误信息添加当前元素的父元素的父元素后面(根据实际html结构进行调整) &#125; else &#123; error.insertAfter(element); &#125;&#125;调整后： 后端校验remote选项用于后端校验，比如校验用户名的唯一性等：12345678910remote: &#123; url: "user/checkUserName", type: "get", dataType: "json", data: &#123; username: function() &#123; return $("input[name='username']").val(); &#125; &#125;&#125;后端返回boolean类型即可。实例编写个form表单：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;form class="form"&gt; &lt;div class="form-group"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type="text" class="form-control" name="userName" placeholder="用户名"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type="password" class="form-control" name="password" placeholder="密码"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;确认密码&lt;/label&gt; &lt;input type="password" class="form-control" name="confirm_password" placeholder="请再次输入密码"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;手机号&lt;/label&gt; &lt;input type="text" class="form-control" name="phone" placeholder="手机号"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;邮箱&lt;/label&gt; &lt;input type="text" class="form-control" name="email" placeholder="邮箱"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;地址&lt;/label&gt; &lt;select class="form-control" name="address"&gt; &lt;option value=""&gt;- 请选择 -&lt;/option&gt; &lt;option value="1"&gt;福州&lt;/option&gt; &lt;option value="2"&gt;厦门&lt;/option&gt; &lt;option value="3"&gt;龙岩&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;爱好&lt;/label&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="checkbox" name="hobby" value="1"&gt; &lt;label class="form-check-label"&gt;游泳&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="checkbox" name="hobby" value="2"&gt; &lt;label class="form-check-label"&gt;唱歌&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="checkbox" name="hobby" value="3"&gt; &lt;label class="form-check-label"&gt;睡觉&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;性别&lt;/label&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="sex" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="sex" value="2"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;上传图片&lt;/label&gt; &lt;input type="file" class="form-control-file" name="file"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input type="checkbox" class="form-check-input" name="subscribe"&gt; &lt;label class="form-check-label"&gt;订阅&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;订阅方式&lt;/label&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="stype" value="1"&gt; &lt;label class="form-check-label"&gt;RSS&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="stype" value="2"&gt; &lt;label class="form-check-label"&gt;邮箱订阅&lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;button id="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;&lt;button id="reset" class="btn btn-danger"&gt;Reset&lt;/button&gt;绑定校验规则等：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111jQuery.validator.addMethod("checkPhone", function(value, element, params) &#123; var checkPhone = /^0?(13[0-9]|15[012356789]|17[013678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/; return this.optional(element) || (checkPhone.test(value));&#125;, "请输入正确的手机号");$(function() &#123; validateRule(); $("#submit").on('click', function() &#123; var validator = $(".form").validate(); var flag = validator.form(); if (flag) &#123; alert("true"); &#125; else &#123; alert("false"); &#125; &#125;); $("#reset").on('click', function() &#123; var validator = $(".form").validate(); validator.resetForm(); &#125;);&#125;);function validateRule() &#123; $(".form").validate(&#123; rules: &#123; userName: &#123; required: true, minlength: 3, maxlength: 10 &#125;, password: &#123; required: true, minlength: 5 &#125;, confirm_password: &#123; required: true, minlength: 5, equalTo: "[name='password']" &#125;, address: &#123; required: true &#125;, phone: &#123; checkPhone: true &#125;, email: &#123; required: true, email: true &#125;, hobby: &#123; required: true, minlength: 2 &#125;, sex: &#123; required: true &#125;, file: &#123; required: true, accept: "image/jpg,image/jpeg,image/png,image/gif" &#125;, stype: &#123; required: "[name='subscribe']:checked" &#125; &#125;, messages: &#123; userName: &#123; required: "请输入用户名", minlength: "用户名长度不能少于&#123;0&#125;个字符", maxlength: "用户名长度不能超过&#123;0&#125;个字符" &#125;, password: &#123; required: "请输入密码", minlength: "密码长度不能小于&#123;0&#125;个字母" &#125;, confirm_password: &#123; required: "请输入密码", minlength: "密码长度不能小于&#123;0&#125;个字母", equalTo: "两次密码输入不一致" &#125;, address: &#123; required: "请选择地址" &#125;, email: &#123; required: "请输入邮箱", email: "邮箱格式不正确" &#125;, hobby: &#123; required: "请选择爱好", minlength: "至少选择&#123;0&#125;项爱好" &#125;, sex: &#123; required: "请选择性别" &#125;, file: &#123; required: "请上传附件", accept: "只支持jpg，jpeg，png或gif后缀的图片" &#125;, stype: &#123; required: "请选择订阅方式" &#125; &#125;, errorPlacement: function(error, element) &#123; if (element.is(':radio') || element.is(':checkbox')) &#123; var eid = element.attr('name'); error.appendTo(element.parent().parent()); &#125; else &#123; error.insertAfter(element); &#125; &#125; &#125;);&#125;这里提下关于附件的格式问题，其限定的不是文件格式后缀，而是文件的MIME类型，具体可参考：BootstrapValidator指南中列举的MIME类型。演示效果如下：See the Pen jquery-validation by wuyouzhuguli (@mrbird) on CodePen.源码地址：https://drive.google.com/open?id=1lyUVNyX5VkxN3GqQz0_y_oBX3twMxPAh其他使用事项可参考：http://www.runoob.com/jquery/jquery-plugin-validate.htmlhttps://jqueryvalidation.org/documentation/]]></content>
      <tags>
        <tag>Bootstrap</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形表格插件jQuery TreeGrid]]></title>
    <url>%2FjQuery-TreeGrid.html</url>
    <content type="text"><![CDATA[借助树形表格插件jQuery TreeGrid，我们可以以表格的形式来展现那些带有层级关系的数据，比如部门上下级，菜单表等。jQuery TreeGrid的官方地址为：http://maxazan.github.io/jquery-treegrid/。由于这里的使用环境为bootstrap，原始的jQuery TreeGrid插件显得不是那么的灵活和美观，为了在bootstrap中无缝的使用该插件，这里引用了经过二次封装的jQuery TreeGrid插件jquery.treegrid.extension.js，作者为：http://www.cnblogs.com/landeanfen/p/6776152.html。引入依赖首先先引入bootstrap相关的依赖：1234&lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css"&gt;&lt;script src="http://code.jquery.com/jquery-2.0.0.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt;然后引入jQuery TreeGrid依赖以及jquery.treegrid.extension.js ：12345&lt;!-- jquery.treegrid --&gt;&lt;link rel="stylesheet" data-th-href="@&#123;css/jqTreeGrid/jquery.treegrid.css&#125;"&gt;&lt;script data-th-src="@&#123;js/jqTreeGrid/jquery.treegrid.js&#125;"&gt;&lt;/script&gt;&lt;!-- jquery.treegrid.extension --&gt;&lt;script data-th-src="@&#123;js/jqTreeGrid/jquery.treegrid.extension.js&#125;"&gt;&lt;/script&gt;因为bootstrap没有自带图标组件，为了下文的使用，这里引入font-awesome:1&lt;link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet"&gt;数据使用的数据表：12345678910111213141516171819202122-- ------------------------------ Table structure for T_DEPT-- ----------------------------DROP TABLE "MRBIRD"."T_DEPT";CREATE TABLE "MRBIRD"."T_DEPT" ("DEPT_ID" NUMBER NOT NULL ,"PARENT_ID" NUMBER NOT NULL ,"DEPT_NAME" VARCHAR2(100 BYTE) NOT NULL ,"ORDER_NUM" NUMBER NULL ,"CREATE_TIME" DATE NULL );-- ------------------------------ Records of T_DEPT-- ----------------------------INSERT INTO "MRBIRD"."T_DEPT" VALUES ('7', '2', '开发一部福州分部', null, TO_DATE('2018-03-15 09:32:15', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('1', '0', '开发部', null, TO_DATE('2018-01-04 15:42:26', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('3', '1', '开发二部', null, TO_DATE('2018-01-04 15:42:29', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('5', '0', '人事部', null, TO_DATE('2018-01-04 15:42:32', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('2', '1', '开发一部', null, TO_DATE('2018-01-04 15:42:34', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('4', '0', '市场部', null, TO_DATE('2018-01-04 15:42:36', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_DEPT" VALUES ('6', '0', '测试部', null, TO_DATE('2018-01-04 15:42:38', 'YYYY-MM-DD HH24:MI:SS'));后端框架为Spring Boot + MyBatis（通用mapper和pagehelper插件），获取数据的具体细节这里不再描述，可参考文末的源码。使用编写一个简单的页面：1234567891011121314151617&lt;form class="form"&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;部门名称：&lt;/span&gt; &lt;div class="form-group"&gt; &lt;input type="text" name="deptName" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col"&gt; &lt;button type="button" class="btn btn-success" onclick="refresh()"&gt;重置&lt;/button&gt; &lt;button type="button" class="btn btn-primary" onclick="search()"&gt;搜索&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;table id="deptTreeTable" data-mobile-responsive="true" class="mb-bootstrap-table text-nowrap"&gt;&lt;/table&gt;jQuery TreeGrid插件的使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var ctx = [[@&#123;/&#125;]];$(function() &#123; initDeptTreeTable();&#125;);function initDeptTreeTable() &#123; $('#deptTreeTable').bootstrapTreeTable(&#123; id: 'deptId', // 选取记录返回的值 code: 'deptId', // 用于设置父子关系 parentCode: 'parentId', // 用于设置父子关系 rootCodeValue: null, //设置根节点code值----可指定根节点，默认为null,"",0,"0" data: [], // 构造table的数据集合，如果是ajax请求则不必填写 type: "GET", // 请求数据的ajax类型 url: ctx + 'dept/list', // 请求数据的ajax的url ajaxParams: &#123; deptName: $(".form").find("input[name='deptName']").val().trim() &#125;, // 请求数据的ajax的data属性 expandColumn: 2, // 在哪一列上面显示展开按钮 expandAll: true, // 是否全部展开 striped: true, // 是否各行渐变色 columns: [&#123; field: 'selectItem', checkbox: true &#125;, &#123; title: '编号', field: 'deptId', width: '50px' &#125;, &#123; title: '名称', field: 'deptName' &#125;, &#123; title: '创建时间', field: 'createTime' &#125; ], // 设置列 toolbar: null, //顶部工具条 height: 0, expanderExpandedClass: 'fa fa-chevron-down', // 展开的按钮的图标 expanderCollapsedClass: 'fa fa-chevron-up' // 缩起的按钮的图标 &#125;);&#125;// 搜索方法function search() &#123; initDeptTreeTable();&#125;// 重置方法function refresh() &#123; $(".form")[0].reset(); search();&#125;参数说明如注解所示，其中expanderExpandedClass和expanderCollapsedClass为展开和缩起的图标，这里使用的是文章开始引入的font-awesome。后端返回的JSON数据如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243[&#123; "deptId": 1, "parentId": 0, "deptName": "开发部", "orderNum": null, "createTime": 1515051746000&#125;, &#123; "deptId": 2, "parentId": 1, "deptName": "开发一部", "orderNum": null, "createTime": 1515051754000&#125;, &#123; "deptId": 3, "parentId": 1, "deptName": "开发二部", "orderNum": null, "createTime": 1515051749000&#125;, &#123; "deptId": 4, "parentId": 0, "deptName": "市场部", "orderNum": null, "createTime": 1515051756000&#125;, &#123; "deptId": 5, "parentId": 0, "deptName": "人事部", "orderNum": null, "createTime": 1515051752000&#125;, &#123; "deptId": 6, "parentId": 0, "deptName": "测试部", "orderNum": null, "createTime": 1515051758000&#125;, &#123; "deptId": 7, "parentId": 2, "deptName": "开发一部福州分部", "orderNum": null, "createTime": 1521077535000&#125;]页面显示效果如下： 其实，在实际使用中我们并不需要配置那么多参数，查看jquery.treegrid.extension.js源码可发现，其默认参数为：12345678910111213141516171819$.fn.bootstrapTreeTable.defaults = &#123; id: 'menuId', code: 'menuId', parentCode: 'parentId', rootCodeValue: null, data: [], type: "GET", url: null, ajaxParams: &#123;&#125;, expandColumn: null, expandAll: true, striped: false, columns: [], toolbar: null, height: 0, expanderExpandedClass: 'fa fa-chevron-down', expanderCollapsedClass: 'fa fa-chevron-up'&#125;;所以使用的时候只需配置几个我们关注的参数即可：1234567891011121314151617181920212223242526272829$('#deptTreeTable').bootstrapTreeTable(&#123; id: 'deptId', code: 'deptId', parentCode: 'parentId', url: ctx + 'dept/list', ajaxParams: &#123; deptName: $(".form").find("input[name='deptName']").val().trim() &#125;, expandColumn: 2, striped: true, columns: [&#123; field: 'selectItem', checkbox: true &#125;, &#123; title: '编号', field: 'deptId', width: '50px' &#125;, &#123; title: '名称', field: 'deptName' &#125;, &#123; title: '创建时间', field: 'createTime' &#125; ]&#125;);jquery.treegrid.extension.js还封装了一些方法：12345678910111213141516171819202122232425262728293031$.fn.bootstrapTreeTable.methods = &#123; // 返回选中记录的id（返回的id由配置中的id属性指定） // 为了兼容bootstrap-table的写法，统一返回数组，这里只返回了指定的id getSelections: function(target, data) &#123; // 所有被选中的记录input var _ipt = target.find("tbody").find("tr").find("input[name='select_item']:checked"); var chk_value = []; // 如果是radio if (_ipt.attr("type") == "radio") &#123; chk_value.push(&#123; id: _ipt.val() &#125;); &#125; else &#123; _ipt.each(function(_i, _item) &#123; chk_value.push(&#123; id: $(_item).val() &#125;); &#125;); &#125; return chk_value; &#125;, // 刷新记录 refresh: function(target, parms) &#123; if (parms) &#123; target.load(parms); &#125; else &#123; target.load(); &#125; &#125;, // 重置表格视图 resetHeight: function(target, height) &#123; target.find("tbody").css("height", height + 'px'); &#125; // 组件的其他方法也可以进行类似封装........&#125;;比如获取选中行的数据可使用getSelections：1$("#deptTreeTable").bootstrapTreeTable("getSelections");附录源码链接：https://drive.google.com/open?id=1fgYRpD5CNCn4gj06_MiLm-g2fCjsSYtk]]></content>
      <tags>
        <tag>Bootstrap</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap Table学习指南]]></title>
    <url>%2FBootstrap-Table%20guide.html</url>
    <content type="text"><![CDATA[Bootstrap Table是一款基于Bootstrap的jQuery表格插件，通过简单的设置，就可以拥有强大的单选、多选、排序、分页，以及编辑、导出、过滤、扩展等等的功能。作者地址：https://github.com/wenzhixin/bootstrap-table。这里简单介绍下使用方法以及对其进行二次封装，方便日常开发使用。准备工作因为基于Bootstrap，所以先引入Bootstrap依赖：1234&lt;link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css"&gt;&lt;script src="http://code.jquery.com/jquery-2.0.0.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt;然后引入Bootstrap Table依赖：123456&lt;!-- Latest compiled and minified CSS --&gt;&lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bootstrap-table/1.9.0/bootstrap-table.min.css"&gt;&lt;!-- Latest compiled and minified JavaScript --&gt;&lt;script src="//cdnjs.cloudflare.com/ajax/libs/bootstrap-table/1.9.0/bootstrap-table.min.js"&gt;&lt;/script&gt;&lt;!-- Latest compiled and minified Locales --&gt;&lt;script src="//cdnjs.cloudflare.com/ajax/libs/bootstrap-table/1.9.0/locale/bootstrap-table-zh-CN.min.js"&gt;&lt;/script&gt;数据准备本例中使用到的数据表SQL如下：123456789101112131415161718192021222324-- ------------------------------ Table structure for T_ROLE-- ----------------------------DROP TABLE "MRBIRD"."T_ROLE";CREATE TABLE "MRBIRD"."T_ROLE" ("ROLE_ID" NUMBER NOT NULL ,"ROLE_NAME" VARCHAR2(100 BYTE) NOT NULL ,"REMARK" VARCHAR2(100 BYTE) NULL ,"CREATE_TIME" DATE NOT NULL ,"MODIFY_TIME" DATE NULL );-- ------------------------------ Records of T_ROLE-- ----------------------------INSERT INTO "MRBIRD"."T_ROLE" VALUES ('23', '用户管理员', '负责用户的增删改操作', TO_DATE('2018-01-09 15:32:41', 'YYYY-MM-DD HH24:MI:SS'), null);INSERT INTO "MRBIRD"."T_ROLE" VALUES ('1', '管理员', '管理员', TO_DATE('2017-12-27 16:23:11', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2018-02-24 16:01:45', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_ROLE" VALUES ('2', '测试账号', '测试账号', TO_DATE('2017-12-27 16:25:09', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2018-01-23 09:11:11', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_ROLE" VALUES ('3', '注册账户', '注册账户，只可查看，不可操作', TO_DATE('2017-12-29 16:00:15', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2018-02-24 17:33:45', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_ROLE" VALUES ('24', '系统监控员', '可查看系统监控信息，但不可操作', TO_DATE('2018-01-09 15:52:01', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2018-03-07 19:05:33', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_ROLE" VALUES ('25', '用户查看', '查看用户，无相应操作权限', TO_DATE('2018-01-09 15:56:30', 'YYYY-MM-DD HH24:MI:SS'), null);INSERT INTO "MRBIRD"."T_ROLE" VALUES ('63', '影院工作者', '可查看影视信息', TO_DATE('2018-02-06 08:48:28', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2018-03-07 19:05:26', 'YYYY-MM-DD HH24:MI:SS'));INSERT INTO "MRBIRD"."T_ROLE" VALUES ('64', '天气预报员', '可查看天气预报信息', TO_DATE('2018-02-27 08:47:04', 'YYYY-MM-DD HH24:MI:SS'), null);INSERT INTO "MRBIRD"."T_ROLE" VALUES ('65', '文章审核', '文章类', TO_DATE('2018-02-27 08:48:01', 'YYYY-MM-DD HH24:MI:SS'), TO_DATE('2018-03-13 11:20:34', 'YYYY-MM-DD HH24:MI:SS'));后端框架为Spring Boot + MyBatis（通用mapper和pagehelper插件），获取数据的具体细节这里不再描述，可参考文末的源码。使用编写一个简单的页面：123456789101112131415161718&lt;form class="form"&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;角色：&lt;/span&gt; &lt;div class="form-group"&gt; &lt;input type="text" name="roleName" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col"&gt;&lt;/div&gt; &lt;div class="col"&gt; &lt;button type="button" class="btn btn-success" onclick="refresh()"&gt;重置&lt;/button&gt; &lt;button type="button" class="btn btn-primary" onclick="search()"&gt;搜索&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;table id="roleTable" data-mobile-responsive="true" class="mb-bootstrap-table text-nowrap"&gt;&lt;/table&gt;Bootstrap Table插件的使用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$('#roleTable').bootstrapTable(&#123; method: 'get', // 服务器数据的请求方式 get or post url: ctx + "bootstrap-table/list", // 服务器数据的加载地址 striped: true, //是否显示行间隔色 cache: false, //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*） pagination: true, //是否显示分页（*） sortable: false, //是否启用排序 sidePagination: "server", //分页方式：client客户端分页，server服务端分页（*） pageNumber: 1, //初始化加载第一页，默认第一页 pageSize: 5, //每页的记录行数（*） pageList: [5, 25, 50, 100], //可供选择的每页的行数（*） strictSearch: true, minimumCountColumns: 2, //最少允许的列数 clickToSelect: true, //是否启用点击选中行 uniqueId: "ID", //每一行的唯一标识，一般为主键列 cardView: false, detailView: false, //是否显示详细视图 smartDisplay: false, queryParams: function(params) &#123; return &#123; pageSize: params.limit, pageNum: params.offset / params.limit + 1, roleName: $(".form").find("input[name='roleName']").val().trim(), &#125;; &#125;, columns: [&#123; checkbox: true &#125;,&#123; field: 'roleId', title: '角色ID' &#125;,&#123; field: 'roleName', title: '角色' &#125;, &#123; field: 'remark', title: '描述' &#125;, &#123; field: 'createTime', title: '创建时间' &#125;, &#123; field: 'modifyTime', title: '修改时间' &#125;]&#125;);// 搜索方法function search() &#123; $('#roleTable').bootstrapTable('refresh');&#125;// 重置方法function refresh() &#123; $(".form")[0].reset(); search();&#125;后端返回的JSON数据如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; "total": 9, "rows": [&#123; "roleId": 1, "roleName": "管理员", "remark": "管理员", "createTime": 1514362991000, "modifyTime": 1519459305000 &#125;, &#123; "roleId": 2, "roleName": "测试账号", "remark": "测试账号", "createTime": 1514363109000, "modifyTime": 1516669871000 &#125;, &#123; "roleId": 3, "roleName": "注册账户", "remark": "注册账户，只可查看，不可操作", "createTime": 1514534415000, "modifyTime": 1519464825000 &#125;, &#123; "roleId": 23, "roleName": "用户管理员", "remark": "负责用户的增删改操作", "createTime": 1515483161000, "modifyTime": null &#125;, &#123; "roleId": 24, "roleName": "系统监控员", "remark": "可查看系统监控信息，但不可操作", "createTime": 1515484321000, "modifyTime": 1520420733000 &#125;, &#123; "roleId": 25, "roleName": "用户查看", "remark": "查看用户，无相应操作权限", "createTime": 1515484590000, "modifyTime": null &#125;, &#123; "roleId": 63, "roleName": "影院工作者", "remark": "可查看影视信息", "createTime": 1517878108000, "modifyTime": 1520420726000 &#125;, &#123; "roleId": 64, "roleName": "天气预报员", "remark": "可查看天气预报信息", "createTime": 1519692424000, "modifyTime": null &#125;, &#123; "roleId": 65, "roleName": "文章审核", "remark": "文章类", "createTime": 1519692481000, "modifyTime": 1520911234000 &#125;]&#125;页面显示效果如下： 二次封装实际使用中除了几个常用的参数比如url，queryParams，columns等等之外，剩下的参数一般默认就好，所以接下来对其进行二次封装，使得开发中更为方便。123456789101112131415161718192021222324252627282930313233343536373839404142434445var $Mrbird = (function() &#123; var bootstrapTable_default = &#123; method: 'get', striped: true, cache: false, pagination: true, sortable: false, sidePagination: "server", pageNumber: 1, pageSize: 5, pageList: [5, 10, 25, 50, 100], strictSearch: true, showColumns: false, minimumCountColumns: 2, clickToSelect: true, uniqueId: "ID", cardView: false, detailView: false, smartDisplay: false, queryParams: function(params) &#123; return &#123; pageSize: params.limit, pageNum: params.offset / params.limit + 1, &#125;; &#125; &#125; function _initTable(id, settings) &#123; var params = $.extend(&#123;&#125;, bootstrapTable_default, settings); if (typeof params.url == 'undefined') &#123; throw '初始化表格失败，请配置url参数！'; &#125; if (typeof params.columns == 'undefined') &#123; throw '初始化表格失败，请配置columns参数！'; &#125; $('#' + id).bootstrapTable(params); &#125; return &#123; initTable: function(id, settings) &#123; _initTable(id, settings); &#125;, refreshTable: function(id) &#123; $('#' + id).bootstrapTable('refresh'); &#125; &#125;&#125;)($);这样，在使用Bootstap Table插件的时候只需要像下面这样书写即可：123456789101112131415161718192021222324252627282930313233$(function() &#123; var settings = &#123; url: ctx + "bootstrap-table/list", queryParams: function(params) &#123; return &#123; pageSize: params.limit, pageNum: params.offset / params.limit + 1, roleName: $(".form").find("input[name='roleName']").val().trim(), &#125;; &#125;, columns: [&#123; checkbox: true &#125;, &#123; field: 'roleId', title: '角色ID' &#125;, &#123; field: 'roleName', title: '角色' &#125;, &#123; field: 'remark', title: '描述' &#125;, &#123; field: 'createTime', title: '创建时间' &#125;, &#123; field: 'modifyTime', title: '修改时间' &#125; ] &#125; $Mrbird.initTable('roleTable', settings);&#125;);附录Bootstap Table除了上面介绍的内容外，其还包含了许多别的特性，可参考官方文档：http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/。源码链接：https://drive.google.com/open?id=1qEVgDDBfbdaVJ1FSckzQr6RAUyGF7k6J]]></content>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下部署Spring Boot jar]]></title>
    <url>%2FLinux%20Spring-Boot-jar.html</url>
    <content type="text"><![CDATA[部署Spring Boot项目可以使用Maven命令mvn:clean package将项目打包成只执行的jar文件，然后使用命令java -jar XX.jar来执行。但这样做无法将shell命令行释放，关闭terminal后项目也随之关闭了。这里介绍在Linux系统中后台运行Spring Boot jar文件的方法。实现这个功能主要依赖于Linux的nohup命令。nohup命令可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。nohup语法：123nohup 命令用途：不挂断地运行命令。语法：nohup Command [ Arg … ][ &amp; ]所以只需要在启动命令前加上nohup命令，末尾加上&amp;即可：nohup java -jar XX.jar &amp;。为了方便，我们可以编写启动脚本start.sh：1nohup java -jar XX.jar &amp;关停脚本stop.sh：12345678PID=`ps -ef | grep sms-2.0.jar | grep -v grep | awk '&#123;print $2&#125;'`if [ -z "$PID" ]then echo Application is already stoppedelse echo kill $PID kill -9 $PIDfi重启脚本run.sh：1234echo stop applicationsource stop.shecho start applicationsource start.sh在编写shell脚本的过程中遇到了两个问题：执行.sh文件提示权限不足：解决办法：执行命令chmod u+x XX.sh赋予当前用于可执行的权限即可。提示/bin/bash^M: bad interpreter: 没有那个文件或目录。问题出现的原因是shell脚本是在windows中编写的然后上传到Linux中的，出现了兼容性问题。解决办法：执行vim XX.sh打开shell文件，然后切换到命令模式，执行:set fileformat=unix后保存退出即可。使用了nohup命令后，会在jar文件目录下生成一个nohup.out文件，可通过其观察当前项目的运行情况：1234567891011121314151617181920$ ll总用量 76612drwxrwxr-x 2 zjrun zjrun 4096 2月 8 08:49 log-rw------- 1 zjrun zjrun 58695723 2月 8 10:15 nohup.out-rwxrw-r-- 1 zjrun zjrun 88 2月 7 15:17 run.sh-rw-rw-r-- 1 zjrun zjrun 19730199 2月 8 10:11 sms-1.0.jar-rwxrw-r-- 1 zjrun zjrun 60 2月 7 15:22 start.sh-rwxrw-r-- 1 zjrun zjrun 184 2月 7 15:19 stop.sh$ tail -10f nohup.out 10:14:31.309 logback [main] INFO o.s.j.e.a.AnnotationMBeanExporter - Registering beans for JMX exposure on startup10:14:31.478 logback [main] INFO o.a.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8963"]10:14:31.498 logback [main] INFO o.a.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8963"]10:14:31.506 logback [main] INFO o.a.tomcat.util.net.NioSelectorPool - Using a shared selector for servlet write/read10:14:31.634 logback [main] INFO o.s.b.c.e.t.TomcatEmbeddedServletContainer - Tomcat started on port(s): 8963 (http)10:14:31.644 logback [main] INFO com.xingyi.sms.SmsApplication - Started SmsApplication in 7.213 seconds (JVM running for 8.03)complete!10:15:26.978 logback [http-nio-8963-exec-1] INFO o.a.c.c.C.[.[localhost].[/mobilePre] - Initializing Spring FrameworkServlet 'dispatcherServlet'10:15:26.979 logback [http-nio-8963-exec-1] INFO o.s.web.servlet.DispatcherServlet - FrameworkServlet 'dispatcherServlet': initialization started10:15:27.004 logback [http-nio-8963-exec-1] INFO o.s.web.servlet.DispatcherServlet - FrameworkServlet 'dispatcherServlet': initialization completed in 25 ms参考自： http://blog.didispace.com/spring-boot-run-backend/]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot logback日志配置[转]]]></title>
    <url>%2FSpring-Boot-logback.html</url>
    <content type="text"><![CDATA[Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。SLF4J —— Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API（JCL）。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的绑定。Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。123456789101112 _ _ _ _ _ _ / \ / \ / \ / \ / \ / \ ( m | r | b | i | r | d ) \_/ \_/ \_/ \_/ \_/ \_/ 2018-02-08 15:05:03.368 INFO 14404 --- [ main] cc.mrbird.Application : Starting Application on SC-201802012049 with PID 14404 (D:\neonWorkspace\mrbird\target\classes started by Administrator in D:\neonWorkspace\mrbird)2018-02-08 15:05:03.375 INFO 14404 --- [ main] cc.mrbird.Application : No active profile set, falling back to default profiles: default2018-02-08 15:05:03.777 INFO 14404 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@31321838: startup date [Thu Feb 08 15:05:03 CST 2018]; root of context hierarchy2018-02-08 15:05:05.083 INFO 14404 --- [ main] o.s.b.f.s.DefaultListableBeanFactory : Overriding bean definition for bean &apos;advisorAutoProxyCreator&apos; with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=shiroConfig; factoryMethodName=advisorAutoProxyCreator; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [cc/mrbird/config/ShiroConfig.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=com.alibaba.druid.spring.boot.autoconfigure.stat.DruidSpringAopConfiguration; factoryMethodName=advisorAutoProxyCreator; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [com/alibaba/druid/spring/boot/autoconfigure/stat/DruidSpringAopConfiguration.class]]2018-02-08 15:05:05.554 INFO 14404 --- [ main] trationDelegate$BeanPostProcessorChecker : Bean &apos;shiroConfig&apos; of type [cc.mrbird.config.ShiroConfig$$EnhancerBySpringCGLIB$$b7e43ac8] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)2018-02-08 15:05:05.600 INFO 14404 --- [ main] trationDelegate$BeanPostProcessorChecker : Bean &apos;com.alibaba.druid.spring.boot.autoconfigure.stat.DruidSpringAopConfiguration&apos; of type [com.alibaba.druid.spring.boot.autoconfigure.stat.DruidSpringAopConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)2018-02-08 15:05:06.231 INFO 14404 --- [ main] trationDelegate$BeanPostProcessorChecker : Bean &apos;mybatis-org.mybatis.spring.boot.autoconfigure.MybatisProperties&apos; of type [org.mybatis.spring.boot.autoconfigure.MybatisProperties] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)...从上面可以看到，日志输出内容元素具体如下：时间日期：精确到毫秒；日志级别：ERROR, WARN, INFO, DEBUG or TRACE；进程ID；分隔符：---标识实际日志的开始；线程名：方括号括起来（可能会截断控制台输出）；Logger名：通常使用源代码的类名；日志内容。添加日志依赖假如maven依赖中添加了spring-boot-starter-logging：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt;那么，我们的Spring Boot应用将自动使用logback作为应用日志框架，Spring Boot启动的时候，由org.springframework.boot.logging.Logging-Application-Listener根据情况初始化并使用。默认配置属性支持Spring Boot为我们提供了很多默认的日志配置，所以，只要将spring-boot-starter-logging作为依赖加入到当前应用的classpath，则“开箱即用”。 下面介绍几种在application.properties就可以配置的日志相关属性。控制台输出日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。 Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。您还可以通过启动您的应用程序–debug标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可：在运行命令后加入–debug标志，如：$ java -jar springTest.jar --debug。在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。文件输出默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log。logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log。如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log。级别控制所有支持的日志记录系统都可以在Spring环境中设置记录级别（例如在application.properties中） 格式为：’logging.level.* = LEVEL’logging.level：日志级别控制前缀，*为包名或Logger名LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF举例：logging.level.com.mrbird=DEBUG：com.mrbird包下所有class以DEBUG级别输出。logging.level.root=WARN：root日志以WARN级别输出。自定义日志配置由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovyLog4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xmlLog4j2：log4j2-spring.xml, log4j2.xmlJDK (Java Util Logging)：logging.propertiesSpring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。上面是默认的命名规则，并且放在src/main/resources下面即可。如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，可以在application.properties配置文件里面通过logging.config属性指定自定义的名字：1logging.config=classpath:logging-config.xml虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日 志配置，这个功能会很有用。下面我们来看看一个普通的logback-spring.xml例子:12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE xml&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="log" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt;--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.mrbird.controller"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name="com.mrbird.controller.LoginController" level="WARN" additivity="false"&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt;&lt;/configuration&gt;根节点&lt;configuration&gt;包含的属性scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。根节点&lt;configuration&gt;的子节点：&lt;configuration&gt;下面一共有2个属性，3个子节点，分别是：属性一：设置上下文名称&lt;contextName&gt;每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改,可以通过%contextName来打印日志上下文名称。1&lt;contextName&gt;logback&lt;/contextName&gt;属性二：设置变量&lt;property&gt; 用来定义变量值的标签，有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。1&lt;property name="log.path" value="log" /&gt;子节点一&lt;appender&gt;appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。控制台输出ConsoleAppender：123456789&lt;!--输出到控制台--&gt;&lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt;&lt;encoder&gt;表示对日志进行编码：%d{HH: mm:ss.SSS}——日志输出时间。%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用。%-5level——日志级别，并且使用5个字符靠左对齐。%logger{36}——日志输出者的名字。%msg——日志消息。%n——平台的换行符。ThresholdFilter为系统定义的拦截器，例如我们用ThresholdFilter来过滤掉ERROR级别以下的日志不输出到文件中。如果不用记得注释掉，不然你控制台会发现没日志~输出到文件RollingFileAppender：另一种常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。RollingFileAppender用于切分文件日志：1234567891011&lt;!--输出到文件--&gt;&lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt;其中重要的是rollingPolicy的定义：&lt;fileNamePattern&gt;${log.path}/logback.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;定义了日志的切分方式——把每一天的日志归档到一个文件中；&lt;maxHistory&gt;30&lt;/maxHistory&gt;表示只保留最近30天的日志，以防止日志填满整个磁盘空间。同理，可以使用%d{yyyy-MM-dd_HH-mm}来定义精确到分的日志切分方式；&lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志。logback 每天生成和大小生成冲突的问题可以看这个解答：http://blog.csdn.net/wujianmin577/article/details/68922545。子节点二&lt;root&gt;root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性，用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。默认是DEBUG。可以包含零个或多个元素，标识这个appender将会添加到这个logger。1234&lt;root level="debug"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt;&lt;/root&gt;子节点三&lt;logger&gt;&lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，一个可选的level和一个可选的addtivity属性。name：用来指定受此logger约束的某一个包或者具体的某一个类。level：用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前logger将会继承上级的级别。addtivity：是否向上级logger传递打印信息。默认是true。logger在实际使用的时候有两种情况：先来看一看代码中如何使用：12345678910111213141516171819202122232425262728package com.mrbird.controller;@Controllerpublic class LearnController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping(value = "/login",method = RequestMethod.POST) @ResponseBody public Map&lt;String,Object&gt; login(HttpServletRequest request, HttpServletResponse response)&#123; //日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。 logger.trace("日志输出 trace"); logger.debug("日志输出 debug"); logger.info("日志输出 info"); logger.warn("日志输出 warn"); logger.error("日志输出 error"); Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); String userName=request.getParameter("userName"); String password=request.getParameter("password"); if(!userName.equals("") &amp;&amp; password!="")&#123; User user =new User(userName,password); request.getSession().setAttribute("user",user); map.put("result","1"); &#125;else&#123; map.put("result","0"); &#125; return map; &#125;&#125;这是一个登录的判断的方法，我们引入日志，并且打印不同级别的日志，然后根据logback-spring.xml中的配置来看看打印了哪几种级别日志。第一种：带有logger的配置，不指定级别，不指定appender：1&lt;logger name="com.mrbird.controller"/&gt;&lt;logger name=&quot;com.mrbird.controller&quot; /&gt;将控制controller包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级的日志级别“info”；没有设置addtivity，默认为true，将此logger的打印信息向上级传递；没有设置appender，此logger本身不打印任何信息。&lt;root level=&quot;info&quot;&gt;将root的打印级别设置为“info”，指定了名字为“console”的appender。当执行com.mrbird.controller.LearnController类的login方法时，LearnController 在包com.mrbird.controller中，所以首先执行&lt;logger name=&quot;com.mrbird.controller&quot;/&gt;，将级别为“info”及大于“info”的日志信息传递给root，本身并不打印； root接到下级传递的信息，交给已经配置好的名为“console”的appender处理，“console”appender将信息打印到控制台；打印结果如下：12316:00:17.407 logback [http-nio-8080-exec-8] INFO com.mrbird.controller.LearnController - 日志输出 info16:00:17.408 logback [http-nio-8080-exec-8] WARN com.mrbird.controller.LearnController - 日志输出 warn16:00:17.408 logback [http-nio-8080-exec-8] ERROR com.mrbird.controller.LearnController - 日志输出 error第二种：带有多个logger的配置，指定级别，指定appender；1234&lt;!--logback.LogbackDemo：类的全路径 --&gt;&lt;logger name="com.mrbird.controller.LearnController" level="WARN" additivity="false"&gt; &lt;appender-ref ref="console"/&gt;&lt;/logger&gt;控制com.mrbird.controller.LearnController类的日志打印，打印级别为“WARN”;additivity属性为false，表示此logger的打印信息不再向上级传递；指定了名字为“console”的appender。这时候执行com.mrbird.controller.LearnController类的login方法时，先执行&lt;logger name=&quot;com.mrbird.controller.LearnController&quot; level=&quot;WARN&quot; additivity=&quot;false&quot;&gt;, 将级别为“WARN”及大于“WARN”的日志信息交给此logger指定的名为“console”的appender处理，在控制台中打出日志，不再向上级root传递打印信息。打印结果如下：1216:00:17.408 logback [http-nio-8080-exec-8] WARN com.mrbird.controller.LearnController - 日志输出 warn16:00:17.408 logback [http-nio-8080-exec-8] ERROR com.mrbird.controller.LearnController - 日志输出 error当然如果你把additivity=”false”改成additivity=”true”的话，就会打印两次，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次。转载自： http://tengj.top/2017/04/05/springboot7/]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap Modal遮罩问题]]></title>
    <url>%2FBootstrap-Moda%20error.html</url>
    <content type="text"><![CDATA[当同时打开多层Modal并关闭的时候，发现页面的遮罩层并没有消失，可以使用下面的方法手动删除：123$("modal").bind('hide.bs.modal', function() &#123; $(".modal-backdrop").remove();&#125;)]]></content>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis通用Mapper和PageHelper]]></title>
    <url>%2FMyBatis%20common%20Mapper%20PageHelper.html</url>
    <content type="text"><![CDATA[如果项目中使用到了MyBatis框架，那么使用通用Mapper和PageHelper分页插件将极大的简化我们的操作。通用Mapper可以简化对单表的CRUD操作，PageHelper分页插件可以帮我们自动拼接分页SQL，并且可以使用MyBatis Geneator来自动生成实体类，Mapper接口和Mapper xml代码，非常的方便。插件地址及作者链接https://gitee.com/free。引入依赖这里使用Spring Boot来构建，可参考Spring-Boot中使用Mybatis.html搭建一个Spring boot + MyBatis的框架，然后在pom中引入：123456789101112131415161718&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- pagehelper 分页插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;接着在pom中配置MyBatis Geneator：123456789101112131415161718192021222324252627282930313233343536373839&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 数据库连接驱动 --&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!--允许移动生成的文件 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!-- 是否覆盖 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!-- 自动生成的配置 --&gt; &lt;configurationFile&gt;src/main/resources/mybatis-generator.xml&lt;/configurationFile&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;src/main/resources/mybatis-generator.xml为生成器的配置，下文会介绍到。配置插件在Spring Boot配置文件application.yml中配置MyBatis：1234567mybatis: # type-aliases扫描路径 type-aliases-package: com.springboot.bean # mapper xml实现扫描路径 mapper-locations: classpath:mapper/*.xml property: order: BEFORE接下来开始配置插件。配置通用Mapper在Spring Boot配置文件application.yml中配置通用Mapper：12345#mappers 多个接口时逗号隔开mapper: mappers: com.springboot.config.MyMapper not-empty: false identity: oracle关于参数的说明，参考https://gitee.com/free/Mapper/blob/master/wiki/mapper3/2.Integration.md中的可配参数介绍。除此之外，我们需要定义一个MyMapper接口：123456import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123; &#125;值得注意的是，该接口不能被扫描到，应该和自己定义的Mapper分开。自己定义的Mapper都需要继承这个接口。配置PageHelper在Spring Boot配置文件application.yml中配置通用配置PageHelper：123456#pagehelperpagehelper: helperDialect: oracle reasonable: true supportMethodsArguments: true params: count=countSql参数相关说明参考https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md中的分页插件参数介绍。配置Geneator*在路径src/main/resources/下新建mybatis-generator.xml：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="oracle" targetRuntime="MyBatis3Simple" defaultModelType="flat"&gt; &lt;plugin type="tk.mybatis.mapper.generator.MapperPlugin"&gt; &lt;!-- 该配置会使生产的Mapper自动继承MyMapper --&gt; &lt;property name="mappers" value="com.springboot.config.MyMapper" /&gt; &lt;!-- caseSensitive默认false，当数据库表名区分大小写时，可以将该属性设置为true --&gt; &lt;property name="caseSensitive" value="false"/&gt; &lt;/plugin&gt; &lt;!-- 阻止生成自动注释 --&gt; &lt;commentGenerator&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库链接地址账号密码 --&gt; &lt;jdbcConnection driverClass="oracle.jdbc.driver.OracleDriver" connectionURL="jdbc:oracle:thin:@localhost:1521:ORCL" userId="scott" password="6742530"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成Model类存放位置 --&gt; &lt;javaModelGenerator targetPackage="com.springboot.bean" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件存放位置 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成Dao类存放位置 --&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.springboot.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 配置需要生成的表 --&gt; &lt;table tableName="T_USER" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;generatedKey column="id" sqlStatement="oralce" identity="true"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;更详细的说明可参考链接：http://blog.csdn.net/isea533/article/details/42102297。代码生成配置好MyBatis Geneator后，在eclipse中运行命令mybatis-generator:generate：以下为自动成成的代码：User：123456789101112131415161718192021@Table(name = "T_USER")public class User &#123; @Id @Column(name = "ID") @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = "USERNAME") private String username; @Column(name = "PASSWD") private String passwd; @Column(name = "CREATE_TIME") private Date createTime; @Column(name = "STATUS") private String status; ...&#125;因为这里数据库试用的是Oracle，其没有主键自动自增的功能，这里先将@GeneratedValue(strategy = GenerationType.IDENTITY)去掉，主键的生成下面会介绍到。生成的主键是BigDecimal类型的，我们将其改为Long类型。UserMapper：12345import com.springboot.bean.User;import com.springboot.config.MyMapper;public interface UserMapper extends MyMapper&lt;User&gt; &#123;&#125;UserMapper.xml：1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.springboot.mapper.UserMapper"&gt; &lt;resultMap id="BaseResultMap" type="com.springboot.bean.User"&gt; &lt;!-- WARNING - @mbg.generated --&gt; &lt;id column="ID" jdbcType="DECIMAL" property="id" /&gt; &lt;result column="USERNAME" jdbcType="VARCHAR" property="username" /&gt; &lt;result column="PASSWD" jdbcType="VARCHAR" property="passwd" /&gt; &lt;result column="CREATE_TIME" jdbcType="TIMESTAMP" property="createTime" /&gt; &lt;result column="STATUS" jdbcType="CHAR" property="status" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt;极其方便的说！Mapper要让Spring Boot扫描到Mapper接口，需要在Spring Boot入口类中加入@MapperScan(&quot;com.springboot.mapper&quot;)注解。为了获取到Oracle 中序列的值，我们定义一个SeqenceMapper接口：1234public interface SeqenceMapper &#123; @Select("select $&#123;seqName&#125;.nextval from dual") Long getSequence(@Param("seqName") String seqName);&#125;因为这里仅介绍Mapper自带的CRUD方法，所以UserMapper接口中无需定义任何方法。通用Service我们可以定义一个通用的Service，在其中定义一些通用的方法：IService：12345678910111213141516171819@Servicepublic interface IService&lt;T&gt; &#123; Long getSequence(@Param("seqName") String seqName); List&lt;T&gt; selectAll(); T selectByKey(Object key); int save(T entity); int delete(Object key); int updateAll(T entity); int updateNotNull(T entity); List&lt;T&gt; selectByExample(Object example);&#125;其实现类BaseService：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public abstract class BaseService&lt;T&gt; implements IService&lt;T&gt; &#123; @Autowired protected Mapper&lt;T&gt; mapper; @Autowired protected SeqenceMapper seqenceMapper; public Mapper&lt;T&gt; getMapper() &#123; return mapper; &#125; @Override public Long getSequence(@Param("seqName") String seqName)&#123; return seqenceMapper.getSequence(seqName); &#125; @Override public List&lt;T&gt; selectAll() &#123; //说明：查询所有数据 return mapper.selectAll(); &#125; @Override public T selectByKey(Object key) &#123; //说明：根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号 return mapper.selectByPrimaryKey(key); &#125; @Override public int save(T entity) &#123; //说明：保存一个实体，null的属性也会保存，不会使用数据库默认值 return mapper.insert(entity); &#125; @Override public int delete(Object key) &#123; //说明：根据主键字段进行删除，方法参数必须包含完整的主键属性 return mapper.deleteByPrimaryKey(key); &#125; @Override public int updateAll(T entity) &#123; //说明：根据主键更新实体全部字段，null值会被更新 return mapper.updateByPrimaryKey(entity); &#125; @Override public int updateNotNull(T entity) &#123; //根据主键更新属性不为null的值 return mapper.updateByPrimaryKeySelective(entity); &#125; @Override public List&lt;T&gt; selectByExample(Object example) &#123; //说明：根据Example条件进行查询 //重点：这个查询支持通过Example类指定查询列，通过selectProperties方法指定查询列 return mapper.selectByExample(example); &#125;&#125;接下来让UserService接口继承IService接口：123public interface UserService extends IService&lt;User&gt;&#123; &#125;其实现类UserServiceImpl：1234@Repository("userService")public class UserServiceImpl extends BaseService&lt;User&gt; implements UserService&#123; &#125;这样即可在UserService中使用BaseService中的通用方法了。测试测试插入：1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = Application.class)public class ApplicationTest &#123; @Autowired private UserService userService; @Test public void test() throws Exception &#123; User user = new User(); user.setId(userService.getSequence("seq_user")); user.setUsername("scott"); user.setPasswd("ac089b11709f9b9e9980e7c497268dfa"); user.setCreateTime(new Date()); user.setStatus("0"); this.userService.save(user); &#125;&#125;运行代码，查看数据库：测试查询：1234567891011121314151617Example example = new Example(User.class);example.createCriteria().andCondition("username like '%i%'");example.setOrderByClause("id desc");List&lt;User&gt; userList = this.userService.selectByExample(example);for (User u : userList) &#123; System.out.println(u.getUsername());&#125;List&lt;User&gt; all = this.userService.selectAll();for (User u : all) &#123; System.out.println(u.getUsername());&#125;User user = new User();user.setId(1l);user = this.userService.selectByKey(user);System.out.println(user.getUsername());测试删除：123User user = new User();user.setId(4l);this.userService.delete(user);分页测试，从第二页开始，每页2条数据：1234567PageHelper.startPage(2, 2);List&lt;User&gt; list = userService.selectAll();PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(list);List&lt;User&gt; result = pageInfo.getList();for (User u : result) &#123; System.out.println(u.getUsername());&#125;查看日志打印出的SQL：12342017-12-28 10:25:14.033 DEBUG 11116 --- [main] c.s.mapper.UserMapper.selectAll : ==&gt; Preparing: SELECT * FROM ( SELECT TMP_PAGE.*, ROWNUM ROW_ID FROM ( SELECT ID,USERNAME,PASSWD,CREATE_TIME,STATUS FROM T_USER ) TMP_PAGE WHERE ROWNUM &lt;= ? ) WHERE ROW_ID &gt; ? 2017-12-28 10:25:14.068 DEBUG 11116 --- [main] c.s.mapper.UserMapper.selectAll : ==&gt; Parameters: 4(Integer), 2(Integer)2017-12-28 10:25:14.073 DEBUG 11116 --- [main] c.s.mapper.UserMapper.selectAll : &lt;== Total: 2插件已经帮我自动拼接好了。其他注意事项参考官方说明。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/27.Spring-Boot-Mapper-PageHelper]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Shiro在线会话管理]]></title>
    <url>%2FSpring-Boot-Shiro%20session.html</url>
    <content type="text"><![CDATA[在Shiro中我们可以通过org.apache.shiro.session.mgt.eis.SessionDAO对象的getActiveSessions()方法方便的获取到当前所有有效的Session对象。通过这些Session对象，我们可以实现一些比较有趣的功能，比如查看当前系统的在线人数，查看这些在线用户的一些基本信息，强制让某个用户下线等。为了达到这几个目标，我们在现有的Spring Boot Shiro项目基础上进行一些改造（缓存使用Ehcache）。更改ShiroConfig为了能够在Spring Boot中使用SessionDao，我们在ShiroConfig中配置该Bean：12345@Beanpublic SessionDAO sessionDAO() &#123; MemorySessionDAO sessionDAO = new MemorySessionDAO(); return sessionDAO;&#125;如果使用的是Redis作为缓存实现，那么SessionDAO则为RedisSessionDAO：123456@Beanpublic RedisSessionDAO sessionDAO() &#123; RedisSessionDAO redisSessionDAO = new RedisSessionDAO(); redisSessionDAO.setRedisManager(redisManager()); return redisSessionDAO;&#125;在Shiro中，SessionDao通过org.apache.shiro.session.mgt.SessionManager进行管理，所以继续在ShiroConfig中配置SessionManager：123456789@Beanpublic SessionManager sessionManager() &#123; DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); Collection&lt;SessionListener&gt; listeners = new ArrayList&lt;SessionListener&gt;(); listeners.add(new ShiroSessionListener()); sessionManager.setSessionListeners(listeners); sessionManager.setSessionDAO(sessionDAO()); return sessionManager;&#125;其中ShiroSessionListener为org.apache.shiro.session.SessionListener接口的手动实现，所以接下来定义一个该接口的实现：123456789101112131415161718public class ShiroSessionListener implements SessionListener&#123; private final AtomicInteger sessionCount = new AtomicInteger(0); @Override public void onStart(Session session) &#123; sessionCount.incrementAndGet(); &#125; @Override public void onStop(Session session) &#123; sessionCount.decrementAndGet(); &#125; @Override public void onExpiration(Session session) &#123; sessionCount.decrementAndGet(); &#125;&#125;其维护着一个原子类型的Integer对象，用于统计在线Session的数量。定义完SessionManager后，还需将其注入到SecurityManager中：12345678@Bean public SecurityManager securityManager()&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shiroRealm()); ... securityManager.setSessionManager(sessionManager()); return securityManager; &#125;UserOnline配置完ShiroConfig后，我们可以创建一个UserOnline实体类，用于描述每个在线用户的基本信息：1234567891011121314151617181920212223public class UserOnline implements Serializable&#123; private static final long serialVersionUID = 3828664348416633856L; // session id private String id; // 用户id private String userId; // 用户名称 private String username; // 用户主机地址 private String host; // 用户登录时系统IP private String systemHost; // 状态 private String status; // session创建时间 private Date startTimestamp; // session最后访问时间 private Date lastAccessTime; // 超时时间 private Long timeout; // get set略&#125;Service创建一个Service接口，包含查看所有在线用户和根据SessionId踢出用户抽象方法：1234public interface SessionService &#123; List&lt;UserOnline&gt; list(); boolean forceLogout(String sessionId);&#125;其具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445@Service("sessionService")public class SessionServiceImpl implements SessionService &#123; @Autowired private SessionDAO sessionDAO; @Override public List&lt;UserOnline&gt; list() &#123; List&lt;UserOnline&gt; list = new ArrayList&lt;&gt;(); Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); for (Session session : sessions) &#123; UserOnline userOnline = new UserOnline(); User user = new User(); SimplePrincipalCollection principalCollection = new SimplePrincipalCollection(); if (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == null) &#123; continue; &#125; else &#123; principalCollection = (SimplePrincipalCollection) session .getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY); user = (User) principalCollection.getPrimaryPrincipal(); userOnline.setUsername(user.getUserName()); userOnline.setUserId(user.getId().toString()); &#125; userOnline.setId((String) session.getId()); userOnline.setHost(session.getHost()); userOnline.setStartTimestamp(session.getStartTimestamp()); userOnline.setLastAccessTime(session.getLastAccessTime()); Long timeout = session.getTimeout(); if (timeout == 0l) &#123; userOnline.setStatus("离线"); &#125; else &#123; userOnline.setStatus("在线"); &#125; userOnline.setTimeout(timeout); list.add(userOnline); &#125; return list; &#125; @Override public boolean forceLogout(String sessionId) &#123; Session session = sessionDAO.readSession(sessionId); session.setTimeout(0); return true; &#125;&#125;通过SessionDao的getActiveSessions()方法，我们可以获取所有有效的Session，通过该Session，我们还可以获取到当前用户的Principal信息。值得说明的是，当某个用户被踢出后（Session Time置为0），该Session并不会立刻从ActiveSessions中剔除，所以我们可以通过其timeout信息来判断该用户在线与否。如果使用的Redis作为缓存实现，那么，forceLogout()方法需要稍作修改：123456@Overridepublic boolean forceLogout(String sessionId) &#123; Session session = sessionDAO.readSession(sessionId); sessionDAO.delete(session); return true;&#125;Controller定义一个SessionContoller，用于处理Session的相关操作：1234567891011121314151617181920212223242526272829@Controller@RequestMapping("/online")public class SessionController &#123; @Autowired SessionService sessionService; @RequestMapping("index") public String online() &#123; return "online"; &#125; @ResponseBody @RequestMapping("list") public List&lt;UserOnline&gt; list() &#123; return sessionService.list(); &#125; @ResponseBody @RequestMapping("forceLogout") public ResponseBo forceLogout(String id) &#123; try &#123; sessionService.forceLogout(id); return ResponseBo.ok(); &#125; catch (Exception e) &#123; e.printStackTrace(); return ResponseBo.error("踢出用户失败"); &#125; &#125;&#125;页面我们编写一个online.html页面，用于展示所有在线用户的信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;在线用户管理&lt;/title&gt; &lt;script th:src="@&#123;/js/jquery-1.11.1.min.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;/js/dateFormat.js&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;在线用户数：&lt;span id="onlineCount"&gt;&lt;/span&gt;&lt;/h3&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;用户名称&lt;/th&gt; &lt;th&gt;登录时间&lt;/th&gt; &lt;th&gt;最后访问时间&lt;/th&gt; &lt;th&gt;主机&lt;/th&gt; &lt;th&gt;状态&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;a th:href="@&#123;/index&#125;"&gt;返回&lt;/a&gt;&lt;/body&gt;&lt;script th:inline="javascript"&gt; var ctx = [[@&#123;/&#125;]]; $.get(ctx + "online/list", &#123;&#125;, function(r)&#123; var length = r.length; $("#onlineCount").text(length); var html = ""; for(var i = 0; i &lt; length; i++)&#123; html += "&lt;tr&gt;" + "&lt;td&gt;" + (i+1) + "&lt;/td&gt;" + "&lt;td&gt;" + r[i].username + "&lt;/td&gt;" + "&lt;td&gt;" + new Date(r[i].startTimestamp).Format("yyyy-MM-dd hh:mm:ss") + "&lt;/td&gt;" + "&lt;td&gt;" + new Date(r[i].lastAccessTime).Format("yyyy-MM-dd hh:mm:ss") + "&lt;/td&gt;" + "&lt;td&gt;" + r[i].host + "&lt;/td&gt;" + "&lt;td&gt;" + r[i].status + "&lt;/td&gt;" + "&lt;td&gt;&lt;a href='#' onclick='offline(\"" + r[i].id + "\",\"" + r[i].status +"\")'&gt;下线&lt;/a&gt;&lt;/td&gt;" + "&lt;/tr&gt;"; &#125; $("table").append(html); &#125;,"json"); function offline(id,status)&#123; if(status == "离线")&#123; alert("该用户已是离线状态！！"); return; &#125; $.get(ctx + "online/forceLogout", &#123;"id": id&#125;, function(r)&#123; if (r.code == 0) &#123; alert('该用户已强制下线！'); location.href = ctx + 'online/index'; &#125; else &#123; alert(r.msg); &#125; &#125;,"json"); &#125;&lt;/script&gt;&lt;/html&gt;在index.html中加入该页面的入口：1234567891011121314...&lt;body&gt; &lt;p&gt;你好！[[$&#123;user.userName&#125;]]&lt;/p&gt; &lt;p shiro:hasRole="admin"&gt;你的角色为超级管理员&lt;/p&gt; &lt;p shiro:hasRole="test"&gt;你的角色为测试账户&lt;/p&gt; &lt;div&gt; &lt;a shiro:hasPermission="user:user" th:href="@&#123;/user/list&#125;"&gt;获取用户信息&lt;/a&gt; &lt;a shiro:hasPermission="user:add" th:href="@&#123;/user/add&#125;"&gt;新增用户&lt;/a&gt; &lt;a shiro:hasPermission="user:delete" th:href="@&#123;/user/delete&#125;"&gt;删除用户&lt;/a&gt; &lt;/div&gt; &lt;a shiro:hasRole="admin" th:href="@&#123;/online/index&#125;"&gt;在线用户管理&lt;/a&gt; &lt;a th:href="@&#123;/logout&#125;"&gt;注销&lt;/a&gt;&lt;/body&gt;...测试启动项目，在Opera浏览器中使用mrbird账户访问：在FireFox浏览器中使用tester账户访问：然后在mrbird主界面点击“在线用户管理”：显示的信息符合我们的预期，点击tester的下线按钮，强制将其踢出：回到tester用户的主界面，点击“查看用户信息”，会发现页面已经被重定向到login页面，因为其Session已经失效！再次刷新mrbird的online页面，显示如下：源码链接（Ehcache版）：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/17.Spring-Boot-Shiro-Session源码链接（Redis版）：https://drive.google.com/open?id=1GHJxnoX2rZuQXtMYpNv-TE5SHRwyqSN7]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Shiro</tag>
        <tag>Security</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Thymeleaf中使用Shiro标签]]></title>
    <url>%2FSpring-Boot-Themeleaf%20Shiro%20tag.html</url>
    <content type="text"><![CDATA[在《Spring-Boot-shiro权限控制》中，当用户访问没有权限的资源时，我们采取的做法是跳转到403页面，但在实际项目中更为常见的做法是只显示当前用户拥有访问权限的资源链接。配合Thymeleaf中的Shiro标签可以很简单的实现这个目标。实际上Thymeleaf官方并没有提供Shiro的标签，我们需要引入第三方实现，地址为https://github.com/theborakompanioni/thymeleaf-extras-shiro。引入thymeleaf-extras-shiro在pom中引入：12345&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;ShiroConfig配置引入依赖后，需要在ShiroConfig中配置该方言标签：1234 @Beanpublic ShiroDialect shiroDialect() &#123; return new ShiroDialect();&#125;首页改造更改index.html，用于测试Shiro标签的使用：12345678910111213141516171819 &lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org" xmlns:shiro="http://www.pollix.at/thymeleaf/shiro" &gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你好！[[$&#123;user.userName&#125;]]&lt;/p&gt; &lt;p shiro:hasRole="admin"&gt;你的角色为超级管理员&lt;/p&gt; &lt;p shiro:hasRole="test"&gt;你的角色为测试账户&lt;/p&gt; &lt;div&gt; &lt;a shiro:hasPermission="user:user" th:href="@&#123;/user/list&#125;"&gt;获取用户信息&lt;/a&gt; &lt;a shiro:hasPermission="user:add" th:href="@&#123;/user/add&#125;"&gt;新增用户&lt;/a&gt; &lt;a shiro:hasPermission="user:delete" th:href="@&#123;/user/delete&#125;"&gt;删除用户&lt;/a&gt; &lt;/div&gt; &lt;a th:href="@&#123;/logout&#125;"&gt;注销&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;值得注意的是，在html页面中使用Shiro标签需要给html标签添加xmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;。测试启动项目，使用mrbird（角色为admin，具有user:user，user:add，user:delete权限）账户登录：使用tester（角色为tester，仅有user:user权限）账户登录：更多标签The following examples show how to integrate the tags in your Thymeleaf templates. These are all implementations of the examples given in the JSP / GSP Tag Library Section of the Apache Shiro documentation.Tags can be written in attribute or element notation:Attribute123&lt;p shiro:anyTag&gt; Goodbye cruel World!&lt;/p&gt;Element123&lt;shiro:anyTag&gt; &lt;p&gt;Hello World!&lt;/p&gt;&lt;/shiro:anyTag&gt;The guest tag123&lt;p shiro:guest=""&gt; Please &lt;a href="login.html"&gt;Login&lt;/a&gt;&lt;/p&gt;The user tag123&lt;p shiro:user=""&gt; Welcome back John! Not John? Click &lt;a href="login.html"&gt;here&lt;a&gt; to login.&lt;/p&gt;The authenticated tag1&lt;a shiro:authenticated="" href="updateAccount.html"&gt;Update your contact information&lt;/a&gt;The notAuthenticated tag123&lt;p shiro:notAuthenticated=""&gt; Please &lt;a href="login.html"&gt;login&lt;/a&gt; in order to update your credit card information.&lt;/p&gt;The principal tag1&lt;p&gt;Hello, &lt;span shiro:principal=""&gt;&lt;/span&gt;, how are you today?&lt;/p&gt;or1&lt;p&gt;Hello, &lt;shiro:principal/&gt;, how are you today?&lt;/p&gt;Typed principal and principal property are also supported.The hasRole tag1&lt;a shiro:hasRole="administrator" href="admin.html"&gt;Administer the system&lt;/a&gt;The lacksRole tag123&lt;p shiro:lacksRole="administrator"&gt; Sorry, you are not allowed to administer the system.&lt;/p&gt;The hasAllRoles tag123&lt;p shiro:hasAllRoles="developer, project manager"&gt; You are a developer and a project manager.&lt;/p&gt;The hasAnyRoles tag123&lt;p shiro:hasAnyRoles="developer, project manager, administrator"&gt; You are a developer, project manager, or administrator.&lt;/p&gt;The hasPermission tag1&lt;a shiro:hasPermission="user:create" href="createUser.html"&gt;Create a new User&lt;/a&gt;The lacksPermission tag123&lt;p shiro:lacksPermission="user:delete"&gt; Sorry, you are not allowed to delete user accounts.&lt;/p&gt;The hasAllPermissions tag123&lt;p shiro:hasAllPermissions="user:create, user:delete"&gt; You can create and delete users.&lt;/p&gt;The hasAnyPermissions tag123&lt;p shiro:hasAnyPermissions="user:create, user:delete"&gt; You can create or delete users.&lt;/p&gt;源码地址：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/16.Spring-Boot-Shiro-Thymeleaf-Tag]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Shiro</tag>
        <tag>Security</tag>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Shiro中使用缓存]]></title>
    <url>%2FSpring-Boot-Shiro%20cache.html</url>
    <content type="text"><![CDATA[在Shiro中加入缓存可以使权限相关操作尽可能快，避免频繁访问数据库获取权限信息，因为对于一个用户来说，其权限在短时间内基本是不会变化的。Shiro提供了Cache的抽象，其并没有直接提供相应的实现，因为这已经超出了一个安全框架的范围。在Shiro中可以集成常用的缓存实现，这里介绍基于Redis和Ehcache缓存的实现。在《Spring-Boot-shiro权限控制》中，当用户访问”获取用户信息”、”新增用户”和”删除用户”的时候，后台输出了三次打印信息，如下所示：123用户mrbird获取权限-----ShiroRealm.doGetAuthorizationInfo用户mrbird获取权限-----ShiroRealm.doGetAuthorizationInfo用户mrbird获取权限-----ShiroRealm.doGetAuthorizationInfo说明在这三次访问中，Shiro都会从数据库中获取用户的权限信息，通过Druid数据源SQL监控后台也可以证实这一点：这对数据库来说是没必要的消耗。接下来使用缓存来解决这个问题。Redis引入Redis依赖网络上已经有关于Shiro集成Redis的实现，我们引入即可：123456&lt;!-- shiro-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;2.4.2.1-RELEASE&lt;/version&gt;&lt;/dependency&gt;配置Redis我们在application.yml配置文件中加入Redis配置：12345678910spring: redis: host: localhost port: 6379 pool: max-active: 8 max-wait: -1 max-idle: 8 min-idle: 0 timeout: 0接着在ShiroConfig中配置Redis：12345678910public RedisManager redisManager() &#123; RedisManager redisManager = new RedisManager(); return redisManager;&#125;public RedisCacheManager cacheManager() &#123; RedisCacheManager redisCacheManager = new RedisCacheManager(); redisCacheManager.setRedisManager(redisManager()); return redisCacheManager;&#125;上面代码配置了RedisManager，并将其注入到了RedisCacheManager中，最后在SecurityManager中加入RedisCacheManager：1234567@Bean public SecurityManager securityManager()&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); ... securityManager.setCacheManager(cacheManager()); return securityManager; &#125;配置完毕启动项目，分别访问访问”获取用户信息”、”新增用户”和”删除用户”，可发现后台只打印一次获取权限信息：1用户mrbird获取权限-----ShiroRealm.doGetAuthorizationInfo查看Druid数据源SQL监控：源码：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/14.Spring-Boot-Shiro-RedisEhcacheEhcache依赖加入Ehcache相关依赖：123456789101112131415&lt;!-- shiro ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- ehchache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;Ehcache配置在src/main/resource/config路径下新增一个Ehcache配置——shiro-ehcache.xml：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd" updateCheck="false"&gt; &lt;diskStore path="java.io.tmpdir/Tmp_EhCache" /&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" overflowToDisk="false" diskPersistent="false" diskExpiryThreadIntervalSeconds="120" /&gt; &lt;!-- 登录记录缓存锁定1小时 --&gt; &lt;cache name="passwordRetryCache" maxEntriesLocalHeap="2000" eternal="false" timeToIdleSeconds="3600" timeToLiveSeconds="0" overflowToDisk="false" statistics="true" /&gt;&lt;/ehcache&gt;ShiroConfig配置Ehcache接着在ShiroConfig中注入Ehcache缓存：123456@Beanpublic EhCacheManager getEhCacheManager() &#123; EhCacheManager em = new EhCacheManager(); em.setCacheManagerConfigFile("classpath:config/shiro-ehcache.xml"); return em;&#125;将缓存对象注入到SecurityManager中：12345678@Bean public SecurityManager securityManager()&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shiroRealm()); securityManager.setRememberMeManager(rememberMeManager()); securityManager.setCacheManager(getEhCacheManager()); return securityManager; &#125;配置完毕启动项目，分别访问访问”获取用户信息”、”新增用户”和”删除用户”，可发现后台只打印一次获取权限信息：1用户mrbird获取权限-----ShiroRealm.doGetAuthorizationInfo查看Druid数据源SQL监控：SQL只执行了一次，说明缓存成功。源码连接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/15.Spring-Boot-Shiro-Ehcache]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Shiro</tag>
        <tag>Security</tag>
        <tag>Spring Boot</tag>
        <tag>Ehcache</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Shiro权限控制]]></title>
    <url>%2FSpring-Boot-Shiro%20Authorization.html</url>
    <content type="text"><![CDATA[在《Spring-Boot-shiro用户认证》中，我们通过继承AuthorizingRealm抽象类实现了doGetAuthenticationInfo()方法完成了用户认证操作。接下来继续实现doGetAuthorizationInfo()方法完成Shiro的权限控制功能。授权也称为访问控制，是管理资源访问的过程。即根据不同用户的权限判断其是否有访问相应资源的权限。在Shiro中，权限控制有三个核心的元素：权限，角色和用户。库模型设计在这里，我们使用RBAC（Role-Based Access Control，基于角色的访问控制）模型设计用户，角色和权限间的关系。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。如下图所示：根据这个模型，设计数据库表，并插入一些测试数据：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394-- ------------------------------ Table structure for T_PERMISSION-- ----------------------------CREATE TABLE "SCOTT"."T_PERMISSION" ( "ID" NUMBER(10) NOT NULL , "URL" VARCHAR2(256 BYTE) NULL , "NAME" VARCHAR2(64 BYTE) NULL );COMMENT ON COLUMN "SCOTT"."T_PERMISSION"."URL" IS 'url地址';COMMENT ON COLUMN "SCOTT"."T_PERMISSION"."NAME" IS 'url描述';-- ------------------------------ Records of T_PERMISSION-- ----------------------------INSERT INTO "SCOTT"."T_PERMISSION" VALUES ('1', '/user', 'user:user');INSERT INTO "SCOTT"."T_PERMISSION" VALUES ('2', '/user/add', 'user:add');INSERT INTO "SCOTT"."T_PERMISSION" VALUES ('3', '/user/delete', 'user:delete');-- ------------------------------ Table structure for T_ROLE-- ----------------------------CREATE TABLE "SCOTT"."T_ROLE" ( "ID" NUMBER NOT NULL , "NAME" VARCHAR2(32 BYTE) NULL , "MEMO" VARCHAR2(32 BYTE) NULL );COMMENT ON COLUMN "SCOTT"."T_ROLE"."NAME" IS '角色名称';COMMENT ON COLUMN "SCOTT"."T_ROLE"."MEMO" IS '角色描述';-- ------------------------------ Records of T_ROLE-- ----------------------------INSERT INTO "SCOTT"."T_ROLE" VALUES ('1', 'admin', '超级管理员');INSERT INTO "SCOTT"."T_ROLE" VALUES ('2', 'test', '测试账户');-- ------------------------------ Table structure for T_ROLE_PERMISSION-- ----------------------------CREATE TABLE "SCOTT"."T_ROLE_PERMISSION" ( "RID" NUMBER(10) NULL , "PID" NUMBER(10) NULL );COMMENT ON COLUMN "SCOTT"."T_ROLE_PERMISSION"."RID" IS '角色id';COMMENT ON COLUMN "SCOTT"."T_ROLE_PERMISSION"."PID" IS '权限id';-- ------------------------------ Records of T_ROLE_PERMISSION-- ----------------------------INSERT INTO "SCOTT"."T_ROLE_PERMISSION" VALUES ('1', '2');INSERT INTO "SCOTT"."T_ROLE_PERMISSION" VALUES ('1', '3');INSERT INTO "SCOTT"."T_ROLE_PERMISSION" VALUES ('2', '1');INSERT INTO "SCOTT"."T_ROLE_PERMISSION" VALUES ('1', '1');-- ------------------------------ Table structure for T_USER-- ----------------------------CREATE TABLE "SCOTT"."T_USER" ( "ID" NUMBER NOT NULL , "USERNAME" VARCHAR2(20 BYTE) NOT NULL , "PASSWD" VARCHAR2(128 BYTE) NOT NULL , "CREATE_TIME" DATE NULL , "STATUS" CHAR(1 BYTE) NOT NULL );COMMENT ON COLUMN "SCOTT"."T_USER"."USERNAME" IS '用户名';COMMENT ON COLUMN "SCOTT"."T_USER"."PASSWD" IS '密码';COMMENT ON COLUMN "SCOTT"."T_USER"."CREATE_TIME" IS '创建时间';COMMENT ON COLUMN "SCOTT"."T_USER"."STATUS" IS '是否有效 1：有效 0：锁定';-- ------------------------------ Records of T_USER-- ----------------------------INSERT INTO "SCOTT"."T_USER" VALUES ('2', 'tester', '243e29429b340192700677d48c09d992', TO_DATE('2017-12-11 17:20:21', 'YYYY-MM-DD HH24:MI:SS'), '1');INSERT INTO "SCOTT"."T_USER" VALUES ('1', 'mrbird', '42ee25d1e43e9f57119a00d0a39e5250', TO_DATE('2017-12-11 10:52:48', 'YYYY-MM-DD HH24:MI:SS'), '1');-- ------------------------------ Table structure for T_USER_ROLE-- ----------------------------CREATE TABLE "SCOTT"."T_USER_ROLE" ( "USER_ID" NUMBER(10) NULL , "RID" NUMBER(10) NULL );COMMENT ON COLUMN "SCOTT"."T_USER_ROLE"."USER_ID" IS '用户id';COMMENT ON COLUMN "SCOTT"."T_USER_ROLE"."RID" IS '角色id';-- ------------------------------ Records of T_USER_ROLE-- ----------------------------INSERT INTO "SCOTT"."T_USER_ROLE" VALUES ('1', '1');INSERT INTO "SCOTT"."T_USER_ROLE" VALUES ('2', '2');一些非空约束这里就不贴了，可参考源码中的init.sql。上面的sql创建了五张表：用户表T_USER、角色表T_ROLE、用户角色关联表T_USER_ROLE、权限表T_PERMISSION和权限角色关联表T_ROLE_PERMISSION。用户mrbird角色为admin，用户tester角色为test。admin角色拥有用户的所有权限（user:user,user:add,user:delete），而test角色只拥有用户的查看权限（user:user）。密码都是123456，经过Shiro提供的MD5加密。Dao层创建两个实体类，对应用户角色表Role和用户权限表Permission：Role:12345678public class Role implements Serializable&#123; private static final long serialVersionUID = -227437593919820521L; private Integer id; private String name; private String memo; // get set略&#125;Permission:12345678public class Permission implements Serializable&#123; private static final long serialVersionUID = 7160557680614732403L; private Integer id; private String url; private String name; // get,set略 &#125;创建两个dao接口，分别用户查询用户的所有角色和用户的所有权限：UserRoleMapper：1234@Mapperpublic interface UserRoleMapper &#123; List&lt;Role&gt; findByUserName(String userName);&#125;UserPermissionMapper：1234@Mapperpublic interface UserPermissionMapper &#123; List&lt;Permission&gt; findByUserName(String userName);&#125;其xml实现：UserRoleMapper.xml：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.springboot.dao.UserRoleMapper"&gt; &lt;resultMap type="com.springboot.pojo.Role" id="role"&gt; &lt;id column="id" property="id" javaType="java.lang.Integer" jdbcType="NUMERIC"/&gt; &lt;id column="name" property="name" javaType="java.lang.String" jdbcType="VARCHAR"/&gt; &lt;id column="memo" property="memo" javaType="java.lang.String" jdbcType="VARCHAR"/&gt; &lt;/resultMap&gt; &lt;select id="findByUserName" resultMap="role"&gt; select r.id,r.name,r.memo from t_role r left join t_user_role ur on(r.id = ur.rid) left join t_user u on(u.id = ur.user_id) where u.username = #&#123;userName&#125; &lt;/select&gt;&lt;/mapper&gt;UserPermissionMapper.xml：1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.springboot.dao.UserPermissionMapper"&gt; &lt;resultMap type="com.springboot.pojo.Permission" id="permission"&gt; &lt;id column="id" property="id" javaType="java.lang.Integer" jdbcType="NUMERIC"/&gt; &lt;id column="url" property="url" javaType="java.lang.String" jdbcType="VARCHAR"/&gt; &lt;id column="name" property="name" javaType="java.lang.String" jdbcType="VARCHAR"/&gt; &lt;/resultMap&gt; &lt;select id="findByUserName" resultMap="permission"&gt; select p.id,p.url,p.name from t_role r left join t_user_role ur on(r.id = ur.rid) left join t_user u on(u.id = ur.user_id) left join t_role_permission rp on(rp.rid = r.id) left join t_permission p on(p.id = rp.pid ) where u.username = #&#123;userName&#125; &lt;/select&gt;&lt;/mapper&gt;数据层准备好后，接下来对Realm进行改造。Realm在Shiro中，用户角色和权限的获取是在Realm的doGetAuthorizationInfo()方法中实现的，所以接下来手动实现该方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ShiroRealm extends AuthorizingRealm &#123; @Autowired private UserMapper userMapper; @Autowired private UserRoleMapper userRoleMapper; @Autowired private UserPermissionMapper userPermissionMapper; /** * 获取用户角色和权限 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principal) &#123; User user = (User) SecurityUtils.getSubject().getPrincipal(); String userName = user.getUserName(); System.out.println("用户" + userName + "获取权限-----ShiroRealm.doGetAuthorizationInfo"); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); // 获取用户角色集 List&lt;Role&gt; roleList = userRoleMapper.findByUserName(userName); Set&lt;String&gt; roleSet = new HashSet&lt;String&gt;(); for (Role r : roleList) &#123; roleSet.add(r.getName()); &#125; simpleAuthorizationInfo.setRoles(roleSet); // 获取用户权限集 List&lt;Permission&gt; permissionList = userPermissionMapper.findByUserName(userName); Set&lt;String&gt; permissionSet = new HashSet&lt;String&gt;(); for (Permission p : permissionList) &#123; permissionSet.add(p.getName()); &#125; simpleAuthorizationInfo.setStringPermissions(permissionSet); return simpleAuthorizationInfo; &#125; /** * 登录认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; // 登录认证已经实现过，这里不再贴代码 &#125;&#125;在上述代码中，我们通过方法userRoleMapper.findByUserName(userName)和userPermissionMapper.findByUserName(userName)获取了当前登录用户的角色和权限集，然后保存到SimpleAuthorizationInfo对象中，并返回给Shiro，这样Shiro中就存储了当前用户的角色和权限信息了。除了对Realm进行改造外，我们还需修改ShiroConfig配置。ShiroConfigShiro为我们提供了一些和权限相关的注解，如下所示：1234567891011121314// 表示当前Subject已经通过login进行了身份验证；即Subject.isAuthenticated()返回true。@RequiresAuthentication // 表示当前Subject已经身份验证或者通过记住我登录的。@RequiresUser // 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。@RequiresGuest // 表示当前Subject需要角色admin和user。 @RequiresRoles(value=&#123;"admin", "user"&#125;, logical= Logical.AND) // 表示当前Subject需要权限user:a或user:b。@RequiresPermissions (value=&#123;"user:a", "user:b"&#125;, logical= Logical.OR)要开启这些注解的使用，需要在ShiroConfig中添加如下配置：12345678...@Beanpublic AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor;&#125;...Controller编写一个UserController，用于处理User类的访问请求，并使用Shiro权限注解控制权限：12345678910111213141516171819202122232425@Controller@RequestMapping("/user")public class UserController &#123; @RequiresPermissions("user:user") @RequestMapping("list") public String userList(Model model) &#123; model.addAttribute("value", "获取用户信息"); return "user"; &#125; @RequiresPermissions("user:add") @RequestMapping("add") public String userAdd(Model model) &#123; model.addAttribute("value", "新增用户"); return "user"; &#125; @RequiresPermissions("user:delete") @RequestMapping("delete") public String userDelete(Model model) &#123; model.addAttribute("value", "删除用户"); return "user"; &#125;&#125;在LoginController中添加一个/403跳转：1234@GetMapping("/403")public String forbid() &#123; return "403";&#125;前端页面对index.html进行改造，添加三个用户操作的链接：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你好！[[$&#123;user.userName&#125;]]&lt;/p&gt; &lt;h3&gt;权限测试链接&lt;/h3&gt; &lt;div&gt; &lt;a th:href="@&#123;/user/list&#125;"&gt;获取用户信息&lt;/a&gt; &lt;a th:href="@&#123;/user/add&#125;"&gt;新增用户&lt;/a&gt; &lt;a th:href="@&#123;/user/delete&#125;"&gt;删除用户&lt;/a&gt; &lt;/div&gt; &lt;a th:href="@&#123;/logout&#125;"&gt;注销&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;当用户对用户的操作有相应权限的时候，跳转到user.html：1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;[[$&#123;value&#125;]]&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;[[$&#123;value&#125;]]&lt;/p&gt; &lt;a th:href="@&#123;/index&#125;"&gt;返回&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;403页面：12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;暂无权限&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;您没有权限访问该资源！！&lt;/p&gt; &lt;a th:href="@&#123;/index&#125;"&gt;返回&lt;/a&gt;&lt;/body&gt;测试启动项目，使用mrbird的账户登录后主页如下图所示：点击”获取用户信息连接”：因为mrbird角色为admin，对着三个链接都由访问权限，所以这里就不演示了。接着使用tester用户登录。因为tester用户角色为test，只拥有（user:user）权限，所以当其点击”新增用户”和”删除用户”的时候：后台抛出org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method:…异常！！！这里有点出乎意料，本以为在ShiroConfig中配置了shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/403&quot;);，没有权限的访问会自动重定向到/403，结果证明并不是这样。后来研究发现，该设置只对filterChain起作用，比如在filterChain中设置了filterChainDefinitionMap.put(&quot;/user/update&quot;, &quot;perms[user:update]&quot;);，如果用户没有user:update权限，那么当其访问/user/update的时候，页面会被重定向到/403。那么对于上面这个问题，我们可以定义一个全局异常捕获类：12345678@ControllerAdvice@Order(value = Ordered.HIGHEST_PRECEDENCE)public class GlobalExceptionHandler &#123; @ExceptionHandler(value = AuthorizationException.class) public String handleAuthorizationException() &#123; return "403"; &#125;&#125;启动项目，再次使用tester的账号点击”新增用户”和”删除用户”链接的时候，页面如下所示：页面已经成功重定向到/403。源码链接https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/13.Spring-Boot-Shiro-Authorization]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Shiro</tag>
        <tag>Security</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Shiro Remember Me]]></title>
    <url>%2FSpring-Boot-Shiro%20Remember-Me.html</url>
    <content type="text"><![CDATA[接着《Spring-Boot-shiro用户认证》，当用户成功登录后，关闭浏览器然后再打开浏览器访问http://localhost:8080/web/index，页面会跳转到登录页，之前的登录因为浏览器的关闭已经失效。Shiro为我们提供了Remember Me的功能，用户的登录状态不会因为浏览器的关闭而失效，直到Cookie过期。更改 ShiroConfig继续编辑ShiroConfig，加入：1234567891011121314151617181920212223/** * cookie对象 * @return */public SimpleCookie rememberMeCookie() &#123; // 设置cookie名称，对应login.html页面的&lt;input type="checkbox" name="rememberMe"/&gt; SimpleCookie cookie = new SimpleCookie("rememberMe"); // 设置cookie的过期时间，单位为秒，这里为一天 cookie.setMaxAge(86400); return cookie;&#125;/** * cookie管理对象 * @return */public CookieRememberMeManager rememberMeManager() &#123; CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); // rememberMe cookie加密的密钥 cookieRememberMeManager.setCipherKey(Base64.decode("4AvVhmFLUs0KTA3Kprsdag==")); return cookieRememberMeManager;&#125;接下来将cookie管理对象设置到SecurityManager中：1234567@Bean public SecurityManager securityManager()&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shiroRealm()); securityManager.setRememberMeManager(rememberMeManager()); return securityManager; &#125;最后修改权限配置，将ShiroFilterFactoryBean的filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);更改为filterChainDefinitionMap.put(&quot;/**&quot;, &quot;user&quot;);。user指的是用户认证通过或者配置了Remember Me记住用户登录状态后可访问。更改 login.html在login.html中加入Remember Me checkbox：12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel="stylesheet" th:href="@&#123;/css/login.css&#125;" type="text/css"&gt; &lt;script th:src="@&#123;/js/jquery-1.11.1.min.js&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="login-page"&gt; &lt;div class="form"&gt; &lt;input type="text" placeholder="用户名" name="username" required="required"/&gt; &lt;input type="password" placeholder="密码" name="password" required="required"/&gt; &lt;p&gt;&lt;input type="checkbox" name="rememberMe" /&gt;记住我&lt;/p&gt; &lt;button onclick="login()"&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script th:inline="javascript"&gt; var ctx = [[@&#123;/&#125;]]; function login() &#123; var username = $("input[name='username']").val(); var password = $("input[name='password']").val(); var rememberMe = $("input[name='rememberMe']").is(':checked'); $.ajax(&#123; type: "post", url: ctx + "login", data: &#123;"username": username,"password": password,"rememberMe": rememberMe&#125;, dataType: "json", success: function (r) &#123; if (r.code == 0) &#123; location.href = ctx + 'index'; &#125; else &#123; alert(r.msg); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;/html&gt;更改 LoginController更改LoginController的login()方法：12345678910111213141516171819@PostMapping("/login")@ResponseBodypublic ResponseBo login(String username, String password, Boolean rememberMe) &#123; password = MD5Utils.encrypt(username, password); UsernamePasswordToken token = new UsernamePasswordToken(username, password, rememberMe); Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(token); return ResponseBo.ok(); &#125; catch (UnknownAccountException e) &#123; return ResponseBo.error(e.getMessage()); &#125; catch (IncorrectCredentialsException e) &#123; return ResponseBo.error(e.getMessage()); &#125; catch (LockedAccountException e) &#123; return ResponseBo.error(e.getMessage()); &#125; catch (AuthenticationException e) &#123; return ResponseBo.error("认证失败！"); &#125;&#125;当rememberMe参数为true的时候，Shiro就会帮我们记住用户的登录状态。启动项目即可看到效果。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/12.Spring-Boot-Shiro-RememberMe]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Shiro</tag>
        <tag>Security</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Shiro用户认证]]></title>
    <url>%2FSpring-Boot-shiro%20Authentication.html</url>
    <content type="text"><![CDATA[在Spring Boot中集成Shiro进行用户的认证过程主要可以归纳为以下三点：1、定义一个ShiroConfig，然后配置SecurityManager Bean，SecurityManager为Shiro的安全管理器，管理着所有Subject；2、在ShiroConfig中配置ShiroFilterFactoryBean，其为Shiro过滤器工厂类，依赖于SecurityManager；3、自定义Realm实现，Realm包含doGetAuthorizationInfo()和doGetAuthenticationInfo()方法，因为本文只涉及用户认证，所以只实现doGetAuthenticationInfo()方法。引入依赖首先可根据文章《开启Spring Boot》搭建一个Spring Boot Web程序，然后引入Shiro、MyBatis、数据库和thymeleaf依赖：123456789101112131415161718192021222324252627282930313233&lt;!-- MyBatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- shiro-spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- oracle驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- druid数据源驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;ShiroConfig定义一个Shiro配置类，名称为ShiroConfig：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configurationpublic class ShiroConfig &#123; @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置securityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 登录的url shiroFilterFactoryBean.setLoginUrl("/login"); // 登录成功后跳转的url shiroFilterFactoryBean.setSuccessUrl("/index"); // 未授权url shiroFilterFactoryBean.setUnauthorizedUrl("/403"); LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;(); // 定义filterChain，静态资源不拦截 filterChainDefinitionMap.put("/css/**", "anon"); filterChainDefinitionMap.put("/js/**", "anon"); filterChainDefinitionMap.put("/fonts/**", "anon"); filterChainDefinitionMap.put("/img/**", "anon"); // druid数据源监控页面不拦截 filterChainDefinitionMap.put("/druid/**", "anon"); // 配置退出过滤器，其中具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put("/logout", "logout"); filterChainDefinitionMap.put("/", "anon"); // 除上以外所有url都必须认证通过才可以访问，未通过认证自动访问LoginUrl filterChainDefinitionMap.put("/**", "authc"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; @Bean public SecurityManager securityManager()&#123; // 配置SecurityManager，并注入shiroRealm DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(shiroRealm()); return securityManager; &#125; @Bean public ShiroRealm shiroRealm()&#123; // 配置Realm，需自己实现 ShiroRealm shiroRealm = new ShiroRealm(); return shiroRealm; &#125; &#125;需要注意的是filterChain基于短路机制，即最先匹配原则，如：12/user/**=anon/user/aa=authc 永远不会执行其中anon、authc等为Shiro为我们实现的过滤器，具体如下表所示：Filter NameClassDescriptionanonorg.apache.shiro.web.filter.authc.AnonymousFilter匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例/static/**=anonauthcorg.apache.shiro.web.filter.authc.FormAuthenticationFilter基于表单的拦截器；如/**=authc，如果没有登录会跳到相应的登录页面登录authcBasicorg.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilterBasic HTTP身份验证拦截器logoutorg.apache.shiro.web.filter.authc.LogoutFilter退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（/），示例/logout=logoutnoSessionCreationorg.apache.shiro.web.filter.session.NoSessionCreationFilter不创建会话拦截器，调用subject.getSession(false)不会有什么问题，但是如果subject.getSession(true)将抛出DisabledSessionException异常permsorg.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter权限授权拦截器，验证用户是否拥有所有权限；属性和roles一样；示例/user/**=perms[&quot;user:create&quot;]portorg.apache.shiro.web.filter.authz.PortFilter端口拦截器，主要属性port(80)：可以通过的端口；示例/test= port[80]，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样restorg.apache.shiro.web.filter.authz.HttpMethodPermissionFilterrest风格拦截器，自动根据请求方法构建权限字符串；示例/users=rest[user]，会自动拼出user:read,user:create,user:update,user:delete权限字符串进行权限匹配（所有都得匹配，isPermittedAll）rolesorg.apache.shiro.web.filter.authz.RolesAuthorizationFilter角色授权拦截器，验证用户是否拥有所有角色；示例/admin/**=roles[admin]sslorg.apache.shiro.web.filter.authz.SslFilterSSL拦截器，只有请求协议是https才能通过；否则自动跳转会https端口443；其他和port拦截器一样；userorg.apache.shiro.web.filter.authc.UserFilter用户拦截器，用户已经身份验证/记住我登录的都可；示例/**=user配置完ShiroConfig后，接下来对Realm进行实现，然后注入到SecurityManager中。Realm自定义Realm实现只需继承AuthorizingRealm类，然后实现doGetAuthorizationInfo()和doGetAuthenticationInfo()方法即可。这两个方法名乍看有点像，authorization发音[ˌɔ:θəraɪˈzeɪʃn]，为授权，批准的意思，即获取用户的角色和权限等信息；authentication发音[ɔ:ˌθentɪ’keɪʃn]，认证，身份验证的意思，即登录时验证用户的合法性，比如验证用户名和密码。1234567891011121314151617181920212223242526272829303132333435363738394041public class ShiroRealm extends AuthorizingRealm &#123; @Autowired private UserMapper userMapper; /** * 获取用户角色和权限 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principal) &#123; return null; &#125; /** * 登录认证 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; // 获取用户输入的用户名和密码 String userName = (String) token.getPrincipal(); String password = new String((char[]) token.getCredentials()); System.out.println("用户" + userName + "认证-----ShiroRealm.doGetAuthenticationInfo"); // 通过用户名到数据库查询用户信息 User user = userMapper.findByUserName(userName); if (user == null) &#123; throw new UnknownAccountException("用户名或密码错误！"); &#125; if (!password.equals(user.getPassword())) &#123; throw new IncorrectCredentialsException("用户名或密码错误！"); &#125; if (user.getStatus().equals("0")) &#123; throw new LockedAccountException("账号已被锁定,请联系管理员！"); &#125; SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, password, getName()); return info; &#125;&#125;因为本节只讲述用户认证，所以doGetAuthorizationInfo()方法先不进行实现。其中UnknownAccountException等异常为Shiro自带异常，Shiro具有丰富的运行时AuthenticationException层次结构，可以准确指出尝试失败的原因。你可以包装在一个try/catch块，并捕捉任何你希望的异常，并作出相应的反应。例如：12345678910try &#123; currentUser.login(token);&#125; catch ( UnknownAccountException uae ) &#123; ...&#125; catch ( IncorrectCredentialsException ice ) &#123; ...&#125; catch ( LockedAccountException lae ) &#123; ...&#125; catch ( ExcessiveAttemptsException eae ) &#123; ...&#125; ... catch your own ...&#125; catch ( AuthenticationException ae ) &#123; //unexpected error?&#125;虽然我们可以准确的获取异常信息，并根据这些信息给用户提示具体错误，但最安全的做法是在登录失败时仅向用户显示通用错误提示信息，例如“用户名或密码错误”。这样可以防止数据库被恶意扫描。在Realm中UserMapper为Dao层，标准的做法应该还有Service层，但这里为了方便就不再定义Service层了。接下来编写和数据库打交道的Dao层。数据层首先创建一张用户表，用于存储用户的基本信息（基于Oracle 11g）：1234567891011121314151617181920212223242526-- ------------------------------ Table structure for T_USER-- ----------------------------CREATE TABLE "SCOTT"."T_USER" ( "ID" NUMBER NOT NULL , "USERNAME" VARCHAR2(20 BYTE) NOT NULL , "PASSWD" VARCHAR2(128 BYTE) NOT NULL , "CREATE_TIME" DATE NULL , "STATUS" CHAR(1 BYTE) NOT NULL );COMMENT ON COLUMN "SCOTT"."T_USER"."USERNAME" IS '用户名';COMMENT ON COLUMN "SCOTT"."T_USER"."PASSWD" IS '密码';COMMENT ON COLUMN "SCOTT"."T_USER"."CREATE_TIME" IS '创建时间';COMMENT ON COLUMN "SCOTT"."T_USER"."STATUS" IS '是否有效 1：有效 0：锁定';-- ------------------------------ Records of T_USER-- ----------------------------INSERT INTO "SCOTT"."T_USER" VALUES ('2', 'test', '7a38c13ec5e9310aed731de58bbc4214', TO_DATE('2017-11-19 17:20:21', 'YYYY-MM-DD HH24:MI:SS'), '0');INSERT INTO "SCOTT"."T_USER" VALUES ('1', 'mrbird', '42ee25d1e43e9f57119a00d0a39e5250', TO_DATE('2017-11-19 10:52:48', 'YYYY-MM-DD HH24:MI:SS'), '1');-- ------------------------------ Primary Key structure for table T_USER-- ----------------------------ALTER TABLE "SCOTT"."T_USER" ADD PRIMARY KEY ("ID");数据源的配置这里就不贴出来了，具体可参考源码，或者参考https://mrbird.cc/Spring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8Mybatis.html。库表对应的实体类：123456789101112public class User implements Serializable&#123; private static final long serialVersionUID = -5440372534300871944L; private Integer id; private String userName; private String password; private Date createTime; private String status; // get,set略&#125;定义接口UserMapper：1234@Mapperpublic interface UserMapper &#123; User findByUserName(String userName);&#125;xml实现：1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.springboot.dao.UserMapper"&gt; &lt;resultMap type="com.springboot.pojo.User" id="User"&gt; &lt;id column="id" property="id" javaType="java.lang.Integer" jdbcType="NUMERIC"/&gt; &lt;id column="username" property="userName" javaType="java.lang.String" jdbcType="VARCHAR"/&gt; &lt;id column="passwd" property="password" javaType="java.lang.String" jdbcType="VARCHAR"/&gt; &lt;id column="create_time" property="createTime" javaType="java.util.Date" jdbcType="DATE"/&gt; &lt;id column="status" property="status" javaType="java.lang.String" jdbcType="VARCHAR"/&gt; &lt;/resultMap&gt; &lt;select id="findByUserName" resultMap="User"&gt; select * from t_user where username = #&#123;userName&#125; &lt;/select&gt;&lt;/mapper&gt;数据层准备完了，接下来编写login.html和index.html页面。页面准备编写登录页面login.html：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel="stylesheet" th:href="@&#123;/css/login.css&#125;" type="text/css"&gt; &lt;script th:src="@&#123;/js/jquery-1.11.1.min.js&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="login-page"&gt; &lt;div class="form"&gt; &lt;input type="text" placeholder="用户名" name="username" required="required"/&gt; &lt;input type="password" placeholder="密码" name="password" required="required"/&gt; &lt;button onclick="login()"&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script th:inline="javascript"&gt; var ctx = [[@&#123;/&#125;]]; function login() &#123; var username = $("input[name='username']").val(); var password = $("input[name='password']").val(); $.ajax(&#123; type: "post", url: ctx + "login", data: &#123;"username": username,"password": password&#125;, dataType: "json", success: function (r) &#123; if (r.code == 0) &#123; location.href = ctx + 'index'; &#125; else &#123; alert(r.msg); &#125; &#125; &#125;); &#125;&lt;/script&gt;&lt;/html&gt;主页index.html：1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你好！[[$&#123;user.userName&#125;]]&lt;/p&gt; &lt;a th:href="@&#123;/logout&#125;"&gt;注销&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;页面准备完毕，接下来编写LoginController。ControllerLoginController代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243@Controllerpublic class LoginController &#123; @GetMapping("/login") public String login() &#123; return "login"; &#125; @PostMapping("/login") @ResponseBody public ResponseBo login(String username, String password) &#123; // 密码MD5加密 password = MD5Utils.encrypt(username, password); UsernamePasswordToken token = new UsernamePasswordToken(username, password); // 获取Subject对象 Subject subject = SecurityUtils.getSubject(); try &#123; subject.login(token); return ResponseBo.ok(); &#125; catch (UnknownAccountException e) &#123; return ResponseBo.error(e.getMessage()); &#125; catch (IncorrectCredentialsException e) &#123; return ResponseBo.error(e.getMessage()); &#125; catch (LockedAccountException e) &#123; return ResponseBo.error(e.getMessage()); &#125; catch (AuthenticationException e) &#123; return ResponseBo.error("认证失败！"); &#125; &#125; @RequestMapping("/") public String redirectIndex() &#123; return "redirect:/index"; &#125; @RequestMapping("/index") public String index(Model model) &#123; // 登录成后，即可通过Subject获取登录的用户信息 User user = (User) SecurityUtils.getSubject().getPrincipal(); model.addAttribute("user", user); return "index"; &#125;&#125;登录成功后，根据之前在ShiroConfig中的配置shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;)，页面会自动访问/index路径。测试最终项目目录如下图所示：启动项目，分别访问：http://localhost:8080/web/http://localhost:8080/web/indexhttp://localhost:8080/web/aaaaaaahttp://localhost:8080/web可发现页面都被重定向到http://localhost:8080/web/login：当输入错误的用户信息时：用test的账户登录（test账户的status为0，已被锁定）：当输入正确的用户名密码时候：点击注销连接，根据ShiroConfig的配置filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;)，Shiro会自动帮我们注销用户信息，并重定向到/路径。Spring Boot集成Shiro进行用户认证到此就结束了，源码参见https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/11.Spring-Boot-Shiro-Authentication]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Shiro</tag>
        <tag>Security</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Shiro简介]]></title>
    <url>%2FApache%20Shiro%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[Apache Shiro（发音为shee-roh，日语堡垒（Castle）的意思）是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。相较于Spring Security来说较为简单，易于上手。Apache Shiro有三个核心的概念Subject，SecurityManager和Realms，如下图所示：1、Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等，即一个抽象概念。所有Subject 都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager。可以把Subject认为是一个门面，SecurityManager才是实际的执行者。在shiro中通过org.apache.shiro.SecurityUtils类来获取Subject对象：1234import org.apache.shiro.subject.Subject;import org.apache.shiro.SecurityUtils;...Subject currentUser = SecurityUtils.getSubject();更多关于Subject的信息可访问http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/subject/Subject.html2、SecurityManager：安全管理器，即所有与安全有关的操作都会与SecurityManager交互，且它管理着所有Subject，可以看出它是Shiro的核心。它负责与后边介绍的其他组件进行 交互，类似于Spring MVC中的DispatcherServlet前端控制器。3、Realm：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法。 也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作。简而言之，创建一个基本的Shiro应用过程为：应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。Shiro并没有为我们提供Realm的实现，需要我们手动编写实现。基本过程为继承org.apache.shiro.realm.AuthorizingRealm抽象类，实现doGetAuthorizationInfo和doGetAuthenticationInfo方法。了解了Shiro的核心组件后，接下来看看Shiro为我们带来了哪些功能模块：Shiro提供了四大基本安全功能：认证，授权，会话管理和加密。身份验证(Authentication)：也称为登录验证，即验证用户名和密码是否正确；授权(Authorization)：根据用户的角色和权限来控制用户可访问的资源；会话管理(Session Management)：即使在非Web或EJB应用程序中，也可以管理用户特定的SESSION会话；密码学(Cryptography)：使用加密算法保证数据安全，同时易于使用。除此之外，Shiro也支持以下特性：Web支持(Web Support)：Shiro提供的web程序API可以帮助轻松保护Web应用程序；缓存(Caching)：缓存可确保安全验证操作保持快速高效；并发性(Concurrency)：Apache Shiro支持具有并发功能的多线程应用程序；测试(Testing)：测试API帮助您编写单元测试和集成测试；运行方式(Run As)：允许用户以别的用户身份（如果允许）登录；记住我(Remember Me)：在会话中记住用户的身份，只有在强制登录时才需要登录。参考自:http://shiro.apache.org/introduction.htmlhttp://www.infoq.com/cn/articles/apache-shiro]]></content>
      <tags>
        <tag>Shiro</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot项目打包成war包]]></title>
    <url>%2FSpring-Boot%20war.html</url>
    <content type="text"><![CDATA[在pom.xml文件中，将打包方式改为war：1&lt;packaging&gt;war&lt;/packaging&gt;然后添加如下的Tomcat依赖配置，覆盖Spring Boot自带的Tomcat依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;在&lt;build&gt;&lt;/build&gt;标签内配置项目名（该配置类似于server.context-path=mrbird）：123456...&lt;build&gt; ... &lt;finalName&gt;mrbird&lt;/finalName&gt;&lt;/build&gt;...添加启动类ServletInitializer：123456789import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.support.SpringBootServletInitializer;public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Application.class); &#125;&#125;其中Application为Spring Boot的启动类。准备完毕后，运行mvn clean package命令即可在target目录下生产war包：]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用缓存]]></title>
    <url>%2FSpring-Boot%20cache.html</url>
    <content type="text"><![CDATA[在程序中可以使用缓存的技术来节省对数据库的开销。Spring Boot对缓存提供了很好的支持，我们几乎不用做过多的配置即可使用各种缓存实现。这里主要介绍平日里个人接触较多的Ehcache和Redis缓存实现。准备工作可根据Spring-Boot中使用Mybatis.html搭建一个Spring Boot项目，然后yml中配置日志输出级别以观察SQL的执行情况：12345logging: level: com: springboot: mapper: debug其中com.spring.mapper为MyBatis的Mapper接口路径。然后编写如下测试方法：12345678910111213141516@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = Application.class)public class ApplicationTest &#123; @Autowired private StudentService studentService; @Test public void test() throws Exception &#123; Student student1 = this.studentService.queryStudentBySno("001"); System.out.println("学号" + student1.getSno() + "的学生姓名为：" + student1.getName()); Student student2 = this.studentService.queryStudentBySno("001"); System.out.println("学号" + student2.getSno() + "的学生姓名为：" + student2.getName()); &#125;&#125;右键run as junit test：123456782017-11-17 16:34:26.535 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2017-11-17 16:34:26.688 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Parameters: 001(String)2017-11-17 16:34:26.716 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno : &lt;== Total: 1学号001的学生姓名为：KangKang2017-11-17 16:34:26.720 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2017-11-17 16:34:26.720 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Parameters: 001(String)2017-11-17 16:34:26.721 DEBUG 9932 --- [main] c.s.m.StudentMapper.queryStudentBySno : &lt;== Total: 1学号001的学生姓名为：KangKang可发现第二个查询虽然和第一个查询完全一样，但其还是对数据库进行了查询。接下来引入缓存来改善这个结果。使用缓存要开启Spring Boot的缓存功能，需要在pom中引入spring-boot-starter-cache：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;接着在Spring Boot入口类中加入@EnableCaching注解开启缓存功能：1234567@SpringBootApplication@EnableCachingpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125;&#125;在StudentService接口中加入缓存注解：123456789101112@CacheConfig(cacheNames = "student")@Repositorypublic interface StudentService &#123; @CachePut(key = "#p0.sno") Student update(Student student); @CacheEvict(key = "#p0", allEntries = true) void deleteStudentBySno(String sno); @Cacheable(key = "#p0") Student queryStudentBySno(String sno);&#125;我们在StudentService接口中加入了@CacheConfig注解，queryStudentBySno方法使用了注解@Cacheable(key=&quot;#p0&quot;)，即将id作为redis中的key值。当我们更新数据的时候，应该使用@CachePut(key=&quot;#p0.sno&quot;)进行缓存数据的更新，否则将查询到脏数据，因为该注解保存的是方法的返回值，所以这里应该返回Student。其实现类：123456789101112131415161718192021@Repository("studentService")public class StudentServiceImpl implements StudentService&#123; @Autowired private StudentMapper studentMapper; @Override public Student update(Student student) &#123; this.studentMapper.update(student); return this.studentMapper.queryStudentBySno(student.getSno()); &#125; @Override public void deleteStudentBySno(String sno) &#123; this.studentMapper.deleteStudentBySno(sno); &#125; @Override public Student queryStudentBySno(String sno) &#123; return this.studentMapper.queryStudentBySno(sno); &#125;&#125;在Spring Boot中可使用的缓存注解有：缓存注解@CacheConfig：主要用于配置该类中会用到的一些共用的缓存配置。在这里@CacheConfig(cacheNames = &quot;student&quot;)：配置了该数据访问对象中返回的内容将存储于名为student的缓存对象中，我们也可以不使用该注解，直接通过@Cacheable自己配置缓存集的名字来定义；@Cacheable：配置了queryStudentBySno函数的返回值将被加入缓存。同时在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问。该注解主要有下面几个参数：value、cacheNames：两个等同的参数（cacheNames为Spring 4新增，作为value的别名），用于指定缓存存储的集合名。由于Spring 4中新增了@CacheConfig，因此在Spring 3中原本必须有的value属性，也成为非必需项了；key：缓存对象存储在Map集合中的key值，非必需，缺省按照函数的所有参数组合作为key值，若自己配置需使用SpEL表达式，比如：@Cacheable(key = &quot;#p0&quot;)：使用函数第一个参数作为缓存的key值，更多关于SpEL表达式的详细内容可参考https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache；condition：缓存对象的条件，非必需，也需使用SpEL表达式，只有满足表达式条件的内容才会被缓存，比如：@Cacheable(key = &quot;#p0&quot;, condition = &quot;#p0.length() &lt; 3&quot;)，表示只有当第一个参数的长度小于3的时候才会被缓存；unless：另外一个缓存条件参数，非必需，需使用SpEL表达式。它不同于condition参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对result进行判断；keyGenerator：用于指定key生成器，非必需。若需要指定一个自定义的key生成器，我们需要去实现org.springframework.cache.interceptor.KeyGenerator接口，并使用该参数来指定；cacheManager：用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用；cacheResolver：用于指定使用那个缓存解析器，非必需。需通过org.springframework.cache.interceptor.CacheResolver接口来实现自己的缓存解析器，并用该参数指定；@CachePut：配置于函数上，能够根据参数定义条件来进行缓存，其缓存的是方法的返回值，它与@Cacheable不同的是，它每次都会真实调用函数，所以主要用于数据新增和修改操作上。它的参数与@Cacheable类似，具体功能可参考上面对@Cacheable参数的解析；@CacheEvict：配置于函数上，通常用在删除方法上，用来从缓存中移除相应数据。除了同@Cacheable一样的参数之外，它还有下面两个参数：allEntries：非必需，默认为false。当为true时，会移除所有数据；beforeInvocation：非必需，默认为false，会在调用方法之后移除数据。当为true时，会在调用方法之前移除数据。缓存实现要使用上Spring Boot的缓存功能，还需要提供一个缓存的具体实现。Spring Boot根据下面的顺序去侦测缓存实现：GenericJCache (JSR-107)EhCache 2.xHazelcastInfinispanRedisGuavaSimple除了按顺序侦测外，我们也可以通过配置属性spring.cache.type来强制指定。接下来主要介绍基于Redis和Ehcache的缓存实现。RedisRedis的下载地址为https://github.com/MicrosoftArchive/redis/releases，Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到C盘。打开一个CMD窗口，输入如下命令：123456789101112131415161718192021222324C:\Users\Administrator&gt;cd c:\Redis-x64-3.2.100c:\Redis-x64-3.2.100&gt;redis-server.exe redis.windows.conf _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 3.2.100 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 6404 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-'[6404] 25 Dec 09:47:58.890 # Server started, Redis version 3.2.100[6404] 25 Dec 09:47:58.898 * DB loaded from disk: 0.007 seconds[6404] 25 Dec 09:47:58.898 * The server is now ready to accept connections on port 6379然后打开另外一个CMD终端，输入：1234C:\Users\Administrator&gt;cd c:\Redis-x64-3.2.100c:\Redis-x64-3.2.100&gt;redis-cli.exe -p 6379127.0.0.1:6379&gt;准备工作做完后，接下来开始在Spring Boot项目里引入Redis：12345&lt;!-- spring-boot redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;在application.yml中配置Redis：12345678910111213141516171819spring: redis: # Redis数据库索引（默认为0） database: 0 # Redis服务器地址 host: localhost # Redis服务器连接端口 port: 6379 pool: # 连接池最大连接数（使用负值表示没有限制） max-active: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-wait: -1 # 连接池中的最大空闲连接 max-idle: 8 # 连接池中的最小空闲连接 min-idle: 0 # 连接超时时间（毫秒） timeout: 0更多关于Spring Boot Redis配置可参考：https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html# REDIS接着创建一个Redis配置类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123; // 自定义缓存key生成策略 @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object target, java.lang.reflect.Method method, Object... params) &#123; StringBuffer sb = new StringBuffer(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125; &#125;; &#125; // 缓存管理器 @Bean public CacheManager cacheManager(@SuppressWarnings("rawtypes") RedisTemplate redisTemplate) &#123; RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate); // 设置缓存过期时间（秒） cacheManager.setDefaultExpiration(3600); return cacheManager; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; StringRedisTemplate template = new StringRedisTemplate(factory); setSerializer(template);// 设置序列化工具 template.afterPropertiesSet(); return template; &#125; private void setSerializer(StringRedisTemplate template) &#123; @SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;) Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); &#125;&#125;运行测试，控制台输出：123452017-11-17 18:17:06.995 DEBUG 8836 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2017-11-17 18:17:07.128 DEBUG 8836 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Parameters: 001(String)2017-11-17 18:17:07.152 DEBUG 8836 --- [main] c.s.m.StudentMapper.queryStudentBySno : &lt;== Total: 1学号001的学生姓名为：KangKang学号001的学生姓名为：KangKang第二次查询没有访问数据库，而是从缓存中获取的，在redis中查看该值：12345127.0.0.1:6379&gt; keys *1) "student~keys"2) "001"127.0.0.1:6379&gt; get 001"[\"com.springboot.bean.Student\",&#123;\"sno\":\"001\",\"name\":\"KangKang\",\"sex\":\"M \"&#125;]"在测试方法中测试更新：1234567891011@Testpublic void test() throws Exception &#123; Student student1 = this.studentService.queryStudentBySno("001"); System.out.println("学号" + student1.getSno() + "的学生姓名为：" + student1.getName()); student1.setName("康康"); this.studentService.update(student1); Student student2 = this.studentService.queryStudentBySno("001"); System.out.println("学号" + student2.getSno() + "的学生姓名为：" + student2.getName());&#125;控制台输出：123456789学号001的学生姓名为：KangKang2017-11-17 19:30:05.813 INFO 11244 --- [main] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; inited2017-11-17 19:30:05.823 DEBUG 11244 --- [main] c.s.mapper.StudentMapper.update : ==&gt; Preparing: update student set sname=?,ssex=? where sno=? 2017-11-17 19:30:05.941 DEBUG 11244 --- [main] c.s.mapper.StudentMapper.update : ==&gt; Parameters: 康康(String), M (String), 001(String)2017-11-17 19:30:05.953 DEBUG 11244 --- [main] c.s.mapper.StudentMapper.update : &lt;== Updates: 12017-11-17 19:30:05.957 DEBUG 11244 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2017-11-17 19:30:05.959 DEBUG 11244 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Parameters: 001(String)2017-11-17 19:30:05.976 DEBUG 11244 --- [main] c.s.m.StudentMapper.queryStudentBySno : &lt;== Total: 1学号001的学生姓名为：康康在redis中查看：12127.0.0.1:6379&gt; get 001"[\"com.springboot.bean.Student\",&#123;\"sno\":\"001\",\"name\":\"\xe5\xba\xb7\xe5\xba\xb7\",\"sex\":\"M \"&#125;]"可见更新数据库的同时，缓存也得到了更新。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/09.Spring-Boot-Redis-CacheEhcache引入Ehcache依赖：12345&lt;!-- ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;在src/main/resources目录下新建ehcache.xml：123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="ehcache.xsd"&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="3600" timeToLiveSeconds="0" overflowToDisk="false" diskPersistent="false" diskExpiryThreadIntervalSeconds="120" /&gt; &lt;cache name="student" maxEntriesLocalHeap="2000" eternal="false" timeToIdleSeconds="3600" timeToLiveSeconds="0" overflowToDisk="false" statistics="true"/&gt;&lt;/ehcache&gt;关于Ehcahe的一些说明：name：缓存名称。maxElementsInMemory：缓存最大数目maxElementsOnDisk：硬盘最大缓存个数。eternal：对象是否永久有效，一但设置了，timeout将不起作用。overflowToDisk：是否保存到磁盘。timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0，也就是对象存活时间无穷大。diskPersistent：是否缓存虚拟机重启期数据，默认值为false。diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。clearOnFlush：内存数量最大时是否清除。memoryStoreEvictionPolicy：Ehcache的三种清空策略：FIFO，first in first out，这个是大家最熟的，先进先出。LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。接着在application.yml中指定ehcache配置的路径：1234spring: cache: ehcache: config: 'classpath:ehcache.xml'这样就可以开始使用ehcache了，运行测试类，观察控制台：123452017-11-18 09:10:40.201 DEBUG 3364 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2017-11-18 09:10:40.343 DEBUG 3364 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Parameters: 001(String)2017-11-18 09:10:40.364 DEBUG 3364 --- [main] c.s.m.StudentMapper.queryStudentBySno : &lt;== Total: 1学号001的学生姓名为：KangKang学号001的学生姓名为：KangKang可看到第二次是从缓存中获取的。测试更新：12345678910112017-11-18 09:18:04.230 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2017-11-18 09:18:04.397 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Parameters: 001(String)2017-11-18 09:18:04.427 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno : &lt;== Total: 1学号001的学生姓名为：KangKang2017-11-18 09:18:04.433 DEBUG 11556 --- [main] c.s.mapper.StudentMapper.update : ==&gt; Preparing: update student set sname=?,ssex=? where sno=? 2017-11-18 09:18:04.438 DEBUG 11556 --- [main] c.s.mapper.StudentMapper.update : ==&gt; Parameters: 康康(String), M (String), 001(String)2017-11-18 09:18:04.440 DEBUG 11556 --- [main] c.s.mapper.StudentMapper.update : &lt;== Updates: 12017-11-18 09:18:04.440 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Preparing: select * from student where sno=? 2017-11-18 09:18:04.441 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno : ==&gt; Parameters: 001(String)2017-11-18 09:18:04.442 DEBUG 11556 --- [main] c.s.m.StudentMapper.queryStudentBySno : &lt;== Total: 1学号001的学生姓名为：康康可见，即使更新方法加了@CachePut注解，第二次查询因为Student对象更新了，其是从数据库获取数据的，所以对于Ehcache来说，更新方法加不加@CachePut注解，结果都一样。源码链接：https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/10.Spring-Boot-Ehcache-Cache]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Ehcache</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle Merge语句]]></title>
    <url>%2FOracle-Merge%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[Merge语句是Oracle 9i新增的语法，用来合并Update和Insert语句。通过Merge语句，根据一张表或子查询的连接条件对另外一张表进行查询，连接条件匹配上的进行Update，无法匹配的执行Insert。这个语法仅需要一次全表扫描就完成了全部工作，执行效率要高于Insert+Update。merge语句语法如下：1234merge into table_name tusing (subquery) s on (s.column = t.column)when matched then update ...when not matched then insert ...on关键字声明了关联条件，当有记录匹配时执行Update语句，没有匹配时，执行Insert语句。示例创建一张student表：1234567create table student( sno varchar2(3) not null, -- 学生编号 sname varchar(9) not null, -- 学生姓名 ssex char(2) not null -- 性别);表已创建。插入一条学生标号为001的数据：123456789101112131415SQL&gt; merge into student s using (select '001' sno,'KangKang' sname,'M' ssex from dual) t on (s.sno = t.sno) when matched then update set s.sname = t.sname,s.ssex = t.ssex when not matched then insert (s.sno,s.sname,s.ssex) values(t.sno,t.sname,t.ssex);1 行已合并。SQL&gt; select * from student;SNO SNAME SS--- --------- --001 KangKang M再次插入一条学生编号为001的数据，不过sname和ssex不一样：123456789101112131415SQL&gt; merge into student s using (select '001' sno,'Maria' sname,'F' ssex from dual) t on (s.sno = t.sno) when matched then update set s.sname = t.sname,s.ssex = t.ssex when not matched then insert (s.sno,s.sname,s.ssex) values(t.sno,t.sname,t.ssex);1 行已合并。SQL&gt; select * from student;SNO SNAME SS--- --------- --001 Maria F]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle分析函数（窗口函数）]]></title>
    <url>%2Foracle%20Window%20function.html</url>
    <content type="text"><![CDATA[Oracle 中的分析函数基于对数据行的分组来计算相关值，类似于聚合函数。其和聚合函数主要的区别在于：分析函数对于每个分组返回多行数据，而聚合函数每个分组只能对应一行数据。分析函数由三个部分组成：分区子句、排序子句和开窗子句，基本语法如下：12function(arg1,arg2,...argN)over([partition-by-clause] [order-by-clause] [windowing-clause])开窗子句windowing-clause 指定了分析函数进行运算的数据子集。开窗子句的具体语法如下：1234[rows | range] between &lt;start expr&gt; and &lt;end expr&gt;&lt;start expr&gt; is [unbounded preceding | current row | n preceding | n following]&lt;end expr&gt; is [unbounded following | current row | n preceding | n following]unbounded preceding表示以分组数据的第一行最为上边界；unbounded following表示以分组数据的最后一行最为下边界；current row表示当前数据行；n preceding表示当前数据行的前n 行；n following表示当前数据行的后n 行。为了演示分析函数，首先在SH用户下创建一张sales_fact表：12345678910111213141516171819SQL&gt; create table sales_fact as select country_name country,country_subRegion region,prod_name product, calendar_year year,calendar_week_number week, sum(amount_sold) sale, sum(amount_sold*( case when mod(rownum,10)=0 then 1.4 when mod(rownum,5)=0 then 0.6 when mod(rownum,2)=0 then 0.9 when mod(rownum,2)=1 then 1.2 else 1 end)) receipts from sales,times,customers,countries,products where sales.time_id=times.time_id and sales.prod_id = products.prod_id and sales.cust_id = customers.cust_id and customers.country_id = countries.country_id group by country_name,country_subRegion,prod_name,calendar_year,calendar_week_number;表已创建。分析模式下的聚合函数前面所说聚合函数每个分组只能对应一行数据是在传统的非分析模式下的结果。分析模式下的聚合函数则没有此限制。比如下面的SQL语句计算了sale列按照产品，国家，地区和年份为一组，从每年年初开始到该年份每一周的动态求和值。（为了节约篇幅，下面结果只取前10周结果集）。12345678910111213141516171819202122232425262728293031323334353637383940414243444546SQL&gt; select year,week,sale, sum(sale) over( partition by product,country,region,year order by week rows between unbounded preceding and current row ) running_sum_sale from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by year,week; YEAR WEEK SALE RUNNING_SUM_SALE---------- ---------- ---------- ---------------- 1998 1 58.15 58.15 1998 2 29.39 87.54 1998 3 29.49 117.03 1998 4 29.49 146.52 1998 5 29.8 176.32 1998 6 58.78 235.1 1998 9 58.78 293.88 1998 10 117.76 411.64 1999 1 53.52 53.52 1999 3 94.6 148.12 1999 4 40.5 188.62 1999 5 80.01 268.63 1999 6 40.5 309.13 1999 8 103.11 412.24 1999 9 53.34 465.58 1999 10 72 537.58 2000 1 46.7 46.7 2000 3 93.41 140.11 2000 4 46.54 186.65 2000 5 46.7 233.35 2000 7 70.8 304.15 2000 8 46.54 350.69 2001 1 92.26 92.26 2001 2 118.38 210.64 2001 3 47.24 257.88 2001 4 256.7 514.58 2001 5 93.44 608.02 2001 6 22.44 630.46 2001 7 69.96 700.42 2001 8 46.06 746.48 2001 9 92.67 839.15 2001 10 69.05 908.2已选择32行。聚合函数sum(sale)声明要求和的列，partition by product,country,region,year分区子句声明了分组的列，order by week排序子句声明了分组的数据行按照week列来进行排序，rows between unbounded preceding and current row开窗子句声明了计算的窗口范围为分组的第一行到当前行。下面例子的窗口范围为整个分组：12345678910111213141516171819202122232425262728293031323334353637383940414243444546SQL&gt; select year,week,sale, max(sale) over( partition by product,country,region,year order by week rows between unbounded preceding and unbounded following ) max_sal_per_year from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by year,week; YEAR WEEK SALE MAX_SAL_PER_YEAR---------- ---------- ---------- ---------------- 1998 1 58.15 117.76 1998 2 29.39 117.76 1998 3 29.49 117.76 1998 4 29.49 117.76 1998 5 29.8 117.76 1998 6 58.78 117.76 1998 9 58.78 117.76 1998 10 117.76 117.76 1999 1 53.52 103.11 1999 3 94.6 103.11 1999 4 40.5 103.11 1999 5 80.01 103.11 1999 6 40.5 103.11 1999 8 103.11 103.11 1999 9 53.34 103.11 1999 10 72 103.11 2000 1 46.7 93.41 2000 3 93.41 93.41 2000 4 46.54 93.41 2000 5 46.7 93.41 2000 7 70.8 93.41 2000 8 46.54 93.41 2001 1 92.26 256.7 2001 2 118.38 256.7 2001 3 47.24 256.7 2001 4 256.7 256.7 2001 5 93.44 256.7 2001 6 22.44 256.7 2001 7 69.96 256.7 2001 8 46.06 256.7 2001 9 92.67 256.7 2001 10 69.05 256.7已选择32行。下面例子的窗口范围为当前周的前两周和后两周，也就是五周。在分组的边界处，窗口会自动缩小：12345678910111213141516171819202122232425262728293031323334353637383940414243444546SQL&gt; select year,week,sale, max(sale) over( partition by product,country,region,year order by week rows between 2 preceding and 2 following ) max_sal_per_year from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by year,week; YEAR WEEK SALE MAX_SAL_PER_YEAR---------- ---------- ---------- ---------------- 1998 1 58.15 58.15 1998 2 29.39 58.15 1998 3 29.49 58.15 1998 4 29.49 58.78 1998 5 29.8 58.78 1998 6 58.78 117.76 1998 9 58.78 117.76 1998 10 117.76 117.76 1999 1 53.52 94.6 1999 3 94.6 94.6 1999 4 40.5 94.6 1999 5 80.01 103.11 1999 6 40.5 103.11 1999 8 103.11 103.11 1999 9 53.34 103.11 1999 10 72 103.11 2000 1 46.7 93.41 2000 3 93.41 93.41 2000 4 46.54 93.41 2000 5 46.7 93.41 2000 7 70.8 70.8 2000 8 46.54 70.8 2001 1 92.26 118.38 2001 2 118.38 256.7 2001 3 47.24 256.7 2001 4 256.7 256.7 2001 5 93.44 256.7 2001 6 22.44 256.7 2001 7 69.96 93.44 2001 8 46.06 92.67 2001 9 92.67 92.67 2001 10 69.05 92.67已选择32行。默认的窗口子句是rows between unbounded preceding and current row。lag和leadlag和lead函数能够实现跨行引用。lag能够访问结果集中前面行内容，lead能够访问结果集中后面行内容。lag和lead函数不支持开窗子句，仅支持partition by和order by子句。laglag函数的语法如下：1lag(expression, offset, default) over(partition-clause order-by-clause)expression表示返回的列，offset表示相隔的行数（不能为负数），default表示默认值。比如，从前一行中返回一个值：123456789101112131415161718192021222324252627282930313233343536373839404142434445SQL&gt; select year,week,sale, lag(sale) over( partition by product,country,region,year order by week ) prior_wk_sales from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week; YEAR WEEK SALE PRIOR_WK_SALES---------- ---------- ---------- -------------- 1998 1 58.15 1998 2 29.39 58.15 1998 3 29.49 29.39 1998 4 29.49 29.49 1998 5 29.8 29.49 1998 6 58.78 29.8 1998 9 58.78 58.78 1998 10 117.76 58.78 1999 1 53.52 1999 3 94.6 53.52 1999 4 40.5 94.6 1999 5 80.01 40.5 1999 6 40.5 80.01 1999 8 103.11 40.5 1999 9 53.34 103.11 1999 10 72 53.34 2000 1 46.7 2000 3 93.41 46.7 2000 4 46.54 93.41 2000 5 46.7 46.54 2000 7 70.8 46.7 2000 8 46.54 70.8 2001 1 92.26 2001 2 118.38 92.26 2001 3 47.24 118.38 2001 4 256.7 47.24 2001 5 93.44 256.7 2001 6 22.44 93.44 2001 7 69.96 22.44 2001 8 46.06 69.96 2001 9 92.67 46.06 2001 10 69.05 92.67已选择32行。可见lag函数在分区的上边界返回空值，默认行数为1。指定lag函数的默认值，并指定行数为3：123456789101112131415161718192021222324252627282930313233343536373839404142434445SQL&gt; select year,week,sale, lag(sale,3,sale) over( partition by product,country,region,year order by week ) prior_wk_sales from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week; YEAR WEEK SALE PRIOR_WK_SALES---------- ---------- ---------- -------------- 1998 1 58.15 58.15 1998 2 29.39 29.39 1998 3 29.49 29.49 1998 4 29.49 58.15 1998 5 29.8 29.39 1998 6 58.78 29.49 1998 9 58.78 29.49 1998 10 117.76 29.8 1999 1 53.52 53.52 1999 3 94.6 94.6 1999 4 40.5 40.5 1999 5 80.01 53.52 1999 6 40.5 94.6 1999 8 103.11 40.5 1999 9 53.34 80.01 1999 10 72 40.5 2000 1 46.7 46.7 2000 3 93.41 93.41 2000 4 46.54 46.54 2000 5 46.7 46.7 2000 7 70.8 93.41 2000 8 46.54 46.54 2001 1 92.26 92.26 2001 2 118.38 118.38 2001 3 47.24 47.24 2001 4 256.7 92.26 2001 5 93.44 118.38 2001 6 22.44 47.24 2001 7 69.96 256.7 2001 8 46.06 93.44 2001 9 92.67 22.44 2001 10 69.05 69.96已选择32行。leadlead和lag类似。不再赘述。first_value和last_valuefirst_value和last_value函数通常与order by语句配合来筛选出分区中的最大值和最小值。它们都支持开窗子句。first_valuefirst_value返回窗口中的第一个值。ignore nulls表示忽略空值，如果第一个是空值返回第二个：12345678910111213141516171819202122232425262728293031323334353637383940414243444546SQL&gt; select year,week,sale, first_value(sale ignore nulls) over( partition by product,country,region,year order by sale desc rows between unbounded preceding and unbounded following ) max_sale from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week; YEAR WEEK SALE MAX_SALE---------- ---------- ---------- ---------- 1998 1 58.15 117.76 1998 2 29.39 117.76 1998 3 29.49 117.76 1998 4 29.49 117.76 1998 5 29.8 117.76 1998 6 58.78 117.76 1998 9 58.78 117.76 1998 10 117.76 117.76 1999 1 53.52 103.11 1999 3 94.6 103.11 1999 4 40.5 103.11 1999 5 80.01 103.11 1999 6 40.5 103.11 1999 8 103.11 103.11 1999 9 53.34 103.11 1999 10 72 103.11 2000 1 46.7 93.41 2000 3 93.41 93.41 2000 4 46.54 93.41 2000 5 46.7 93.41 2000 7 70.8 93.41 2000 8 46.54 93.41 2001 1 92.26 256.7 2001 2 118.38 256.7 2001 3 47.24 256.7 2001 4 256.7 256.7 2001 5 93.44 256.7 2001 6 22.44 256.7 2001 7 69.96 256.7 2001 8 46.06 256.7 2001 9 92.67 256.7 2001 10 69.05 256.7已选择32行。last_valuelast_value返回窗口中的最后一个值。respect nulls表示识别空值，如果最后一个是空值也将其返回。12345678910111213141516171819202122232425262728293031323334353637383940414243444546SQL&gt; select year,week,sale, last_value(sale respect nulls) over( partition by product,country,region,year order by sale desc rows between unbounded preceding and unbounded following ) min_sale from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week; YEAR WEEK SALE MIN_SALE---------- ---------- ---------- ---------- 1998 1 58.15 29.39 1998 2 29.39 29.39 1998 3 29.49 29.39 1998 4 29.49 29.39 1998 5 29.8 29.39 1998 6 58.78 29.39 1998 9 58.78 29.39 1998 10 117.76 29.39 1999 1 53.52 40.5 1999 3 94.6 40.5 1999 4 40.5 40.5 1999 5 80.01 40.5 1999 6 40.5 40.5 1999 8 103.11 40.5 1999 9 53.34 40.5 1999 10 72 40.5 2000 1 46.7 46.54 2000 3 93.41 46.54 2000 4 46.54 46.54 2000 5 46.7 46.54 2000 7 70.8 46.54 2000 8 46.54 46.54 2001 1 92.26 22.44 2001 2 118.38 22.44 2001 3 47.24 22.44 2001 4 256.7 22.44 2001 5 93.44 22.44 2001 6 22.44 22.44 2001 7 69.96 22.44 2001 8 46.06 22.44 2001 9 92.67 22.44 2001 10 69.05 22.44已选择32行。nth_valuenth_value函数用于返回任意行的数据，语法如下：12nth_value(measure, n) [from first | from last] [respect nulls | ignore nulls]over(partition-clause order-by-clause windowing-clause)比如first_value(sale)等价于nth_value(sale,1)；first_value(sale ignore nulls)等价于nth_value(sale,1) from first ignore nulls。比如求得分区内第二大的sale值大小：12345678910111213141516171819202122232425262728293031323334353637383940414243444546SQL&gt; select year,week,sale, nth_value(sale,2) ignore nulls over( partition by product,country,region,year order by sale desc rows between unbounded preceding and unbounded following ) second_max_sale from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week; YEAR WEEK SALE SECOND_MAX_SALE---------- ---------- ---------- --------------- 1998 1 58.15 58.78 1998 2 29.39 58.78 1998 3 29.49 58.78 1998 4 29.49 58.78 1998 5 29.8 58.78 1998 6 58.78 58.78 1998 9 58.78 58.78 1998 10 117.76 58.78 1999 1 53.52 94.6 1999 3 94.6 94.6 1999 4 40.5 94.6 1999 5 80.01 94.6 1999 6 40.5 94.6 1999 8 103.11 94.6 1999 9 53.34 94.6 1999 10 72 94.6 2000 1 46.7 70.8 2000 3 93.41 70.8 2000 4 46.54 70.8 2000 5 46.7 70.8 2000 7 70.8 70.8 2000 8 46.54 70.8 2001 1 92.26 118.38 2001 2 118.38 118.38 2001 3 47.24 118.38 2001 4 256.7 118.38 2001 5 93.44 118.38 2001 6 22.44 118.38 2001 7 69.96 118.38 2001 8 46.06 118.38 2001 9 92.67 118.38 2001 10 69.05 118.38已选择32行。rankrank函数以数值的形式返回一个数据行在排序后的结果集中的位置。在排名并列的情况下，具有相同值的行将具有相同的排名，并且接下来的排名会被跳过。rank函数不支持开窗子句，作用于整个分区：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SQL&gt; select * from ( select year,week,sale, rank() over( partition by product,country,region,year order by sale desc ) sales_rank from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week ) order by year,sales_rank; YEAR WEEK SALE SALES_RANK---------- ---------- ---------- ---------- 1998 10 117.76 1 1998 6 58.78 2 1998 9 58.78 2 1998 1 58.15 4 1998 5 29.8 5 1998 4 29.49 6 1998 3 29.49 6 1998 2 29.39 8 1999 8 103.11 1 1999 3 94.6 2 1999 5 80.01 3 1999 10 72 4 1999 1 53.52 5 1999 9 53.34 6 1999 4 40.5 7 1999 6 40.5 7 2000 3 93.41 1 2000 7 70.8 2 2000 1 46.7 3 2000 5 46.7 3 2000 4 46.54 5 2000 8 46.54 5 2001 4 256.7 1 2001 2 118.38 2 2001 5 93.44 3 2001 9 92.67 4 2001 1 92.26 5 2001 7 69.96 6 2001 10 69.05 7 2001 3 47.24 8 2001 8 46.06 9 2001 6 22.44 10已选择32行。dense_rankdense_rank函数是rank函数的变体，区别在于dense_rank函数的排名值是连续的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SQL&gt; select * from ( select year,week,sale, dense_rank() over( partition by product,country,region,year order by sale desc ) sales_dense_rank from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week ) order by year,sales_dense_rank; YEAR WEEK SALE SALES_DENSE_RANK---------- ---------- ---------- ---------------- 1998 10 117.76 1 1998 6 58.78 2 1998 9 58.78 2 1998 1 58.15 3 1998 5 29.8 4 1998 4 29.49 5 1998 3 29.49 5 1998 2 29.39 6 1999 8 103.11 1 1999 3 94.6 2 1999 5 80.01 3 1999 10 72 4 1999 1 53.52 5 1999 9 53.34 6 1999 4 40.5 7 1999 6 40.5 7 2000 3 93.41 1 2000 7 70.8 2 2000 1 46.7 3 2000 5 46.7 3 2000 4 46.54 4 2000 8 46.54 4 2001 4 256.7 1 2001 2 118.38 2 2001 5 93.44 3 2001 9 92.67 4 2001 1 92.26 5 2001 7 69.96 6 2001 10 69.05 7 2001 3 47.24 8 2001 8 46.06 9 2001 6 22.44 10已选择32行。row_numberrow_number函数为结果集中的每一行分配一个递增行编号，支持开窗子句。如果存在值相同的数据行，谁先谁后具有不确定性。123456789101112131415161718192021222324252627282930313233343536373839404142434445SQL&gt; select year,week,sale, row_number() over( partition by product,country,region,year order by sale ) sales_rn from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,sale; YEAR WEEK SALE SALES_RN---------- ---------- ---------- ---------- 1998 2 29.39 1 1998 3 29.49 2 1998 4 29.49 3 1998 5 29.8 4 1998 1 58.15 5 1998 9 58.78 6 1998 6 58.78 7 1998 10 117.76 8 1999 4 40.5 1 1999 6 40.5 2 1999 9 53.34 3 1999 1 53.52 4 1999 10 72 5 1999 5 80.01 6 1999 3 94.6 7 1999 8 103.11 8 2000 4 46.54 1 2000 8 46.54 2 2000 5 46.7 3 2000 1 46.7 4 2000 7 70.8 5 2000 3 93.41 6 2001 6 22.44 1 2001 8 46.06 2 2001 3 47.24 3 2001 10 69.05 4 2001 7 69.96 5 2001 1 92.26 6 2001 9 92.67 7 2001 5 93.44 8 2001 2 118.38 9 2001 4 256.7 10已选择32行。ratio_to_reportratio_to_report函数用于计算当前行的值占分区总和的值的百分比，该函数没有排序和开窗子句。比如计算当前周的销售额在该年以及所有销售额中的百分比：12345678910111213141516171819202122232425262728293031323334353637383940414243SQL&gt; select year,week,sale, trunc(100*ratio_to_report(sale) over(partition by product,country,region,year),2) || '%' p1, trunc(100*ratio_to_report(sale) over(partition by product,country,region),2) || '%' p2 from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week &lt;= 10 order by product,country,year,week; YEAR WEEK SALE P1 P2 ---------- ---------- ---------- --------------- ----------------- 1998 1 58.15 14.12% 2.63% 1998 2 29.39 7.13% 1.33% 1998 3 29.49 7.16% 1.33% 1998 4 29.49 7.16% 1.33% 1998 5 29.8 7.23% 1.34% 1998 6 58.78 14.27% 2.66% 1998 9 58.78 14.27% 2.66% 1998 10 117.76 28.6% 5.33% 1999 1 53.52 9.95% 2.42% 1999 3 94.6 17.59% 4.28% 1999 4 40.5 7.53% 1.83% 1999 5 80.01 14.88% 3.62% 1999 6 40.5 7.53% 1.83% 1999 8 103.11 19.18% 4.66% 1999 9 53.34 9.92% 2.41% 1999 10 72 13.39% 3.26% 2000 1 46.7 13.31% 2.11% 2000 3 93.41 26.63% 4.23% 2000 4 46.54 13.27% 2.1% 2000 5 46.7 13.31% 2.11% 2000 7 70.8 20.18% 3.2% 2000 8 46.54 13.27% 2.1% 2001 1 92.26 10.15% 4.17% 2001 2 118.38 13.03% 5.36% 2001 3 47.24 5.2% 2.13% 2001 4 256.7 28.26% 11.62% 2001 5 93.44 10.28% 4.23% 2001 6 22.44 2.47% 1.01% 2001 7 69.96 7.7% 3.16% 2001 8 46.06 5.07% 2.08% 2001 9 92.67 10.2% 4.19% 2001 10 69.05 7.6% 3.12%已选择32行。ntilentile函数对一个分区中的有序结果集进行划分，分为若干个组，如果不能够等分，则每个组中相差的数据行不能超过一行，并为每个小组分配唯一的组编号。该函数不支持开窗子句。比如将2001年的销售额数据行分为十个小组：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657SQL&gt; select year,week,sale, ntile(10) over( partition by product,country,region,year order by sale ) group# from sales_fact where country in ('Australia') and product = 'Xtend Memory' and year=2001; YEAR WEEK SALE GROUP#---------- ---------- ---------- ---------- 2001 18 22.37 1 2001 23 22.38 1 2001 6 22.44 1 2001 52 23.14 1 2001 50 23.14 1 2001 44 23.29 2 2001 40 45.18 2 2001 49 45.26 2 2001 8 46.06 2 2001 3 47.24 2 2001 41 67.19 3 2001 34 68.9 3 2001 32 68.9 3 2001 10 69.05 3 2001 7 69.96 3 2001 11 71.57 4 2001 36 91.12 4 2001 15 91.98 4 2001 31 92.21 4 2001 1 92.26 4 2001 9 92.67 5 2001 37 93.16 5 2001 5 93.44 5 2001 46 93.58 5 2001 27 94.48 5 2001 51 114.82 6 2001 33 115.52 6 2001 39 115.57 6 2001 13 116.81 6 2001 12 116.81 7 2001 29 116.85 7 2001 20 118.03 7 2001 2 118.38 7 2001 24 136.92 8 2001 42 136.98 8 2001 38 139 8 2001 25 139.28 8 2001 43 139.58 9 2001 22 141.78 9 2001 14 162.91 9 2001 30 162.91 9 2001 48 182.96 10 2001 21 233.7 10 2001 4 256.7 10 2001 16 278.44 10已选择45行。stddevstddev函数用于计算某些数据行在分区中的标准差：12345678910111213141516171819202122232425262728293031323334353637383940414243SQL&gt; select year,week,sale, stddev(sale) over( partition by product,country,region,year order by sale rows between unbounded preceding and unbounded following ) stddev from sales_fact where country in ('Australia') and product = 'Xtend Memory' and week&lt;10 order by product,country,year,week; YEAR WEEK SALE STDDEV---------- ---------- ---------- ---------- 1998 1 58.15 15.517783 1998 2 29.39 15.517783 1998 3 29.49 15.517783 1998 4 29.49 15.517783 1998 5 29.8 15.517783 1998 6 58.78 15.517783 1998 9 58.78 15.517783 1999 1 53.52 25.8395281 1999 3 94.6 25.8395281 1999 4 40.5 25.8395281 1999 5 80.01 25.8395281 1999 6 40.5 25.8395281 1999 8 103.11 25.8395281 1999 9 53.34 25.8395281 2000 1 46.7 19.670004 2000 3 93.41 19.670004 2000 4 46.54 19.670004 2000 5 46.7 19.670004 2000 7 70.8 19.670004 2000 8 46.54 19.670004 2001 1 92.26 68.235866 2001 2 118.38 68.235866 2001 3 47.24 68.235866 2001 4 256.7 68.235866 2001 5 93.44 68.235866 2001 6 22.44 68.235866 2001 7 69.96 68.235866 2001 8 46.06 68.235866 2001 9 92.67 68.235866已选择29行。listagglistagg函数将分区中多个数据行中的某列的值以某个符号拼接成一行，语法如下：1listagg(string,separator) within group(order-by-clause) over(partition-by-clause)within group(order-by-clause)子句声明排序顺序。比如将sales_fact数据表中的country转化为以逗号分隔的一行值：12345678910111213SQL&gt; col country_string for a50SQL&gt; select listagg(country,',') within group(order by country desc) country_string from( select distinct country from sales_fact );COUNTRY_STRING--------------------------------------------------United States of America,United Kingdom,Turkey,Spain,Singapore,Saudi Arabia,Poland,New Zealand,Japan,Italy,Germany,France,Denmark,China,Canada,Brazil,Australia,Argentina]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle对象类型]]></title>
    <url>%2FOracle-Object-Type.html</url>
    <content type="text"><![CDATA[在Oracle数据库中，我们可以创建自定义的对象类型（Object Type）。数据库的对象类型和Java中的类相似，可以包含属性和方法（函数和存储过程）。对象类型包括对象类型规范（Object Type Specification）和对象类型主体（Object Type Body）。对象类型规范用于定义对象的属性和不包含实现的方法。对象类型主体用于实现对象类型规范中定义的方法。如果对象类型规范中没有定义方法，则可以不用定义对象类型主体。创建简单的对象类型简单的对象类型就是不包含方法的对象类型，语法如下：1234create [or replace] type type_name as object ( column_name data_type [,column_name data_type, ... ]);比如创建一个地址对象类型：1234567SQL&gt; create or replace type address as object ( province varchar2(10), city varchar2(10) ) not final; /类型已创建。not final关键字说明该对象类型可以被继承，接下来定义一个子类型addressDetail 继承自address 类型：1234567891011121314SQL&gt; create or replace type addressdetail under address ( street varchar2(20) ); /类型已创建。SQL&gt; desc addressdetail; addressdetail 扩展 SCOTT.ADDRESS 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- PROVINCE VARCHAR2(10) CITY VARCHAR2(10) STREET VARCHAR2(20)可见addressdetail 继承了address 的province 和city 属性。创建带有方法的对象类型可以在定义对象类型规范的时候包含函数或者存储过程，语法如下：1234567create [or replace] type type_name as object ( column_name data_type, ..., [ map|order ]member function method_name(args_list) return return_type, [ map|order ]member procedure pro_name(aggs_list), ...)其中map 或order 关键字表示对结果进行排序。比如创建一个学生信息对象类型student：123456789SQL&gt; create or replace type student as object ( name varchar2(20), sex char(2), birthday date, member function get_age return number ); /类型已创建。函数get_age()用于返回学生年龄。接下来创建student 对象主体：1234567891011SQL&gt; create or replace type body student as member function get_age return number as var_age number; begin select floor(months_between(sysdate,birthday)/12) into var_age from dual; return var_age; end; end; /类型主体已创建。对象类型的应用创建对象类型后，可以在数据库中使用对象类型。一般来说根据使用情况的不同，可以分为以下四种类型：列对象、对象表、可变数组与嵌套表。列对象列对象指的是数据表中的单个列的类型为对象类型。创建员工信息表，其中address属性类型为上述定义的addressdetail类型：12345678SQL&gt; create table empinfo ( eName varchar2(20), eSex char(2), eAge int, eAddress addressdetail );表已创建。查看empinfo表的结构：123456789101112SQL&gt; set desc depth 2SQL&gt; desc empinfo 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- ENAME VARCHAR2(20) ESEX CHAR(2) EAGE NUMBER(38) EADDRESS ADDRESSDETAIL ADDRESSDETAIL 扩展 SCOTT.ADDRESS PROVINCE VARCHAR2(10) CITY VARCHAR2(10) STREET VARCHAR2(20)在往包含列对象的数据表插入数据的时候，只能使用对象类型的构造方法：123SQL&gt; insert into empinfo values('KangKang','M',25,addressdetail('福建','福州','鼓楼区'));已创建 1 行。查询student表信息的时候，如果以对象类型中的某个属性为查询条件时，必须使用表的别名的形式，比如：1234567891011SQL&gt; select * from empinfo where eAddress.city='福州';select * from empinfo where eAddress.city='福州' *第 1 行出现错误:ORA-00904: "EADDRESS"."CITY": 标识符无效SQL&gt; select * from empinfo e where e.eAddress.city='福州';ENAME ES EAGE EADDRESS(PROVINCE, CITY, STREET)-------------------- -- ---------- ----------------------------------------KangKang M 25 ADDRESSDETAIL('福建', '福州', '鼓楼区')更新包含两种方式：整体更新和只更列对象的某一列。1.更新整体：123 SQL&gt; update empinfo e set e.eAddress = addressdetail('福建','福州','台江区');已更新 1 行。2.更新列对象的某一列：123SQL&gt; update empinfo e set e.eAddress.city='厦门' where e.eName='KangKang';已更新 1 行。对象表如果需要使用对象类型来定义整个表，那么可以将这个表创建为对象表，对象表中的每一组数据都是一个对象。语法如下：1create table table_name of type_name;创建一个上述定义的student 对象表：12345678910SQL&gt; create table studentinfo of student;表已创建。SQL&gt; desc studentinfo 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- NAME VARCHAR2(20) SEX CHAR(2) BIRTHDAY DATE向对象表插入数据有两种方式：当普通表插入和使用构造方法插入：1.当普通表插入：123SQL&gt; insert into studentinfo values('KangKang','M',to_date('19920314','yyyyMMdd'));已创建 1 行。2.使用构造方法插入：123SQL&gt; insert into studentinfo values(student('Jane','F',to_date('19930905','yyyyMMdd')));已创建 1 行。查询数据和查询普通表没有区别。因为student对象包含了get_age()函数，这里演示该函数的使用：123456SQL&gt; select s.name,s.birthday,s.get_age() age from studentinfo s;NAME BIRTHDAY AGE-------------------- -------------- ----------KangKang 14-3月 -92 25Jane 05-9月 -93 24对象标识符和对象引用对象表中的每个对象都具有一个唯一的对象标识符（Object Identifier，OID），可以存储在名为ref 的列中：1234567891011SQL&gt; col ref for a60SQL&gt; set linesize 120SQL&gt; select s.name,ref(s) ref from studentinfo s;NAME REF-------------------- ------------------------------------------------------------KangKang 00002802093C3B2A8DC8BD4ED991B4D78B90B44F1A293F80C3178D48158B B3E126560AE7120100023F0000Jane 0000280209E237A8A6E6A844AE87A66B0F284E7231293F80C3178D48158B B3E126560AE7120100023F0001那个一大串的字符便是OID。对象的引用使用ref 关键字来完成，引用的值实际上为对象表中的OID。比如创建一个成绩表，其中stu 属性为studentinfo 对象表中对象的引用：123456SQL&gt; create table stuScore ( stu ref student, score number );表已创建。往该表插入信息：123456SQL&gt; insert into stuScore select ref(s),98 from studentinfo s where s.name='KangKang';已创建 1 行。SQL&gt; insert into stuScore select ref(s),100 from studentinfo s where s.name='Jane';已创建 1 行。ref(s)可以获取对当前对象表中对象的OID。查询：12345678910SQL&gt; col stu for a60SQL&gt; select stu,score from stuScore;STU SCORE------------------------------------------------------------ ----------00002202083C3B2A8DC8BD4ED991B4D78B90B44F1A293F80C3178D48158B 98B3E126560AE7120000220208E237A8A6E6A844AE87A66B0F284E7231293F80C3178D48158B 100B3E126560AE712这里虽然关联了学生信息表studentinfo，但是默认查询出来stu 的值为OID，如果需要查看详细的学生信息，可以使用deref()函数：123456SQL&gt; select deref(stu) stu,score from stuScore;STU(NAME, SEX, BIRTHDAY) SCORE------------------------------------------------------------ ----------STUDENT('KangKang', 'M ', '14-3月 -92') 98STUDENT('Jane', 'F ', '05-9月 -93') 100使用下面的方法也可以查询出关联信息：123456SQL&gt; select s.stu.name,s.stu.birthday,s.stu.get_age(),s.score from stuScore s;STU.NAME STU.BIRTHDAY S.STU.GET_AGE() SCORE-------------------- -------------- --------------- ----------KangKang 14-3月 -92 25 98Jane 05-9月 -93 24 100可变数组Oralce中的可变数组就是一个可以存储多个值的有最大长度的数组，数组的成员可以是任意类型。创建一个长度为10的可变数组，存放数据类型是scoreType1234567891011SQL&gt; create or replace type scoreType as object ( subName varchar2(10), score int ); /类型已创建。SQL&gt; create or replace type arrScoreType as varray(10) of scoreType; /类型已创建。创建一个学生信息表：123456SQL&gt; create table stuInfo ( stuId int primary key, score arrScoreType );表已创建。使用可变数组的构造函数往stuInfo 表插入数据：123456789SQL&gt; insert into stuInfo values(1, arrScoreType(scoreType('sql', 50), scoreType('C#', 80), scoreType('java', 90)));已创建 1 行。SQL&gt; insert into stuInfo values(2, arrScoreType(scoreType('sql', 60), scoreType('C#', 85), scoreType('java', 95), scoreType('html', 60)));已创建 1 行。直接查询stuInfo 表数据：1234567SQL&gt; col score for a100SQL&gt; select stuid, score from stuInfo; STUID SCORE(SUBNAME, SCORE)---------- ---------------------------------------------------------------------------------------------------- 1 ARRSCORETYPE(SCORETYPE('sql', 50), SCORETYPE('C#', 80), SCORETYPE('java', 90)) 2 ARRSCORETYPE(SCORETYPE('sql', 60), SCORETYPE('C#', 85), SCORETYPE('java', 95), SCORETYPE('html', 60))查询结果是集合。如何才能查询出可变数组里的数据呢？思路是：用table函数把集合转化为表，然后再从这个表查询数据：12345678910111213SQL&gt; select s.stuid,t.* from stuinfo s,table(select score from stuinfo where stuid = s.stuid) t; STUID SUBNAME SCORE---------- ---------- ---------- 1 sql 50 1 C# 80 1 java 90 2 sql 60 2 C# 85 2 java 95 2 html 60已选择7行。table函数里面只能是一个可变数组或嵌套表。更新值。更新stuinfo只能整个可变数组一起更新，不能只更新数组的某个元素：123update stuInfo set score = arrScoreType(scoreType('sql', 50), scoreType('C#', 80)) where stuId = 1;已更新 1 行。嵌套表创建一个嵌套表类型，类型为scoreType：1234SQL&gt; create or replace type nestTableType is table of scoreType; /类型已创建。接着创建包含嵌套表的学生信息表：123456SQL&gt; create table stuInfo ( stuid int, score nestTableType ) nested table score store as nestTable;表已创建。nested table score store as nestTable意思是：stuInfo这个表中的score这一列是嵌套表类型，嵌套表实际是存在nestTable这个表中。插入值的方式和可变数组一样：123SQL&gt; insert into stuInfo values(3, nestTableType(scoreType('sql', 70), scoreType('java', 93)));已创建 1 行。查询方式也和可变数组一样：123456SQL&gt; select s.stuid,t.* from stuinfo s,table(select score from stuinfo where stuid = s.stuid) t; STUID SUBNAME SCORE---------- ---------- ---------- 3 sql 70 3 java 93嵌套表更新和可变数组不一样，嵌套表更新可以只更新部分数据：123SQL&gt; update table(select score from stuinfo where stuid = 3) t set t.score = 80 where t.subname = 'sql';已更新 1 行。可变数组和嵌套表的异同：相同点：都是对象类型；都可以作为表中某列的数据类型（record和快表是不能作为列的数据类型的）。不同点：可变数组本身就存放在原表中，而嵌套表存放在另外的表中；可变数组有大小限制，而嵌套表没有；可变数组更新时必须更新整个可变数组，而嵌套表更新时可以只更新嵌套表中的部分记录。参考自https://my.oschina.net/u/2273582/blog/493931]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle程序包]]></title>
    <url>%2FOracle%E7%A8%8B%E5%BA%8F%E5%8C%85.html</url>
    <content type="text"><![CDATA[程序包由PL/SQL 程序元素（如变量、类型）和匿名PL/SQL 块（如游标）、命名PL/SQL 块（如存储过程和函数）组成。一个完整的程序包包含程序包规范和程序包主体，程序包规范用于规定在程序包中可以使用哪些变量、类型、游标和子程序（只包含名称没有具体实现）；程序包的主体包含了在规范中声明的游标、过程和函数的实现代码。这个过程类似于在Java中定义一个包含抽象方法的接口，然后创建一个该接口的实现类。程序包的规范程序包的语法如下：1234567create [or replace ] package pack_name is [declare_variable]; [declare_type]; [declare_cursor]; [declare_function]; [declare_ procedure];end [pack_name];比如创建一个程序包规范，并声明一个获取指定部门平均工资函数和一个提高指定部门指定百分比工资的存储过程：1234567SQL&gt; create or replace package pack_test is function avg_sal(var_deptno number) return number; procedure rise_sal(var_job varchar2,percent number); end; /程序包已创建。在“规范”中声明的函数和存储过程只有头部的声明，而没有函数体和存储过程主体。程序包主体程序包的语法如下：1234567891011121314151617create [or replace] package body pack_name is [inner_variable] [cursor_body] [function_title] &#123;begin fun_plsql; [exception] [dowith _ sentences;] end [fun_name]&#125; [procedure_title] &#123;begin pro_plsql; [exception] [dowith _ sentences;] end [pro_name]&#125; …end [pack_name];创建pack_test的主体：1234567891011121314151617181920SQL&gt; create or replace package body pack_test is function avg_sal(var_deptno number) return number is //函数实现 num_avg_sal number; begin select avg(sal) into num_avg_sal from emp where deptno = var_deptno; return num_avg_sal; exception when no_data_found then dbms_output.put_line('没有该部门'); return 0; end; procedure rise_sal(var_job varchar2,percent number) is //存储过程实现 begin update emp set sal=sal*(1+percent) where job = var_job; end; end; /程序包体已创建。在PL/SQL代码块中调用程序包的avg_sal函数和rise_sal存储过程：123456789101112SQL&gt; set serveroutput onSQL&gt; declare num_avg_sal number; begin num_avg_sal:=pack_test.avg_sal(10); dbms_output.put_line('10号部门的平均工资为：'||num_avg_sal); pack_test.rise_sal('SALESMAN',0.2); end; /10号部门的平均工资为：2916.666666666666666666666666666666666667PL/SQL 过程已成功完成。]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle触发器]]></title>
    <url>%2FOracle%E8%A7%A6%E5%8F%91%E5%99%A8.html</url>
    <content type="text"><![CDATA[触发器可以看做一种“特殊”的存储过程，由“触发事件”触发。所谓的“触发事件”指能够引起触发器运行的操作，包括：1.执行DML 语句（使用INSERT、UPDATE、DELETE 语句对表或视图执行数据处理操作）；2.执行DDL语句（使用CREATE、ALTER、DROP语句在数据库中创建、修改、删除模式对象）；3.引发数据库系统事件（如系统启动或退出、产生异常错误等）；4.引发用户事件（如登录或退出数据库操作）。 触发器的语法如下：1234567create [or replace] trigger tri_name [before | after | instead of] tri_event on table_name | view_name | user_name | db_name [for each row] [when tri_condition]begin plsql_sentences;end tri_name;before | after | instead of：表示“触发时机”的关键字。before 表示在执行DML 等操作之前触发；after 表示在DML等操作之后发生；instead of 表示触发器为 替代触发器。on：表示操作的数据表、视图、用户模式和数据库等，对它们执行某种数据操作（比如对表执行INSERT、ALTER、DROP 等操作），将引起触发器的运行。for each row：指定触发器为行级触发器，当DML语句对每一行数据进行操作时都会引起该触发器的运行。如果未指定该条件，则表示创建语句级触发器，这时无论数据操作影响多少行，触发器都只会执行一次。tri_condition：表示触发条件表达式。根据触发器的触发事件和触发器的执行情况，将Oracle 所支持的触发器分为以下4 种类型：语句级触发器语句级触发器，就是针对一条DML 语句而引起的触发器执行。在语句级触发器中，不使用for each row 子句，也就是说无论数据操作影响多少行，触发器都只会执行一次。比如设计一个触发器，用于记录对soctt.dept表的增删改查操作：1.创建dept_log 数据表，用于记录操作类型和时间：123456SQL&gt; create table dept_log( operate_tag varchar2(10), operate_time date );表已创建。2.创建一个关于dept 表的语句级触发器，将用户对dept 表的操作信息保存到dept_log 表中：123456789101112131415161718SQL&gt; create or replace trigger tir_dept before insert or update or delete on dept declare var_tag varchar2(10); begin if inserting then var_tag:='insert'; elsif updating then var_tag:='update'; elsif deleting then var_tag:='delete'; end if; insert into dept_log values(var_tag,sysdate); end; /触发器已创建用户甚至还可以在其中判断特定列是否被更新。例如，要判断用户是否对dept 表中dname 列进行了修改，可以使用下面的语句：123if updating(dname) then //若修改了dept 表中的dname 列 do something about update dnameend if;3.执行DML 语句来触发tri_dept：123456789SQL&gt; delete from dept where deptno = 90;已删除 1 行。SQL&gt; insert into dept values(90,'清算风控部门','福州');已创建 1 行。SQL&gt; update dept set loc='厦门' where deptno = 90;已更新 1 行。4.到dept_log 表中查看日志信息：1234567SQL&gt; select * from dept_log;OPERATE_TA OPERATE_TIME---------- --------------delete 13-11月-17insert 13-11月-17update 13-11月-17行级触发器行级触发器会针对DML 操作所影响的每一行数据都执行一次触发器。创建这种触发器时，必须在语法中使用for each row。使用行级触发器的一个典型应用就是给数据表生成主键值。举个例子：1.创建一个用于存储商品种类的数据表，其中包括商品序号列和商品名称列，其中商品序号为主键：123456SQL&gt; create table goods( id int not null primary key, good_name varchar2(50) );表已创建。2.为主键创建一个序列：123SQL&gt; create sequence seq_goods_id;序列已创建。3.创建一个触发器，用于自动为goods 表的id 列赋值：12345678910SQL&gt; create or replace trigger tri_save_good before insert on goods for each row begin select seq_goods_id.nextval into :new.id from dual; end; /触发器已创建这里使用了:new.id关键字——列标识符，这个列标识符用来指向新行的id 列，给它赋值。列标识符可以分为原值标识符和新值标识符：原值标识符用于标识当前行某个列的原始值，记作:old.column_name（如，:old.id），通常在update 语句和delete 语句中使用；新值标识符用于标识当前行某个列的新值，记作:new.column_name（如，:new.id），通常在insert 语句和update 语句中使用。4.向 goods 表中插入两条记录，其中一条记录不指定id 列的值，由序列seq_goods_id 来产生；另一条记录指定id 的值：123456SQL&gt; insert into goods(good_name) values('apple');已创建 1 行。SQL&gt; insert into goods(id,good_name) values(100,'banana');已创建 1 行。5.查看goods表结果：123456SQL&gt; select * from goods; ID GOOD_NAME---------- ---------------------- 1 apple 2 banana可见手动指定的id值（100）无法覆盖触发器中指定的seq_goods_id.nextval值。替换触发器替换触发器——instead of 触发器是定义在视图view上的。Oracle中一般不让直接对视图进行DML操作，但我们可以使用替换触发器来实现。1.创建一个包含dept表和emp表信息的视图：123456SQL&gt; create view view_emp_dept as select empno,ename,dept.deptno,dname,job,hiredate from emp,dept where emp.deptno = dept.deptno;视图已创建。直接往视图里插入数据：123456SQL&gt; insert into view_emp_dept values(7966,'Jane',70,'市场部','经理',sysdate);insert into view_emp_dept values(*第 1 行出现错误:ORA-01776: 无法通过联接视图修改多个基表2.直接往视图里插入数据报错，此时编写一个关于view_emp_dept 视图在insert 事件中的触发器：12345678910111213141516SQL&gt; create or replace trigger tri_insert_view_emp_dept instead of insert on view_emp_dept declare row_dept dept%rowtype; begin select * into row_dept from dept where deptno=:new.deptno; if sql%notfound then insert into dept(deptno,dname) values(:new.deptno,:new.dname); end if; insert into emp(empno,ename,deptno,job,hiredate) values(:new.empno,:new.ename,:new.deptno,:new.job,:new.hiredate); end; /触发器已创建在上面触发器的主体代码中，如果新插入行的部门编号（deptno）不在dept 表中，则首先向dept表中插入关于新部门编号的数据行，然后再向emp 表中插入记录行，这是因为emp 表的外键值（emp.deptno）是dept 表的主键值（dept.deptno）。3.再次执行insert into view_emp_dept values(7966,&#39;Jane&#39;,70,&#39;市场部&#39;,&#39;经理&#39;,sysdate);：12345678SQL&gt; insert into view_emp_dept values(7966,'Jane',70,'市场部','经理',sysdate);已创建 1 行。SQL&gt; select * from view_emp_dept where empno=7966; EMPNO ENAME DEPTNO DNAME JOB HIREDATE---------- ---------- ---------- -------------- --------- -------------- 7966 Jane 70 市场部 经理 13-11月-17用户事件触发器用户事件触发器是因进行 DDL 操作或用户登录、退出等操作而引起运行的一种触发器，引起该类型触发器运行的常见用户事件包括：CREATE、ALTER、DROP、ANALYZE、COMMENT、GRANT、REVOKE、RENAME、TRUNCATE、SUSPEND、LOGON 和LOGOFF 等。1.创建一个日志信息表，用于保存DDL 操作的信息:123456789SQL&gt; create table ddl_oper_log( db_obj_name varchar2(20), //数据对象名称 db_obj_type varchar2(20), //数据对象类型 oper_action varchar2(20), //操作行为 oper_user varchar2(20), //操作用户 oper_time date //操作时间 );表已创建。2.创建一个用户触发器，用于将当前模式下的DDL 操作信息保存到上面所创建的ddl_oper_log日志信息表中：1234567891011121314SQL&gt; create or replace trigger tri_ddl_oper before create or alter or drop on scott.schema begin insert into ddl_oper_log values( ora_dict_obj_name, ora_dict_obj_type, ora_sysevent, ora_login_user, sysdate); end; /触发器已创建ora_dict_obj_name：获取DDL 操作所对应的数据库对象。ora_dict_obj_type：获取DDL 操作所对应的数据库对象的类型。ora_sysevent：获取触发器的系统事件名。ora_login_user：获取登录用户名。3.执行一些DDL 操作：123456789101112SQL&gt; create table tb_test(id number);表已创建。SQL&gt; create view v_test as select * from tb_test;视图已创建。SQL&gt; drop view v_test;视图已删除。SQL&gt; drop table tb_test;表已删除。4.查看ddl_oper_log日志表：12345678SQL&gt; select * from ddl_oper_log;DB_OBJ_NAME DB_OBJ_TYPE OPER_ACTION OPER_USER OPER_TIME-------------------- -------------------- -------------------- -------------------- -------------TB_TEST TABLE CREATE SCOTT 13-11月-17V_TEST VIEW CREATE SCOTT 13-11月-17V_TEST VIEW DROP SCOTT 13-11月-17TB_TEST TABLE DROP SCOTT 13-11月-17]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle存储过程与函数]]></title>
    <url>%2FOracle%20Stored%20procedure%20function.html</url>
    <content type="text"><![CDATA[存储过程存储过程是一种命名的PL/SQL程序块，它既可以没有参数，也可以有若干个输入、输出参数，甚至可以有多个既作输入又作输出的参数，但它通常没有返回值。存储过程被保存在数据库中，它不可以被SQL 语句直接执行或调用，只能通过EXECUT 命令执行或在PL/SQL 程序块内部被调用。由于存储过程是已经编译好的代码，所以其被调用或引用时，执行效率非常高。创建存储过程创建存储过程的语法如下：123456create [or replace] procedure pro_name [(parameter1[,parameter2]…)] is|asbegin plsql_sentences;[exception] [dowith _ sentences;]end [pro_name];pro_name：存储过程的名称，如果数据库中已经存在了此名称，则可以指定“or replace”关键字，这样新的存储过程将覆盖掉原来的存储过程。parameter1：存储过程的参数，若是输入参数，则需要在其后指定“in”关键字；若是输出参数，则需要在其后面指定“out”关键字。在in或out关键字的后面是参数的数据类型，但不能指定该类型的长度。创建一个存储过程，该存储过程实现向dept表中插入一条记录：123456789SQL&gt; create or replace procedure save_dept is begin insert into dept values(50,'开发一部','福州'); commit; dbms_output.put_line('插入数据成功！'); end; /过程已创建。创建过程中如果出现错误，可以使用show err指令查看。若要执行这个存储过程，则需要在SQL*Plus 环境中使用EXECUTE命令来执行该存储过程，或者在PL/SQL 程序块中调用该存储过程。12345SQL&gt; set serveroutput onSQL&gt; execute save_dept插入数据成功！PL/SQL 过程已成功完成。或者在 PL/SQL 块中调用存储过程：123456789101112SQL&gt; delete from dept where deptno=50;已删除 1 行。SQL&gt; set serveroutput onSQL&gt; begin save_dept; end; /插入数据成功！PL/SQL 过程已成功完成。存储过程的参数存储过程可以接受多个参数，参数模式包括IN、OUT 和IN OUT 3 种：1.IN模式参数这是一种输入类型的参数，参数值由调用方传入，并且只能被存储过程读取，是默认的参数模式。比如创建一个存储过程，并定义 3 个in 模式的变量，然后将这3 个变量的值插入到dept表中：1234567891011SQL&gt; create or replace procedure save_dept( deptno in number, dname in varchar2, loc in varchar2) is begin insert into dept values(deptno,dname,loc); commit; end; /过程已创建。调用该存储过程时传参有以下几种方式：指定名称传递：1pro_name(parameter1=&gt;value1[,parameter2=&gt;value2]…)使用这种方式调用上面定义的存储过程：123456SQL&gt; begin save_dept(dname=&gt;'开发二部',loc=&gt;'福州',deptno=&gt;60); end; /PL/SQL 过程已成功完成。使用“指定名称”的方式传递参数值与参数的定义顺序无关，但与参数个数有关。按位置传递：采用这种方式时，用户提供的参数值顺序必须与存储过程中定义的参数顺序相同：123456SQL&gt; begin save_dept(70,'市场部','福州'); end; /PL/SQL 过程已成功完成。混合方式传递：混合方式就是将前两种方式结合到一起：12345678 PL/SQL 过程已成功完成。SQL&gt; begin save_dept(80,loc=&gt;'福州',dname=&gt;'财务管理部'); end; /PL/SQL 过程已成功完成。有时候参数过多，用户不容易记住参数的顺序和类型，用户可以通过desc命令来查看存储过程中参数的定义信息：1234567SQL&gt; desc save_deptPROCEDURE save_dept参数名称 类型 输入/输出默认值?------------------------------ ----------------------- ------ -------- DEPTNO NUMBER IN DNAME VARCHAR2 IN LOC VARCHAR2 IN2.OUT 模式参数这是一种输出类型的参数，表示这个参数在存储过程中已经被赋值，并且这个参数值可以传递到当前存储过程以外的环境中：1234567891011SQL&gt; create or replace procedure select_dept( var_deptno in number, var_dname out dept.dname%type, var_loc out dept.loc%type) is begin select dname,loc into var_dname,var_loc from dept where deptno = var_deptno; end; /过程已创建。上述存储过程定义了两个out 参数，由于存储过程要通过out 参数返回值，所以当调用或执行这个存储过程时，都需要定义变量来保存这两个out参数值。使用EXECUTE命令来执行该存储过程：123456789101112131415161718192021222324SQL&gt; variable var_dname varchar2(50);SQL&gt; variable var_loc varchar2(50);SQL&gt; execute select_dept(50,:var_dname,:var_loc);PL/SQL 过程已成功完成。SQL&gt; print var_dname var_loc;VAR_DNAME--------------------------------------------------------------------------------开发一部VAR_LOC--------------------------------------------------------------------------------福州SQL&gt; select :var_dname,:var_loc from dual;:VAR_DNAME--------------------------------------------------------------------------------:VAR_LOC--------------------------------------------------------------------------------开发一部福州在PL/SQL 程序块中调用该存储过程：123456789101112SQL&gt; set serveroutput onSQL&gt; declare var_dname dept.dname%type; var_loc dept.loc%type; begin save_dept(50,var_dname,var_loc); dbms_output.put_line(var_dname||'位于'||var_loc); end; /开发一部位于福州PL/SQL 过程已成功完成。3.IN OUT模式参数在调用存储过程时，IN OUT模式参数可以从外界向该类型的参数传入值；在执行完存储过程之后，可以将该参数的返回值传给外界：12345678SQL&gt; create or replace procedure square( num in out number) is begin num:=power(num,2); end; /过程已创建。上面的存储过程中定义了一个in out模式的参数num，其既是输入参数也是输出参数，下面用PL/SQL程序块调用该存储过程：12345678910111213SQL&gt; declare var_number number; var_temp number; begin var_temp:=3; var_number:=var_temp; square(var_number); dbms_output.put_line(var_temp||'的平方为：'||var_number); end; /3的平方为：9PL/SQL 过程已成功完成。从上面的例子中可以看出，变量var_number 在调用存储过程之前是3，而存储过程执行完毕之后，该变量的值变为其平方根9。IN 参数的默认值前面的 IN 参数的值都是在调用存储过程时传入的，实际上，Oracle 支持在声明IN 参数的同时给其初始化默认值，这样在存储过程调用时，如果没有向IN参数传入值，则存储过程可以使用默认值进行操作：12345678910SQL&gt; create or replace procedure save_dept( var_deptno in number, var_dname in varchar2 default '产品创新中心', var_loc in varchar2 default '福州') is begin insert into dept values(var_deptno,var_dname,var_loc); end; /过程已创建。var_dname和var_loc定义了默认值，下面调用该存储过程：123456789SQL&gt; execute save_dept(90,var_dname=&gt;'人事行政部');PL/SQL 过程已成功完成。SQL&gt; select * from dept where deptno = 90; DEPTNO DNAME LOC---------- -------------- ------------- 90 人事行政部 福州这里var_loc采用了默认值“福州”。删除存储过程删除存储过程的语法很简单：1drop procedure procedure_name;比如删除save_dept这个存储过程：123SQL&gt; drop procedure save_dept;过程已删除。函数函数一般用于计算和返回一个值，可以将经常需要使用的计算或功能写成一个函数。创建函数函数的创建语法与存储过程比较类似，它也是一种存储在数据库中的命名程序块，函数可以接受零或多个输入参数，并且函数必须有返回值，语法如下：1234567create [or replace] function fun_name[(parameter1[,parameter2]…) return data_type is [inner_variable]begin plsql_ sentence;[exception] [dowith _ sentences;]end [fun_name];由于函数有返回值，所以在函数主体部分（即begin 部分）必须使用return 语句返回函数值，并且要求返回值的类型要与函数声明时的返回值类型（即data_type）相同。定义一个函数，用于计算emp 表中指定某个部门的平均工资：1234567891011121314SQL&gt; create or replace function avg_sal(var_deptno number) return number is var_result number; begin select avg(sal) into var_result from emp where deptno = var_deptno; return var_result; exception when no_data_found then dbms_output.put_line('没有该部门'); return 0; end; /函数已创建。调用函数由于函数有返回值，所以在调用函数时，必须使用一个变量来保存函数的返回值：1234567891011SQL&gt; set serveroutput onSQL&gt; declare var_result number; begin var_result:=avg_sal(10); dbms_output.put_line('编号为10的部门平均工资为：'||var_result); end; /编号为10的部门平均工资为：2916.666666666666666666666666666666666667PL/SQL 过程已成功完成。删除函数删除avg_sal函数：123SQL&gt; drop function avg_sal;函数已删除。]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle PL/SQL编程]]></title>
    <url>%2FOracle-PL-SQL%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[PL/SQL(Procedural Language/SQL)是一种过程化语言，在PL/SQL 中可以通过IF 语句或LOOP 语句实现控制程序的执行流程，甚至可以定义变量，以便在语句之间传递数据信息，这样PL/SQL 语言就能够实现操控程序处理的细节过程。PL/SQL 程序都是以块（BLOCK）为基本单位，整个PL/SQL 块分3 部分：声明部分（用DECLARE开头）、执行部分（以BEGIN 开头）和异常处理部分（以EXCEPTION 开头）：1234567[DECLARE] --声明部分，可选BEGIN --执行部分，必须[EXCEPTION] --异常处理部分，可选END对于 PL/SQL 块中的语句，需要指出的是：每一条语句都必须以分号结束，每条SQL 语句可以写成多行的形式，同样必须使用分号来结束。另外，一行中也可以有多条SQL 语句，但是它们之间必须以分号分隔。比如：12345678910111213141516SQL&gt; set serveroutput onSQL&gt; declare a int:=100; b int:=200; c number; begin c:=(a+b)/(a-b); dbms_output.put_line(c); exception when zero_divide then dbms_output.put_line('除数不能为零'); end; /-3PL/SQL 过程已成功完成。其中，“set serveroutput on”命令来实现在服务端显示执行结果；“dbms_output.put_line(c);”语句用于输出信息。数据类型基本数据类型1.数值类型数值类型主要包括NUMBER、PLS_INTEGER 和BINARY_INTEGER 3 种基本类型。其中，NUMBER 类型的变量可以存储整数或浮点数；而BINARY_INTEGER或PLS_INTEGER 类型的变量只存储整数。NUMBER 类型还可以通过NUMBER(P,S)的形式来格式化数字，其中，参数P表示精度，参数S表示刻度范围。精度是指数值中所有有效数字的个数。比如：1money number(9,2);2.字符类型字符类型主要包括 VARCHAR2、CHAR、LONG、NCHAR 和NVARCHAR2 等。这些类型的变量用来存储字符串或字符数据。VARCHAR2 类型：用于存储可变长度的字符串，其语法格式为：1VARCHAR2(maxlength)参数 maxlength表示可以存储字符串的最大长度，maxlength的最大值可以是32767 字节。CHAR 类型：CHAR 类型表示指定长度的字符串，其语法格式如下：1CHAR(maxlength)参数 maxlength 是指可存储字符串的最大长度，以字节为单位，最大为32767字节，CHAR 类型的默认最大长度为1字节。LONG 类型：LONG 类型表示一个可变的字符串，最大长度是32767 字节。NCHAR 和NVARCHAR2类型：这两种数据类型的长度要根据各国字符集来确定，只能具体情况具体分析。3.日期类型日期类型只有一种——DATE 类型，用来存储日期和时间信息，DATE类型的存储空间是7个字节，分别使用一个字节存储世纪、年、月、天、小时、分钟和秒。4.布尔类型布尔类型也只有一种——BOOLEAN类型，其变量值可以是TRUE、FALSE 或NULL 中的一种。特殊数据类型1.%TYPE 类型使用%TYPE关键字可以声明一个与指定列名称相同的数据类型，比如声明一个与 emp 表中job 列的数据类型完全相同的变量var_job：1declare var_job emp.job%type;如果emp.job 列的数据类型为VARCHAR2(10)，那么变量var_job 的数据类型也是 VARCHAR2(10)。比如，使用%type 类型的变量输出emp 表中编号为7369 的员工名称和职务信息：1234567891011121314SQL&gt; set serveroutput onSQL&gt; declare var_ename scott.emp.ename%type; var_job scott.emp.job%type; begin select ename,job into var_ename,var_job from scott.emp where empno=7369; dbms_output.put_line(var_ename||'的职务是'||var_job); end; /SMITH的职务是CLERKPL/SQL 过程已成功完成。由于into子句中的变量只能存储一个单独的值，所以要求select 子句只能返回一行数据。若SELECT子句返回多行数据，则代码运行后会返回错误信息。2.RECORD 类型RECORD 类型也称作“记录类型”，存储由多个列值组成的一行数据。语法结构如下：12345type record_type is record(var_member1 data_type [not null] [:=default_value],…var_membern data_type [not null] [:=default_value])比如，声明一个记录类型emp_type，然后使用该类型的变量存储emp表中的一条记录信息，并输出这条记录信息：12345678910111213141516171819SQL&gt; set serveroutput onSQL&gt; declare type emp_type is record ( var_ename varchar2(20), var_job varchar2(20), var_sal number ); empinfo emp_type; begin select ename,job,sal into empinfo from scott.emp where empno=7369; dbms_output.put_line('雇员'||empinfo.var_ename||'的职务是'||empinfo.var_job||'，工资是'||empinfo.var_sal); end; /雇员SMITH的职务是CLERK，工资是800PL/SQL 过程已成功完成。3.%ROWTYPE 类型%ROWTYPE 类型的变量结合了%TYPE 类型和RECORD 类型变量的优点，它可以根据数据表中行的结构定义一种特殊的数据类型，用来存储从数据表中检索到的一行数据，语法如下：1rowVar_name table_name%rowtype;使用%ROWTYPE改造上个RECORD类型的例子：123456789101112SQL&gt; set serveroutput onSQL&gt; declare row_emp scott.emp%rowtype; begin select * into row_emp from scott.emp where empno=7369; dbms_output.put_line('雇员'||row_emp.ename||'的职务是'||row_emp.job||'，工资是'||row_emp.sal); end; /雇员SMITH的职务是CLERK，工资是800PL/SQL 过程已成功完成。变量与常量定义变量定义变量的格式如下所示：1&lt;变量名&gt; &lt;数据类型&gt; [(长度):=&lt;初始值&gt;];比如： 定义一个用于存储国家名称的可变字符串变量 var_countryname，该变量的最大长度 是50，并且该变量的初始值为“中国”：1var_countryname varchar2(50):='中国';定义常量定义常量的格式如下所示：1&lt;常量名&gt; constant &lt;数据类型&gt;:=&lt;常量值&gt;;定义一个常量con_day，用来存储一年的天数：1con_day constant integer:=365;流程控制if…then语句其语法如下：123if &lt; condition_expression&gt; then plsql_sentenceend if;如果 if 后面的条件表达式存在“并且”、“或者”、“非”等逻辑运算，则可以使用“and”、“or”、“not”等逻辑运算符。另外，如果要判断if后面的条件表达式的值为空值，则需要在条件表达式中使用“is”和“null”关键字。if…then…else语句其语法如下：12345if &lt;condition_expression&gt; then plsql_sentence1;else plsql_sentence2;end if;if…then…elsif语句其语法如下：12345678if &lt; condition_expression1 &gt; then plsql_sentence_1;elsif &lt; condition_expression2 &gt; then plsql_sentence_2; ...else plsql_sentence_n;end if;case语句其语法如下：12345678910case &lt; selector&gt; when &lt;expression_1&gt; then plsql_sentence_1; when &lt;expression_2&gt; then plsql_sentence_2; ... when &lt;expression_n&gt; then plsql_sentence_n; [else plsql_sentence;]end case;loop语句loop 语句会先执行一次循环体，然后再判断“exit when”关键字后面的条件表达式的值是true 还是false，如果是true，则程序会退出循环体，否则程序将再次执行循环体，这样就使得程序至少能够执行一次循环体，语法如下：1234loop plsql_sentence; exit when end_condition_ exp;end loop;比如计算1到100自然数的和：12345678910111213141516SQL&gt; set serveroutput onSQL&gt; declare sum_i int:=0; i int:=0; begin loop i:=i+1; sum_i:=sum_i+i; exit when i&gt;=100; end loop; dbms_output.put_line('自然数1到100的和为：'||sum_i); end; /自然数1到100的和为：5050PL/SQL 过程已成功完成。while语句语法如下：123while condition_expression loop plsql_sentence;end loop;使用 while 语句求得前100 个自然数的和：123456789101112131415SQL&gt; set serveroutput onSQL&gt; declare sum_i int:=0; i int:=0; begin while i&lt;=99 loop i:=i+1; sum_i:=sum_i+i; end loop; dbms_output.put_line('自然数1到100的和为：'||sum_i); end; /自然数1到100的和为：5050PL/SQL 过程已成功完成。for语句语法如下：123for variable_ counter_name in [reverse] lower_limit..upper_limit loop plsql_sentence;end loop;variable_ counter_name：表示一个变量，通常为整数类型，用来作为计数器。默认情况下计数器的值会循环递增，当在循环中使用reverse关键字时，计数器的值会随循环递减。lower_limit：计数器的下限值，当计数器的值小于下限值时，程序终止for循环。upper_limit：计数器的上限值，当计数器的值大于上限值时，程序终止for循环。比如，使用 for 语句求得前100 个自然数中奇数之和，12345678910111213141516SQL&gt; set serveroutput onSQL&gt; declare i int:=0; sum_i int:=0; begin for i in reverse 1..100 loop if mod(i,2)!=0 then sum_i:=sum_i+i; end if; end loop; dbms_output.put_line('自然数1到100的奇数和为：'||sum_i); end; /自然数1到100的奇数和为：2500PL/SQL 过程已成功完成。在上面的for 语句中，由于使用了关键字“reverse”，表示计数器i 的值为递减状态，即i 的初始值为100，随着每次递减1，最后一次for 循环时i 的值变为1。如果在for 语句中不使用关键字“reverse”，则表示计数器i 的值为递增状态，即i 的初始值为1。游标游标分为显式游标和隐式游标。显式游标显式游标是由用户声明和操作的一种游标，通常用于操作查询结果集，使用它处理数据的步骤包括：声明游标、打开游标、读取游标和关闭游标4个步骤。1.声明游标声明游标主要包括游标名称和为游标提供结果集的 SELECT 语句。语法如下：123cursor cur_name[(input_parameter1[,input_parameter2]…)] [return ret_type]is select_ sentence;cur_name：表示所声明的游标名称。ret_type：表示执行游标操作后的返回值类型，这是一个可选项。select_ sentence：游标所使用的SELECT 语句，它为游标的反复读取提供了结果集。input_parameter1：作为游标的“输入参数”，可以有多个，这是一个可选项。比如声明一个游标，用来读取emp 表中职务为销售员（SALESMAN）的雇员信息：12345SQL&gt; declare cursor cur_emp(var_job in varchar2:='SALESMAN') is select empno,ename,sal from emp where job=var_job;输入参数var_job类型为varchar2，但不可以指定长度，如：varchar2(10)，否则程序报错。2.打开游标打开游标的语法格式如下：1open cur_name[(para_value1[,para_value2]…)];比如：1open cur_emp('MANAGER');上面这条语句表示打开游标 cur_emp，然后给游标的“输入参数”赋值为“MANAGER”。当然这里可以省略“(‘MANAGER’)”，这样表示“输入参数”的值仍然使用其初始值（即SALESMAN）。3.读取游标当打开一个游标之后，就可以读取游标中的数据了其语法格式如下：1fetch cur_name into &#123;variable&#125;;cur_name：要读取的游标名称。variable：%RECORD类型或者%ROWTYPE类型变量。4.关闭游标游标使用完毕后需要关闭，以释放系统资源，比如 SELECT 语句返回的结果集等。它的语法格式如下：1close cur_name;游标的属性无论是显式游标还是隐式游标，都具有%found、%notfound、%isopen 和%rowcount4个属性，通过这4个属性可以获知SQL语句的执行结果以及该游标的状态信息：%found：布尔型属性，如果SQL 语句至少影响到一行数据，则该属性为true，否则为fasle。%notfound：布尔型属性，与%found 属性的功能相反。%rowcount：数字型属性，返回受SQL 语句影响的行数。%isopen：布尔型属性，当游标已经打开时返回true，游标关闭时则为false。下面举个使用显式游标的例子：12345678910111213141516171819202122SQL&gt; set serveroutput onSQL&gt; declare cursor cur_emp(var_job in varchar2:='SALESMAN') is select * from scott.emp where job=var_job; row_emp scott.emp%rowtype; begin open cur_emp; fetch cur_emp into row_emp; //先让指针指向结果集中的第一行，并将值保存到row_emp中 while cur_emp%found loop dbms_output.put_line('雇员'||row_emp.ename||'的编号是'||row_emp.empno||'，工资是：'||row_emp.sal); fetch cur_emp into row_emp; //让指针指向结果集中的下一行，并将值保存到row_emp中 end loop; close cur_emp; end; /雇员ALLEN的编号是7499，工资是：1600雇员WARD的编号是7521，工资是：1250雇员MARTIN的编号是7654，工资是：1250雇员TURNER的编号是7844，工资是：1500PL/SQL 过程已成功完成。隐式游标在执行一个 SQL 语句时，Oracle 会自动创建一个隐式游标。这个游标是内存中处理该语句的工作区域。隐式游标主要是处理数据操纵语句（如UPDATE、DELETE 语句）的执行结果，当然特殊情况下，也可以处理SELECT 语句的查询结果。由于隐式游标也有属性，当使用隐式游标的属性时，需要在属性前面加上隐式游标的默认名称——sql。在实际的 PL/SQL 编程中，经常使用隐式游标来判断更新数据行或删除数据行的情况。比如把scott.emp表中销售员（即SALESMAN）的工资上调20%，然后使用隐式游标sql的%rowcount属性输出上调工资的员工数量：1234567891011121314SQL&gt; set serveroutput onSQL&gt; begin update scott.emp set sal=sal*1.2 where job='SALESMAN'; if sql%notfound then dbms_output.put_line('没有雇员需要上调工资'); else dbms_output.put_line('有'||sql%rowcount||'个雇员工资上调20%'); end if; end; /有4个雇员工资上调20%PL/SQL 过程已成功完成。通过for语句循环游标在使用隐式游标或显式游标处理具有多行数据的结果集时，用户可以配合for语句来完成。在使用for语句遍历游标中的数据时，可以把它的计时器看做一个自动的RECORD类型的变量。比如使用for遍历一个隐式游标：12345678910111213SQL&gt; set serveroutput onSQL&gt; begin for emp_record in (select * from scott.emp where job='SALESMAN') loop dbms_output.put_line('雇员编号：'||emp_record.empno||'，雇员姓名：'||emp_record.ename||'，工资为：'||emp_record); end loop; end; /雇员编号：7499，雇员姓名：ALLEN，工资为：1920雇员编号：7521，雇员姓名：WARD，工资为：1500雇员编号：7654，雇员姓名：MARTIN，工资为：1500雇员编号：7844，雇员姓名：TURNER，工资为：1800PL/SQL 过程已成功完成。异常在编写PL/SQL程序时，避免不了会发生一些异常。Oracle 系统异常分为预定义异常和自定义异常。预定义异常Oracle系统常见的预定义异常及其说明如下表所示：系统预定义异常说明ZERO_DIVIDE除数为零时引发的异常ACCESS_INTO_NULL企图为某个未初始化对象的属性赋值COLLECTION_IS_NULL企图使用未初始化的集合元素CURSOR_ALREADY_OPEN企图再次打开一个已经打开过的游标，但在重新打开之前，游标未关闭INVALID_CURSOR执行一个非法的游标操作，例如，关闭一个未打开的游标INVALID_NUMBER企图将一个字符串转换成一个无效的数字而失败LOGIN_DENIED企图使用无效的用户名或密码连接数据库NO_DATA_FOUNDSELECT INTO 语句没有返回数据ROWTYPE_MISMATCH主游标变量与PL/SQL 游标变量的返回类型不兼容SELF_IS_NULL使用对象类型时，使用空对象调用其方法SUBSCRIPT_BEYOND_COUNT元素下标超过嵌套表或VARRAY 的最大值SUBSCRIPT_OUTSIDE_LIMIT企图使用非法索引号引用嵌套表或VARRAY 中的元素SYS_INVALID_ROWID字符串向ROWID 转换时的错误，因为该字符串不是一个有效的ROWID 值TIMEOUT_ON_RESOURCEOracle 在等待资源时超时TOO_MANY_ROWS执行SELECT INTO 语句时，结果集超过一行引发的异常比如：1234567891011121314151617181920SQL&gt; set serveroutput onSQL&gt; declare var_empno number; var_ename varchar2(50); begin select empno,ename into var_empno,var_ename from scott.emp where deptno=10; if sql%found then dbms_output.put_line('雇员编号：'||var_empno); end if; exception when too_many_rows then dbms_output.put_line('返回记录超过一行'); when no_data_found then dbms_output.put_line('无数据'); end; /返回记录超过一行PL/SQL 过程已成功完成。自定义异常Oracle的自定义异常就可以分为错误编号异常和业务逻辑异常两种。1.错误编号异常错误编号异常是指在Oracle系统发生错误时，系统会显示错误编号和相关描述信息的异常，比如：12345SQL&gt; insert into scott.dept values(10,'开发一部','福州');insert into scott.dept values(10,'开发一部','福州')*第 1 行出现错误:ORA-00001: 违反唯一约束条件 (SCOTT.PK_DEPT)对于这种异常，首先在PL/SQL块的声明部分（DECLARE 部分）使用EXCEPTION类型定义一个异常变量名，然后使用语句PRAGMA EXCEPTION_INIT为“错误编号”关联这个异常变量名，接下来就可以像对待系统预定义异常一样处理了。比如：1234567891011121314SQL&gt; set serveroutput onSQL&gt; declare primary_iterant exception; pragma exception_init(primary_iterant,-00001); begin insert into scott.dept values(10,'开发一部','福州'); exception when primary_iterant then dbms_output.put_line('主键重复！'); end; /主键重复！PL/SQL 过程已成功完成。2.业务异常程序开发人员可以根据具体的业务逻辑规则自定义一个异常。业务逻辑异常是Oracle系统本身无法知道的，这样就需要有一个引发异常的机制，引发业务逻辑异常通常使用RAISE 语句来实现。比如，自定义一个异常变量，在向dept表中插入数据时，若判断loc字段的值为null，则使用raise语句引发异常：123456789101112131415161718192021SQL&gt; set serveroutput onSQL&gt; declare null_exception exception; dept_row scott.dept%rowtype; begin dept_row.deptno:=66; dept_row.dname:='开发二部'; insert into scott.dept values(dept_row.deptno,dept_row.dname,dept_row.loc); if dept_row.loc is null then raise null_exception; end if; exception when null_exception then dbms_output.put_line('loc字段不能为空！'); rollback; end; /loc字段不能为空！PL/SQL 过程已成功完成。]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle SQLPlus命令]]></title>
    <url>%2FOracle-SQLPlus%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[SQLPlus是一个被DBA和开发人员广泛使用的功能强大的Oracle工具，可以在各个平台上拥有操作的一致性。SQLPlus可以执行输入的SQL语句和SQL文件，通过SQLPlus可以和数据库进行对话。以下例子基于Oracle 11g。set命令设置运行环境在Oracle 11g中，可以使用set命令来设置SQLPlus的运行环境。set命令语法如下：1set variable valuevariable为变量名，value为变量值。下面介绍几个常用的set变量。pagesize变量pagesize变量用来设置从顶部标题到页结束行（包含页首的空行）之间的行数。pagesize的默认值为14：12SQL&gt; show pagesizepagesize 14使用set pagesize命令修改一页的行数为18：1234567891011121314151617181920SQL&gt; set pagesize 18;SQL&gt; select user_id,username,account_status from dba_users; USER_ID USERNAME ACCOUNT_STATUS---------- ------------------------------ -------------------------------- 74 MGMT_VIEW OPEN 0 SYS OPEN 5 SYSTEM OPEN 30 DBSNMP OPEN 72 SYSMAN OPEN 84 SCOTT OPEN 9 OUTLN EXPIRED &amp; LOCKED 75 FLOWS_FILES EXPIRED &amp; LOCKED 57 MDSYS EXPIRED &amp; LOCKED 53 ORDSYS EXPIRED &amp; LOCKED 42 EXFSYS EXPIRED &amp; LOCKED 32 WMSYS EXPIRED &amp; LOCKED 31 APPQOSSYS EXPIRED &amp; LOCKED 78 APEX_030200 EXPIRED &amp; LOCKED 83 OWBSYS_AUDIT EXPIRED &amp; LOCKED可手动数一下是不是18行(lll￢ω￢)。newpage变量该变量用于设置一页中空行的数量，默认值为1，可以使用set newpage命令改变该值：12345678910111213141516171819202122SQL&gt; show newpagenewpage 1SQL&gt; set newpage 5SQL&gt; select user_id,username,account_status from dba_users; USER_ID USERNAME ACCOUNT_STATUS---------- ------------------------------ -------------------------------- 74 MGMT_VIEW OPEN 0 SYS OPEN 5 SYSTEM OPEN 30 DBSNMP OPEN 72 SYSMAN OPEN 84 SCOTT OPEN 9 OUTLN EXPIRED &amp; LOCKED 75 FLOWS_FILES EXPIRED &amp; LOCKED 57 MDSYS EXPIRED &amp; LOCKED 53 ORDSYS EXPIRED &amp; LOCKED 42 EXFSYS EXPIRED &amp; LOCKEDlinesize变量该变量用于设置SQLPlus环境中一行所显示的最多字符总数，默认值为80，当pagesize过小时，数据就会出现折行显示的情况。可以使用set linesize命令来调整linesize的值：123SQL&gt; show linesizelinesize 80SQL&gt; set linesize 120pause变量用于设置输出结果翻页时，是否暂停，基本语法如下：1set pause valuevalue可取的值有：off，默认值，返回结果一次性输出完毕，中间翻页不会暂停；on，表示输出结果的每一页都暂停，用户按ENTER继续；text，在设置为on之后，继续设置text的值，用于暂停时显示；比如：1234567891011121314151617181920212223SQL&gt; set pause onSQL&gt; set pause '按&lt;enter&gt;键继续'SQL&gt; select user_id,username,account_status from dba_users;按&lt;enter&gt;键继续 USER_ID USERNAME ACCOUNT_STATUS---------- ------------------------------ -------------------------------- 74 MGMT_VIEW OPEN 0 SYS OPEN 5 SYSTEM OPEN 30 DBSNMP OPEN 72 SYSMAN OPEN 84 SCOTT OPEN 9 OUTLN EXPIRED &amp; LOCKED 75 FLOWS_FILES EXPIRED &amp; LOCKED 57 MDSYS EXPIRED &amp; LOCKED 53 ORDSYS EXPIRED &amp; LOCKED 42 EXFSYS EXPIRED &amp; LOCKED 32 WMSYS EXPIRED &amp; LOCKED 31 APPQOSSYS EXPIRED &amp; LOCKED 78 APEX_030200 EXPIRED &amp; LOCKED 83 OWBSYS_AUDIT EXPIRED &amp; LOCKED按&lt;enter&gt;键继续numformat变量该变量值用于设置显示数值的默认格式，基本语法如下：1set numformat formatformat为数值掩码，常用值及其说明如下：掩码说明举例9查询结果中数字替换格式的掩码9990格式中的掩码屏蔽掉查询结果中的数字999.00$在查询结果中的数字前添加美元前缀$999S为数字显示符号类型，通常用于显示查询结果中的正负数字S999,在字符,位置上放置都逗号/td&gt;999,99查看scott.emp表中的SAL字段值，然后使用”$999,999,999.00”格式显示:12345678910111213141516171819202122232425262728293031SQL&gt; select ename,job,sal from scott.emp;ENAME JOB SAL---------- --------- ----------SMITH CLERK 800ALLEN SALESMAN 1600WARD SALESMAN 1250JONES MANAGER 2975MARTIN SALESMAN 1250BLAKE MANAGER 2850CLARK MANAGER 2450SCOTT ANALYST 3000KING PRESIDENT 5000TURNER SALESMAN 1500ADAMS CLERK 1100SQL&gt; set numformat $999,999,999.00SQL&gt; select ename,job,sal from scott.emp;ENAME JOB SAL---------- --------- ----------------SMITH CLERK $800.00ALLEN SALESMAN $1,600.00WARD SALESMAN $1,250.00JONES MANAGER $2,975.00MARTIN SALESMAN $1,250.00BLAKE MANAGER $2,850.00CLARK MANAGER $2,450.00SCOTT ANALYST $3,000.00KING PRESIDENT $5,000.00TURNER SALESMAN $1,500.00ADAMS CLERK $1,100.00timing变量该变量用于显示执行SQL语句所花的时间，默认值为off：1234567891011121314151617181920212223242526SQL&gt; set timing onSQL&gt; select ename,job,sal from scott.emp;ENAME JOB SAL---------- --------- ----------------SMITH CLERK $800.00ALLEN SALESMAN $1,600.00WARD SALESMAN $1,250.00JONES MANAGER $2,975.00MARTIN SALESMAN $1,250.00BLAKE MANAGER $2,850.00CLARK MANAGER $2,450.00SCOTT ANALYST $3,000.00KING PRESIDENT $5,000.00TURNER SALESMAN $1,500.00ADAMS CLERK $1,100.00ENAME JOB SAL---------- --------- ----------------JAMES CLERK $950.00FORD ANALYST $3,000.00MILLER CLERK $1,300.00已选择14行。已用时间: 00: 00: 00.04set命令还有很多变量可用，可使用help set命令来查看。常用SQLPlus命令help命令help命令用来帮助用户查询指定命令详细介绍，类似于Linux的man，其的语法如下：1help|? [topic]?表示一个命令的部分字符，用于模糊查询；topic参数表示要查询的命令的完整名称。如果直接输入help，则显示的是命令本身的详细信息：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SQL&gt; help HELP ---- Accesses this command line help system. Enter HELP INDEX or ? INDEX for a list of topics. You can view SQL*Plus resources at http://www.oracle.com/technology/tech/sql_plus/ and the Oracle Database Library at http://www.oracle.com/technology/documentation/ HELP|? [topic]SQL&gt; help set SET --- Sets a system variable to alter the SQL*Plus environment settings for your current session. For example, to: - set the display width for data - customize HTML formatting - enable or disable printing of column headings - set the number of lines per page SET system_variable value where system_variable and value represent one of the following clauses: APPI[NFO]&#123;OFF|ON|text&#125; NEWP[AGE] &#123;1|n|NONE&#125; ARRAY[SIZE] &#123;15|n&#125; NULL text AUTO[COMMIT] &#123;OFF|ON|IMM[EDIATE]|n&#125; NUMF[ORMAT] format AUTOP[RINT] &#123;OFF|ON&#125; NUM[WIDTH] &#123;10|n&#125; AUTORECOVERY &#123;OFF|ON&#125; PAGES[IZE] &#123;14|n&#125; AUTOT[RACE] &#123;OFF|ON|TRACE[ONLY]&#125; PAU[SE] &#123;OFF|ON|text&#125; [EXP[LAIN]] [STAT[ISTICS]] RECSEP &#123;WR[APPED]|EA[CH]|OFF&#125; BLO[CKTERMINATOR] &#123;.|c|ON|OFF&#125; RECSEPCHAR &#123;_|c&#125; CMDS[EP] &#123;;|c|OFF|ON&#125; SERVEROUT[PUT] &#123;ON|OFF&#125; COLSEP &#123;_|text&#125; [SIZE &#123;n | UNLIMITED&#125;] CON[CAT] &#123;.|c|ON|OFF&#125; [FOR[MAT] &#123;WRA[PPED] | COPYC[OMMIT] &#123;0|n&#125; WOR[D_WRAPPED] | COPYTYPECHECK &#123;ON|OFF&#125; TRU[NCATED]&#125;] DEF[INE] &#123;&amp;|c|ON|OFF&#125; SHIFT[INOUT] &#123;VIS[IBLE] | DESCRIBE [DEPTH &#123;1|n|ALL&#125;] INV[ISIBLE]&#125; [LINENUM &#123;OFF|ON&#125;] [INDENT &#123;OFF|ON&#125;] SHOW[MODE] &#123;OFF|ON&#125; ECHO &#123;OFF|ON&#125; SQLBL[ANKLINES] &#123;OFF|ON&#125; EDITF[ILE] file_name[.ext] SQLC[ASE] &#123;MIX[ED] | EMB[EDDED] &#123;OFF|ON&#125; LO[WER] | UP[PER]&#125; ERRORL[OGGING] &#123;ON|OFF&#125; SQLCO[NTINUE] &#123;&gt; | text&#125; [TABLE [schema.]tablename] SQLN[UMBER] &#123;ON|OFF&#125; [TRUNCATE] [IDENTIFIER identifier] SQLPLUSCOMPAT[IBILITY] &#123;x.y[.z]&#125; ESC[APE] &#123;\|c|OFF|ON&#125; SQLPRE[FIX] &#123;#|c&#125; ESCCHAR &#123;@|?|%|$|OFF&#125; SQLP[ROMPT] &#123;SQL&gt;|text&#125; EXITC[OMMIT] &#123;ON|OFF&#125; SQLT[ERMINATOR] &#123;;|c|ON|OFF&#125; FEED[BACK] &#123;6|n|ON|OFF&#125; SUF[FIX] &#123;SQL|text&#125; FLAGGER &#123;OFF|ENTRY|INTERMED[IATE]|FULL&#125; TAB &#123;ON|OFF&#125; FLU[SH] &#123;ON|OFF&#125; TERM[OUT] &#123;ON|OFF&#125; HEA[DING] &#123;ON|OFF&#125; TI[ME] &#123;OFF|ON&#125; HEADS[EP] &#123;||c|ON|OFF&#125; TIMI[NG] &#123;OFF|ON&#125; INSTANCE [instance_path|LOCAL] TRIM[OUT] &#123;ON|OFF&#125; LIN[ESIZE] &#123;80|n&#125; TRIMS[POOL] &#123;OFF|ON&#125; LOBOF[FSET] &#123;1|n&#125; UND[ERLINE] &#123;-|c|ON|OFF&#125; LOGSOURCE [pathname] VER[IFY] &#123;ON|OFF&#125; LONG &#123;80|n&#125; WRA[P] &#123;ON|OFF&#125; LONGC[HUNKSIZE] &#123;80|n&#125; XQUERY &#123;BASEURI text| MARK[UP] HTML [OFF|ON] ORDERING&#123;UNORDERED| [HEAD text] [BODY text] [TABLE text] ORDERED|DEFAULT&#125;| [ENTMAP &#123;ON|OFF&#125;] NODE&#123;BYVALUE|BYREFERENCE| [SPOOL &#123;OFF|ON&#125;] DEFAULT&#125;| [PRE[FORMAT] &#123;OFF|ON&#125;] CONTEXT text&#125;也可以使用help index命令查看SQLPlus命令清单：123456789101112131415161718SQL&gt; help indexEnter Help [topic] for help. @ COPY PAUSE SHUTDOWN @@ DEFINE PRINT SPOOL / DEL PROMPT SQLPLUS ACCEPT DESCRIBE QUIT START APPEND DISCONNECT RECOVER STARTUP ARCHIVE LOG EDIT REMARK STORE ATTRIBUTE EXECUTE REPFOOTER TIMING BREAK EXIT REPHEADER TTITLE BTITLE GET RESERVED WORDS (SQL) UNDEFINE CHANGE HELP RESERVED WORDS (PL/SQL) VARIABLE CLEAR HOST RUN WHENEVER OSERROR COLUMN INPUT SAVE WHENEVER SQLERROR COMPUTE LIST SET XQUERY CONNECT PASSWORD SHOWdescribe命令该命令用于查询指定数据表的组成结构，语法如下：1desc[ribe] object_namedescribe可缩写为desc。比如查询scott.emp表中SALESMAN的编号，姓名和工资，过程中，使用#desc scott.emp命令查询scott.emp表中工资字段的名称：123456789101112131415161718192021SQL&gt; select empno,ename, 2 #desc scott.emp 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- EMPNO NOT NULL NUMBER(4) ENAME VARCHAR2(10) JOB VARCHAR2(9) MGR NUMBER(4) HIREDATE DATE SAL NUMBER(7,2) COMM NUMBER(7,2) DEPTNO NUMBER(2) 2 sal from scott.emp where job = 'SALESMAN'; EMPNO ENAME SAL---------- ---------- ---------- 7499 ALLEN 1600 7521 WARD 1250 7654 MARTIN 1250 7844 TURNER 1500spool命令该命令可以将查询结果输出到指定文件中，spool的语法格式如下：1spo[ol] [file_name[.ext] [CRE[ATE] | REP[LACE] | APP[END]] | OFF | OUT]cre[ate]，表示创建一个新的文件，默认值；rep[lace]，表示覆盖已存在的文件；app[end]，表示追加到一个已存在的文件中；off|out，表示关闭spool输出。比如：1234567891011121314151617181920212223242526SQL&gt; spool d:\emp.txtSQL&gt; select empno,ename,job,sal from scott.emp; EMPNO ENAME JOB SAL---------- ---------- --------- ---------- 7369 SMITH CLERK 800 7499 ALLEN SALESMAN 1600 7521 WARD SALESMAN 1250 7566 JONES MANAGER 2975 7654 MARTIN SALESMAN 1250 7698 BLAKE MANAGER 2850 7782 CLARK MANAGER 2450 7788 SCOTT ANALYST 3000 7839 KING PRESIDENT 5000 7844 TURNER SALESMAN 1500 7876 ADAMS CLERK 1100 EMPNO ENAME JOB SAL---------- ---------- --------- ---------- 7900 JAMES CLERK 950 7902 FORD ANALYST 3000 7934 MILLER CLERK 1300已选择14行。SQL&gt; spool off到D盘打开emp.txt如下：define命令该命令用来定义一个变量并赋值，基本语法如下：1def[ine] [variable] | [variable = text]比如：123SQL&gt; define vjob='SALESMAN'SQL&gt; define vjobDEFINE VJOB = "SALESMAN" (CHAR)show命令show命令用来显示SQLPlus系统变量的值，语法如下：1sho[w] optionoption表示要显示的系统选项，常用的值有：all，parameters [parameter_name]，sga，spool和user等。1234567891011121314SQL&gt; show parameters db_block_sizeNAME TYPE VALUE------------------------------------ ----------- ------------------------------db_block_size integer 8192SQL&gt; show sgaTotal System Global Area 3373858816 bytesFixed Size 2180424 bytesVariable Size 1862273720 bytesDatabase Buffers 1493172224 bytesRedo Buffers 16232448 bytesSQL&gt; show userUSER 为 "SYSTEM"save命令该命令将SQL缓冲区的最近一条SQL或PL/SQL块保存到指定的文件中，语法如下：1sav[e] [FILE] file_name[.ext] [CRE[ATE] | REP[LACE] | APP[END]]比如：1234567891011SQL&gt; select * from scott.dept; DEPTNO DNAME LOC---------- -------------- ------------- 10 ACCOUNTING NEW YORK 20 RESEARCH DALLAS 30 SALES CHICAGO 40 OPERATIONS BOSTONSQL&gt; save d:\dept.sql已创建 file d:\dept.sql如果不指定文件扩展名，默认为.sql。get命令该命令将一个SQL脚本文件的内容放进SQL的缓冲区，语法格式如下：1get [FILE] file_name[.ext] [LIST | NOLIST]其中list表示加载到缓冲区的时候显示文件的内容，nolist则表示不显示。比如加载d:\dept.sql到SQL缓冲区，并运行命令/执行该语句：12345678910SQL&gt; get d:\dept.sql list 1* select * from scott.deptSQL&gt; / DEPTNO DNAME LOC---------- -------------- ------------- 10 ACCOUNTING NEW YORK 20 RESEARCH DALLAS 30 SALES CHICAGO 40 OPERATIONS BOSTONstart和@两个命令都是用于执行一个sql脚本文件，比如：1234567891011121314151617SQL&gt; start d:\dept.sql DEPTNO DNAME LOC---------- -------------- ------------- 10 ACCOUNTING NEW YORK 20 RESEARCH DALLAS 30 SALES CHICAGO 40 OPERATIONS BOSTONSQL&gt; @ d:\dept.sql DEPTNO DNAME LOC---------- -------------- ------------- 10 ACCOUNTING NEW YORK 20 RESEARCH DALLAS 30 SALES CHICAGO 40 OPERATIONS BOSTON格式化查询结果column该命令可以实现格式化查询结果，设置列宽，设置列标题等。语法如下：1col[umn] [column_name|alias|option]column_name用于指定要设置的列的名称，alias用于指定列的别名，option用于指定列的显示格式，其值和说明如下表所示：option选项的值说明clear清除指定列所设置的格式，恢复默认值format格式化指定列heading指定列标题justify调整列标题的对齐方式，默认情况下：数值类型的右对齐，其他类型的左对齐null替换null值print/noprint显示列标题或隐藏列标题，默认为printon/off控制定义的显示属性状态，off表示定义的所有显示属性都不起作用wrapped当字符串的长度超过显示宽度时，将字符串的超出部分折叠到下一行显示word_wrapped表示从一个完整的字符处折叠truncated表示截取字符串尾部format选项使用format选项格式化scott.emp表中的sal列，格式为$999,999.00：123456789101112131415161718192021222324SQL&gt; column sal format $999,999.00SQL&gt; select empno,ename,sal from scott.emp; EMPNO ENAME SAL---------- ---------- ------------ 7369 SMITH $800.00 7499 ALLEN $1,600.00 7521 WARD $1,250.00 7566 JONES $2,975.00 7654 MARTIN $1,250.00 7698 BLAKE $2,850.00 7782 CLARK $2,450.00 7788 SCOTT $3,000.00 7839 KING $5,000.00 7844 TURNER $1,500.00 7876 ADAMS $1,100.00 EMPNO ENAME SAL---------- ---------- ------------ 7900 JAMES $950.00 7902 FORD $3,000.00 7934 MILLER $1,300.00已选择14行。heading选项使用heading选项将scott.emp表的empno，ename和sal三个列名转换为中文：1234567891011121314151617181920212223242526SQL&gt; column empno heading 员工编号SQL&gt; column ename heading 员工姓名SQL&gt; column sal heading 工资SQL&gt; select empno,ename,sal from scott.emp; 员工编号 员工姓名 工资---------- ---------- ------------ 7369 SMITH $800.00 7499 ALLEN $1,600.00 7521 WARD $1,250.00 7566 JONES $2,975.00 7654 MARTIN $1,250.00 7698 BLAKE $2,850.00 7782 CLARK $2,450.00 7788 SCOTT $3,000.00 7839 KING $5,000.00 7844 TURNER $1,500.00 7876 ADAMS $1,100.00 员工编号 员工姓名 工资---------- ---------- ------------ 7900 JAMES $950.00 7902 FORD $3,000.00 7934 MILLER $1,300.00已选择14行。null选项使用null选项将scott.emp表中comm列值为null显示成“空值”：1234567891011121314151617SQL&gt; column comm null '空值'SQL&gt; select empno,ename,comm from scott.emp where comm is null; 员工编号 员工姓名 COMM---------- ---------- ---------- 7369 SMITH 空值 7566 JONES 空值 7698 BLAKE 空值 7782 CLARK 空值 7788 SCOTT 空值 7839 KING 空值 7876 ADAMS 空值 7900 JAMES 空值 7902 FORD 空值 7934 MILLER 空值已选择10行。wrapped/word_wrapped选项使用wrapped选项实现按照指定长度折行：12345678910111213141516171819202122232425SQL&gt; create table test( 2 col1 varchar2(100) 3 );表已创建。SQL&gt; insert into test(col1) values ('HOW ARE YOU?');已创建 1 行。SQL&gt; select col1 from test;COL1--------------------------------------------------------------------------------HOW ARE YOU?SQL&gt; column col1 format a5SQL&gt; column col1 wrappedSQL&gt; select col1 from test;COL1-----HOW ARE YOU?使用word_wrapped选项按照完整字符串折行12345678SQL&gt; column col1 word_wrappedSQL&gt; select col1 from test;COL1-----HOWAREYOU?ttitle和btitle命令这两个命令分别用来设置打印时每页的页首和页脚标题，其中ttitle语法如下（btitle语法类似）：1tti[tle] [printspec [text|variable] ...] | [OFF|ON]printspec作为头标题的修饰性选项，其值和说明如下表所示：printspec选项的值说明col指定当前行的第几列打印头标题skip跳到从下一行开始的第几行，默认为1left在当前行中左对齐打印数据center在当前行中间打印数据right在当前行中右对齐打印数据bold以黑体打印数据比如：打印输出scott.salgrade数据表中的记录，并设置标题：1234567891011121314151617181920SQL&gt; set pagesize 8SQL&gt; ttitle left '销售情况排行表'SQL&gt; btitle left '打印日期2017年11月5日 打印人 MrBird'SQL&gt; select * from scott.salgrade;销售情况排行表 GRADE LOSAL HISAL---------- ---------- ---------- 1 700 1200 2 1201 1400 3 1401 2000打印日期2017年11月5日 打印人 MrBird销售情况排行表 GRADE LOSAL HISAL---------- ---------- ---------- 4 2001 3000 5 3001 9999打印日期2017年11月5日 打印人 MrBird]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx Rewrite]]></title>
    <url>%2FNginx-rewrite.html</url>
    <content type="text"><![CDATA[Nginx服务器提供了Rewrite功能，用于实现URL的重写。该功能由ngx_http_rewrite_module模块提供，该模块默认开启。Nginx服务器的Rewrite功能依赖于PCRE(Perl Compatible Regular Expressions，Perl兼容的正则表达式)，所以在编译安装Nginx的时候需要先安装PCRE库。Rewrite功能就是，使用Nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。Rewrite只能对域名后边的除去传递的参数外的字符串起作用，例如https://mrbird.cc/page/2/search?type=1&amp;value=nginx只对/page/2/search重写。if指令用于根据不同条件选择不同的Nginx配置，可在server和location块中配置。语法如下：1if (condition) &#123; &#125;condition为判断条件（true/false）：变量名。如果变量的值为空字符串或者以0开头的任意字符串，为false。其余为true；比较变量的内容时候，使用=或!=；使用正则表达式。~（大小写敏感），~*（大小写不敏感），!~和!~*。正则表达式一般不加双引号，除非包含}或者分号;字符；-f和!-f用来判断是否存在文件；-d和!-d用来判断是否存在目录；-e和!-e用来判断是否存在文件或目录；-x和!-x用来判断文件是否可执行。几个实例：123456789101112131415if ($request_method = POST) &#123; return 405; # 如果请求方法为POST，则直接返回405HTTP状态码。&#125;if ($slow) &#123; limit_rate 10k;&#125;if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /msie/$1 break; # 如果UA包含"MSIE"，rewrite请求到/msid/目录下&#125;if ($http_cookie ~* "id=([^;]+)(?:;|$)") &#123; set $id $1; # 如果cookie匹配正则，设置变量$id等于正则引用部分&#125;if (!-f $request_filename)&#123; # 判断请求的文件是否不存在&#125;break指令该指令用于中断当前相同作用域的Nginx配置。Nginx遇到该指令时，回到上一层作用域继续向下读取配置。该指令可在server，location和if块中使用。语法如下：1break;比如：12345678location / &#123; if ($slow) &#123; set $id $1; break; # 跳出if作用域 limit_rate 10k; # 无效 &#125; ... # 继续读取&#125;return指令该指令用于完成对请求的处理，直接向客户端返回响应状态码，处于该指令后的所有Nginx配置都是无效的。语法结构如下：123return [text];return code URL;return URL;比如：123location = /404 &#123; return 404 "sorry page not found!\n"&#125;rewrite指令该指令通过正则表达式来改变URL，可以同时存在一个或多个指令，按照顺序依次对URL进行匹配处理。该指令可在server，location和if块中配置，语法如下：1rewrite regex replacement [flag];regex用于匹配URL的正则表达式，使用()标记要截取的内容。replacement匹配成功后用于替换URL中被截取的部分。默认情况下，如果replacement是由http://或者https://开头的字符串，则直接将重写后的URL返回客户端。flag标志位，其值有如下几种：last，Nginx遇到含有该标志位的rewrite命令时，停止向下处理，直接使用该rewrite返回的新的URL去和所有的location块重新匹配。break，将此处重写的URL作为一个新的URL，在本块中继续进行处理。该标志重写后的URL在当前location块中执行，不会转向到其他的location块。redirect将重写后的URL返回给客户端，状态码为302，表示临时重定向URL。permanent将重写后的URL返回给客户端，状态码为301，表示永久重定向URL。举些例子：1234location / &#123; rewrite ^(/myweb/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last; rewrite ^(/myweb/.*)/audio/(.*)\..*$ $1/mp4/$2.ra last; &#125;如果某个请求URL在第2行被匹配成功，Nginx不会继续使用第3行配置处理新的URL，而是让所有的location重新匹配新的URL。1234location /myweb/ &#123; rewrite ^(/myweb/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 break; rewrite ^(/myweb/.*)/audio/(.*)\..*$ $1/mp4/$2.ra break; &#125;如果某个请求URL在第2行被匹配成功，Nginx服务器将新的URL继续使用本块中的第3行配置进行处理，不会将新的URL发送到其他location块。如果这里将break替换为last的话，新的URL包含/myweb/串，本location块可能继续捕获到该新的URL，这样便造成了死循环。Nginx在尝试10次循环之后，返回500 Internal Server Error错误。rewrite_log指令该指令配置是否开启重写URL日志的输出功能，语法如下：1rewrite_log on | off默认值为off。日志将以notice级别输出到error_log配置的日志文件中。set指令该指令用于设置一个新的变量，语法如下：1set variable value变量名称必须以$开头，且不能和Nginx服务器预设的全局变量同名，变量的作用域为全局。uninitialized_variable_warn指令该指令用于配置实用未初始化的变量时，是否记录警告日志，语法如下：1uninitialized_variable_warn on | off默认值为on。rewrite常用全局变量下表列出了在rewrite配置过程中可能会使用到的Nginx全局变量：变量说明$args请求URL中的请求参数串，如arg1=value1&amp;arg2=value2$content_length请求头中的Content-length字段$content_type请求头重的Content-type片段$document_root当前请求的根路径$document_uri当前请求的URI，比如https://mrbird.cc/page/2/search?type=1&amp;value=nginx中的/page/2/search$host当前URL的主机部分字段，比如https://mrbird.cc/page/2/search?type=1&amp;value=nginx中的mrbird.cc。如果为空，则为server块中server_name指令的配置值$http_user_agent客户端的代理信息$http_cookie客户端的cookie信息$limit_rateNginx服务器对网络连接速率的限制，即Nginx配置中的limit_rate指令的配置值$remote_addr客户端的IP地址$remote_port客户端的端口号$request_body_file发给后端服务器的本地文件资源名称$request_method客户端的请求方式，如get，post等$request_filename当前请求的文件路径，由root或alias指令与URI请求生成。$request_uri包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”$query_string和$args相同$schemeHTTP方法（如http，https，ftp）$server_protocol请求使用的协议，通常是HTTP/1.0或HTTP/1.1$server_addr服务器的地址$server_name服务器名称$server_port请求到达服务器的端口号$uri同$document_urirewrite实例域名跳转123456server &#123; listen 80; server_name jump.myweb.name; rewrite ^/ http://www.myweb.info/; ...&#125;比如客户端访问http://jump.myweb.name时，URL将被重写为http://jump.myweb.info。12345678server &#123; listen 80; server_name jump.myweb.name jump.myweb.info if ($host ~ myweb\.info) &#123; rewrite ^(.*) http://jump.myweb.name$1 permanent; &#125; ...&#125;当客户端访问http://jump.myweb.info/reqsource时，URL将被重写为http://jump.myweb.name/reqsource。123456789server &#123; listen 80; server_name jump1.myweb.name jump2.myweb.name; if ($http_host ~* ^(.*)\.myweb\.name$) &#123; rewrite ^(.*) http://jump.myweb.name$1; break; &#125; ...&#125;当客户端访问http://jump1.myweb.name/reponse或者http://jump2.myweb.name/reponse时，URL都将被Nginx重写为http://jump.myweb.name/reponse。目录合并123456789server &#123; listen 80; server_name www.myweb.name; location ^~ /server &#123; rewrite ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\.htm$ /server/$1/$2/$3/$4/$5.html last; break; &#125;&#125;...此时如果客户端输入http://www.myweb.name/server-12-34-56-78-9.htm即可访问到http://www.myweb.name/server/12/34/56/78/9.html。这样做将多级目录下的资源文件请求转换为了目录计数少的资源请求，有利于SEO。防盗链防盗链的实现原理：通过HTTP协议中的请求头中的Referer头域，我们可以检测到访问目标资源的源地址，如果该地址不是自己站点的URL，就采取组织措施。Nginx配置中有一个指令valid_referers，如果Referer头域没有符合valid_referers配置的值，$invalid_referer变量的值将被赋值为1。valid_referers语法如下：1valid_referers none | blocked | server_names | string ...;none检测Referer头域不存在的情况。blocked检测Referer头域的值被防火墙或者代理服务器删除或伪装的情况。server_names设置URL。1234567891011server &#123; listen 80; server_name www.myweb.name; location ~* ^.+\.(gif|jpg|png|swf|flv|rar|zip)$ &#123; ... valid_referers none blocked server_names *.myweb.com; if ($invalid_referer) &#123; rewrite ^/ http://www.myweb.com/images/forbidden.png; &#125; &#125;...]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx upstream]]></title>
    <url>%2FNginx-upstream.html</url>
    <content type="text"><![CDATA[upstream指令用于配置Nginx后端服务器组。Nginx支持设置一组服务器作为后端服务器，由标准的HTTP模块ngx_http_upstream_module进行解析和处理。服务器组的设置涉及以下几个指令：upstream指令该指令为设置后端服务器组的主要指令，其他的指令都在该指令中进行配置，语法结构如下：1upstream name &#123; &#125;其中name为后端服务器组的名称，{}中包含服务器。某个服务器组收到请求后，按照权重的大小依次选择组内的服务器处理请求。如果出现错误，则顺次交给组内的下一个服务器进行处理，以此类推直到正常响应。如果都出错，则返回最后一个服务器处理的结果。server指令该指令用于设置组内的服务器，语法如下：1server address [parameters];address服务器的地址，支持IP，域名和unix地址；parameters设置更多的属性，包括：weight=number用于设置权重，权重高的优先处理。默认值为1。max_fails=number设置请求失败的次数。在fail_timeout时间范围内，服务器请求失败的次数超过该值时，则将该服务器置为down（无效）状态。fail_timeout=time除了用在max_fails外，该属性还用于设置某个down状态服务器的持续时间，在这个时间段内不再检查该服务器的状态，一直认为它是down状态。默认值为10s。backup设置服务器为备用服务器。当正常的服务器处于down或者busy状态时，该服务器才被用来处理请求。down将服务器标记为永久down状态。举个例子：12345upstream backend &#123; server www.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3;&#125;上述指令设置了一个名为backend的服务器组，包含三台服务器。第一台服务器是基于域名的，并且权重为5，将优先处理客户端请求；第二台服务器基于IP地址，并且设置如果30s内连续产生3次请求失败，则该服务器在之后的30s内被认为是down状态；第三台服务器基于unix地址。ip_hash指令该指令用于保障客户端和服务器建立稳定的会话。只有当该服务器处于down状态时，客户端请求才会被下一个服务器接收和处理。语法如下：1ip_hash;ip_hash指令不能和weight一起使用；Nginx服务器应为最前端的服务器。比如：12345upstream backend &#123; ip_hash; server myback1.proxy.com; server myback2.proxy.com;&#125;上述配置会使得客户端的请求都由第一台服务器处理（前提是没有出错），如果去掉ip_hash，则组内的两台服务器轮流响应请求。keep_alive指令该指令用于控制Nginx服务器的工作进程为服务器打开一定范围的网络连接，语法如下：1keepalive connections;connections用于限定该范围的上限值。如果超过该值，工作进程将采用LRU（最近最少使用）算法来关闭网络连接。least_conn指令该指令用于控制服务器组处理客户端请求时，除了考虑权重的大小之外，每次选择的服务器都是当前网络连接最少的那台。语法如下：1least_conn;]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx Gzip压缩]]></title>
    <url>%2FNginx-Gzip%E5%8E%8B%E7%BC%A9.html</url>
    <content type="text"><![CDATA[Nginx开启Gzip压缩可以将页面资源进行压缩后传输给浏览器，浏览器判断页面资源是否有进行压缩，如果有，则先进行解压然后再渲染页面。目前流行的浏览器都支持了该项技术（除了远古时代的IE6）。Gzip压缩可以降低网络带宽消耗，同时提升访问速度，使访问者拥有更好的用户体验。ngx_http_gzip_module该模块默认开启，主要负责Gzip功能的开启与设置，对响应数据进行在线实时压缩。涉及的指令主要有以下9个：gzip指令该指令用于开启或关闭Gzip功能，语法结构如下：1gzip on | off默认值为off。gzip_buffers指令该指令用于设置Gzip压缩文件使用缓存空间的大小，语法结构如下：1gzip_buffers number size;Nginx服务器在进行压缩时，需要向系统申请number*size大小的空间用于存储压缩数据。默认情况下number*size的值为128，size值为系统内存页一页的大小，为4K或8k，即：1gzip_buffers 32 4k | 16 8kgzip_comp_level指令用于设定Gzip压缩率。压缩率级别从1到9，其中1表示压缩率最低，压缩时间最短；9表示压缩率最高，压缩时间最长。语法结构如下：1gzip_comp_level level默认值为1。gzip_disable指令针对不同类型的客户端发起的请求，可以选择性的开启或关闭Gzip功能。比如IE6对Gzip的支持不好，所以如果发送请求的客户端为IE6，则关闭Gzip的功能。语法如下：1gzip_disable regex ...其中regex为浏览器的UA标志的正则表达式。比如：1gzip_disable MSIE [4-6]\.即UA字符串包括MSIE 4，MSIE 5，MSIE 6的浏览器发送的请求，Nginx将不进行Gzip压缩。gzip_http_version指令早期的HTTP客户端可能不支持Gzip的自解压，所以该指令用于限制开启Gzip压缩的最低HTTP协议版本，语法如下：1gzip_http_version 1.0 | 1.1默认值为1.1。目前来说大多数浏览器都支持Gzip自解压，所以采用默认值即可。gzip_min_length指令Gzip压缩功能对于size较大的文件压缩效果明显，而对于一些size很小的文件可能会出现数据量越压缩越大的情况。所以为了防止出现这种情况，可用该指令来限制压缩的最低数据量，语法如下：1gzip_min_length length默认值为20，为0时表示不进行限制。一般情况下设置为1kb即可。gzip_proxied指令该指令用于设置Nginx服务器是否对后端服务器返回的结果进行Gzip压缩。该指令在使用Nginx服务器的反向代理功能时有效。语法如下：1gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any ...off关闭Nginx服务器对后端服务器返回结果进行Gzip压缩，为默认值。expired当后端服务器响应页头部包含用于指示响应数据过期时间的expired头域时，开启Gzip压缩。no-cache当后端服务器响应页头部包含用于通知所有缓存机制是否缓存的Cache-control头域且其指令值为no-cache时，开启Gzip压缩。no-store当后端服务器响应页头部包含用于通知所有缓存机制是否缓存的Cache-control头域且其指令值为no-store时，开启Gzip压缩。private当后端服务器响应页头部包含用于通知所有缓存机制是否缓存的Cache-control头域且其指令值为private时，开启Gzip压缩。no_last_modified当后端服务器响应页头部不包含用于指明需要获取数据最后修改时间的Last-Modified头域时，开启Gzip压缩。no-etag当后端服务器响应页头部不包含用于标识被请求变量的实体值的ETag头域时，开启Gzip压缩。auth当后端服务器响应页头部包含用于标识HTTP授权证书的Authorization头域时，开启Gzip压缩。any无条件开启Gzip压缩。gzip_types指令根据响应页的MIME类型选择性的开启Gzip压缩。语法为：1gzip_types mime-types ...默认值为text/html，变量值还可以取*，表示对所有MIME类型的页面数据都进行Gzip压缩。gzip_vary指令该指令用于设置在使用了Gzip功能时是否发送带有“vary:Accept-Encoding”头域的响应头部。比如打开百度页面的控制台，可看到：其语法如下：1gzip_vary on | off默认值为off。ngx_http_gzip_static_module该模块主要负责搜索和发送经过Gzip功能预压缩的数据。如果客户端请求的数据在之前就被压缩过，则直接返回。和ngx_http_gzip_module主要的区别是，该模块使用的是静态压缩，在HTTP响应头部包含Content-Length头域来指明报文体的长度，用于服务器确定响应数据的长度。该模块默认关闭，如果需要使用，必须在Nginx程序配置时添加–with-http_gzip_static_module指令。与该模块有关的命令有如下几个：gzip_static、gzip_http_version、gzip-proxied、gzip_disable和gzip_vary等。gzip_static指令该指令用于开启或关闭Gzip静态压缩。语法如下：1gzip_static on | off | always其余指令和ngx_http_gzip_module类似。ngx_http_gunzip_module该模块用来针对不支持Gzip压缩数据处理的客户端浏览器，对压缩数据进行解压处理。有关的命令如下：gunzip、gunzip_buffers、gzip_http_version、gzip_proxied、gzip_disable和gzip_vary等。该模块默认关闭，如果需要使用，必须在Nginx程序配置时添加 –with-http_gunzip_module指令。gunzip指令该指令用于开启或关闭该模块的功能，语法如下：1gunzip_static on | off启用该功能后，如果客户端浏览器不支持Gzip数据处理时，Nginx只是在将数据返回给浏览器前进行了解压处理。当Nginx和后端服务器交互的数据或者本身存储的数据还是使用了Gzip压缩的。这样做是可以保证浏览器解析数据不出现问题，同时减少了和后端服务器之间的数据传输量，降低了本地的存储空间和缓存的使用率。其余指令和ngx_http_gzip_module模块类似。配置实例使用hexo生成的静态页面为例子，配置Nginx如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748worker_processes 1;error_log logs/error.log;events &#123; worker_connections 1024; use epoll;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_min_length 1024; gzip_buffers 4 16k; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; gzip_disable "MSIE [1-6]\."; server &#123; listen 80; server_name localhost; charset utf-8; location /index &#123; alias /home/mrbird/mrbirdcc; index index.html; &#125; &#125; server &#123; listen 8082; server_name 192.168.112.130; charset utf-8; gzip off; # 关闭Gzip压缩 location /index &#123; alias /home/mrbird/mrbirdcc; index index.html; &#125; &#125;&#125;启动Nginx，访问开启了Gzip压缩的location：http://localhost/index/，显示如下：可见开启Gzip压缩后，文件大小变小了，并且响应头部包含Content-Encoding: gzip。访问未开启Gzip压缩的location：http://192.168.112.130:8082/index/，显示如下：]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx的基本配置]]></title>
    <url>%2FNginx%20basic%20config.html</url>
    <content type="text"><![CDATA[Nginx配置文件主要分成四部分：main（全局设置）、http（HTTP的通用设置）、server（虚拟主机设置）、location（匹配URL路径）。还有一些其他的配置段，如event，upstream等。一个完整的Nginx配置如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374user www www; ## Default: nobodyworker_processes 5; ## Default: 1error_log logs/error.log;pid logs/nginx.pid;worker_rlimit_nofile 8192;events &#123; worker_connections 4096; ## Default: 1024 multi_accept on; use epoll;&#125;http &#123; include conf/mime.types; include /etc/nginx/proxy.conf; include /etc/nginx/fastcgi.conf; index index.html index.htm index.php; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] $status ' '"$request" $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log logs/access.log main; sendfile on; tcp_nopush on; server_names_hash_bucket_size 128; # this seems to be required for some vhosts server &#123; # php/fastcgi listen 80; server_name domain1.com www.domain1.com; access_log logs/domain1.access.log main; root html; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:1025; &#125; &#125; server &#123; # simple reverse-proxy listen 80; server_name domain2.com www.domain2.com; access_log logs/domain2.access.log main; # serve static files location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/big.server.com/htdocs; expires 30d; &#125; # pass requests for dynamic content to rails/turbogears/zope, et al location / &#123; proxy_pass http://127.0.0.1:8080; &#125; &#125; upstream big_server_com &#123; server 127.0.0.3:8000 weight=5; server 127.0.0.3:8001 weight=5; server 192.168.0.1:8000; server 192.168.0.1:8001; &#125; server &#123; # simple load balancing listen 80; server_name big.server.com; access_log logs/big.server.access.log main; location / &#123; proxy_pass http://big_server_com; &#125; &#125;&#125;Nginx基础配置指令user用于指定运行Nginx的用户和组：1user user [group]只有被设置的用户或者用户组成员才有权限启动Nginx服务。如果希望所有用户都可以启动Nginx，则只需将其注释掉或者指定为：1user nobody nobodyworker_processes指定Nginx的工作进程的个数，可以设置为与 CPU 数量相同，基本语法：1worker_processes number|auto设置为auto时，Nginx进程将自动检测。当worker_processes设置为1时：12345# sbin/nginx # ps -ef|grep nginxroot 5882 1326 0 13:07 ? 00:00:00 nginx: master process sbin/nginxnobody 5883 5882 0 13:07 ? 00:00:00 nginx: worker processroot 5885 5430 0 13:07 pts/1 00:00:00 grep --color=auto nginx将worker_processes设置为3时：123456# ps -ef|grep nginxroot 5919 1326 0 13:09 ? 00:00:00 nginx: master process sbin/nginxnobody 5920 5919 0 13:09 ? 00:00:00 nginx: worker processnobody 5921 5919 0 13:09 ? 00:00:00 nginx: worker processnobody 5922 5919 0 13:09 ? 00:00:00 nginx: worker processroot 5924 5430 0 13:09 pts/1 00:00:00 grep --color=auto nginxworker_processes进程数变成了3个。error_log用于配置错误日志的存放路径。http，server和location块也可配置error_log，区别在于级别不一样。基本语法：1error_log files|stderr [ debug | info | notice | warn | error | crit | alert | emerg ]debug级别最高，emerg级别最低。比如设置级别为warn后，warn，error，crit，alert和emerg级别的日志都会被记录。Nginx默认日志存放路径为：logs/error.log。pidpid指令用于指定存放Nginx主进程号存放文件的路径。默认的路径为：123# ./sbin/nginx # cat logs/nginx.pid 101106worker_rlimit_nofile设置毎个进程的最大文件打开数。如果不设的话上限就是系统的ulimit –n的数字（1024）。worker_connections设定一个worker进程的最大连接数。默认为512，按自己系统的硬件配置调整，不能超过worker_rlimit_nofile。includeinclude指令用于引入第三方配置文件，比如常见的MIME类型等。accept_mutex该条指令目的是为了解决“惊群”的问题。“惊群”大致意思是：当某个时刻只有一个网络连接时，多个进程会被同时唤醒，但最终实际上只有一个进程可以获得连接，由于唤醒了别的不必要的进程，造成了性能的浪费。accept_mutex语法如下：1accept_mutex on | off默认为开启（on）状态，只能在events块中进行设置。multi_accept用于设置是否允许worker_process同时接受多个网络连接。语法如下：1multi_accept on | off其默认为关闭（off）状态，也就是说每个worker_process一次只能接收一个新到达的网络连接。该指令只能在events模块中设置。useuse指令用于选择事件的驱动模型。语法如下：1use methodNginx提供了多种事件驱动模型来处理网络消息，method可选的内容有：select，poll，kqueue，epoll，rtsig，/dev/poll和eventport。该指令只能在events模块中设置。worker_connentions用于设置每个worker_process最大的连接数。语法如下：1worker_process number该指令只能在events模块中设置。指定MIME在配置文件中，可以看到如下两条配置：12include conf/mime.types;default_type application/octet-stream;include指令引入了mime.types文件，其中mime.types内容如下：123456789101112131415161718192021222324252627282930types &#123; text/html html htm shtml; text/css css; text/xml xml; image/gif gif; image/jpeg jpeg jpg; application/javascript js; application/atom+xml atom; application/rss+xml rss; text/mathml mml; text/plain txt; text/vnd.sun.j2me.app-descriptor jad; text/vnd.wap.wml wml; text/x-component htc; ... video/3gpp 3gpp 3gp; video/mp2t ts; video/mp4 mp4; video/mpeg mpeg mpg; video/quicktime mov; video/webm webm; video/x-flv flv; video/x-m4v m4v; video/x-mng mng; video/x-ms-asf asx asf; video/x-ms-wmv wmv; video/x-msvideo avi;&#125;default_type application/octet-stream指定了默认类型为二进制流。如果不指定的话，默认值为text/plain。该指令可以在http，server或location模块中设置。自定义服务日志error_log用于记录Nginx运行时的常规日志，而access_log（服务日志）是指Nginx服务器在响应各种前端请求的日志。包含两个指令：access_log和log_format。access_log的语法如下：1access_log ptah[format[buffer=size]]path用于指定该日志的存放路径，format为可选项，代指自定义服务日志的格式字符串。size为可选项，用于配置临时存放日志的内存缓存区大小。log_format的语法如下：1log_format name string ...name用于为该格式定义一个变量名，供access_log指令使用。string为格式字符串，比如：$remote_addr - $remote_user [$time_local] $status其中$remote_addr等为Nginx预设的一些变量，常用的变量有：参数说明示例$remote_addr客户端地址211.28.65.253$remote_user客户端用户名称–$time_local访问时间和时区18/Jul/2012:17:00:01 +0800$request请求的URI和HTTP协议“GET /article-10000.html HTTP/1.1”$http_host请求地址，即浏览器中你输入的地址（IP或域名）www.it300.com192.168.100.100$statusHTTP请求状态200$upstream_statusupstream状态200$body_bytes_sent发送给客户端文件内容大小1547$http_refererurl跳转来源https://www.baidu.com/$http_user_agent用户终端浏览器等信息“Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;$ssl_protocolSSL协议版本TLSv1$ssl_cipher交换数据中的算法RC4-SHA$upstream_addr后台upstream的地址，即真正提供服务的主机地址10.10.10.100:80$request_time整个请求的总时间0.205$upstream_response_time请求过程中，upstream响应时间0.002该指令只能在http模块中设置。sendfile &amp; sendfile_max_chunksendfile用于开启或关闭使用sendfile()传输文件。语法如下：1sendfile on | off可以在http，server或location中进行配置。sendfile_max_chunk用于设置Nginx进程中的每个worker_process每次调用sendfile()传输的数据量的最大值。默认值为0，表示没有限制。比如：1sendfile_max_chunk 128k该指令可以在http，server或location块中配置。keepalive_timeout用于设置Nginx服务器与用户建立会话连接保持的时间，语法如下：1keepalive_timeout timeout[header_timeout]timeout用于设置服务器端保持连接的时间；header_timeout为可选项，用于配置应答报文头部的Keep-Alive域的值。该指令可以在http，server和location块中配置。keepalive_requests用于限制用户通过某一连接向服务器发送请求的次数，语法如下：1keepalive_requests number默认值为100，可以在http，server和location块中配置。listen该指令用于配置监听。配置方法主要有三种：1、配置监听的IP地址：1listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl]2、配置监听端口1listen port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ipv6only=on|off] [ssl]3、配置UNIX Domain Socket1listen unix:path [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl]address，IP地址，如果是IPv6的地址，需使用[]，比如[fe80 ::1]。port，端口号。path，socket文件路径，如/var/run/nginx.sock等。default_server，标识符，表示设置为默认主机。rcvbuf=size，设置监听socket接收缓存区大小。sndbuf=size，设置监听socket发送缓存区大小。deferred，标识符，将accept()设置为Deferred模式。accept_filter=filter，设置监听端口对请求的过滤 ，被过滤的内容不能被接收和处理。ssl，标识符，设置会话连接使用SSL模式进行。一些例子：1234listen *:80 | *:8080; #监听所有80端口和8080端口listen 192.168.1.10:8080; #监听具体IP和具体端口上的连接listen 8000; #监听所有IP地址的8000端口，等同于 listen *:8000listen 192.168.1.10 default_server; #设置192.168.1.10的连接请求默认由此虚拟主机处理server_nameNginx配置文件中的每个server块对于一个虚拟主机配置，server_name用于指定虚拟主机的名称，用户可通过这个名称来向此虚拟主机发送请求。server_name的配置分为名称和IP两种方式。基于名称的虚拟主机配置基于名称的虚拟主机配置时，server_name的语法如下：1server_name name ...name可以有一个或多个名称并列，用空格隔开。每个名称对应一个域名，由两段或者三段组成，之间由.隔开。比如：1server_name www.mrbird.cc mrbird.cc;1、在name中可以使用通配符*，通配符可用在三段式域名的头或尾，或两段式域名的尾部，比如：1server_name *.mrbird.cc mrbird.*;2、在name中还可以使用正则表达式。使用~作为正则表达式开始的标记，比如：1server_name ~^www\d+\.mrbird\.cc$;此时比如通过www1.mrbird.cc可以访问Nginx服务，而www.mrbird.cc不可以。name中的正则表达式支持字符串捕获功能，字符串捕获通过( )来拾取后面不紧跟其他的正则表达式的字符。一个正则表达式中可以存在多个不嵌套的小括号，这些内容会从左到右依次存放在变量$1、$2、$3……中。下文使用时就可直接使用这些变量，作用域为当前的server块。比如有如下的server_name配置：1server_name ~^www\.(.+)\.cc$;当通过www.mrbird.cc访问Nginx服务器时，将会被上面的正则表达式匹配成功，mrbird将会被捕获，并且赋值给$1。由于有两种匹配的方式，所以有可能出现两种情况都匹配的时候，这时候Nginx按照以下的优先级进行选择：准确匹配server_name。通配符在开始时匹配server_name成功。通配符在结束时匹配server_name成功。正则表达式匹配server_name成功。此外，如果server_name被处于同一优先级的匹配方式多次匹配成功，则以首先匹配成功的为主。基于IP的虚拟主机配置Linux操作系统支持IP别名的添加，配置基于IP的虚拟主机，即为Nginx服务器提供的每台虚拟主机配置一个不同的IP。查看当前网络配置：123456789101112131415161718# ifconfigens33 Link encap:Ethernet HWaddr 00:0c:29:25:f3:bb inet addr:192.168.112.128 Bcast:192.168.112.255 Mask:255.255.255.0 inet6 addr: fe80::4fe4:f0e0:9e9b:7ec/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:360100 errors:0 dropped:0 overruns:0 frame:0 TX packets:89081 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:504446360 (504.4 MB) TX bytes:7347923 (7.3 MB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:35127 errors:0 dropped:0 overruns:0 frame:0 TX packets:35127 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:2931450 (2.9 MB) TX byens33为正在使用的网卡，IP为192.168.112.128，给其添加两个IP别名192.168.112.130和192.168.112.131：12345678910111213141516171819202122232425262728# ifconfig ens33:0 192.168.112.130 Mask 255.255.255.0 up # ifconfig ens33:1 192.168.112.131 Mask 255.255.255.0 up # ifconfigens33 Link encap:Ethernet HWaddr 00:0c:29:25:f3:bb inet addr:192.168.112.128 Bcast:192.168.112.255 Mask:255.255.255.0 inet6 addr: fe80::4fe4:f0e0:9e9b:7ec/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:360100 errors:0 dropped:0 overruns:0 frame:0 TX packets:89081 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:504446360 (504.4 MB) TX bytes:7347923 (7.3 MB)ens33:0 Link encap:Ethernet HWaddr 00:0c:29:25:f3:bb inet addr:192.168.112.130 Bcast:192.168.112.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1ens33:1 Link encap:Ethernet HWaddr 00:0c:29:25:f3:bb inet addr:192.168.112.131 Bcast:192.168.112.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:221 errors:0 dropped:0 overruns:0 frame:0 TX packets:221 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:16787 (16.7 KB) TX bytes:16787 (16.7 KB)关于给网卡添加多个IP别名可以参考http://www.cnblogs.com/biaopei/p/7730517.html这时候就可以在Nginx配置文件中配置两台基于IP配置的虚拟主机了：12345678910111213... http &#123; ... server &#123; listen: 80; server_name: 192.168.112.130; ... &#125; server &#123; listen: 80; server_name: 192.168.112.131; &#125; &#125;location块location语法如下：1location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;uri是待匹配的请求字符串，可以是标准uri（不含正则表达式）和正则uri。=用于标准uri前，要求请求字符串与uri严格匹配，如果成功，则停止搜索并立即处理此请求。~用于表示uri含正则表达式，区分大小写。~*用于表示uri包含正则表达式，不区分大小写。^~用于标准uri前，要求Nginx服务器找到和请求字符串匹配度最高的标准uri对应的location后，立即用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。一个示例：1234567891011121314151617181920212223242526272829303132333435363738394041location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ]&#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ]&#125;location ~ /documents/Abc &#123; # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ]&#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F与G的放置顺序是没有关系的 [ configuration G ]&#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ]&#125;匹配的优先级：(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)按照上面的location写法，以下的匹配示例成立：/ -&gt; config A 精确完全匹配，即使/index.html也匹配不了。/downloads/download.html -&gt; config B 匹配B以后，往下没有任何匹配，采用B。/images/1.gif -&gt; configuration D 匹配到F，往下匹配到D，停止往下。/images/abc/def -&gt; config D 最长匹配到G，往下匹配D，停止往下。 你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序/documents/document.html -&gt; config C 匹配到C，往下没有任何匹配，采用C。/documents/1.jpg -&gt; configuration E 匹配到C，往下正则匹配到E。/documents/Abc.jpg -&gt; config CC 最长匹配到C，往下正则顺序匹配到CC，不会往下到E。参考自： seanlook’s blogrootroot用于配置根目录，比如有如下location配置：123location /data/ &#123; root /locationtest1;&#125;当location块接收到/data/index.html的请求后，将在/locationtest1/data/目录下找到index.html。该指令可在http，server或location块中配置。aliasalias用于改变location接收到的URI请求路径。比如：123location ~ ^/data/(.+\.html)$ &#123; alias /locationtest1/other/$1;&#125;当location块接收到/data/index.html的请求后，通过alias，Nginx到/locationtest1/other/目录下搜寻index.html。相当于请求从/data/index.html更改为了/locationtest1/other/index.html。indexindex用于设置网站的默认首页。比如：123location ~ ^/data/(.+)/web/ $ &#123; index index.$1.html index.html myindex.html&#125;当请求为/data/locationtest1/web/时，Nginx依次搜寻index.locationtest1.html、index.html和myindex.html页面，先找到哪个就用哪个。error_page该指令用于设置网站的错误页面。语法如下：1error_page code ... [=[response]] uricode，要处理的HTTP错误码。response，可选项，将code指定的错误码转化为新的错误代码response。uri，错误页面的路径或者网站地址。比如：1error_page 404 /404.html;Nginx使用Nginx安装目录/html/404.html页面响应404错误。1error_page 403 http://somewebsite.com/forbidden.html;Nginx使用http://somewebsite.com/forbidden.html页面响应403错误。1error_page 410 =301 /empty.gif;Nginx服务器产生410的HTTP消息时，使用Nginx安装目录/html/empty.gif返回给用户，HTTP的状态码为301。加入想要改变Nginx安装目录/html/这个默认的路径，可以添加一个locaiton块：123location /404.html &#123; root /myserver/errorpages/;&#125;该指令可在http，server和location块中配置。基于IP配置Nginx访问权限allow指令用于配置允许访问Nginx的客户端IP，语法如下：1allow address | CIDR | alladdress，指定允许访问的IP，不支持多个值，如需要有多个IP设置，需要重复使用allow命令。CIDR，允许访问的客户端的CIDR地址。all，代表允许所有的客户端访问。deny指令用于配置禁止访问Nginx的客户端IP，语法如下：1deny address | CIDR | all这两个指令可在http，server和location块中配置。配置Nginx密码auth_basic指令用于开启或者关闭认证功能，语法如下：1auth_basic string | offstirng，开启认证功能，并配置了验证时的信息。off，关闭认证。auth_basic_user_file指令指定了包含用户名和密码的信息文件路径，语法结构为：1auth_basic_user_file file如，在nignx.conf里配置如下：生产htpasswd文件：123# printf "mrbird:$(openssl passwd -crypt 123456)\n" &gt;&gt;conf/htpasswd# cat conf/htpasswdmrbird:vdV.OwMSzfJrQ重启Nginx后，访问http://localhost/index.html，页面显示如下：配置实例将conf/nginx.conf配置成如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566worker_processes 1;error_log logs/error.log;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; sendfile on; keepalive_timeout 65; # 配置server1 server &#123; listen 8081; server_name localhost; charset utf-8; access_log /myweb/server1/log/access.log main; error_page 404 /myweb/error/404.html; # 配置/server1/location1/请求的location location /server1/location1 &#123; root /myweb; index index.html; &#125; # 配置/server1/location2请求的location location /server1/location2 &#123; root /myweb; index index.html; &#125; &#125; # 配置server2 server &#123; listen 8082; server_name 192.168.112.130; charset utf-8; access_log /myweb/server2/log/access.log main; error_page 404 /404.html; # 配置/server2/location1/请求的locaiton location /server2/location1 &#123; root /myweb; index index.html; &#125; # 配置/server2/location2/请求的location location /svr2/loc2 &#123; alias /myweb/server2/location2; # 对location的uri进行更改 index index.html; &#125; # 重定向404页面地址 location = /404.html &#123; root /myweb/error; index 404.html; &#125; &#125;&#125;构建一个静态网站，目录结构如下：1234567891011121314151617/myweb/├── error│ └── 404.html├── server1│ ├── location1│ │ └── index.html│ ├── location2│ │ └── index.html│ └── log│ └── access.log└── server2 ├── location1 │ └── index.html ├── location2 │ └── index.html └── log └── access.log启动Nginx服务：1234# /nginx/sbin/nginx -tnginx: the configuration file /nginx/conf/nginx.conf syntax is oknginx: configuration file /nginx/conf/nginx.conf test is successful# /nginx/sbin/nginx访问http://localhost:8081/server1/location1/：访问http://localhost:8081/server1/location2/：访问http://192.168.112.130:8082/server2/location1/：访问http://192.168.112.130:8082/svr2/loc2/：访问http://192.168.112.130:8082/svr2/loc3/：结果证明，上述配置正确。]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装与部署]]></title>
    <url>%2FNginx%20install%20deploy.html</url>
    <content type="text"><![CDATA[下载NginxNginx官网：http://nginx.org/en/download.html。网页提供了Nginx三种版本下载：开发版（Mainline Version）、稳定版（Stable Version）和过期版（Legacy Version）。Nignx提供Linux和Windows版本，这里使用的是Linux版本。此外，http://nginx.org/download/提供了所有版本的Nginx下载。Nginx源码的编译需要GCC编译器：12345# gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.截止2017年10月15日，Nginx最新稳定版为1.12.2，下载并解压：1234567891011121314151617181920# mkdir nginx-download# cd nginx-download/# wget http://nginx.org/download/nginx-1.12.2.tar.gz# tar -zxvf nginx-1.12.2.tar.gz # cd nginx-1.12.2# lltotal 732drwxr-xr-x 8 1001 1001 4096 Oct 17 21:16 ./drwxr-xr-x 3 root root 4096 Oct 26 14:05 ../-rw-r--r-- 1 1001 1001 278202 Oct 17 21:16 CHANGES-rw-r--r-- 1 1001 1001 423948 Oct 17 21:16 CHANGES.ru-rw-r--r-- 1 1001 1001 1397 Oct 17 21:16 LICENSE-rw-r--r-- 1 1001 1001 49 Oct 17 21:16 READMEdrwxr-xr-x 6 1001 1001 4096 Oct 26 14:05 auto/drwxr-xr-x 2 1001 1001 4096 Oct 26 14:05 conf/-rwxr-xr-x 1 1001 1001 2481 Oct 17 21:16 configure*drwxr-xr-x 4 1001 1001 4096 Oct 26 14:05 contrib/drwxr-xr-x 2 1001 1001 4096 Oct 26 14:05 html/drwxr-xr-x 2 1001 1001 4096 Oct 26 14:05 man/drwxr-xr-x 9 1001 1001 4096 Oct 26 14:05 src/src目录下存放了Nginx的源代码；man目录下存放了Nginx的帮助文档；html目录存放了两个HTML文件，分别为Nginx欢迎页和异常页面；logs目录用于存放Nginx运行日志；auto目录存放了大量的脚本文件，和configure脚本有关；configure文件为Nginx的自动脚本程序。Nginx编译与安装在解压路径下，运行命令./configure --prefix=/nginx（configure脚本支持的选项可参考附录）配置Nginx的安装目录并生成Makefile文件：1234567891011121314151617181920# ./configure --prefix=/nginx...Configuration summary + using system PCRE library + OpenSSL library is not used + using system zlib library nginx path prefix: "/nginx" nginx binary file: "/nginx/sbin/nginx" nginx modules path: "/nginx/modules" nginx configuration prefix: "/nginx/conf" nginx configuration file: "/nginx/conf/nginx.conf" nginx pid file: "/nginx/logs/nginx.pid" nginx error log file: "/nginx/logs/error.log" nginx http access log file: "/nginx/logs/access.log" nginx http client request body temporary files: "client_body_temp" nginx http proxy temporary files: "proxy_temp" nginx http fastcgi temporary files: "fastcgi_temp" nginx http uwsgi temporary files: "uwsgi_temp" nginx http scgi temporary files: "scgi_temp"过程中可能出现一些依赖库缺失问题，可参考下面的常见问题。生成了Makefile文件后，使用make命令进行编译：12345678910111213141516171819# makemake -f objs/Makefilemake[1]: Entering directory '/temp/nginx-download/nginx-1.12.2'cc -c -pipe -O -W -Wall -Wpointer-arith -Wno-unused-parameter -Werror -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs \ -o objs/src/core/nginx.o \ src/core/nginx.ccc -c -pipe -O -W -Wall -Wpointer-arith -Wno-unused-parameter -Werror -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs \...objs/src/http/modules/ngx_http_upstream_keepalive_module.o \objs/src/http/modules/ngx_http_upstream_zone_module.o \objs/ngx_modules.o \-ldl -lpthread -lcrypt -lpcre -lz \-Wl,-Esed -e "s|%%PREFIX%%|/nginx|" \ -e "s|%%PID_PATH%%|/nginx/logs/nginx.pid|" \ -e "s|%%CONF_PATH%%|/nginx/conf/nginx.conf|" \ -e "s|%%ERROR_LOG_PATH%%|/nginx/logs/error.log|" \ &lt; man/nginx.8 &gt; objs/nginx.8make[1]: Leaving directory '/temp/nginx-download/nginx-1.12.2'编译顺利完成后，接着使用make install命令进行安装：12345678910# make installmake -f objs/Makefile installmake[1]: Entering directory '/temp/nginx-download/nginx-1.12.2'test -d '/nginx' || mkdir -p '/nginx'test -d '/nginx/sbin' \ || mkdir -p '/nginx/sbin'...test -d '/nginx/logs' \ || mkdir -p '/nginx/logs'make[1]: Leaving directory '/temp/nginx-download/nginx-1.12.2'将目录切换到/nginx下，并查看：123456789101112131415161718192021222324# cd /nginx/# lltotal 24drwxr-xr-x 6 root root 4096 Oct 26 14:30 ./drwxr-xr-x 26 root root 4096 Oct 26 14:30 ../drwxr-xr-x 2 root root 4096 Oct 26 14:30 conf/drwxr-xr-x 2 root root 4096 Oct 26 14:30 html/drwxr-xr-x 2 root root 4096 Oct 26 14:30 logs/drwxr-xr-x 2 root root 4096 Oct 26 14:30 sbin/# ls *conf:fastcgi.conf koi-win scgi_paramsfastcgi.conf.default mime.types scgi_params.defaultfastcgi_params mime.types.default uwsgi_paramsfastcgi_params.default nginx.conf uwsgi_params.defaultkoi-utf nginx.conf.default win-utfhtml:50x.html index.htmllogs:sbin:nginxNginx的启停Nginx常用命令nginx命令所支持的选项有：123456789101112131415# ./sbin/nginx -hnginx version: nginx/1.12.2Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /nginx/) -c filename : set configuration file (default: conf/nginx.conf) -g directives : set global directives out of configuration file-v选项用来显示Nginx服务器的版本号，-V选项除了显示版本号，还显示其编译情况：123456# ./sbin/nginx -vnginx version: nginx/1.12.2# ./sbin/nginx -Vnginx version: nginx/1.12.2built by gcc 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) configure arguments: --prefix=/nginx-t选项用于检查Nginx服务器配置文件是否有语法错误：123# ./sbin/nginx -tnginx: the configuration file /nginx/conf/nginx.conf syntax is oknginx: configuration file /nginx/conf/nginx.conf test is successful等。Nginx启动启动Nginx服务器很简单，只需要运行sbin下的nginx脚本就行了：12345# ./sbin/nginx # ps -ef|grep nginxroot 74808 1308 0 14:47 ? 00:00:00 nginx: master process ./sbin/nginxnobody 74809 74808 0 14:47 ? 00:00:00 nginx: worker processroot 74811 71675 0 14:47 pts/4 00:00:00 grep --color=auto nginx可看到Nginx已经启动，包含了一个主进程（master process）和一个工作进程（worker process），主进程号为74808。启动Nginx服务后，也可以通过查看logs目录下的nginx.pid来查看主进程号：12# cat logs/nginx.pid 74808Nginx的默认端口号为80，在浏览器中输入localhost/index.html查看是否启动成功：Nginx停止停止Nginx服务可分为两种类型：1.快速停止：立即停止当前Nginx服务正在处理的所有网络请求，马上丢弃连接，停止工作。相关命令为：kill -TERM 进程号或者kill -INT 进程号；2.平缓停止：允许Nginx服务将当前的网络请求处理完毕，但不再接受新请求，之后关闭连接，停止工作。相关的命令为：kill -QUIT 进程号；停止Nginx服务，采用快速停止方式：123# kill -TERM 74808# ps -ef|grep nginxroot 74998 71675 0 15:03 pts/4 00:00:00 grep --color=auto nginxNginx重启Nginx重启采用平滑重启的方式。Nginx服务进程号接收到重启信号后，先读取新的Nginx配置文件，如果配置语法正确，则启动新的Nginx服务，然后平缓的关闭旧的服务。如果配置语法错误，则继续采用旧的Nginx进程提供服务。有两种方式进行平滑重启：1.检查配置文件是否正确，如果正确进行重启：1234# ./sbin/nginx -tnginx: the configuration file /nginx/conf/nginx.conf syntax is oknginx: configuration file /nginx/conf/nginx.conf test is successful# ./sbin/nginx -s reload2.kill -HUP 主进程号:123# cat logs/nginx.pid 75011# kill -HUP 75011常见问题缺少依赖库缺少PCRE依赖库./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using –without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using –with-pcre=option.解决办法：1sudo apt-get install libpcre3 libpcre3-dev缺少zlib依赖库./configure: error: the HTTP gzip module requires the zlib library. You can either disable the module by using –without-http_gzip_module option, or install the zlib library into the system, or build the zlib library statically from the source with nginx by using –with-zlib=option.解决办法：1sudo apt-get install zlib1g-dev其他问题apt-get命令被占用E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?解决办法：找到占用进程，然后kill：123ps -A|grep apt 61213 ? 00:00:02 aptdkill -9 61213附录注：由于渲染原因–实际为 --，如–prefix=…实际为 --prefix=...configure开关选项选项&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值–prefix=…指定安装Nginx的基础目录/usr/local/nginx, 注意：如果你在配置时使用了相对路径，则连接到基础目录。示例：指定–conf-path=conf/nginx.conf 则配置文件会在目录：/usr/local/nginx/conf/nginx.conf–sbin-path=…Nginx二进制文件安装的路径&lt;prefix&gt;/sbin/nginx–conf-path=…主要配置文件放置目录&lt;prefix&gt;/conf/nginx.conf–error-log-path=…错误日志存放的路径。错误日志在配置文件中须配置得非常正确，该路径只应用于你在配置文件中没有指定任何错误的日志指令时&lt;prefix&gt;/logs/error.log–pid-path=…指定Nginx的pid文件的路径。可以在配置文件中指定pid文件的路径，如果没有具体的指定，则使用在这里对该选项指定的该路径&lt;prefix&gt;/logs/nginx.pid注意：该pid文件是一个简单的文件文件，它包含进程的标识符。该文件应该放置在一个清晰可见的位置，以便其他应用程序能够很容易找到运行该程序的pid–lock-path=…锁文件（lock file）的存放路径。同样，该文件也可以在配置文件中指定，但是，如果在配置文件中没有指定，则使用该值&lt;prefix&gt;/logs/nginx.lock注意：锁文件允许其他应用程序确定是否一个程序在运行，就Nginx来说，它用于确定该进程没有被启动两次–with-perl_modules_path=…定义Perl模块的路径。如果需要包含另外的Perl模块，必须定义该参数–with-perl=…Perl二进制文件的路径。用于执行Perl脚本。如果想执行一个Perl脚本，必须设置该路径–http-log-path=…定义被访问文件的日志文件存放路径。该路径只用于在配置文件中没有定义访问日志的情况&lt;prefix&gt;/logs/access.log–http-client-body-temp-path=…该目录用于存储客户端请求产生的临时文件&lt;prefix&gt;/client_body_temp–http-proxy-temp-path=…该目录用于代理存储临时文件&lt;prefix&gt;/proxy_temp–http-fastcgi-temp-path=…指定用于HTTP FastCGI模块使用的临时文件的存放路径&lt;prefix&gt;/fastcgi_temp–builddir=…指定创建应用程序的位置configure先決条件选项编译选项–with-cc=…&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定一个备用的C编译器的位置–with-cpp=…指定一个备用的C预处理器的位置–with-cc-opt=…定义额外的选项，然后在命令行传递给C编译器–with-ld-opt=…定义额外的选项，然后在命令行传递给C连接器–with-cpu-opt=…指定不同的目标处理器结构，可以是下列值：pentium，pentiumpro，pentium3，pentium4，athlon，opteron，sparc32，sparc64和ppc64PCRE选项–without-pcre不使用PCRE库。这个设置不推荐使用，因为它会移除对正则表达式的支持，从而使Rewrite模块失去作用。–with-pcre强制作用PCRE库–with-pcre=…允许指定PCRE库的源代码–with-pcre-opt=…用于建立PCRE库的另外的选项MD5选项–with-md5=…指定MD5库源代码的路径–with-md5-opt=…用于建立MD5库的另外选项–with-md5-asm为建MD5库使用汇编语言源代码SHA1选项–with-sha1=…指定SHA1库的源代码–with-sha1-opt=…用于建立SHA1库的另外选项–with-sha1-asm为建立SHA1库使用汇编语言源代码zlib选项–with-zlib=…指定zlib库的源代码–with-zlib-opt=…用于建立zlib库的另外的选项–with-zlib-asm=…使用汇编语言最大限度地优化下列目标结构：Pentium, pentiumproOpenSSL选项–with-openssl=…指定OpenSSL库的源代码路径–with-openssl-opt=…为建立OpenSSL库的另外的选项configure模块选项以下是Nginx默认开启的模块，可以使用表格中的命令来关闭相应模块：默认开启的模块&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;描述–without-http-charset_module禁用Charset模块，该模块用于对网页重新编码–without-http-gzip_module禁用Gzip压缩模块–without-http_ssi_module禁用服务器端包含模块–without-http_access_module禁用访问模块，对于指定的IP段，允许访问配置–without-http_userid_module禁用用户ID模块。该模块为用户通过cookie验证身份–without-http_auth_basic_module禁用基本的认证模块–without-http_autoindex_module禁用自动索引模块–without-http_geo_module禁用Geo模块，该模块允许你定义依赖于IP地址段的变量–without-http_map_module禁用Map模块，该模块允许你声明map区段–without-http_referer_module禁用Referer控制模块–without-http_rewrite_module禁用Rewrite模块–without-http_proxy_module禁用代理模块。该模块用于向其他服务器传输请求–without-http_fastcgi_module禁用FastCGI模块。该模块是用于与FastCGI进程配合工作–without-http_memcached_module&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;禁用Memcached模块。该模块是用于与memcached守护进程配合工作–without-http_limit_zone_module禁用Limit Zone模块。该模块是用于根据定义的zone来限制约束对资源的使用。–without-http_limit_req_module禁用Limit Requests模块。该模块允许你限制每个用户请求的总数–without-http_empty_gif_module禁用Empty Gif模块。该模块用于在内存中提供一个空白的GIF图像–without-http_browser_module禁用Browser模块。该模块用于解释用户代理字符串–without-http_upstream_ip_hash_module禁用Upstream模块。该模块用于配置负载均衡结构以下是Nginx默认关闭的模块，可以使用表格中的命令来开启相应模块：默认禁用的模块&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;描述–with-http_ssl_module开启SSL模块，支持使用HTTPS协议的网页–with-http_realip_module开启Real IP的支持，该模块用于从客户请求的头数据中读取real IP地址–with-http_addition_module开启Addition模块，该模块允许你追加或前置数据（prepend data）到响应的主体部分–with-http_xslt_module开启XSLT模块的支持，该模块实现XSLT转化为XML文档–with-http_image_filter_module开启Image Filter模块，该模块是让你修改图像。注意：如果想编译该模块，需要在系统中安装libgd库–with-http_geoip_module开启GeoIP模块，该模块通过使用MaxMind’s GeoI 二进制数据库来获取客户端在地理上的分布。注意：如果希望编译该模块，需要在系统中安装libgeoip库。–with-http_sub_module开启Substitution模块，该模块用于在网页中替换文本–with-http_dav_module开启WebDAV模块–with-http_flv_module开启FLV模块，该模块用于专门处理.flv(flash视频)文件–with-http_gzip_static_module开启Gzip静态模块，该模块用于发送预压缩的文件–with-http_random_index_module开启Random Index模块。该模块用于挑选一个随机的文件作为该目录的index–with-http_secure_link_module开启Secure Link模块，该模块用于在URL中检测关键字的存在–with-http_stub_status_module开启Stub Status模块，该模块会产生一个服务器状态和信息页–with-google_perftools_module&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;开启google性能工具模块其它configure选项邮件服务代理–with-mail开启邮件服务代理（mail server proxy）模块，支持POP3，IMAP4和SMTP。该功能默认禁用–with-mail_ssl_module开启邮件代理服务对SSL的支持。该功能默认禁用–without-mail_pop3_module在邮件代理下禁用POP3功能。在开启邮件代理模块后该功能默认启用–without-mail_imap_module对邮件代理服务器禁用IMAP4模块，在开启邮件代理模块后该功能默认启用–without-mail_smtp_module对于邮件代理服务器禁用SMTP模块，在开启邮件代理模块后该功能默认启用事件管理–with-rtsig_module开启rtsig模块，使用rtsig作为事件通知机制–with-select_module开启select模块，使用select作为事件通知机制。默认情况下，该模块是开启的，除非系统有一种更好的方式发现——kqueue, epoll, rtsig 或 poll–without-select_module禁用select模块–with-poll_module开启poll模块，该模块使用poll作为事件通知机制。默认情况下，如果有效，该模块是开启的，除非系统上有一种更好的方式发现——kqueue, epoll或rtsig–without-poll_module禁用poll模块用户和组选项–user=…指定启动Nginx进程的默认用户。这个设置仅用于在配置文件中省略user指令来指定用户的情况–group=…指定启动Nginx进程默认的用户组。这个设置仅用于在配置文件中省略使用group指令来指定用户的情况其它选项–with-ipv6开启对IPv6的支持–without-http禁用HTTP服务–without-http-cache禁用HTTP缓冲功能–add-module=PATH通过指定的路径编译添加第三方模块。如果希望编译多个模块，那么该选项可以无限次使用–with-debug开启记录额外的调试信息]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用thymeleaf]]></title>
    <url>%2FSpring-Boot%E4%BD%BF%E7%94%A8thymeleaf.html</url>
    <content type="text"><![CDATA[Spring Boot支持FreeMarker、Groovy、Thymeleaf和Mustache四种模板解析引擎，官方推荐使用Thymeleaf。spring-boot-starter-thymeleaf在Spring Boot中使用Thymeleaf只需在pom中加入Thymeleaf的starter即可：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;在Spring Boot 1.5.9.RELEASE版本中，默认的Thymeleaf版本为2.1.6.RELEASE版本，这里推荐使用3.0以上版本。在pom中将Thymeleaf的版本修改为3.0.2.RELEASE：1234&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.0.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;在Spring Boot中，默认的html页面地址为src/main/resources/templates，默认的静态资源地址为src/main/resources/static。Thymeleaf默认配置在Spring Boot配置文件中可对Thymeleaf的默认配置进行修改：123456789101112131415161718192021222324#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #Check that the template exists before rendering it.spring.thymeleaf.check-template=true #检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true#模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names=一般开发中将spring.thymeleaf.cache设置为false，其他保持默认值即可。简单示例编写一个简单的Controller：1234567891011121314@Controllerpublic class IndexController &#123; @RequestMapping("/account") public String index(Model m) &#123; List&lt;Account&gt; list = new ArrayList&lt;Account&gt;(); list.add(new Account("KangKang", "康康", "e10adc3949ba59abbe56e", "超级管理员", "17777777777")); list.add(new Account("Mike", "麦克", "e10adc3949ba59abbe56e", "管理员", "13444444444")); list.add(new Account("Jane","简","e10adc3949ba59abbe56e","运维人员","18666666666")); list.add(new Account("Maria", "玛利亚", "e10adc3949ba59abbe56e", "清算人员", "19999999999")); m.addAttribute("accountList",list); return "account"; &#125;&#125;编写account.html页面：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;account&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;link rel="stylesheet" th:href="@&#123;/css/style.css&#125;" type="text/css"&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;no&lt;/th&gt; &lt;th&gt;account&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;accountType&lt;/th&gt; &lt;th&gt;tel&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="list,stat : $&#123;accountList&#125;"&gt; &lt;td th:text="$&#123;stat.count&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.account&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.password&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.accountType&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;list.tel&#125;"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;最终项目目录如下所示：启动项目，访问http://localhost:8080/web/account：source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 局部变量]]></title>
    <url>%2FThymeleaf-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html</url>
    <content type="text"><![CDATA[在Thymeleaf模板引擎中，使用 th:with属性来声明一个局部变量：123&lt;div th:with="firstPer=$&#123;persons[0]&#125;"&gt; &lt;p&gt;The name of the first person is &lt;span th:text="$&#123;firstPer.name&#125;"&gt;Julius Caesar&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;在上面div中，th:width属性声明了一个名为firstPer的局部变量，内容为${persons[0]}。该局部变量的作用域为整个div内。也可以一次性定义多个变量：123456789&lt;div th:with="firstPer=$&#123;persons[0]&#125;,secondPer=$&#123;persons[1]&#125;"&gt; &lt;p&gt; The name of the first person is &lt;span th:text="$&#123;firstPer.name&#125;"&gt;Julius Caesar&lt;/span&gt;. &lt;/p&gt; &lt;p&gt; But the name of the second person is &lt;span th:text="$&#123;secondPer.name&#125;"&gt;Marcus Antonius&lt;/span&gt;. &lt;/p&gt;&lt;/div&gt;th:with属性允许重用在同一个属性中定义的变量：1&lt;div th:with="company=$&#123;user.company + ' Co.'&#125;,account=$&#123;accounts[company]&#125;"&gt;...&lt;/div&gt;]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 模板布局]]></title>
    <url>%2FThymeleaf-%E6%A8%A1%E6%9D%BF%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[th:include,th:insert和th:replace在模板的编写中，通常希望能够引入别的模板片段，比如通用的头部和页脚。Thymeleaf模板引擎的th:include，th:insert和th:replace属性可以轻松的实现该需求。不过从Thymeleaf 3.0版本后， 不再推荐使用th:include属性。在index.html页面路径下创建一个footer.html：12345678&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt; &lt;body&gt; &lt;footer th:fragment="copy"&gt; &amp;copy; 2016 - 2017 MrBird Powered by Hexo &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt;在footer.html中，使用th:fragment属性定义了&lt;footer&gt;片段，然后在index.html中引用它：123&lt;div th:include="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt; &lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt; &lt;div th:replace="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;其中footer为被引用的模板名称（templatename），copy为th:fragment标记的片段名称（selector），~{...}称为片段表达式，由于其不是一个复杂的片段表达式，所以可以简写为：1&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;页面显示如下：通过观察渲染出的源码可发现th:include，th:insert和th:replace的区别所在：1234567891011&lt;div&gt; &amp;copy; 2016 - 2017 MrBird Powered by Hexo&lt;/div&gt; &lt;div&gt; &lt;footer&gt; &amp;copy; 2016 - 2017 MrBird Powered by Hexo &lt;/footer&gt;&lt;/div&gt; &lt;footer&gt; &amp;copy; 2016 - 2017 MrBird Powered by Hexo&lt;/footer&gt;引用本页面的片段可以略去templatename，或者使用this来代替。引用没有th:fragment的片段如果片段不包含th:fragment属性，我们可以使用CSS选择器来选中该片段，如：123&lt;div id="copy-section"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;引用方式：1&lt;div th:insert="~&#123;footer :: #copy-section&#125;"&gt;&lt;/div&gt;在th:fragment中使用参数使用th:fragment定义的片段可以指定一组参数：123&lt;div th:fragment="frag (onevar,twovar)"&gt; &lt;p th:text="$&#123;onevar&#125; + ' - ' + $&#123;twovar&#125;"&gt;...&lt;/p&gt;&lt;/div&gt;然后在引用的时候给这两个参数赋值，有如下两种方式：12&lt;div th:replace="this :: frag ('value1','value2')"&gt;&lt;/div&gt;&lt;div th:replace="this :: frag (onevar='value_one',twovar='value_two')"&gt;&lt;/div&gt;对于第二种方式，onevar和twovar的顺序不重要，并且使用第二种方式引用片段时，片段可以简写为：123&lt;div th:fragment="frag"&gt; &lt;p th:text="$&#123;onevar&#125; + ' - ' + $&#123;twovar&#125;"&gt;...&lt;/p&gt;&lt;/div&gt;th:removeth:remove用于删除片段，支持的属性值有：all：删除标签及其所有子标签。body：不删除包含的标签，但删除其所有子代。tag：删除包含的标签，但不要删除其子标签。all-but-first：删除除第一个之外的所有包含标签的子标签。none。比如有如下片段：1234567891011121314151617&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;th&gt;COMMENTS&lt;/th&gt; &lt;/tr&gt; &lt;tr th:remove="value"&gt; &lt;td&gt;Mild Cinnamon&lt;/td&gt; &lt;td&gt;1.99&lt;/td&gt; &lt;td&gt;yes&lt;/td&gt; &lt;td&gt; &lt;span&gt;3&lt;/span&gt; comment/s &lt;a href="comments.html"&gt;view&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;当value为all时，页面渲染为：12345678&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;th&gt;COMMENTS&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;当value为body时，页面渲染为：12345678910&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;th&gt;COMMENTS&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;/tr&gt;&lt;/table&gt;当value为tag时，页面渲染为：123456789101112131415&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;th&gt;COMMENTS&lt;/th&gt; &lt;/tr&gt; &lt;td&gt;Mild Cinnamon&lt;/td&gt; &lt;td&gt;1.99&lt;/td&gt; &lt;td&gt;yes&lt;/td&gt; &lt;td&gt; &lt;span&gt;3&lt;/span&gt; comment/s &lt;a href="comments.html"&gt;view&lt;/a&gt; &lt;/td&gt;&lt;/table&gt;当value为all-but-first时，页面渲染为：1234567891011&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;th&gt;COMMENTS&lt;/th&gt; &lt;/tr&gt; &lt;tr th:remove="value"&gt; &lt;td&gt;Mild Cinnamon&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 条件语句]]></title>
    <url>%2FThymeleaf%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5.html</url>
    <content type="text"><![CDATA[if 与 unless假如现在有一个商品列表，当商品有评论时，显示view按钮，否则不显示。这时候就可以使用Thymeleaf的th:if标签来实现:123&lt;a href="comments.html" th:href="@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;" th:if="$&#123;not #lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;当prod.comments不为空时，页面将渲染出该&lt;a&gt;标签。另外，th:if有一个反向属性th:unless，用于代替上面的not：123&lt;a href="comments.html" th:href="@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;" th:unless="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;switchThymeleaf中的th:switch和其他语言的switch case语句差不多：1234&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="'manager'"&gt;User is a manager&lt;/p&gt;&lt;/div&gt;th:case=&quot;*&quot;表示默认选项，相当于default：12345&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="'manager'"&gt;User is a manager&lt;/p&gt; &lt;p th:case="*"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 迭代]]></title>
    <url>%2FThymeleaf-%E8%BF%AD%E4%BB%A3.html</url>
    <content type="text"><![CDATA[在Thymeleaf中，使用th:each标签可对集合类型进行迭代，支持的类型有：1.任何实现了java.util.List的对象；2.任何实现了java.util.Iterable的对象；3.任何实现了java.util.Enumeration的对象；4.任何实现了java.util.Iterator的对象;5.任何实现了java.util.Map的对象。当迭代maps时，迭代变量是java.util.Map.Entry类型；6.任何数组。一个简单的例子：1234&lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt;&lt;/tr&gt;其中${prods}为迭代值，prod为迭代变量。除此之外，我们还可以通过状态变量获取迭代的状态信息，比如：1&lt;tr th:each="prod,stat : $&#123;prods&#125;"&gt; ...其中stat就是状态变量。默认为迭代变量加上Stat后缀，在本例中，不直接申明stat，则状态变量名称为prodStat。状态变量包含以下信息：1.index，当前迭代下标，从0开始；2.count，当前迭代位置，从1开始；3.size，迭代变量中的总计数量；4.current，每次迭代的迭代变量；5.even/odd，当前迭代是偶数还是奇数；6.first，当前迭代的是不是第一个；7.last，当前迭代的是不是最后一个；例子：12345678910&lt;div th:each="habbits,stat : $&#123;user.habbit&#125;"&gt; &lt;span th:text="$&#123;habbits&#125;"&gt;&lt;/span&gt; &lt;span th:text="$&#123;stat.index&#125;"&gt;&lt;/span&gt; &lt;span th:text="$&#123;stat.count&#125;"&gt;&lt;/span&gt; &lt;span th:text="$&#123;stat.size&#125;"&gt;&lt;/span&gt; &lt;span th:text="$&#123;stat.current&#125;"&gt;&lt;/span&gt; &lt;span th:text="$&#123;stat.even&#125;"&gt;&lt;/span&gt; &lt;span th:text="$&#123;stat.first&#125;"&gt;&lt;/span&gt; &lt;span th:text="$&#123;stat.last&#125;"&gt;&lt;/span&gt;&lt;/div&gt;页面显示如下：]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 表达式工具类]]></title>
    <url>%2FThymeleaf-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E5%85%B7%E7%B1%BB.html</url>
    <content type="text"><![CDATA[Thymeleaf默认提供了丰富的表达式工具类，这里列举一些常用的工具类。Objects工具类12345678/* * 当obj不为空时，返回obj，否则返回default默认值 * 其同样适用于数组、列表或集合 */$&#123;#objects.nullSafe(obj,default)&#125;$&#123;#objects.arrayNullSafe(objArray,default)&#125;$&#123;#objects.listNullSafe(objList,default)&#125;$&#123;#objects.setNullSafe(objSet,default)&#125;String工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/* * Null-safe toString() */$&#123;#strings.toString(obj)&#125; // 也可以是 array*、list* 或 set*/* * 检查String是否为空(或null)。在检查之前执行trim()操作也同样适用于数组、列表或集合 */$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;/* * 对字符串执行“isEmpty()”检查, 如果为false则返回它, 如果为true则默认为另一个指定的字符串。 * 也同样适用于数组、列表或集合 */$&#123;#strings.defaultString(text,default)&#125;$&#123;#strings.arrayDefaultString(textArr,default)&#125;$&#123;#strings.listDefaultString(textList,default)&#125;$&#123;#strings.setDefaultString(textSet,default)&#125;/* * 检查字符串中是否包含片段，比如 $&#123;#strings.containsIgnoreCase(user.name,'kang')&#125; * 也同样适用于数组、列表或集合 */$&#123;#strings.contains(name,'ez')&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.containsIgnoreCase(name,'ez')&#125; // 也可以是 array*、list* 或 set*/* * 检查字符串是否以片段开始或结束 * 也同样适用于数组、列表或集合 */$&#123;#strings.startsWith(name,'Don')&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.endsWith(name,endingFragment)&#125; // 也可以是 array*、list* 或 set*/* * 子串相关操作 * 也同样适用于数组、列表或集合 */$&#123;#strings.indexOf(name,frag)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.substring(name,3,5)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.substringAfter(name,prefix)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.substringBefore(name,suffix)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.replace(name,'las','ler')&#125; // 也可以是 array*、list* 或 set*/* * 附加和前置 * 也同样适用于数组、列表或集合 */$&#123;#strings.prepend(str,prefix)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.append(str,suffix)&#125; // 也可以是 array*、list* 或 set*/* * 大小写转换 * 也同样适用于数组、列表或集合 */$&#123;#strings.toUpperCase(name)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.toLowerCase(name)&#125; // 也可以是 array*、list* 或 set*/* * 拆分和拼接 */$&#123;#strings.arrayJoin(namesArray,',')&#125;$&#123;#strings.listJoin(namesList,',')&#125;$&#123;#strings.setJoin(namesSet,',')&#125;$&#123;#strings.arraySplit(namesStr,',')&#125; // 返回String []$&#123;#strings.listSplit(namesStr,',')&#125; // 返回List&lt;String&gt;$&#123;#strings.setSplit(namesStr,',')&#125; // 返回Set&lt;String&gt;/* * Trim * 也同样适用于数组、列表或集合 */$&#123;#strings.trim(str)&#125; // 也可以是 array*、list* 或 set*/* * 计算长度 * 也同样适用于数组、列表或集合 */$&#123;#strings.length(str)&#125; // 也可以是 array*、list* 或 set*/* * 缩写文本, 使其最大大小为n。如果文本较大, 它将被剪辑并在末尾附加“...” * 也同样适用于数组、列表或集合 */$&#123;#strings.abbreviate(str,10)&#125; // 也可以是 array*、list* 或 set*/* * 将第一个字符转换为大写(反之亦然) */$&#123;#strings.capitalize(str)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.unCapitalize(str)&#125; // 也可以是 array*、list* 或 set*/* * 将每个单词的第一个字符转换为大写 */$&#123;#strings.capitalizeWords(str)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.capitalizeWords(str,delimiters)&#125; // 也可以是 array*、list* 或 set*/* * 转义字符串 */$&#123;#strings.escapeXml(str)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.escapeJava(str)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.escapeJavaScript(str)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.unescapeJava(str)&#125; // 也可以是 array*、list* 或 set*$&#123;#strings.unescapeJavaScript(str)&#125; // 也可以是 array*、list* 或 set*/* * 空安全比较和连接 */$&#123;#strings.equals(first, second)&#125;$&#123;#strings.equalsIgnoreCase(first, second)&#125;$&#123;#strings.concat(values...)&#125;$&#123;#strings.concatReplaceNulls(nullValue, values...)&#125;/* * 随机数 */$&#123;#strings.randomAlphanumeric(count)&#125;Dates工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * 使用标准区域设置格式格式化日期 * 也同样适用于数组、列表或集合 */$&#123;#dates.format(date)&#125;$&#123;#dates.arrayFormat(datesArray)&#125;$&#123;#dates.listFormat(datesList)&#125;$&#123;#dates.setFormat(datesSet)&#125;/* * 使用ISO8601格式格式化日期 * 也同样适用于数组、列表或集合 */$&#123;#dates.formatISO(date)&#125;$&#123;#dates.arrayFormatISO(datesArray)&#125;$&#123;#dates.listFormatISO(datesList)&#125;$&#123;#dates.setFormatISO(datesSet)&#125;/* * 使用指定的格式格式化日期，比如 $&#123;#dates.format(date,'yyyy-MM-dd HH:mm:ss')&#125; * 也同样适用于数组、列表或集合 */$&#123;#dates.format(date, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')&#125;/* * 获取日期属性 * 也同样适用于数组、列表或集合 */$&#123;#dates.day(date)&#125; // 也可以是 arrayDay(...), listDay(...)之类的$&#123;#dates.month(date)&#125; // 也可以是 arrayMonth(...), listMonth(...)之类的$&#123;#dates.monthName(date)&#125; // 也可以是 arrayMonthName(...), listMonthName(...)之类的$&#123;#dates.monthNameShort(date)&#125; // 也可以是 arrayMonthNameShort(...), listMonthNameShort(...)之类的$&#123;#dates.year(date)&#125; // 也可以是 arrayYear(...), listYear(...)之类的$&#123;#dates.dayOfWeek(date)&#125; // 也可以是 arrayDayOfWeek(...), listDayOfWeek(...)之类的$&#123;#dates.dayOfWeekName(date)&#125; // 也可以是 arrayDayOfWeekName(...), listDayOfWeekName(...)之类的$&#123;#dates.dayOfWeekNameShort(date)&#125; // 也可以是 arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...)之类的$&#123;#dates.hour(date)&#125; // 也可以是 arrayHour(...), listHour(...)之类的$&#123;#dates.minute(date)&#125; // 也可以是 arrayMinute(...), listMinute(...)之类的$&#123;#dates.second(date)&#125; // 也可以是 arraySecond(...), listSecond(...)之类的$&#123;#dates.millisecond(date)&#125; // 也可以是 arrayMillisecond(...), listMillisecond(...)之类的/* * 根据year,month,day创建日期(java.util.Date)对象，比如 $&#123;#dates.create('2008','08','08')&#125; */$&#123;#dates.create(year,month,day)&#125;$&#123;#dates.create(year,month,day,hour,minute)&#125;$&#123;#dates.create(year,month,day,hour,minute,second)&#125;$&#123;#dates.create(year,month,day,hour,minute,second,millisecond)&#125;/* * 创建当前日期和时间创建日期(java.util.Date)对象，比如 $&#123;#dates.format(#dates.createNow(),'yyyy-MM-dd HH:mm:ss')&#125; */$&#123;#dates.createNow()&#125;$&#123;#dates.createNowForTimeZone()&#125;/* * 创建当前日期创建一个日期(java.util.Date)对象(时间设置为00:00) */$&#123;#dates.createToday()&#125;$&#123;#dates.createTodayForTimeZone()&#125;Calendars工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * 使用标准区域设置格式格式化日历 * 也同样适用于数组、列表或集合 */$&#123;#calendars.format(cal)&#125;$&#123;#calendars.arrayFormat(calArray)&#125;$&#123;#calendars.listFormat(calList)&#125;$&#123;#calendars.setFormat(calSet)&#125;/* * 使用ISO8601格式格式化日历 * 也同样适用于数组、列表或集合 */$&#123;#calendars.formatISO(cal)&#125;$&#123;#calendars.arrayFormatISO(calArray)&#125;$&#123;#calendars.listFormatISO(calList)&#125;$&#123;#calendars.setFormatISO(calSet)&#125;/* * 使用指定的格式格式化日历 * 也同样适用于数组、列表或集合 */$&#123;#calendars.format(cal, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.arrayFormat(calArray, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.listFormat(calList, 'dd/MMM/yyyy HH:mm')&#125;$&#123;#calendars.setFormat(calSet, 'dd/MMM/yyyy HH:mm')&#125;/* * 获取日历属性 * 也同样适用于数组、列表或集合 */$&#123;#calendars.day(date)&#125; // 也可以是 arrayDay(...), listDay(...)之类的$&#123;#calendars.month(date)&#125; // 也可以是 arrayMonth(...), listMonth(...)之类的$&#123;#calendars.monthName(date)&#125; // 也可以是 arrayMonthName(...), listMonthName(...)之类的$&#123;#calendars.monthNameShort(date)&#125; // 也可以是 arrayMonthNameShort(...), listMonthNameShort(...)之类的$&#123;#calendars.year(date)&#125; // 也可以是 arrayYear(...), listYear(...)之类的$&#123;#calendars.dayOfWeek(date)&#125; // 也可以是 arrayDayOfWeek(...), listDayOfWeek(...)之类的$&#123;#calendars.dayOfWeekName(date)&#125; // 也可以是 arrayDayOfWeekName(...), listDayOfWeekName(...)之类的$&#123;#calendars.dayOfWeekNameShort(date)&#125; // 也可以是 arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...)之类的$&#123;#calendars.hour(date)&#125; // 也可以是 arrayHour(...), listHour(...)之类的$&#123;#calendars.minute(date)&#125; // 也可以是 arrayMinute(...), listMinute(...)之类的$&#123;#calendars.second(date)&#125; // 也可以是 arraySecond(...), listSecond(...)之类的$&#123;#calendars.millisecond(date)&#125; // 也可以是 arrayMillisecond(...), listMillisecond(...)之类的/* * 从其组件创建日历(java.util.Calendar)对象 */$&#123;#calendars.create(year,month,day)&#125;$&#123;#calendars.create(year,month,day,hour,minute)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second,millisecond)&#125;$&#123;#calendars.createForTimeZone(year,month,day,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,timeZone)&#125;$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,millisecond,timeZone)&#125;/* * 为当前日期和时间创建一个日历(java.util.Calendar)对象 */$&#123;#calendars.createNow()&#125;$&#123;#calendars.createNowForTimeZone()&#125;/* * 为当前日期创建日历(java.util.Calendar)对象(时间设置为00:00) */$&#123;#calendars.createToday()&#125;$&#123;#calendars.createTodayForTimeZone()&#125;Numbers工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * ========================== * 格式化整数 * ========================== *//* * 设置最小整数位数。 * 也同样适用于数组、列表或集合 */$&#123;#numbers.formatInteger(num,3)&#125;$&#123;#numbers.arrayFormatInteger(numArray,3)&#125;$&#123;#numbers.listFormatInteger(numList,3)&#125;$&#123;#numbers.setFormatInteger(numSet,3)&#125;/* * 设置最小整数位数和千位分隔符： * 'POINT'、'COMMA'、'WHITESPACE'、'NONE' 或 'DEFAULT'(根据本地化)。 * 也同样适用于数组、列表或集合 */$&#123;#numbers.formatInteger(num,3,'POINT')&#125;$&#123;#numbers.arrayFormatInteger(numArray,3,'POINT')&#125;$&#123;#numbers.listFormatInteger(numList,3,'POINT')&#125;$&#123;#numbers.setFormatInteger(numSet,3,'POINT')&#125;/* * ========================== * 格式化十进制数 * ========================== *//* * 设置最小整数数字和(精确的)十进制数字。 * 也同样适用于数组、列表或集合 */$&#123;#numbers.formatDecimal(num,3,2)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2)&#125;$&#123;#numbers.listFormatDecimal(numList,3,2)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2)&#125;/* * 设置最小整数数字和(精确的)小数位数, 以及小数分隔符。 * 也同样适用于数组、列表或集合 */$&#123;#numbers.formatDecimal(num,3,2,'COMMA')&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2,'COMMA')&#125;$&#123;#numbers.listFormatDecimal(numList,3,2,'COMMA')&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2,'COMMA')&#125;/* * 设置最小整数数字和(精确的)十进制数字, 以及千位和十进制分隔符。 * 也同样适用于数组、列表或集合 */$&#123;#numbers.formatDecimal(num,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.listFormatDecimal(numList,3,'POINT',2,'COMMA')&#125;$&#123;#numbers.setFormatDecimal(numSet,3,'POINT',2,'COMMA')&#125;/* * ========================== * 实用方法 * ========================== *//* * 创建一个从x到y的整数序列(数组) */$&#123;#numbers.sequence(from,to)&#125;$&#123;#numbers.sequence(from,to,step)&#125;比如：1234&lt;p th:utext="$&#123;#numbers.formatInteger(0.1024,3)&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1.024,3)&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(10.24,3)&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(102.4,3)&#125;"&gt;&lt;/p&gt;页面输出：1234567891011&lt;p th:utext="$&#123;#numbers.formatInteger(1.024,2,'POINT')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1024,3,'POINT')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1024,10,'POINT')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1.024,2,'COMMA')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1024,3,'COMMA')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1024,10,'COMMA')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1.024,2,'WHITESPACE')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1024,3,'WHITESPACE')&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;#numbers.formatInteger(1024,10,'WHITESPACE')&#125;"&gt;&lt;/p&gt;页面输出：POINT指的是.，COMMA指的是,，WHITESPACE指的是空格。三个数位为一组，使用指定的分隔符分割。比如1.024并不是小数，而是使用了.分隔的1024。Booleans工具类123456789101112131415161718192021222324252627282930313233/* * 评估条件, 类似于 th:if 标签 * 也同样适用于数组、列表或集合 */$&#123;#bools.isTrue(obj)&#125;$&#123;#bools.arrayIsTrue(objArray)&#125;$&#123;#bools.listIsTrue(objList)&#125;$&#123;#bools.setIsTrue(objSet)&#125;/* * 用否定来评估条件 * 也同样适用于数组、列表或集合 */$&#123;#bools.isFalse(cond)&#125;$&#123;#bools.arrayIsFalse(condArray)&#125;$&#123;#bools.listIsFalse(condList)&#125;$&#123;#bools.setIsFalse(condSet)&#125;/* * 评估条件并执行与操作 * 接收数组、列表或集合作为参数 */$&#123;#bools.arrayAnd(condArray)&#125;$&#123;#bools.listAnd(condList)&#125;$&#123;#bools.setAnd(condSet)&#125;/* * 评估条件并执行或操作 * 接收数组、列表或集合作为参数 */$&#123;#bools.arrayOr(condArray)&#125;$&#123;#bools.listOr(condList)&#125;$&#123;#bools.setOr(condSet)&#125;Arrays工具类12345678910111213141516171819202122232425262728293031/* * 转换为数组, 试图推断数组组件类。注意, 如果结果数组为空, 或者目标对象的元素不是全部相同的类, 则 * 此方法将返回Object []。 */$&#123;#arrays.toArray(object)&#125;/* * 转换为指定组件类的数组。 */$&#123;#arrays.toStringArray(object)&#125;$&#123;#arrays.toIntegerArray(object)&#125;$&#123;#arrays.toLongArray(object)&#125;$&#123;#arrays.toDoubleArray(object)&#125;$&#123;#arrays.toFloatArray(object)&#125;$&#123;#arrays.toBooleanArray(object)&#125;/** 计算数组长度 */$&#123;#arrays.length(array)&#125;/* * 检查数组是否为空 */$&#123;#arrays.isEmpty(array)&#125;/* * 检查数组中是否包含元素或元素集合 */$&#123;#arrays.contains(array, element)&#125;$&#123;#arrays.containsAll(array, elements)&#125;Lists工具类1234567891011121314151617181920212223242526/* * 转化为 list */$&#123;#lists.toList(object)&#125;/* * 计算大小 */$&#123;#lists.size(list)&#125;/* */$&#123;#lists.isEmpty(list)&#125;/* * 检查list中是否包含元素或元素集合 */$&#123;#lists.contains(list, element)&#125;$&#123;#lists.containsAll(list, elements)&#125;/* * 排序给定列表的副本。列表的成员必须 * 实现comparable, 或者必须定义comparator。 */$&#123;#lists.sort(list)&#125;$&#123;#lists.sort(list, comparator)&#125;Sets工具类1234567891011121314151617181920/* * 转化为 to set */$&#123;#sets.toSet(object)&#125;/* * 计算大小 */$&#123;#sets.size(set)&#125;/* * 检查set是否为empty */$&#123;#sets.isEmpty(set)&#125;/* * 检查set中是否包含元素或元素集合 */$&#123;#sets.contains(set, element)&#125;$&#123;#sets.containsAll(set, elements)&#125;Maps工具类1234567891011121314151617/* * 计算大小 */$&#123;#maps.size(map)&#125;/* * 检查map是否为空 */$&#123;#maps.isEmpty(map)&#125;/* * 检查map中是否包含key/s或value/s */$&#123;#maps.containsKey(map, key)&#125;$&#123;#maps.containsAllKeys(map, keys)&#125;$&#123;#maps.containsValue(map, value)&#125;$&#123;#maps.containsAllValues(map, value)&#125;注意事项值得注意的是，在使用工具类对某个表达式进行处理时候，你可能会写成：1$&#123;#strings.isEmpty($&#123;session.user.name&#125;)&#125;。实际上这种写法是错误的，将抛出异常。正确的写法为：1$&#123;#strings.isEmpty(session.user.name)&#125;。]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 标准表达式语法]]></title>
    <url>%2FThymeleaf-Standard-Expression-Syntax.html</url>
    <content type="text"><![CDATA[记录几个比较容易忘记的Thymeleaf标准表达式语法，例子基于Spring MVC。变量表达式${ }在控制器中往页面传递几个变量：1234567891011121314@Controllerpublic class IndexController &#123; @RequestMapping(value="/index",method=RequestMethod.GET) public String index(HttpSession session, Model model)&#123; User user = new User(); user.setName("KangKang"); user.setAge(25); user.setHabbit(new String[]&#123;"football","basketball","swim"&#125;); session.setAttribute("user", user); model.addAttribute(user); return "index"; &#125;&#125;在页面中使用变量表达式${}来获取它们：1234&lt;p th:utext="$&#123;user.name&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;session.user.getName()&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;session.user.upcaseName()&#125;"&gt;&lt;/p&gt;&lt;p th:utext="$&#123;user.habbit[0]&#125;"&gt;&lt;/p&gt;可以看到变量表达式不但可以获取变量的属性值，甚至还可以访问变量的方法（getName()和upcaseName()）。session代表HttpSession对象。选择表达式*{ }选择表达式的使用方法如下所示：12345&lt;div th:object="$&#123;session.user&#125;"&gt; &lt;p&gt;name: &lt;span th:text="*&#123;name&#125;"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;age: &lt;span th:text="*&#123;age&#125;"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;habbit: &lt;span th:text="*&#123;habbit[0]&#125;"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;*{}代指th:object所指定的对象，即${session.user}。URL链接表达式@{ }URL链接表达式会给URL自动添加上下文的名字。比如：1&lt;a th:href="@&#123;/main&#125;"&gt;main&lt;/a&gt;解析后的href值为http://localhost:8080/thymeleaf/main。当需要在URL中传递参数时，比如这样http://localhost:8080/thymeleaf/main?name=KangKang，可以如下操作：1&lt;a th:href="@&#123;/main(name=$&#123;session.user.name&#125;)&#125;"&gt;main&lt;/a&gt;传递多个参数：1&lt;a th:href="@&#123;/main(name=$&#123;session.user.name&#125;,age=$&#123;session.user.age&#125;)&#125;"&gt;main&lt;/a&gt;路径变量的写法：1&lt;a th:href="@&#123;/main/&#123;name&#125;(name=$&#123;session.user.name&#125;)&#125;"&gt;main&lt;/a&gt;后端接受路径变量：12345@RequestMapping(value="main/&#123;name&#125;")public String main(@PathVariable String name)&#123; System.out.println("pathValue: "+name); return "main";&#125;字面量文本常量文本常量指的是单引号之间的字符串，比如：1&lt;p th:text="'Welcome KangKang'"&gt;&lt;/p&gt;数字常量12&lt;p&gt;The year is &lt;span th:text="2017"&gt;1492&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;In two years, it will be &lt;span th:text="2017 + 2"&gt;1494&lt;/span&gt;.&lt;/p&gt;Boolean类型的常量Boolean类型的常量就是true和false。例如：1&lt;div th:if="$&#123;user.isAdmin()&#125; == false"&gt; ...Null常量1&lt;div th:if="$&#123;variable.something&#125; == null"&gt; ...字面量替换除了使用&#39;...&#39; + ${}来连接字面量和变量外，还可以使用|...|来代替，比如：1&lt;p th:utext="|hello,$&#123;session.user.name&#125;,your age is $&#123;session.user.age&#125;|"&gt;&lt;/p&gt;等价于：1&lt;p th:utext="'hello,'+$&#123;session.user.name&#125;+',your age is '+$&#123;session.user.age&#125;"&gt;&lt;/p&gt;在| ... |字面替换中只允许有变量表达式${...}条件表达式条件表达式实际上就是三目运算符。比如：123&lt;tr th:class="$&#123;row.even&#125;? 'even' : 'odd'"&gt; ...&lt;/tr&gt;条件表达式也可以使用括号嵌套：123&lt;tr th:class="$&#123;row.even&#125;? ($&#123;row.first&#125;? 'first' : 'even') : 'odd'"&gt; ...&lt;/tr&gt;else表达式也可以省略，在这种情况下，如果条件为false，则返回空值：123&lt;tr th:class="$&#123;row.even&#125;? 'even'"&gt; ...&lt;/tr&gt;默认表达式默认表达式是一种特殊类型的条件值，不带then部分。比如：1&lt;p th:utext="$&#123;session.user.sex&#125; ?: 'sex is unknown'"&gt;&lt;/p&gt;表示，当${session.user.sex}为null时，值为sex is unknown，否则为表达式的值。这就好像为表达式指定了一个默认值一样。其等价于：1&lt;p th:utext=&quot;$&#123;session.user.sex != null&#125; ? $&#123;session.user.sex&#125;: &apos;sex is unknown&apos;&quot;&gt;&lt;/p&gt;更详细的内容可参考官方文档：http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax]]></content>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义annotation]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89annotation.html</url>
    <content type="text"><![CDATA[meta-annotationJava从JDK5.0开始便提供了四个meta-annotation用于自定义注解的时候使用，这四个注解为：@Target，@Retention，@Documented 和@Inherited。@Target：用于描述注解的使用范围（即：被描述的注解可以用在什么地方），其源码如下：1234567@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125;可见@Target 注解只有唯一成员value，类型为ElementType数组。查看ElementType的源码可以发现，ElementType可取的值有：CONSTRUCTOR：用于描述构造器；FIELD：用于描述成员变量；LOCAL_VARIABLE：用于描述局部变量；METHOD：用于描述方法；PACKAGE：用于描述包；PARAMETER：用于描述参数；TYPE：用于描述类、接口(包括注解类型) 或enum声明。@Retention：指定被描述的注解在什么范围内有效。源码如下：1234567@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125;其中RetentionPolicy可取的值有：SOURCE：在源文件中有效（即源文件保留）；CLASS：在class文件中有效（即class保留）；RUNTIME：在运行时有效（即运行时保留）。@Documented：是一个标记注解，木有成员，用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。@Inherited：元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。自定义annotation用@interface 自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个成员。方法的名称就是成员的名称，返回值类型就是成员的类型。可以通过default来声明参数的默认值。自定义注解的基本格式为：123public @interface AnnotationName &#123; // ...&#125;Annotation的成员定义必须满足以下三点：成员只能用public或默认(default)这两个访问权修饰；成员的类型只能是基本类型，String，Enum，Class，Annotation以及它们的数组类型；如果只有一个成员，最好将其名称设为value。AnnotatedElement代表被注解的元素，其包含许多方法，如下图所示：…其中主要的几个方法有：1234&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationType) // 根据annotationType获取注解对象Annotation[] getAnnotations() // 获取所有注解boolean isAnnotationPresent(Class&lt;T&gt; annotationType) // 判断当前元素是否被annotationType注解Annotation[] getDeclareAnnotations() // 与getAnnotations() 类似，但是不包括父类中被Inherited修饰的注解实战假如现在有一个数据库表对应的POJO被一些自定义注解所标记，现在要根据这个POJO自动生成创建库表的SQL语句。其中POJO代码如下：1234567891011@Table(name = "Student")class Bean &#123; @Column(name = "age", length = 3) int age; @Column(name = "userName", length = 10) String name; @Column(name = "birthday", defaultValue = "sysdate") Date birthday;&#125;需要生成类似如下的SQL语句：1create table Student(age NUMBER(3),userName VARCHAR2(10),birthday DATE default sysdate)Bean类被@Table 注解所标记，所以需要定义一个ElementType.TYPE级别的注解：12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface Table &#123; String name(); // name用来设置表名&#125;而@Column 注解标注于Bean的成员变量，并且包含三个成员：1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)@interface Column &#123; String name() default ""; // name用来设置字段名 int length() default 0; // length用来设置字段长度 String defaultValue() default ""; // defaultValue用来设置默认值&#125;接下来定义两个方法getTableName(Class&lt;?&gt; bean)和getColumns(Class&lt;?&gt; bean)，分别用于获取@Table 注解中的表名和被@Column 注解标记的成员变量信息：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private static String getTableName(Class&lt;?&gt; bean) &#123; String name = null; // 判断bean是否被@Table注解 if (bean.isAnnotationPresent(Table.class)) &#123; // 获取注解对象 Annotation tableAnnotation = bean.getAnnotation(Table.class); try &#123; // 获取@Table注解所对应的name Method method = Table.class.getMethod("name"); name = (String) method.invoke(tableAnnotation); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return name;&#125;private static List&lt;ColumnBean&gt; getColumns(Class&lt;?&gt; bean) &#123; List&lt;ColumnBean&gt; columns = new ArrayList&lt;ColumnBean&gt;(); Field[] fields = bean.getDeclaredFields(); if (fields != null) &#123; // 表里所有成员变量（fields）,获取其注解信息 for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; // 判断是否被@Column注解标记 if (field.isAnnotationPresent(Column.class)) &#123; String name = null; int length = 0; String defaultValue = null; String type = null; // 分别获取@Column注解里成员的值 Annotation columnAnnotation = field.getAnnotation(Column.class); try &#123; Method nameMethod = Column.class.getMethod("name"); name = (String) nameMethod.invoke(columnAnnotation); Method rangeMethod = Column.class.getMethod("length"); length = (Integer) rangeMethod.invoke(columnAnnotation); Method defaultValueMethod = Column.class.getMethod("defaultValue"); defaultValue = (String) defaultValueMethod.invoke(columnAnnotation); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 判断类型，Java类型转换为数据库类型 if (int.class.isAssignableFrom(field.getType()) || Integer.class.isAssignableFrom(field.getType())) &#123; type = "NUMBER"; &#125; else if (String.class.isAssignableFrom(field.getType())) &#123; type = "VARCHAR2"; &#125; else if (Date.class.isAssignableFrom(field.getType()))&#123; type = "DATE"; &#125;else &#123; throw new RuntimeException("unspported type=" + field.getType().getSimpleName()); &#125; columns.add(new ColumnBean(type, name, length, defaultValue)); &#125; &#125; &#125; return columns;&#125;// 用于描述Columnprivate static class ColumnBean &#123; final String type; final String name; final int length; final String defaultValue; public ColumnBean(String type, String name, int length, String defaultValue) &#123; this.type = type; this.name = name; this.length = length; this.defaultValue = defaultValue; &#125;&#125;最后编写生成SQL的方法：123456789101112131415161718192021222324252627282930313233343536public static String createTable(Class&lt;?&gt; bean) &#123; String tableName = getTableName(bean); List&lt;ColumnBean&gt; columns = getColumns(bean); if (tableName != null &amp;&amp; !tableName.equals("") &amp;&amp; !columns.isEmpty()) &#123; StringBuilder createTableSql = new StringBuilder("create table "); // 拼接表名 createTableSql.append(tableName); createTableSql.append("("); //拼接字段信息 for (int i = 0; i &lt; columns.size(); i++) &#123; ColumnBean column = columns.get(i); createTableSql.append(column.name); createTableSql.append(" "); createTableSql.append(column.type); int length = column.length; if(length != 0)&#123; createTableSql.append("("); createTableSql.append(column.length); createTableSql.append(")"); &#125; String defaultValue = column.defaultValue; if(defaultValue != null &amp;&amp; defaultValue.length() != 0)&#123; createTableSql.append(" default "); createTableSql.append(defaultValue); &#125; if (i != columns.size() - 1) &#123; createTableSql.append(","); &#125; &#125; createTableSql.append(")"); return createTableSql.toString(); &#125;else &#123; throw new RuntimeException("table's name is null"); &#125;&#125;测试12345public class Test &#123; public static void main(String[] args) &#123; System.out.println(TestUtils.createTable(Bean.class)); &#125;&#125;生成的结果和预期一致总结上述的过程可归纳为以下几个步骤：判断AnnotatedElement是否被某注解所标记：AnnotatedElement.isAnnotationPresent(SomeAnnotation.class)；是的话，获取该注解对象：Annotation annotation = bean.getAnnotation(SomeAnnotation.class);；根据该注解对象获取某个成员参数（比如name）：Method method = SomeAnnotation.class.getMethod(&quot;name&quot;);；利用反射机制，获取该注解中的某成员的值：String name = (String) method.invoke(annotation);。Source Code]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSV读写]]></title>
    <url>%2FCSV%E8%AF%BB%E5%86%99.html</url>
    <content type="text"><![CDATA[CSV是以逗号间隔的文本文件。当导出的数据不涉及公式和复杂的表格样式的时候，可以考虑使用javacsv来代替POI，以便节省性能。引入javacsv依赖：123456&lt;!-- https://mvnrepository.com/artifact/net.sourceforge.javacsv/javacsv --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.javacsv&lt;/groupId&gt; &lt;artifactId&gt;javacsv&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;CsvWriter12345678910111213141516171819202122232425import java.nio.charset.Charset;import com.csvreader.CsvWriter;public class CsvWrite &#123; public static void csvWrite()&#123; String csvFilePath = "D://test.csv"; try &#123; CsvWriter csvWriter = new CsvWriter(csvFilePath, ',', Charset.forName("UTF-8")); // 表头 String[] csvHeaders = &#123; "编号", "姓名", "年龄" &#125;; csvWriter.writeRecord(csvHeaders); // 内容 for (int i = 0; i &lt; 5; i++) &#123; String[] csvContent = &#123; i + "", "userName", "1" + i &#125;; csvWriter.writeRecord(csvContent); &#125; csvWriter.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; CsvWrite.csvWrite(); &#125;&#125;生成文件如下：CsvReader12345678910111213141516171819202122232425262728293031323334353637import java.io.IOException;import java.nio.charset.Charset;import java.util.ArrayList;import com.csvreader.CsvReader;public class CsvRead &#123; public static void readCSV() &#123; ArrayList&lt;String[]&gt; csvFileList = new ArrayList&lt;String[]&gt;(); String csvFilePath = "D://test.csv"; try &#123; CsvReader reader = new CsvReader(csvFilePath, ',', Charset.forName("UTF-8")); // 跳过表头 reader.readHeaders(); // 逐行读入除表头的数据 while (reader.readRecord()) &#123; System.out.println(reader.getRawRecord()); csvFileList.add(reader.getValues()); &#125; reader.close(); // 遍历读取CSV每行每列 for (int row = 0; row &lt; csvFileList.size(); row++) &#123; String[] cells = csvFileList.get(row); for(String str : cells)&#123; System.out.print(str+" "); &#125; System.out.println(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; CsvRead.readCSV(); &#125;&#125;输出：123456789100,userName,101,userName,112,userName,123,userName,134,userName,140 userName 10 1 userName 11 2 userName 12 3 userName 13 4 userName 14javacsv API：http://javacsv.sourceforge.net/]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot AOP记录用户操作日志]]></title>
    <url>%2FSpring-Boot-AOP%20log.html</url>
    <content type="text"><![CDATA[在Spring框架中，使用AOP配合自定义注解可以方便的实现用户操作的监控。首先搭建一个基本的Spring Boot Web环境开启Spring Boot，然后引入必要依赖：123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- aop依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- oracle驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- druid数据源驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;自定义注解定义一个方法级别的@Log注解，用于标注需要监控的方法：12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Log &#123; String value() default "";&#125;创建库表和实体在数据库中创建一张sys_log表，用于保存用户的操作日志，数据库采用oracle 11g：1234567891011121314151617181920CREATE TABLE "SCOTT"."SYS_LOG" ( "ID" NUMBER(20) NOT NULL , "USERNAME" VARCHAR2(50 BYTE) NULL , "OPERATION" VARCHAR2(50 BYTE) NULL , "TIME" NUMBER(11) NULL , "METHOD" VARCHAR2(200 BYTE) NULL , "PARAMS" VARCHAR2(500 BYTE) NULL , "IP" VARCHAR2(64 BYTE) NULL , "CREATE_TIME" DATE NULL );COMMENT ON COLUMN "SCOTT"."SYS_LOG"."USERNAME" IS '用户名';COMMENT ON COLUMN "SCOTT"."SYS_LOG"."OPERATION" IS '用户操作';COMMENT ON COLUMN "SCOTT"."SYS_LOG"."TIME" IS '响应时间';COMMENT ON COLUMN "SCOTT"."SYS_LOG"."METHOD" IS '请求方法';COMMENT ON COLUMN "SCOTT"."SYS_LOG"."PARAMS" IS '请求参数';COMMENT ON COLUMN "SCOTT"."SYS_LOG"."IP" IS 'IP地址';COMMENT ON COLUMN "SCOTT"."SYS_LOG"."CREATE_TIME" IS '创建时间';CREATE SEQUENCE seq_sys_log START WITH 1 INCREMENT BY 1;库表对应的实体：1234567891011121314public class SysLog implements Serializable&#123; private static final long serialVersionUID = -6309732882044872298L; private Integer id; private String username; private String operation; private Integer time; private String method; private String params; private String ip; private Date createTime; // get,set略&#125;保存日志的方法为了方便，这里直接使用Spring JdbcTemplate来操作数据库。定义一个SysLogDao接口，包含一个保存操作日志的抽象方法：123public interface SysLogDao &#123; void saveSysLog(SysLog syslog);&#125;其实现方法：1234567891011121314151617@Repositorypublic class SysLogDaoImp implements SysLogDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public void saveSysLog(SysLog syslog) &#123; StringBuffer sql = new StringBuffer("insert into sys_log "); sql.append("(id,username,operation,time,method,params,ip,create_time) "); sql.append("values(seq_sys_log.nextval,:username,:operation,:time,:method,"); sql.append(":params,:ip,:createTime)"); NamedParameterJdbcTemplate npjt = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); npjt.update(sql.toString(), new BeanPropertySqlParameterSource(syslog)); &#125;&#125;切面和切点定义一个LogAspect类，使用@Aspect标注让其成为一个切面，切点为使用@Log注解标注的方法，使用@Around环绕通知：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Aspect@Componentpublic class LogAspect &#123; @Autowired private SysLogDao sysLogDao; @Pointcut("@annotation(com.springboot.annotation.Log)") public void pointcut() &#123; &#125; @Around("pointcut()") public Object around(ProceedingJoinPoint point) &#123; Object result = null; long beginTime = System.currentTimeMillis(); try &#123; // 执行方法 result = point.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; // 保存日志 saveLog(point, time); return result; &#125; private void saveLog(ProceedingJoinPoint joinPoint, long time) &#123; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLog sysLog = new SysLog(); Log logAnnotation = method.getAnnotation(Log.class); if (logAnnotation != null) &#123; // 注解上的描述 sysLog.setOperation(logAnnotation.value()); &#125; // 请求的方法名 String className = joinPoint.getTarget().getClass().getName(); String methodName = signature.getName(); sysLog.setMethod(className + "." + methodName + "()"); // 请求的方法参数值 Object[] args = joinPoint.getArgs(); // 请求的方法参数名称 LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); String[] paramNames = u.getParameterNames(method); if (args != null &amp;&amp; paramNames != null) &#123; String params = ""; for (int i = 0; i &lt; args.length; i++) &#123; params += " " + paramNames[i] + ": " + args[i]; &#125; sysLog.setParams(params); &#125; // 获取request HttpServletRequest request = HttpContextUtils.getHttpServletRequest(); // 设置IP地址 sysLog.setIp(IPUtils.getIpAddr(request)); // 模拟一个用户名 sysLog.setUsername("mrbird"); sysLog.setTime((int) time); sysLog.setCreateTime(new Date()); // 保存系统日志 sysLogDao.saveSysLog(sysLog); &#125;&#125;测试TestController：1234567891011121314151617@RestControllerpublic class TestController &#123; @Log("执行方法一") @GetMapping("/one") public void methodOne(String name) &#123; &#125; @Log("执行方法二") @GetMapping("/two") public void methodTwo() throws InterruptedException &#123; Thread.sleep(2000); &#125; @Log("执行方法三") @GetMapping("/three") public void methodThree(String name, String age) &#123; &#125;&#125;最终项目目录如下图所示：启动项目，分别访问：http://localhost:8080/web/one?name=KangKanghttp://localhost:8080/web/twohttp://localhost:8080/web/three?name=Mike&amp;age=25查询数据库：123456789101112SQL&gt; select * from sys_log order by id; ID USERNAME OPERATION TIME METHOD PARAMS IP CREATE_TIME---------- ---------- ---------- ---------- ------------------------------ ------------------------------ ---------- -------------- 11 mrbird 执行方法一 6 com.springboot.controller.Test name: KangKang 127.0.0.1 08-12月-17 Controller.methodOne() 12 mrbird 执行方法二 2000 com.springboot.controller.Test 127.0.0.1 08-12月-17 Controller.methodTwo() 13 mrbird 执行方法三 0 com.springboot.controller.Test name: Mike age: 25 127.0.0.1 08-12月-17 Controller.methodThree()source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美团外卖开发总结]]></title>
    <url>%2Fmeituan%20waimai.html</url>
    <content type="text"><![CDATA[准备工作首先需要申请开发者账号，地址：http://developer.meituan.com/home。通过之后可以得到developerId:10**16和SignKey:s9bvk***mjm9xms以及测试门店信息。开发者可使用美团外卖app端，修改定位到： 墨脱县–搜索色金拉–搜索测试门店名称测试下单。门店管理可以使用美团外卖商家版APP进行管理。对接可以使用美团开发平台SDK或者UISDK。开发平台SDK下载地址：https://drive.google.com/open?id=14RkrayTt_MKb2d38FhN8aHop-shEv9nJ绑定与解绑美团外卖商家绑定地址为：https://open-erp.meituan.com/login?developerId=101416&amp;businessId=2&amp;ePoiId=123324214214&amp;signKey=s9bvktibcmjm9xms。除了developerId和SignKey之外，还需传入businessId（2表示外卖业务）和ePoiId（该商户在ERP厂商上的唯一标识码）。绑定成功后，美团会返回一个appAuthToken（绑定门店成功后开放平台生产的token）。在回调方法中（下面会说到）将该token保存到数据库，用于后续调用接口。美团外卖商家解绑地址为：https://open-erp.meituan.com/releasebinding?signKey=s9bvktibcmjm9xms&amp;businessId=2&amp;appAuthToken=35be4d3e63270abd28b9a320611bbdb616b1bd6ac7e11fce132e11196a4e6c89558b10f5d651d355a135bf7c49da75c2其中appAuthToken为门店绑定的时候生成的token。回调美团开发平台为外卖各个流程状态提供了回调URL，如下图所示： 回调URL对应为项目中方法的请求地址，比如订单推送URL对应项目中的：1234567891011121314151617/** * 美团外卖订单推送回调 * @param order * @return */@ResponseBody@RequestMapping(value="/plugpay/mtOrderPush.php",produces=&#123;"application/json;charset=UTF-8"&#125;)public Map&lt;String,String&gt; mtOrderPush(String order)&#123; synchronized (this) &#123; Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(); System.out.println(order); System.out.println("您有新的美团外卖订单，请及时处理"); // 保存订单到数据库... result.put("data", "OK"); return result; &#125; &#125;订单推送回调方法需要返回{&quot;data&quot;: &quot;OK&quot;}JSON数据，代表推送成功，否则开发平台会间隔时间连续推送。其中关于回调返回的字段可参考美团开发平台回调API：http://developer.meituan.com/openapi#7.5.1。除了订单回调，美团开发平台还提供了门店绑定和解绑的回调，和订单类似，配置好回调URL即可。比如门店绑定回调方法：123456789101112131415161718192021/** * 门店绑定成功回调 * @param appAuthToken * @param businessId * @param ePoiId * @param timestamp * @return */@ResponseBody@RequestMapping(value="/plugpay/mtOauth.php",produces=&#123;"application/json;charset=UTF-8"&#125;)public JSONObject saveLogin(String appAuthToken, String businessId, String ePoiId, String timestamp)&#123; synchronized (this) &#123; JSONObject jsonObject = new JSONObject(); System.out.println("appAuthToken: "+appAuthToken+"businessId: "+businessId+"ePoiId: "+ePoiId+ "timestamp: "+timestamp); System.out.println("商户绑定成功"); // 保存token... jsonObject.element("data","success"); return jsonObject; &#125;&#125;除此之外，还有一个比较特殊的回调：心跳是用来检测餐饮商户设备是否正常工作的定时机制，其中餐饮商户的设备包括所使用的ERP系统的云端、pos等各类设备。心跳由ERP厂商负责上报，聚宝盆开放平台负责收集，并将收集到的结果应用于外卖、点餐等业务线。回调方法很简单：12345678910111213/** * 心跳 * @param request * @return */@ResponseBody@RequestMapping(value="/plugpay/heartbeat.php",method=&#123;RequestMethod.GET&#125;)public Map&lt;String,String&gt; mtHeartbeatBack(HttpServletRequest request)&#123; Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(); result.put("data", "OK"); System.out.println("mtHeartbeat "+System.currentTimeMillis()); return result;&#125;使用SDK操作订单SDK中各个API对应的封装类按如下规则命名：通用前缀 + 业务类型前缀 + 业务二级前缀 + 具体操作 + 通用后缀。比如确认外卖订单请求的URL为：http://api.open.cater.meituan.com/waimai/order/confirm。接口对应完整类为：CipCater + Takeout + Order + Confirm + Request = CipCaterTakeoutOrderConfirmRequest。返回结果为JSON字符串。具体例子如下：123456789101112131415161718192021222324252627JSONObject result_json = new JSONObject();// 声明公共参数，RequestSysParams构造方法接收两个参数，第一个为signkey，第二个为appAuthTokenRequestSysParams requestSysParams = new RequestSysParams("yourSecret", "yourToken");// 声明所需request，此Request对象为根据url在表中查询获得CipCaterTakeoutOrderConfirmRequest request = new CipCaterTakeoutOrderConfirmRequest();// 设置公共参数request.setRequestSysParams(requestSysParams);// 设置业务级参数request.setOrderId(orderId);// 准备接收返回JsonString resultJson = "";try &#123; // 发送请求，接收Json，所有Request都有doRequest方法直接调用即可 result_json = JSONObject.fromObject(request.doRequest());&#125; catch (IOException e) &#123; // 处理io异常&#125; catch (URISyntaxException e) &#123; // 处理URI语法异常 &#125;String data = getJsonValueString(result_json, "data");if("OK".equalsIgnoreCase(data))&#123; // 成功&#125;else&#123; JSONObject error = JSONObject.fromObject(getJsonValueString(result_json, "error")); String message = getJsonValueString(error, "message"); //失败&#125;其中getJsonValueString方法作用为根据字段名从JSON中获取值：123456789101112131415161718192021222324/** * 根据名称获取Json里的值 * @param json * @param name * @return */public String getJsonValueString(JSONObject json,String name) &#123; return json.has(name)?json.getString(name):"";&#125;public int getJsonValueInt(JSONObject json,String name) &#123; return json.has(name)?json.getInt(name):0;&#125;public double getJsonValueDouble(JSONObject json,String name) &#123; return json.has(name)?json.getDouble(name):0.0;&#125;public boolean getJsonValueBoolean(JSONObject json,String name) &#123; return json.has(name)?json.getBoolean(name):false;&#125;public JSONArray getJsonValueArray(JSONObject json,String name) &#123; return json.has(name)?json.getJSONArray(name):new JSONArray();&#125;public JSONObject getJsonValueObj(JSONObject json,String name) &#123; return json.has(name)?json.getJSONObject(name):new JSONObject();&#125;使用的JSON包为net.sf.json。其他接口的使用以此类推。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot MyBatis配置Druid多数据源]]></title>
    <url>%2FSpring-Boot-MyBatis%20Druid.html</url>
    <content type="text"><![CDATA[回顾在Spring中配置MyBatis SqlSessionFactory的配置：12345&lt;!-- mybatis 的SqlSessionFactory --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean" scope="prototype"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt;&lt;/bean&gt;所以实际上在Spring Boot中配置MyBatis多数据源的关键在于创建SqlSessionFactory的时候为其分配不同的数据源。引入依赖先根据https://mrbird.cc/%E5%BC%80%E5%90%AFSpring-Boot.html开启一个最简单的Spring Boot应用，然后引入如下依赖：12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- oracle驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- druid数据源驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;多数据源配置在Spring Boot配置文件application.yml中配置多数据源和Spring Boot JdbcTemplate配置Druid多数据源一致。然后根据application.yml创建两个数据源配置类MysqlDatasourceConfig和OracleDatasourceConfig：MysqlDatasourceConfig：12345678910111213141516171819202122232425262728293031323334@Configuration@MapperScan(basePackages = MysqlDatasourceConfig.PACKAGE, sqlSessionFactoryRef = "mysqlSqlSessionFactory")public class MysqlDatasourceConfig &#123; // mysqldao扫描路径 static final String PACKAGE = "com.springboot.mysqldao"; // mybatis mapper扫描路径 static final String MAPPER_LOCATION = "classpath:mapper/mysql/*.xml"; @Primary @Bean(name = "mysqldatasource") @ConfigurationProperties("spring.datasource.druid.mysql") public DataSource mysqlDataSource() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(name = "mysqlTransactionManager") @Primary public DataSourceTransactionManager mysqlTransactionManager() &#123; return new DataSourceTransactionManager(mysqlDataSource()); &#125; @Bean(name = "mysqlSqlSessionFactory") @Primary public SqlSessionFactory mysqlSqlSessionFactory(@Qualifier("mysqldatasource") DataSource dataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); //如果不使用xml的方式配置mapper，则可以省去下面这行mapper location的配置。 sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(MysqlDatasourceConfig.MAPPER_LOCATION)); return sessionFactory.getObject(); &#125;&#125;上面代码配置了一个名为mysqldatasource的数据源，对应application.yml中spring.datasource.druid.mysql前缀配置的数据库。然后创建了一个名为mysqlSqlSessionFactory的Bean，并且注入了mysqldatasource。与此同时，还分别定了两个扫描路径PACKAGE和MAPPER_LOCATION，前者为Mysql数据库对应的mapper接口地址，后者为对应的mapper xml文件路径。@Primary标志这个Bean如果在多个同类Bean候选时，该Bean优先被考虑。多数据源配置的时候，必须要有一个主数据源，用@Primary标志该Bean。同理，接着配置Oracle数据库对应的配置类：OracleDatasourceConfig：1234567891011121314151617181920212223242526272829303132@Configuration@MapperScan(basePackages = OracleDatasourceConfig.PACKAGE, sqlSessionFactoryRef = "oracleSqlSessionFactory")public class OracleDatasourceConfig &#123; // oracledao扫描路径 static final String PACKAGE = "com.springboot.oracledao"; // mybatis mapper扫描路径 static final String MAPPER_LOCATION = "classpath:mapper/oracle/*.xml"; @Bean(name = "oracledatasource") @ConfigurationProperties("spring.datasource.druid.oracle") public DataSource oracleDataSource() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(name = "oracleTransactionManager") public DataSourceTransactionManager oracleTransactionManager() &#123; return new DataSourceTransactionManager(oracleDataSource()); &#125; @Bean(name = "oracleSqlSessionFactory") public SqlSessionFactory oracleSqlSessionFactory(@Qualifier("oracledatasource") DataSource dataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); //如果不使用xml的方式配置mapper，则可以省去下面这行mapper location的配置。 sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(OracleDatasourceConfig.MAPPER_LOCATION)); return sessionFactory.getObject(); &#125;&#125;测试配置完多数据源，接下来分别在com.springboot.mysqldao路径和com.springboot.oracledao路径下创建两个mapper接口：MysqlStudentMapper：12345678910package com.springboot.mysqldao;import java.util.List;import java.util.Map;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface MysqlStudentMapper &#123; List&lt;Map&lt;String, Object&gt;&gt; getAllStudents();&#125;OracleStudentMapper：12345678910package com.springboot.oracledao;import java.util.List;import java.util.Map;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface OracleStudentMapper &#123; List&lt;Map&lt;String, Object&gt;&gt; getAllStudents();&#125;接着创建mapper接口对应的实现：在src/main/resource/mapper/mysql/路径下创建MysqlStudentMapper.xml：12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.springboot.mysqldao.MysqlStudentMapper"&gt; &lt;select id="getAllStudents" resultType="java.util.Map"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt;在src/main/resource/mapper/oracle/路径下创建OracleStudentMapper.xml：12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.springboot.oracledao.OracleStudentMapper"&gt; &lt;select id="getAllStudents" resultType="java.util.Map"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt;Service，Controller以及测试数据同Spring Boot JdbcTemplate配置Druid多数据源，这里不再赘述。最终项目目录如下图所示：启动项目，访问：http://localhost:8080/web/querystudentsfrommysql：http://localhost:8080/web/querystudentsfromoracle：source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>MyBatis</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot JdbcTemplate配置Druid多数据源]]></title>
    <url>%2FSpring-Boot-JdbcTemplate%20Druid.html</url>
    <content type="text"><![CDATA[JdbcTemplate配置Druid多数据源的核心在于创建JdbcTemplate时候为其分配不同的数据源，然后在需要访问不同数据库的时候使用对应的JdbcTemplate即可。这里介绍在Spring Boot中基于Oracle和Mysql配置Druid多数据源。引入依赖先根据https://mrbird.cc/%E5%BC%80%E5%90%AFSpring-Boot.html开启一个最简单的Spring Boot应用，然后引入如下依赖：123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- oracle驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- druid数据源驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;多数据源配置接着在Spring Boot配置文件application.yml中配置多数据源：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273server: context-path: /webspring: datasource: druid: # 数据库访问配置, 使用druid数据源 # 数据源1 mysql mysql: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;zeroDateTimeBehavior=convertToNull username: root password: 123456 # 数据源2 oracle oracle: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@localhost:1521:ORCL username: scott password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select '1' from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, 'wall'用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.springboot.servie.* # WebStatFilter配置 web-stat-filter: enabled: true # 添加过滤规则 url-pattern: /* # 忽略过滤的格式 exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' # StatViewServlet配置 stat-view-servlet: enabled: true # 访问路径为/druid时，跳转到StatViewServlet url-pattern: /druid/* # 是否能够重置数据 reset-enable: false # 需要账号密码才能访问控制台 login-username: druid login-password: druid123 # IP白名单 # allow: 127.0.0.1 # IP黑名单（共同存在时，deny优先于allow） # deny: 192.168.1.218 # 配置StatFilter filter: stat: log-slow-sql: true然后创建一个多数据源配置类，根据application.yml分别配置一个Mysql和Oracle的数据源，并且将这两个数据源注入到两个不同的JdbcTemplate中：123456789101112131415161718192021222324252627@Configurationpublic class DataSourceConfig &#123; @Primary @Bean(name = "mysqldatasource") @ConfigurationProperties("spring.datasource.druid.mysql") public DataSource dataSourceOne()&#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(name = "oracledatasource") @ConfigurationProperties("spring.datasource.druid.oracle") public DataSource dataSourceTwo()&#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(name = "mysqlJdbcTemplate") public JdbcTemplate primaryJdbcTemplate( @Qualifier("mysqldatasource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "oracleJdbcTemplate") public JdbcTemplate secondaryJdbcTemplate( @Qualifier("oracledatasource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125;上述代码根据application.yml创建了mysqldatasource和oracledatasource数据源，其中mysqldatasource用@Primary标注为主数据源，接着根据这两个数据源创建了mysqlJdbcTemplate和oracleJdbcTemplate。@Primary标志这个Bean如果在多个同类Bean候选时，该Bean优先被考虑。多数据源配置的时候，必须要有一个主数据源，用@Primary标志该Bean。数据源创建完毕，接下来开始进行测试代码编写。测试首先往Mysql和Oracle中创建测试表，并插入一些测试数据：Mysql：12345678910DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `sno` varchar(3) NOT NULL, `sname` varchar(9) NOT NULL, `ssex` char(2) NOT NULL, `database` varchar(10) DEFAULT NULL) DEFAULT CHARSET=utf8;INSERT INTO `student` VALUES ('001', '康康', 'M', 'mysql');INSERT INTO `student` VALUES ('002', '麦克', 'M', 'mysql');Oracle：123456789101112DROP TABLE "SCOTT"."STUDENT";CREATE TABLE "SCOTT"."STUDENT" ( "SNO" VARCHAR2(3 BYTE) NOT NULL , "SNAME" VARCHAR2(9 BYTE) NOT NULL , "SSEX" CHAR(2 BYTE) NOT NULL , "database" VARCHAR2(10 BYTE) NULL );INSERT INTO "SCOTT"."STUDENT" VALUES ('001', 'KangKang', 'M ', 'oracle');INSERT INTO "SCOTT"."STUDENT" VALUES ('002', 'Mike', 'M ', 'oracle');INSERT INTO "SCOTT"."STUDENT" VALUES ('003', 'Jane', 'F ', 'oracle');INSERT INTO "SCOTT"."STUDENT" VALUES ('004', 'Maria', 'F ', 'oracle');接着创建两个Dao及其实现类，分别用于从Mysql和Oracle中获取数据：MysqlStudentDao接口：123public interface MysqlStudentDao &#123; List&lt;Map&lt;String, Object&gt;&gt; getAllStudents();&#125;MysqlStudentDao实现；1234567891011@Repositorypublic class MysqlStudentDaoImp implements MysqlStudentDao&#123; @Autowired @Qualifier("mysqlJdbcTemplate") private JdbcTemplate jdbcTemplate; @Override public List&lt;Map&lt;String, Object&gt;&gt; getAllStudents() &#123; return this.jdbcTemplate.queryForList("select * from student"); &#125;&#125;可看到，在MysqlStudentDaoImp中注入的是mysqlJdbcTemplate。OracleStudentDao接口：123public interface OracleStudentDao &#123; List&lt;Map&lt;String, Object&gt;&gt; getAllStudents();&#125;OracleStudentDao实现：1234567891011@Repositorypublic class OracleStudentDaoImp implements OracleStudentDao&#123; @Autowired @Qualifier("oracleJdbcTemplate") private JdbcTemplate jdbcTemplate; @Override public List&lt;Map&lt;String, Object&gt;&gt; getAllStudents() &#123; return this.jdbcTemplate.queryForList("select * from student"); &#125;&#125;在OracleStudentDaoImp中注入的是oracleJdbcTemplate。随后编写Service层：StudentService接口：1234public interface StudentService &#123; List&lt;Map&lt;String, Object&gt;&gt; getAllStudentsFromOralce(); List&lt;Map&lt;String, Object&gt;&gt; getAllStudentsFromMysql();&#125;StudentService实现：1234567891011121314151617@Service("studentService")public class StudentServiceImp implements StudentService&#123; @Autowired private OracleStudentDao oracleStudentDao; @Autowired private MysqlStudentDao mysqlStudentDao; @Override public List&lt;Map&lt;String, Object&gt;&gt; getAllStudentsFromOralce() &#123; return this.oracleStudentDao.getAllStudents(); &#125; @Override public List&lt;Map&lt;String, Object&gt;&gt; getAllStudentsFromMysql() &#123; return this.mysqlStudentDao.getAllStudents(); &#125;&#125;最后编写一个Controller：123456789101112131415@RestControllerpublic class StudentController &#123; @Autowired private StudentService studentService; @RequestMapping("querystudentsfromoracle") public List&lt;Map&lt;String, Object&gt;&gt; queryStudentsFromOracle()&#123; return this.studentService.getAllStudentsFromOralce(); &#125; @RequestMapping("querystudentsfrommysql") public List&lt;Map&lt;String, Object&gt;&gt; queryStudentsFromMysql()&#123; return this.studentService.getAllStudentsFromMysql(); &#125;&#125;最终项目目录如下图所示：启动项目，访问：http://localhost:8080/web/querystudentsfrommysql：http://localhost:8080/web/querystudentsfromoracle：source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用JdbcTemplate]]></title>
    <url>%2FSpring-Boot%20JdbcTemplate.html</url>
    <content type="text"><![CDATA[个人觉得JdbcTemplate相较于MyBaits，Hibernate等数据库框架更容易上手，对SQL的操作也更为直观方便，所以在项目中也是一个不错的选择。在Spring Boot开启JdbcTemplate很简单，只需要引入spring-boot-starter-jdbc依赖即可。JdbcTemplate封装了许多SQL操作，具体可查阅官方文档https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html。引入依赖spring-boot-starter-jdbc：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;数据库驱动为ojdbc6，数据源采用Druid。具体可参考https://mrbird.cc/Spring-Boot%E4%B8%AD%E4%BD%BF%E7%94%A8Mybatis.html。代码编写数据准备：123456789CREATE TABLE "SCOTT"."STUDENT" ( "SNO" VARCHAR2(3 BYTE) NOT NULL , "SNAME" VARCHAR2(9 BYTE) NOT NULL , "SSEX" CHAR(2 BYTE) NOT NULL );INSERT INTO "SCOTT"."STUDENT" VALUES ('001', 'KangKang', 'M ');INSERT INTO "SCOTT"."STUDENT" VALUES ('002', 'Mike', 'M ');INSERT INTO "SCOTT"."STUDENT" VALUES ('003', 'Jane', 'F ');这里主要演示在Dao的实现类里使用JdbcTemplate，所以其它模块代码的编写就不展示了，具体可参考文末的源码。StudentDaoImp类代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Repository("studentDao")public class StudentDaoImp implements StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int add(Student student) &#123; // String sql = "insert into student(sno,sname,ssex) values(?,?,?)"; // Object[] args = &#123; student.getSno(), student.getName(), student.getSex() &#125;; // int[] argTypes = &#123; Types.VARCHAR, Types.VARCHAR, Types.VARCHAR &#125;; // return this.jdbcTemplate.update(sql, args, argTypes); String sql = "insert into student(sno,sname,ssex) values(:sno,:name,:sex)"; NamedParameterJdbcTemplate npjt = new NamedParameterJdbcTemplate(this.jdbcTemplate.getDataSource()); return npjt.update(sql, new BeanPropertySqlParameterSource(student)); &#125; @Override public int update(Student student) &#123; String sql = "update student set sname = ?,ssex = ? where sno = ?"; Object[] args = &#123; student.getName(), student.getSex(), student.getSno() &#125;; int[] argTypes = &#123; Types.VARCHAR, Types.VARCHAR, Types.VARCHAR &#125;; return this.jdbcTemplate.update(sql, args, argTypes); &#125; @Override public int deleteBysno(String sno) &#123; String sql = "delete from student where sno = ?"; Object[] args = &#123; sno &#125;; int[] argTypes = &#123; Types.VARCHAR &#125;; return this.jdbcTemplate.update(sql, args, argTypes); &#125; @Override public List&lt;Map&lt;String, Object&gt;&gt; queryStudentsListMap() &#123; String sql = "select * from student"; return this.jdbcTemplate.queryForList(sql); &#125; @Override public Student queryStudentBySno(String sno) &#123; String sql = "select * from student where sno = ?"; Object[] args = &#123; sno &#125;; int[] argTypes = &#123; Types.VARCHAR &#125;; List&lt;Student&gt; studentList = this.jdbcTemplate.query(sql, args, argTypes, new StudentMapper()); if (studentList != null &amp;&amp; studentList.size() &gt; 0) &#123; return studentList.get(0); &#125; else &#123; return null; &#125; &#125;&#125;在引入spring-boot-starter-jdbc驱动后，可直接在类中注入JdbcTemplate。由上面代码可发现，对于保存操作有两种不同的方法，当插入的表字段较多的情况下，推荐使用NamedParameterJdbcTemplate。对于返回结果，可以直接使用List&lt;Map&lt;String, Object&gt;&gt;来接收，这也是个人比较推荐使用的方式，毕竟比较简单方便；也可以使用库表对应的实体对象来接收，不过这时候我们就需要手动创建一个实现了org.springframework.jdbc.core.RowMapper的对象，用于将实体对象属性和库表字段一一对应：12345678910public class StudentMapper implements RowMapper&lt;Student&gt;&#123; @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setSno(rs.getString("sno")); student.setName(rs.getString("sname")); student.setSex(rs.getString("ssex")); return student; &#125;&#125;测试最终项目目录如下图所示：启动项目，测试插入数据http://localhost:8080/web/addstudent?sno=004&amp;name=Maria&amp;sex=F：查询所有学生数据http://localhost:8080/web/queryallstudent:测试删除http://localhost:8080/web/deletestudent?sno=004：source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用MyBatis]]></title>
    <url>%2FSpring-Boot%20Mybatis.html</url>
    <content type="text"><![CDATA[整合MyBatis之前，先搭建一个基本的Spring Boot项目开启Spring Boot。然后引入mybatis-spring-boot-starter和数据库连接驱动（这里使用关系型数据库Oracle 11g）。mybatis-spring-boot-starter在pom中引入：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;不同版本的Spring Boot和MyBatis版本对应不一样，具体可查看官方文档：http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/。通过dependency:tree命令查看mybatis-spring-boot-starter都有哪些隐性依赖：123456789+- org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:1.3.1:compile| +- org.springframework.boot:spring-boot-starter-jdbc:jar:1.5.9.RELEASE:compile| | +- org.apache.tomcat:tomcat-jdbc:jar:8.5.23:compile| | | \- org.apache.tomcat:tomcat-juli:jar:8.5.23:compile| | \- org.springframework:spring-jdbc:jar:4.3.13.RELEASE:compile| | \- org.springframework:spring-tx:jar:4.3.13.RELEASE:compile| +- org.mybatis.spring.boot:mybatis-spring-boot-autoconfigure:jar:1.3.1:compile| +- org.mybatis:mybatis:jar:3.4.5:compile| \- org.mybatis:mybatis-spring:jar:1.3.1:compile可发现其包含了spring-boot-starter-jdbc依赖，默认使用tomcat-jdbc数据源。引入ojdbc6由于版权的原因，我们需要将ojdbc6.jar依赖安装到本地的maven仓库，然后才可以在pom中进行配置。下载ojdbc6.jar文件后，将其放到比较好找的目录下，比如D盘根目录。然后运行以下命令：123456789101112131415C:\Users\Administrator&gt;mvn install:install-file -Dfile=D:/ojdbc6.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=6.0 -Dpackaging=jar -DgeneratePom=true...[INFO] --- maven-install-plugin:2.4:install-file (default-cli) @ standalone-pom ---[INFO] Installing D:\ojdbc6.jar to D:\m2\repository\com\oracle\ojdbc6\6.0\ojdbc6-6.0.jar[INFO] Installing C:\Users\ADMINI~1\AppData\Local\Temp\mvninstall9103688544010617483.pom to D:\m2\repository\com\oracle\ojdbc6\6.0\ojdbc6-6.0.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.940 s[INFO] Finished at: 2017-08-13T15:06:38+08:00[INFO] Final Memory: 6M/145M[INFO] ------------------------------------------------------------------------接着在pom中引入：12345&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;6.0&lt;/version&gt;&lt;/dependency&gt;这里的groupid就是你之前安装时指定的-Dgroupid的值，artifactid就是你安装时指定的-Dartifactid的值，version也一样。Druid数据源Druid是一个关系型数据库连接池，是阿里巴巴的一个开源项目，地址：https://github.com/alibaba/druid。Druid不但提供连接池的功能，还提供监控功能，可以实时查看数据库连接池和SQL查询的工作情况。配置Druid依赖Druid为Spring Boot项目提供了对应的starter：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;Druid数据源配置上面通过查看mybatis starter的隐性依赖发现，Spring Boot的数据源配置的默认类型是org.apache.tomcat.jdbc.pool.Datasource，为了使用Druid连接池，需要在application.yml下配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263server: context-path: /webspring: datasource: druid: # 数据库访问配置, 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@localhost:1521:ORCL username: scott password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select '1' from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, 'wall'用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.springboot.servie.* # WebStatFilter配置 web-stat-filter: enabled: true # 添加过滤规则 url-pattern: /* # 忽略过滤的格式 exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' # StatViewServlet配置 stat-view-servlet: enabled: true # 访问路径为/druid时，跳转到StatViewServlet url-pattern: /druid/* # 是否能够重置数据 reset-enable: false # 需要账号密码才能访问控制台 login-username: druid login-password: druid123 # IP白名单 # allow: 127.0.0.1 # IP黑名单（共同存在时，deny优先于allow） # deny: 192.168.1.218 # 配置StatFilter filter: stat: log-slow-sql: true上述配置不但配置了Druid作为连接池，而且还开启了Druid的监控功能。 其他配置可参考官方wiki——https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter此时，运行项目，访问http://localhost:8080/web/druid：输入账号密码即可看到Druid监控后台：关于Druid的更多说明，可查看官方wiki——https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98使用MyBatis使用的库表：123456789CREATE TABLE "SCOTT"."STUDENT" ( "SNO" VARCHAR2(3 BYTE) NOT NULL , "SNAME" VARCHAR2(9 BYTE) NOT NULL , "SSEX" CHAR(2 BYTE) NOT NULL );INSERT INTO "SCOTT"."STUDENT" VALUES ('001', 'KangKang', 'M ');INSERT INTO "SCOTT"."STUDENT" VALUES ('002', 'Mike', 'M ');INSERT INTO "SCOTT"."STUDENT" VALUES ('003', 'Jane', 'F ');创建对应实体：1234567public class Student implements Serializable&#123; private static final long serialVersionUID = -339516038496531943L; private String sno; private String name; private String sex; // get,set略&#125;创建一个包含基本CRUD的StudentMapper：123456public interface StudentMapper &#123; int add(Student student); int update(Student student); int deleteByIds(String sno); Student queryStudentById(Long id);&#125;StudentMapper的实现可以基于xml也可以基于注解。使用注解方式继续编辑StudentMapper：12345678910111213141516171819@Component@Mapperpublic interface StudentMapper &#123; @Insert("insert into student(sno,sname,ssex) values(#&#123;sno&#125;,#&#123;name&#125;,#&#123;sex&#125;)") int add(Student student); @Update("update student set sname=#&#123;name&#125;,ssex=#&#123;sex&#125; where sno=#&#123;sno&#125;") int update(Student student); @Delete("delete from student where sno=#&#123;sno&#125;") int deleteBysno(String sno); @Select("select * from student where sno=#&#123;sno&#125;") @Results(id = "student",value= &#123; @Result(property = "sno", column = "sno", javaType = String.class), @Result(property = "name", column = "sname", javaType = String.class), @Result(property = "sex", column = "ssex", javaType = String.class) &#125;) Student queryStudentBySno(String sno);简单的语句只需要使用@Insert、@Update、@Delete、@Select这4个注解即可，动态SQL语句需要使用@InsertProvider、@UpdateProvider、@DeleteProvider、@SelectProvider等注解。具体可参考MyBatis官方文档：http://www.mybatis.org/mybatis-3/zh/java-api.html。使用xml方式使用xml方式需要在application.yml中进行一些额外的配置：1234567mybatis: # type-aliases扫描路径 # type-aliases-package: # mapper xml实现扫描路径 mapper-locations: classpath:mapper/*.xml property: order: BEFORE测试接下来编写Service：123456public interface StudentService &#123; int add(Student student); int update(Student student); int deleteBysno(String sno); Student queryStudentBySno(String sno);&#125;实现类：12345678910111213141516171819202122232425@Service("studentService")public class StudentServiceImp implements StudentService&#123; @Autowired private StudentMapper studentMapper; @Override public int add(Student student) &#123; return this.studentMapper.add(student); &#125; @Override public int update(Student student) &#123; return this.studentMapper.update(student); &#125; @Override public int deleteBysno(String sno) &#123; return this.studentMapper.deleteBysno(sno); &#125; @Override public Student queryStudentBySno(String sno) &#123; return this.studentMapper.queryStudentBySno(sno); &#125;&#125;编写controller：1234567891011@RestControllerpublic class TestController &#123; @Autowired private StudentService studentService; @RequestMapping( value = "/querystudent", method = RequestMethod.GET) public Student queryStudentBySno(String sno) &#123; return this.studentService.queryStudentBySno(sno); &#125;&#125;完整的项目目录如下图所示：启动项目访问：http://localhost:8080/web/querystudent?sno=001：查看SQL监控情况：可看到其记录的就是刚刚访问/querystudent得到的SQL。source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>MyBatis</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot一些基础配置]]></title>
    <url>%2FSpring-Boot%20basic%20config.html</url>
    <content type="text"><![CDATA[定制BannerSpring Boot项目在启动的时候会有一个默认的启动图案：1234567 . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.9.RELEASE)我们可以把这个图案修改为自己想要的。在src/main/resources目录下新建banner.txt文件，然后将自己的图案黏贴进去即可。ASCII图案可通过网站http://www.network-science.de/ascii/一键生成，比如输入mrbird生成图案后复制到banner.txt，启动项目，eclipse控制台输出如下：12345678 _ _ _ _ _ _ / \ / \ / \ / \ / \ / \ ( m | r | b | i | r | d ) \_/ \_/ \_/ \_/ \_/ \_/ ...2017-08-12 10:11:25.952 INFO 7160 --- [main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-08-12 10:11:26.057 INFO 7160 --- [main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-08-12 10:11:26.064 INFO 7160 --- [main] com.springboot.demo.DemoApplication : Started DemoApplication in 3.933 seconds (JVM running for 4.241)banner也可以关闭，在main方法中：12345public static void main(String[] args) &#123; SpringApplication app = new SpringApplication(DemoApplication.class); app.setBannerMode(Mode.OFF); app.run(args);&#125;全局配置文件在src/main/resources目录下，Spring Boot提供了一个名为application.properties的全局配置文件，可对一些默认配置的配置值进行修改。附：application.properties中可配置所有官方属性自定义属性值Spring Boot允许我们在application.properties下自定义一些属性，比如：12mrbird.blog.name=mrbird's blogmrbird.blog.title=Spring Boot定义一个BlogProperties Bean，通过@Value(&quot;${属性名}&quot;)来加载配置文件中的属性值：1234567891011@Componentpublic class BlogProperties &#123; @Value("$&#123;mrbird.blog.name&#125;") private String name; @Value("$&#123;mrbird.blog.title&#125;") private String title; // get,set略 &#125;编写IndexController，注入该Bean：12345678910@RestControllerpublic class IndexController &#123; @Autowired private BlogProperties blogProperties; @RequestMapping("/") String index() &#123; return blogProperties.getName()+"——"+blogProperties.getTitle(); &#125;&#125;启动项目，访问http://localhost:8080，页面显示如下：在属性非常多的情况下，也可以定义一个和配置文件对应的Bean：123456@ConfigurationProperties(prefix="mrbird.blog")public class ConfigBean &#123; private String name; private String title; // get,set略&#125;通过注解@ConfigurationProperties(prefix=&quot;mrbird.blog&quot;)指明了属性的通用前缀，通用前缀加属性名和配置文件的属性名一一对应。除此之外还需在Spring Boot入口类加上注解@EnableConfigurationProperties({ConfigBean.class})来启用该配置：12345678@SpringBootApplication@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;之后便可在IndexController中注入该Bean，并使用了：12345678910@RestControllerpublic class IndexController &#123; @Autowired private ConfigBean configBean; @RequestMapping("/") String index() &#123; return configBean.getName()+"——"+configBean.getTitle(); &#125;&#125;属性间的引用在application.properties配置文件中，各个属性可以相互引用，如下：123mrbird.blog.name=mrbird&apos;s blogmrbird.blog.title=Spring Bootmrbird.blog.wholeTitle=$&#123;mrbird.blog.name&#125;--$&#123;mrbird.blog.title&#125;自定义配置文件除了可以在application.properties里配置属性，我们还可以自定义一个配置文件。在src/main/resources目录下新建一个test.properties:12test.name=KangKangtest.age=25定义一个对应该配置文件的Bean：123456789@Configuration@ConfigurationProperties(prefix="test")@PropertySource("classpath:test.properties")@Componentpublic class TestConfigBean &#123; private String name; private int age; // get,set略&#125;注解@PropertySource(&quot;classpath:test.properties&quot;)指明了使用哪个配置文件。要使用该配置Bean，同样也需要在入口类里使用注解@EnableConfigurationProperties({TestConfigBean.class})来启用该配置。通过命令行设置属性值在运行Spring Boot jar文件时，可以使用命令java -jar xxx.jar --server.port=8081来改变端口的值。这条命令等价于我们手动到application.properties中修改（如果没有这条属性的话就添加）server.port属性的值为8081。如果不想项目的配置被命令行修改，可以在入口文件的main方法中进行如下设置：12345public static void main(String[] args) &#123; SpringApplication app = new SpringApplication(Application.class); app.setAddCommandLineProperties(false); app.run(args);&#125;使用xml配置虽然Spring Boot并不推荐我们继续使用xml配置，但如果出现不得不使用xml配置的情况，Spring Boot允许我们在入口类里通过注解@ImportResource({&quot;classpath:some-application.xml&quot;})来引入xml配置文件。Profile配置Profile用来针对不同的环境下使用不同的配置文件，多环境配置文件必须以application-{profile}.properties的格式命，其中{profile}为环境标识。比如定义两个配置文件：application-dev.properties：开发环境1server.port=8080application-prod.properties：生产环境1server.port=8081至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。如：spring.profiles.active=dev就会加载application-dev.properties配置文件内容。可以在运行jar文件的时候使用命令java -jar xxx.jar --spring.profiles.active={profile}切换不同的环境配置。source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启Spring Boot]]></title>
    <url>%2F%E5%BC%80%E5%90%AFSpring-Boot.html</url>
    <content type="text"><![CDATA[Spring Boot是在Spring框架上创建的一个全新的框架，其设计目的是简化Spring应用的搭建和开发过程。开启Spring Boot有许多种方法可供选择，这里仅介绍使用http://start.spring.io/来构建一个简单的Spring Boot项目。生成项目文件访问http://start.spring.io/，页面显示如下：这里选择以Maven构建，语言选择Java，Spring Boot版本为1.5.9。然后点击Switch to the full version，可看到更多的配置以及依赖选择：在项目信息里选择以jar包的方式部署，Java版本为7。在页面的下方还可以选择诸多的依赖，这里仅选择web进行演示：最后点击页面的generate project按钮生成项目文件。文件下载后是一个压缩包，进行解压然后使用eclipse以Maven项目的形式导入。导入后eclipse会自动编译项目并下载相应的依赖，项目目录如下所示：简单演示项目根目录下生成了一个artifactId+Application命名规则的入口类，为了演示简单，不再新建控制器，直接在入口类中编写代码：1234567891011121314151617181920package com.springboot.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class DemoApplication &#123; @RequestMapping("/") String index() &#123; return "hello spring boot"; &#125; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125;然后右键点击DemoAppliction，选择run as → Java Application：访问http://localhost:8080，页面显示如下：打包发布在eclipse中右击项目，选择run as → Maven build…，如下图所示：在Goals中输入clean package命令，然后点击下方的run就将项目打包成jar包（初次打包会自动下载一些依赖）。打包完毕后可看到项目目录target文件夹下生成了一个jar文件：生成jar包后，cd到target目录下，执行以下命令：访问http://localhost:8080，效果如上。聊聊pom.xml打开pom.xml可看到配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;spring-boot-starter-parentspring-boot-starter-parent指定了当前项目为一个Spring Boot项目，它提供了诸多的默认Maven依赖，具体可查看目录D:\m2\repository\org\springframework\boot\spring-boot-dependencies\1.5.9.RELEASE下的spring-boot-dependencies-1.5.9.RELEASE.pom文件，这里仅截取一小部分：1234567891011121314151617181920212223&lt;properties&gt;... &lt;spring-security.version&gt;4.2.3.RELEASE&lt;/spring-security.version&gt; &lt;spring-security-jwt.version&gt;1.0.8.RELEASE&lt;/spring-security-jwt.version&gt; &lt;spring-security-oauth.version&gt;2.0.14.RELEASE&lt;/spring-security-oauth.version&gt; &lt;spring-session.version&gt;1.3.1.RELEASE&lt;/spring-session.version&gt; &lt;spring-social.version&gt;1.1.4.RELEASE&lt;/spring-social.version&gt; &lt;spring-social-facebook.version&gt;2.0.3.RELEASE&lt;/spring-social-facebook.version&gt; &lt;spring-social-linkedin.version&gt;1.0.2.RELEASE&lt;/spring-social-linkedin.version&gt; &lt;spring-social-twitter.version&gt;1.1.2.RELEASE&lt;/spring-social-twitter.version&gt; &lt;spring-ws.version&gt;2.4.2.RELEASE&lt;/spring-ws.version&gt; &lt;sqlite-jdbc.version&gt;3.15.1&lt;/sqlite-jdbc.version&gt; &lt;statsd-client.version&gt;3.1.0&lt;/statsd-client.version&gt; &lt;sun-mail.version&gt;$&#123;javax-mail.version&#125;&lt;/sun-mail.version&gt; &lt;thymeleaf.version&gt;2.1.6.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-extras-springsecurity4.version&gt;2.1.3.RELEASE&lt;/thymeleaf-extras-springsecurity4.version&gt; &lt;thymeleaf-extras-conditionalcomments.version&gt;2.1.2.RELEASE&lt;/thymeleaf-extras-conditionalcomments.version&gt; &lt;thymeleaf-layout-dialect.version&gt;1.4.0&lt;/thymeleaf-layout-dialect.version&gt; &lt;thymeleaf-extras-data-attribute.version&gt;1.3&lt;/thymeleaf-extras-data-attribute.version&gt; &lt;thymeleaf-extras-java8time.version&gt;2.1.0.RELEASE&lt;/thymeleaf-extras-java8time.version&gt; &lt;tomcat.version&gt;8.5.23&lt;/tomcat.version&gt;... &lt;/properties&gt;需要说明的是，并非所有在&lt;properties&gt;标签中配置了版本号的依赖都有被启用，其启用与否取决于您是否配置了相应的starter。比如tomcat这个依赖就是spring-boot-starter-web的传递性依赖（下面将会描述到）。当然，我们可以手动改变这些依赖的版本。比如我想把thymeleaf的版本改为3.0.0.RELEASE，我们可以在pom.xml中进行如下配置：123&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.0.RELEASE&lt;/thymeleaf.version&gt;&lt;/properties&gt;spring-boot-starter-webSpring Boot提供了许多开箱即用的依赖模块，这些模块都是以spring-boot-starter-XX命名的。比如要开启Spring Boot的web功能，只需要在pom.xml中配置spring-boot-starter-web即可：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;因为其依赖于spring-boot-starter-parent，所以这里可以不用配置version。保存后Maven会自动帮我们下载spring-boot-starter-web模块所包含的jar文件。如果需要具体查看spring-boot-starter-web包含了哪些依赖，我们可以右键项目选择run as → Maven Build…，在Goals中输入命令dependency:tree，然后点击run即可在eclipse控制台查看到如下信息：1234567891011121314151617181920212223242526272829[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:1.5.9.RELEASE:compile[INFO] | +- org.springframework.boot:spring-boot-starter:jar:1.5.9.RELEASE:compile[INFO] | | +- org.springframework.boot:spring-boot:jar:1.5.9.RELEASE:compile[INFO] | | +- org.springframework.boot:spring-boot-autoconfigure:jar:1.5.9.RELEASE:compile[INFO] | | +- org.springframework.boot:spring-boot-starter-logging:jar:1.5.9.RELEASE:compile[INFO] | | | +- ch.qos.logback:logback-classic:jar:1.1.11:compile[INFO] | | | | \- ch.qos.logback:logback-core:jar:1.1.11:compile[INFO] | | | +- org.slf4j:jcl-over-slf4j:jar:1.7.25:compile[INFO] | | | +- org.slf4j:jul-to-slf4j:jar:1.7.25:compile[INFO] | | | \- org.slf4j:log4j-over-slf4j:jar:1.7.25:compile[INFO] | | \- org.yaml:snakeyaml:jar:1.17:runtime[INFO] | +- org.springframework.boot:spring-boot-starter-tomcat:jar:1.5.9.RELEASE:compile[INFO] | | +- org.apache.tomcat.embed:tomcat-embed-core:jar:8.5.23:compile[INFO] | | | \- org.apache.tomcat:tomcat-annotations-api:jar:8.5.23:compile[INFO] | | +- org.apache.tomcat.embed:tomcat-embed-el:jar:8.5.23:compile[INFO] | | \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:8.5.23:compile[INFO] | +- org.hibernate:hibernate-validator:jar:5.3.6.Final:compile[INFO] | | +- javax.validation:validation-api:jar:1.1.0.Final:compile[INFO] | | +- org.jboss.logging:jboss-logging:jar:3.3.1.Final:compile[INFO] | | \- com.fasterxml:classmate:jar:1.3.4:compile[INFO] | +- com.fasterxml.jackson.core:jackson-databind:jar:2.8.10:compile[INFO] | | +- com.fasterxml.jackson.core:jackson-annotations:jar:2.8.0:compile[INFO] | | \- com.fasterxml.jackson.core:jackson-core:jar:2.8.10:compile[INFO] | +- org.springframework:spring-web:jar:4.3.13.RELEASE:compile[INFO] | | +- org.springframework:spring-aop:jar:4.3.13.RELEASE:compile[INFO] | | +- org.springframework:spring-beans:jar:4.3.13.RELEASE:compile[INFO] | | \- org.springframework:spring-context:jar:4.3.13.RELEASE:compile[INFO] | \- org.springframework:spring-webmvc:jar:4.3.13.RELEASE:compile[INFO] | \- org.springframework:spring-expression:jar:4.3.13.RELEASE:compile上述这些依赖都是隐式依赖于spring-boot-starter-web，我们也可以手动排除一些我们不需要的依赖。比如spring-boot-starter-web默认集成了tomcat，假如我们想把它换为jetty，可以在pom.xml中spring-boot-starter-web下排除tomcat依赖，然后手动引入jetty依赖：1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;tips：依赖的坐标可以到上述的spring-boot-dependencies-1.5.9.RELEASE.pom文件里查找。再次运行dependency:tree：123456789101112131415161718192021222324252627282930[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:1.5.9.RELEASE:compile...[INFO] +- org.springframework.boot:spring-boot-starter-jetty:jar:1.5.9.RELEASE:compile[INFO] | +- org.eclipse.jetty:jetty-servlets:jar:9.4.7.v20170914:compile[INFO] | | +- org.eclipse.jetty:jetty-continuation:jar:9.4.7.v20170914:compile[INFO] | | +- org.eclipse.jetty:jetty-http:jar:9.4.7.v20170914:compile[INFO] | | +- org.eclipse.jetty:jetty-util:jar:9.4.7.v20170914:compile[INFO] | | \- org.eclipse.jetty:jetty-io:jar:9.4.7.v20170914:compile[INFO] | +- org.eclipse.jetty:jetty-webapp:jar:9.4.7.v20170914:compile[INFO] | | +- org.eclipse.jetty:jetty-xml:jar:9.4.7.v20170914:compile[INFO] | | \- org.eclipse.jetty:jetty-servlet:jar:9.4.7.v20170914:compile[INFO] | | \- org.eclipse.jetty:jetty-security:jar:9.4.7.v20170914:compile[INFO] | | \- org.eclipse.jetty:jetty-server:jar:9.4.7.v20170914:compile[INFO] | +- org.eclipse.jetty.websocket:websocket-server:jar:9.4.7.v20170914:compile[INFO] | | +- org.eclipse.jetty.websocket:websocket-common:jar:9.4.7.v20170914:compile[INFO] | | | \- org.eclipse.jetty.websocket:websocket-api:jar:9.4.7.v20170914:compile[INFO] | | +- org.eclipse.jetty.websocket:websocket-client:jar:9.4.7.v20170914:compile[INFO] | | | \- org.eclipse.jetty:jetty-client:jar:9.4.7.v20170914:compile[INFO] | | \- org.eclipse.jetty.websocket:websocket-servlet:jar:9.4.7.v20170914:compile[INFO] | | \- javax.servlet:javax.servlet-api:jar:3.1.0:compile[INFO] | +- org.eclipse.jetty.websocket:javax-websocket-server-impl:jar:9.4.7.v20170914:compile[INFO] | | +- org.eclipse.jetty:jetty-annotations:jar:9.4.7.v20170914:compile[INFO] | | | +- org.eclipse.jetty:jetty-plus:jar:9.4.7.v20170914:compile[INFO] | | | +- javax.annotation:javax.annotation-api:jar:1.2:compile[INFO] | | | +- org.ow2.asm:asm:jar:5.1:compile[INFO] | | | \- org.ow2.asm:asm-commons:jar:5.1:compile[INFO] | | | \- org.ow2.asm:asm-tree:jar:5.1:compile[INFO] | | +- org.eclipse.jetty.websocket:javax-websocket-client-impl:jar:9.4.7.v20170914:compile[INFO] | | \- javax.websocket:javax.websocket-api:jar:1.0:compile[INFO] | \- org.mortbay.jasper:apache-el:jar:8.0.33:compile可看到tomcat已被替换为了jetty。spring-boot-maven-pluginspring-boot-maven-plugin为Spring Boot Maven插件，提供了：把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。搜索public static void main()方法来标记为可运行类。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Thymeleaf3国际化]]></title>
    <url>%2FSpring-Tymeleaf3%E5%9B%BD%E9%99%85%E5%8C%96.html</url>
    <content type="text"><![CDATA[Spring+Thymeleaf3国际化配置国际化过程很简单，只需要在src/main/resources路径下定义不同语言环境的配置文件就好了，配置文件需以message开头，加上语言缩写后缀。比如定义一个英文配置：src/main/resources/message_en.properties；中文环境：src/main/resources/message_zh_CN.properties；默认配置（就是都没匹配上的时候采用）：src/main/resources/message.properties。定义一个简单的HTML页面用于测试：12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;home&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p data-th-utext="#&#123;home.welcome&#125;"&gt;home&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;其中message_en.properties配置如下：1home.welcome=This is &lt;b&gt;home&lt;/b&gt; page.中文环境配置message_zh_CN.properties：1home.welcome=\u4F60\u597D\uFF0C\u8FD9\u662F&lt;b&gt;\u4E3B\u9875&lt;/b&gt;启动项目，访问该页面：将浏览器的语言环境设置为英文：刷新页面如下：有些版本可能需要手动配置MessageConfiguration：1234567891011121314151617import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ResourceBundleMessageSource;@Configurationpublic class I18nConfiguration &#123; @Bean public ResourceBundleMessageSource messageSource()&#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setUseCodeAsDefaultMessage(true); messageSource.setFallbackToSystemLocale(false); messageSource.setBasenames("message"); messageSource.setDefaultEncoding("UTF-8"); messageSource.setCacheSeconds(2); return messageSource; &#125;&#125;我们还可以在properties文件中使用占位符：1home.welcome=hello,&#123;0&#125;页面：1&lt;p data-th-utext="#&#123;home.welcome($&#123;user.name&#125;)&#125;"&gt;home&lt;/p&gt;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring4中配置Thymeleaf3视图]]></title>
    <url>%2FSpring4%E4%B8%AD%E9%85%8D%E7%BD%AEThymeleaf3%E8%A7%86%E5%9B%BE.html</url>
    <content type="text"><![CDATA[引入必要的依赖文件：123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf/thymeleaf-spring4 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring4&lt;/artifactId&gt; &lt;version&gt;3.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;配置Thymeleaf试图解析器：1234567891011121314151617&lt;!-- Thymeleaf视图解析器 --&gt;&lt;bean id="viewResolver" class="org.thymeleaf.spring4.view.ThymeleafViewResolver" p:templateEngine-ref="templateEngine" p:characterEncoding="UTF-8" /&gt;&lt;!-- 模板引擎 --&gt;&lt;bean id="templateEngine" class="org.thymeleaf.spring4.SpringTemplateEngine" p:templateResolver-ref="templateResolver" /&gt;&lt;!-- 模板解析器 --&gt; &lt;bean id="templateResolver" class="org.thymeleaf.templateresolver.ServletContextTemplateResolver" p:prefix="/WEB-INF/templates/" p:suffix=".html" p:templateMode="HTML5" p:cacheable="false" p:characterEncoding="UTF-8"/&gt;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring4配置多数据源]]></title>
    <url>%2FSpring4%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90.html</url>
    <content type="text"><![CDATA[Spring在每次操作数据库的时候都会通过AbstractRoutingDataSource类中的determineTargetDataSource()方法获取当前数据源，所以可以通过继承AbstractRoutingDataSource并重写determineTargetDataSource()方法来实现多数据源的配置。定义一个DynamicDataSource类，继承AbstractRoutingDataSource：123456789package cc.mrbird.datasource;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DatabaseContextHolder.getCustomerType(); &#125; &#125;其中DatabaseContextHolder用于保存当前使用的数据库名称：1234567891011121314151617package cc.mrbird.datasource;public class DatabaseContextHolder &#123; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;(); public static void setCustomerType(String customerType) &#123; contextHolder.set(customerType); &#125; public static String getCustomerType() &#123; return contextHolder.get(); &#125; public static void clearCustomerType() &#123; contextHolder.remove(); &#125; &#125;定义一个数据库名常量类：1234567package cc.mrbird.datasource;public class DataSourceConst &#123; public static final String DB1 = "dataSource1"; public static final String DB2 = "dataSource2"; &#125;dataSource1和dataSource2为在Spring上下文配置文件applicationContext.xml中配置的两个数据源：123456789101112131415161718192021222324252627&lt;bean id="dataSource1" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="oracle.jdbc.driver.OracleDriver" /&gt; &lt;property name="jdbcUrl" value="jdbc:oracle:thin:@192.168.140.139:1521:orcl"&gt;&lt;/property&gt; &lt;property name="user" value="test"&gt;&lt;/property&gt; &lt;property name="password" value="test_123"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="150" /&gt; &lt;property name="minPoolSize" value="5" /&gt; &lt;property name="initialPoolSize" value="10" /&gt; &lt;property name="maxIdleTime" value="60" /&gt; &lt;property name="acquireIncrement" value="3" /&gt; &lt;property name="maxStatements" value="0" /&gt; &lt;property name="idleConnectionTestPeriod" value="60" /&gt;&lt;/bean&gt; &lt;bean id="dataSource2" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="oracle.jdbc.driver.OracleDriver" /&gt; &lt;property name="jdbcUrl" value="jdbc:oracle:thin:@192.168.140.148:1521:PISDATA"&gt;&lt;/property&gt; &lt;property name="user" value="test"&gt;&lt;/property&gt; &lt;property name="password" value="test_456"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="150" /&gt; &lt;property name="minPoolSize" value="5" /&gt; &lt;property name="initialPoolSize" value="10" /&gt; &lt;property name="maxIdleTime" value="60" /&gt; &lt;property name="acquireIncrement" value="3" /&gt; &lt;property name="maxStatements" value="0" /&gt; &lt;property name="idleConnectionTestPeriod" value="60" /&gt;&lt;/bean&gt;接着配置动态数据源，类型为上面定义的DynamicDataSource类：123456789&lt;bean id="dynamicDataSource" class="cc.mrbird.datasource.DynamicDataSource"&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry value-ref="dataSource1" key="dataSource1"&gt;&lt;/entry&gt; &lt;entry value-ref="dataSource2" key="dataSource2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultTargetDataSource" ref="dataSource1" /&gt; &lt;/bean&gt;默认的数据源为dataSource1。测试使用Spring提供的jdbcTemplate进行测试，完整的applicationContext.xml配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:p="http://www.springframework.org/schema/p" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.3.xsd" default-autowire="byName" &gt; &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package="cc.mrbird"/&gt; &lt;bean id="dataSource1" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="oracle.jdbc.driver.OracleDriver" /&gt; &lt;property name="jdbcUrl" value="jdbc:oracle:thin:@192.168.140.139:1521:orcl"&gt;&lt;/property&gt; &lt;property name="user" value="test"&gt;&lt;/property&gt; &lt;property name="password" value="test_123"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="150" /&gt; &lt;property name="minPoolSize" value="5" /&gt; &lt;property name="initialPoolSize" value="10" /&gt; &lt;property name="maxIdleTime" value="60" /&gt; &lt;property name="acquireIncrement" value="3" /&gt; &lt;property name="maxStatements" value="0" /&gt; &lt;property name="idleConnectionTestPeriod" value="60" /&gt; &lt;/bean&gt; &lt;bean id="dataSource2" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="oracle.jdbc.driver.OracleDriver" /&gt; &lt;property name="jdbcUrl" value="jdbc:oracle:thin:@192.168.140.148:1521:PISDATA"&gt;&lt;/property&gt; &lt;property name="user" value="test"&gt;&lt;/property&gt; &lt;property name="password" value="test_456"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="150" /&gt; &lt;property name="minPoolSize" value="5" /&gt; &lt;property name="initialPoolSize" value="10" /&gt; &lt;property name="maxIdleTime" value="60" /&gt; &lt;property name="acquireIncrement" value="3" /&gt; &lt;property name="maxStatements" value="0" /&gt; &lt;property name="idleConnectionTestPeriod" value="60" /&gt; &lt;/bean&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate" abstract="false" lazy-init="false" autowire="default"&gt; &lt;property name="dataSource"&gt; &lt;ref bean="dynamicDataSource" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dynamicDataSource" class="cc.mrbird.datasource.DynamicDataSource"&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry value-ref="dataSource1" key="dataSource1"&gt;&lt;/entry&gt; &lt;entry value-ref="dataSource2" key="dataSource2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultTargetDataSource" ref="dataSource1"/&gt; &lt;/bean&gt; &lt;!-- 事物注解开启 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dynamicDataSource" /&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt;&lt;/beans&gt;编写TestDynamicDataSourceDao接口：123456package cc.mrbird.dao;public interface TestDynamicDataSourceDao &#123; String getDataSource1Name(); String getDataSource2Name();&#125;其实现类：123456789101112131415161718192021222324252627282930313233343536373839package cc.mrbird.dao.impl;import org.springframework.jdbc.core.support.JdbcDaoSupport;import org.springframework.stereotype.Repository;import cc.mrbird.dao.TestDynamicDataSourceDao;import cc.mrbird.datasource.DataSourceConst;import cc.mrbird.datasource.DatabaseContextHolder;@Repository("testDynamicDataSourceDao")public class TestDynamicDataSourceDaoImpl extends JdbcDaoSupport implements TestDynamicDataSourceDao&#123; public String getDataSource1Name() &#123; String sql = ""; try &#123; sql = "select SYS_CONTEXT('USERENV','INSTANCE_NAME') from dual"; return this.getJdbcTemplate().queryForObject(sql, String.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getDataSource2Name() &#123; String sql = ""; try &#123; // 切换到数据源datasource2 DatabaseContextHolder.setCustomerType(DataSourceConst.DB2); sql = "select SYS_CONTEXT('USERENV','INSTANCE_NAME') from dual"; return this.getJdbcTemplate().queryForObject(sql, String.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 恢复到默认数据源datasource1 DatabaseContextHolder.clearCustomerType(); &#125; return null; &#125;&#125;编写Service接口及其实现类：1234567package cc.mrbird.service;public interface TestDynamicDataSourceService &#123; String getDataSource1Name(); String getDataSource2Name();&#125;12345678910111213141516171819202122package cc.mrbird.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import cc.mrbird.dao.TestDynamicDataSourceDao;import cc.mrbird.service.TestDynamicDataSourceService;@Service("testDynamicDataSourceService")public class TestDynamicDataSourceServiceImpl implements TestDynamicDataSourceService&#123; @Autowired private TestDynamicDataSourceDao dao; public String getDataSource1Name() &#123; return dao.getDataSource1Name(); &#125; public String getDataSource2Name() &#123; return dao.getDataSource2Name(); &#125;&#125;在控制器中测试：123456789101112131415161718192021222324package cc.mrbird.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import cc.mrbird.service.TestDynamicDataSourceService;@Controllerpublic class IndexController &#123; @Autowired private TestDynamicDataSourceService service; @RequestMapping("/test") public void test()&#123; String dataSource1Name = service.getDataSource1Name(); String dataSource2Name = service.getDataSource2Name(); System.out.println(dataSource1Name); System.out.println(dataSource2Name); &#125;&#125;页面访问/test路径，控制台输出：12orclpisdata总结配置JdbcTemplate多数据源的核心在于初始化JdbcTemplate的时候数据源配置为动态数据源，就如xml配置的那样：123456&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate" abstract="false" lazy-init="false" autowire="default"&gt; &lt;property name="dataSource"&gt; &lt;ref bean="dynamicDataSource" /&gt; &lt;/property&gt;&lt;/bean&gt;假如使用的是MyBatis，则只需要在配置sqlSessionFactory的时候指定数据源为动态数据源即可：1234&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean" scope="prototype"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt;&lt;/bean&gt;]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中使用@Scheduled注解任务调度]]></title>
    <url>%2FSpring%E4%B8%AD%E4%BD%BF%E7%94%A8-Scheduled%E6%B3%A8%E8%A7%A3%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.html</url>
    <content type="text"><![CDATA[spring-context包里提供的@Scheduled注解可以很方便的实现定时任务，在引入spring-context依赖后，在Spring xmlns中加入：1xmlns:task="http://www.springframework.org/schema/task"然后在xsi:schemaLocation中加入：12http://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task-4.3.xsd定义一个类，包含定时执行的方法：12345678910111213141516package cc.mrbird.timer;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class Timer &#123; @Scheduled(cron="0/5 * * * * ?") public void test()&#123; System.out.println("SimpleJob,triggered is "+ new SimpleDateFormat("HH:mm:ss").format((new Date()))); &#125;&#125;Timer类用@Component注解标注，以纳入Spring容器中。定时调用的方法使用@Scheduled标志，并用cron表达式定义了定时执行的规则。 接下来在Spring上下文配置中启动扫描，加载定时器：1234&lt;!-- 开启组件扫描 --&gt;&lt;context:component-scan base-package="cc.mrbird"/&gt;&lt;!-- spring 定时器 加载 --&gt;&lt;task:annotation-driven /&gt;启动项目，输出：12345678910111213SimpleJob,triggered is 14:33:10SimpleJob,triggered is 14:33:15SimpleJob,triggered is 14:33:20SimpleJob,triggered is 14:33:25SimpleJob,triggered is 14:33:30SimpleJob,triggered is 14:33:35SimpleJob,triggered is 14:33:40SimpleJob,triggered is 14:33:45SimpleJob,triggered is 14:33:50SimpleJob,triggered is 14:33:55SimpleJob,triggered is 14:34:00SimpleJob,triggered is 14:34:05...]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring4中使用Quartz]]></title>
    <url>%2FSpring4%E4%B8%AD%E4%BD%BF%E7%94%A8Quartz.html</url>
    <content type="text"><![CDATA[Spring提供了几个类用于简化在Spring中使用Quartz任务调度。这里使用的Spring版本为4.3.5，Quartz版本为2.2.1。除了搭建Spring MVC的几个依赖外，还需引入：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;在Quartz Scheduler中配置Job新建一个quartz-context.xml，用于配置Job，触发器等信息。通常使用MethodInvokingJobDetailFactoryBean来配置Job：1234&lt;bean id="simpleJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="simpleJob" /&gt; &lt;property name="targetMethod" value="printMessage" /&gt;&lt;/bean&gt;targetObject制定调用的Bean，targetMethod指定调用的方法。simpleJob Bean如下：123456789101112import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.stereotype.Component;@Component("simpleJob")public class SimpleJob &#123; public void printMessage() &#123; System.out.println("SimpleJob,triggered is "+ new SimpleDateFormat("HH:mm:ss").format((new Date()))); &#125;&#125;在Quartz Scheduler中配置触发规则两种方式配置触发规则：SimpleTrigger12345&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="simpleJobDetail" /&gt; &lt;property name="startDelay" value="1000" /&gt; &lt;property name="repeatInterval" value="2000" /&gt;&lt;/bean&gt;CronTrigger1234&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="simpleJobDetail" /&gt; &lt;property name="cronExpression" value="0/5 * * * * ?" /&gt;&lt;/bean&gt;配置SchedulerFactoryBean使用SchedulerFactoryBean将jobDetails和triggers配置在一起：12345678910111213&lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="jobDetails"&gt; &lt;list&gt; &lt;ref bean="simpleJobDetail" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="simpleTrigger" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;完整的quartz-context.xml配置如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:component-scan base-package="cc.mrbird.scheduling" /&gt; &lt;bean id="simpleJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="simpleJob" /&gt; &lt;property name="targetMethod" value="printMessage" /&gt; &lt;/bean&gt; &lt;!-- &lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt; --&gt;&lt;!-- &lt;property name="jobDetail" ref="simpleJobDetail" /&gt; --&gt;&lt;!-- &lt;property name="startDelay" value="1000" /&gt; --&gt;&lt;!-- &lt;property name="repeatInterval" value="2000" /&gt; --&gt;&lt;!-- &lt;/bean&gt; --&gt; &lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="simpleJobDetail" /&gt; &lt;property name="cronExpression" value="0/5 * * * * ?" /&gt; &lt;/bean&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="jobDetails"&gt; &lt;list&gt; &lt;ref bean="simpleJobDetail" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="cronTrigger" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;在web.xml中加入quartz-context.xml启动项：123456...&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml,classpath:quartz-context.xml&lt;/param-value&gt;&lt;/init-param&gt;...部署项目，启动后控制台输出：123456789101112131415SimpleJob,triggered is 17:43:35SimpleJob,triggered is 17:43:40SimpleJob,triggered is 17:43:45SimpleJob,triggered is 17:43:50SimpleJob,triggered is 17:43:55SimpleJob,triggered is 17:44:00SimpleJob,triggered is 17:44:05SimpleJob,triggered is 17:44:10SimpleJob,triggered is 17:44:15SimpleJob,triggered is 17:44:20SimpleJob,triggered is 17:44:25SimpleJob,triggered is 17:44:30SimpleJob,triggered is 17:44:35SimpleJob,triggered is 17:44:40...参考自http://websystique.com/spring/spring-4-quartz-scheduler-integration-example/]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz guide]]></title>
    <url>%2FQuartz-guide.html</url>
    <content type="text"><![CDATA[Quartz是一款开源的任务调度框架，对任务调度过程进行了高度的抽象，包含调度器（Scheduler），任务（Job）和触发器（Trigger）。Quartz在org.quartz.*中通过接口和类对这三个概念进行了描述（这里使用的Quartz版本为1.8.6）：Job：一个简单的接口，只包含一个void execute(JobExecutionContext context)抽象方法。实际开发中，通过实现该接口来定义需要执行的任务。JobExecutionContext提供了调度上下文信息。1234public interface Job &#123; void execute(JobExecutionContext context) throws JobExecutionException;&#125;JobDetail：包含多个构造函数，最常用的为JobDetail(String name, String group, Class jobClass)jobClass为实现了Job接口的类，name为任务在Scheduler中的名称，group为任务在Scheduler中的组名。组名默认为Scheduler.DEFAULT_GROUP。Trigger：一个类，用于描述触发Job执行的时间规则。包含：SimpleTrigger: 一次或者固定时间间隔周期的触发规则。CronTrigger：通过cron表达式描述出更为复杂的触发规则。Calendar：Quartz提供的日历类。一个Trigger可以和多个Calendar关联，以此来排除一些特殊的日期。Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail被注册到Scheduler中，二者在Scheduler中拥有各自的名称（name）和组名（group）。Trigger和JobDetail的名称和组名的组合必须唯一，但是Trigger的名称和组名的组合可以和JobDetail的相同，因为它们类型不同。一个Job可以绑定多个Trigger，反之不然。Job还有一个子接口：StatefulJob，其是一个没有方法的标签接口，代表有状态的任务。无状态任务：拥有JobDataMap复制，所以可以并发运行；有状态任务：共享一份JobDataMap，每次对JobDataMap的修改会被保存下来。所以前次的StatefulJob会阻塞下一次的StatefulJob。SimpleTriggerSimpleTrigger包含多个重载的构造器，可根据实际需求来选择。这里使用SimpleTrigger来演示触发一个JobDetail。首先定义一个简单的Job实现类，代表我们需要进行调度的任务：123456789101112131415import java.text.SimpleDateFormat;import java.util.Date;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;public class SimpleJob implements Job&#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println("TriggerName: "+context.getTrigger().getName()+ " Triggered time is: "+new SimpleDateFormat("HH:mm:ss").format((new Date()))); &#125;&#125;下面通过SimpleTrigger对SimpleJob进行调度：12345678910111213141516171819202122232425262728import java.util.Date;import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.SimpleTrigger;import org.quartz.impl.StdSchedulerFactory;public class SimpleTriggerRunner &#123; public static void main(String[] args) &#123; try &#123; JobDetail jobDetail = new JobDetail("job1","job_group1",SimpleJob.class); SimpleTrigger simpleTrigger = new SimpleTrigger("trigger1","trigger_group1"); simpleTrigger.setStartTime(new Date()); simpleTrigger.setRepeatInterval(2000); simpleTrigger.setRepeatCount(10); Scheduler scheduler = new StdSchedulerFactory().getScheduler(); scheduler.scheduleJob(jobDetail, simpleTrigger); scheduler.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;上面代码中做的事情主要有：通过JobDetail封装SimpleJob，同时指定其名称为job1，组名为job_group1；创建一个SimpleTrigger，并指定其名称为trigger1，组名为trigger_group1，触发启动时间为马上触发，时间间隔为2000毫秒，重复10次；接着创建了一个Scheduler实例，并且将JobDetail和Trigger实例注册到Scheduler中。运行代码，观察输出：1234567891011TriggerName: trigger1 Triggered time is: 16:27:07TriggerName: trigger1 Triggered time is: 16:27:09TriggerName: trigger1 Triggered time is: 16:27:11TriggerName: trigger1 Triggered time is: 16:27:13TriggerName: trigger1 Triggered time is: 16:27:15TriggerName: trigger1 Triggered time is: 16:27:17TriggerName: trigger1 Triggered time is: 16:27:19TriggerName: trigger1 Triggered time is: 16:27:21TriggerName: trigger1 Triggered time is: 16:27:23TriggerName: trigger1 Triggered time is: 16:27:25TriggerName: trigger1 Triggered time is: 16:27:27CronTriggerCronTrigger的调度规则基于Cron表达式。Cron表达式由6个或7个由空格分隔的时间字段：位置时间域名允许值允许的特殊字符1秒0-59, - * /2分钟0-59, - * /3小时0-23, - * /4日期1-31, - * ? / L W C5月份1-12, - * /6星期1-7, - * ? / L C #7年(可选)空值1970-2099, - * /其中特殊字符的含义如下：星号（*）：可用在所有字段中，表示对应时间域的每一个时刻。例如，*在分钟字段时，表示“每分钟”；问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；减号（-）：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；逗号（,）：表示一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；斜杠（/）：x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；L：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；如果L用在星期中，则表示一个星期的最后一天（也就是星期六，国外星期第一天为周天）。但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后一个星期X-1”，例如，6L表示该月的最后一个星期五，5L表示该月的最后一个星期四，以此类推。W：该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如15W表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意关联的匹配日期不能够跨月，如你指定1W，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天；LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日；井号（#）：该字符只能在星期字段中使用，表示当月某个工作日。如6#3表示当月的第三个星期五（6表示星期五，#3表示当前的第三个），而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发；C：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。下面给出一些完整的Cron表示式的实例：表示式说明“0 0 12 * * ? “每天12点运行“0 15 10 ? * *“每天10:15运行“0 15 10 * * ?”每天10:15运行“0 15 10 * * ? *“每天10:15运行“0 15 10 * * ? 2008”在2008年的每天10：15运行“0 * 14 * * ?”每天14点到15点之间每分钟运行一次，开始于14:00，结束于14:59。“0 0/5 14 * * ?”每天14点到15点每5分钟运行一次，开始于14:00，结束于14:55。“0 0/5 14,18 * * ?”每天14点到15点每5分钟运行一次，此外每天18点到19点每5钟也运行一次。“0 0-5 14 * * ?”每天14:00点到14:05，每分钟运行一次。“0 10,44 14 ? 3 WED”3月每周三的14:10分到14:44，每分钟运行一次。“0 15 10 ? * MON-FRI”每周一，二，三，四，五的10:15分运行。“0 15 10 15 * ?”每月15日10:15分运行。“0 15 10 L * ?”每月最后一天10:15分运行。“0 15 10 ? * 6L”每月最后一个星期五10:15分运行。“0 15 10 ? * 6L 2014-2016”在2014,2015,2016年每个月的最后一个星期五的10:15分运行。“0 15 10 ? * 6#3”每月第三个星期五的10:15分运行。附：在线Cron表达式生成器CronTrigger实例使用CronTrigger对simpleJob进行调度，使用Cron表达式制定调度规则，让其每5秒运行一次：123456789101112131415161718192021222324import org.quartz.CronExpression;import org.quartz.CronTrigger;import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.impl.StdSchedulerFactory;public class CronTriggerRunner &#123; public static void main(String[] args) &#123; try &#123; JobDetail jobDetail = new JobDetail("job2","job_group2",SimpleJob.class); CronTrigger cronTrigger = new CronTrigger("trigger2","trigger_group2"); CronExpression ce = new CronExpression("0/5 * * * * ?"); cronTrigger.setCronExpression(ce); Scheduler scheduler = new StdSchedulerFactory().getScheduler(); scheduler.scheduleJob(jobDetail, cronTrigger); scheduler.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;运行，观察输出：123456789101112131415TriggerName: trigger2 Triggered time is: 09:38:00TriggerName: trigger2 Triggered time is: 09:38:05TriggerName: trigger2 Triggered time is: 09:38:10TriggerName: trigger2 Triggered time is: 09:38:15TriggerName: trigger2 Triggered time is: 09:38:20TriggerName: trigger2 Triggered time is: 09:38:25TriggerName: trigger2 Triggered time is: 09:38:30TriggerName: trigger2 Triggered time is: 09:38:35TriggerName: trigger2 Triggered time is: 09:38:40TriggerName: trigger2 Triggered time is: 09:38:45TriggerName: trigger2 Triggered time is: 09:38:50TriggerName: trigger2 Triggered time is: 09:38:55TriggerName: trigger2 Triggered time is: 09:39:00TriggerName: trigger2 Triggered time is: 09:39:05...Calendar略。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Flex布局]]></title>
    <url>%2F%E5%88%9D%E8%AF%86Flex%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[传统的CSS布局方法中，一般使用float属性和display:table来实现布局，但在使用的过程中总有种无法随心所欲的感觉，元素的位置摆放总是显得不是那么的直观，而Flexbox很好的解决了这个问题。Flexbox俗称弹性盒子模型，在开始使用Flexbox之前，首先要声明一个Flex容器（Flex Container）。而Flex容器中的元素称为Flex项目（Flex Item）。声明一个Flex容器：1234567div &#123; display: flex;&#125;// 对于行内元素：div &#123; display: inline-flex;&#125;对于一个Flex容器，其存在两个轴。水平方向的称为主轴（main axis），竖直方向的称为交叉轴（cross axis）。如下图所示：FlexBox主要包含12个属性，其中Flex容器6个，Flex项目6个。Flex容器属性flex-directionflex-direction属性决定了项目的排列方向，语法如下：1flex-direction: row | row-reverse | column | column-reverse;可取的值有：row（默认值）：项目水平方向排列，起点在左端。row-reverse：项目水平方向排列，起点在右端。column：项目竖直方向排列，起点在上沿。column-reverse：项目竖直方向排列，起点在下沿。默认情况下，flex-direction的取值为row：See the Pen xrvQqe by wuyouzhuguli (@mrbird) on CodePen.当flex-direction属性的值为row-reverse时，项目的起点在右端：See the Pen yoLJYb by wuyouzhuguli (@mrbird) on CodePen.当flex-direction属性的值为column时，项目垂直排列，起点在上沿：See the Pen yoLJOX by wuyouzhuguli (@mrbird) on CodePen.当flex-direction属性的值为column-reverse时，项目垂直排列，起点在下沿：See the Pen OjJXXV by wuyouzhuguli (@mrbird) on CodePen.flex-wrapflex-wrap属性规定了项目在一条轴线上排不下时，是否换行。语法如下：1flex-wrap: nowrap | wrap | wrap-reverse;属性可取的值有：nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。flex-wrap默认取值为nowrap，即不换行，如果项目排列方向为水平方向，则项目宽度自动收缩（因为项目的flex-shrink属性值默认为1，即如果空间不足，该项目宽度将缩小。）：See the Pen KvKMNm by wuyouzhuguli (@mrbird) on CodePen.将flex-wrap属性值设置为warp时：See the Pen zdYBoj by wuyouzhuguli (@mrbird) on CodePen.将flex-wrap属性值设置为wrap-reverse时：See the Pen eEYzgV by wuyouzhuguli (@mrbird) on CodePen.当项目排列方向为竖直方向，如果一列排不下并且flex-wrap属性值为no-wrap时，项目将会超出容器的高度，项目并不会收缩。flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。justify-contentjustify-content属性定义了项目在主轴上的对齐方式。语法如下：1justify-content: flex-start | flex-end | center | space-between | space-around;属性可取的值有：flex-start（默认值）：左对齐。flex-end：右对齐。center： 居中。space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。默认情况下为左对齐，当justify-content属性值设为flex-end时：See the Pen vJYKgo by wuyouzhuguli (@mrbird) on CodePen.当justify-content属性值为center时：See the Pen probdW by wuyouzhuguli (@mrbird) on CodePen.当justify-content属性值为space-between时：See the Pen dzyXZB by wuyouzhuguli (@mrbird) on CodePen.当justify-content属性值为space-around时：See the Pen QMWEag by wuyouzhuguli (@mrbird) on CodePen.align-itemsalign-items属性定义项目在交叉轴上如何对齐。语法如下：1align-items: flex-start | flex-end | center | baseline | stretch;属性可取的值有：flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。当align-items属性值为flex-start时（将第2，4个项目高度设置为120px，以更好的区分各属性的效果）：See the Pen NvWrYp by wuyouzhuguli (@mrbird) on CodePen.当align-items属性值为flex-end时：See the Pen jLOrpG by wuyouzhuguli (@mrbird) on CodePen.当align-items属性值为center时：See the Pen XaWKvO by wuyouzhuguli (@mrbird) on CodePen.当align-items属性值为baseline时，项目沿着第一行文字的基线对齐：See the Pen YxzWMy by wuyouzhuguli (@mrbird) on CodePen.当align-items属性值为stretch（默认值）时，如果项目未设置高度或设为auto，将占满整个容器的高度。See the Pen aybZjX by wuyouzhuguli (@mrbird) on CodePen.align-contentalign-content属性定义了多根轴线（多行）的对齐方式。如果项目只有一根轴线，该属性不起作用。语法如下：1align-content: flex-start | flex-end | center | space-between | space-around | stretch;属性可取的值有：flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。当align-content属性值为flex-start时，项目交叉轴的起点对齐：See the Pen oeNzZx by wuyouzhuguli (@mrbird) on CodePen.当align-content属性值为flex-end时，项目交叉轴的终点对齐：See the Pen PKoGmJ by wuyouzhuguli (@mrbird) on CodePen.当align-content属性值为center时，项目交叉轴的中点对齐：See the Pen proEPQ by wuyouzhuguli (@mrbird) on CodePen.当align-content属性值为space-between时：See the Pen XaWjRL by wuyouzhuguli (@mrbird) on CodePen.当align-content属性值为space-around时：See the Pen oeNzwx by wuyouzhuguli (@mrbird) on CodePen.当align-content属性值为stretch（默认值），项目高度为auto时，项目将占满整个交叉轴：See the Pen vJYXZg by wuyouzhuguli (@mrbird) on CodePen.项目属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0，它可以接受一个正值，也可以接受一个负值。语法如下：1order: &lt;integer&gt;;默认情况下，因为项目的order属性都为0，所以排列顺序按照HTML源码进行排列，比如：123456&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;在FlexBox布局里，li默认按1，2，3，4的顺序排列，现在不改变HTML源码的情况下，将序号为1的li移到最末尾：See the Pen proRge by wuyouzhuguli (@mrbird) on CodePen.这里只需将第一个li的order属性值设为大于0的数即可。flex-growflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。语法如下：1flex-grow: &lt;number&gt;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）：See the Pen NvWdRr by wuyouzhuguli (@mrbird) on CodePen.从结果可以看到，这三个li的宽度都变大了，等分了外层ul的剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍：See the Pen EvxZNR by wuyouzhuguli (@mrbird) on CodePen.flex-shrinkflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。语法如下：1flex-shrink: &lt;number&gt;;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效：See the Pen vJYgxo by wuyouzhuguli (@mrbird) on CodePen.flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。基本语法如下：1flex-basis: &lt;length&gt; | auto;flex-basis可以手动的设置为一个合法的px值，这样项目原本的width将失效。比如，第一个li的宽度为70px，在将其flex-basis属性设置为140px之后：See the Pen YxzNEm by wuyouzhuguli (@mrbird) on CodePen.flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。语法如下：1align-self: auto | flex-start | flex-end | center | baseline | stretch;比如，将第二个li的aligh-self属性值设置为flex-end：See the Pen MvWJGV by wuyouzhuguli (@mrbird) on CodePen.]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3滤镜filter]]></title>
    <url>%2FCSS%E6%BB%A4%E9%95%9Cfilter.html</url>
    <content type="text"><![CDATA[CSS滤镜（filter）用于定义滤镜效果，也就是改变元素的透明度、对比度、亮度和模糊度等效果。其包含一系列的函数来实现各种滤镜效果，也可以将这些函数组合起来，以此达到更复杂的滤镜效果。blur()给图像设置高斯模糊的效果。默认值为0，接受css长度值，不能为百分数。比如给下面的背景图设置不同的模糊度，并对比结果：See the Pen gRNgzX by wuyouzhuguli (@mrbird) on CodePen.可见，长度值越大，效果越模糊。brightness()用于给图像设置亮暗程度，值为0%时，图像全黑；值为100%时，图像没有任何变化。比如给下面的背景图设置不同的亮度，并对比结果：See the Pen rwEyNO by wuyouzhuguli (@mrbird) on CodePen.contrast()调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。比如给下面的背景图设置不同的对比度，并对比结果：See the Pen EXBWVg by wuyouzhuguli (@mrbird) on CodePen.grayscale()将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。比如给下面的背景图设置不同的灰度值，并对比结果：See the Pen NgZpYK by wuyouzhuguli (@mrbird) on CodePen.hue-rotate()给图像应用色相旋转。angle值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。比如给下面的背景图设置不同的色相旋转值，并对比结果：See the Pen LLKWJd by wuyouzhuguli (@mrbird) on CodePen.invert()反转图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。若值未设置，值默认是0。比如给下面的背景图设置不同的反转值，并对比结果：See the Pen rwEyQm by wuyouzhuguli (@mrbird) on CodePen.opacity()转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。比如给下面的背景图设置不同的透明度，并对比结果：See the Pen EXBWrb by wuyouzhuguli (@mrbird) on CodePen.saturate()转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。超过100%的值是允许的，则有更高的饱和度。若值未设置，值默认是1。比如给下面的背景图设置不同的饱和度，并对比结果：See the Pen XgLMQa by wuyouzhuguli (@mrbird) on CodePen.sepia()将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。若未设置，值默认是0。比如给下面的背景图设置不同的褐色值，并对比结果：See the Pen owrZrP by wuyouzhuguli (@mrbird) on CodePen.drop-shadow()给图像设置一个阴影效果。该函数与已有的box-shadow属性很相似。不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。参数类型和box-shadow一致，这里就不演示啦。url()URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。比如通过url函数引入一个svg滤镜资源：1.effect &#123; filter: url(commonfilters.xml#large-blur) &#125;]]></content>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS媒体查询]]></title>
    <url>%2FCSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[一个媒体查询由一个可选的媒体类型和零个或多个使用媒体功能限制样式表范围的表达式组成, 例如宽度，高度和颜色等。这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。举个简单的例子：1234567891011&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel="stylesheet" media="(max-width: 800px)" href="example.css" /&gt;&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt;当媒体查询结果为true时，相应的样式就会被应用。需要注意的是，即使媒体查询结果为false，link还是会加载相应的css文件，只不过这份样式文件不会被应用罢了。媒体查询中，默认的媒体类型是all。常见的媒体类型有：媒体类型描述all用于所有的媒体设备。aural用于语音和音频合成器。braille用于盲人用点字法触觉回馈设备。embossed用于分页的盲人用点字法打印机。handheld用于小的手持的设备。print用于打印机。projection用于方案展示，比如幻灯片。screen用于电脑显示器。tty用于使用固定密度字母栅格的媒体，比如电传打字机和终端。tv用于电视机类型的设备。逻辑操作符媒体查询操作符包括and，not，only和or（也可以是逗号“，”）。andand操作符只有当各个查询都为true时，才返回true。比如，下面的媒体查询仅在可视区域宽度不小于700像素并且在横屏时有效：1@media (min-width: 700px) and (orientation: landscape) &#123; ... &#125;这里媒体类型默认为all，如果要将媒体类型限制为电脑屏幕，则改写媒体查询为：1@media tv and (min-width: 700px) and (orientation: landscape) &#123; ... &#125;notnot关键字应用于整个媒体查询，在媒体查询为假时返回真。比如下面的媒体查询在屏幕宽度大于700px并且非横屏时有效：1@media not (min-width: 700px) and (orientation: landscape) &#123; ... &#125;其等价于：1@media not ((min-width: 700px) and (orientation: landscape)) &#123; ... &#125;逗号分隔列表媒体查询中使用逗号分隔效果等同于 or 逻辑操作符。当使用逗号分隔的媒体查询时，如果任何一个媒体查询返回真，样式就是有效的。例如，如果你想在最小宽度为700像素或是横屏的手持设备上应用一组样式，你可以这样写：1@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125;onlyonly 关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式：1&lt;link rel="stylesheet" media="only screen and (color)" href="example.css" /&gt;常用媒体属性向所有能显示颜色的设备应用样式表：1@media all and (color) &#123; ... &#125;向所有黑白设备应用样式表：1@media all and (monochrome) &#123; ... &#125;向竖屏设备应用样式表：1@media all and (orientation: portrait) &#123; ... &#125;向横屏设备应用样式表：1@media all and (orientation: landscape) &#123; ... &#125;向最小像素密度为300dpi的设备应用样式表：1@media all and (min-resolution: 300dpi) &#123; ... &#125;宽度和高度属性上面例子中有出现，不再赘述。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 animation]]></title>
    <url>%2FCSS3-animation.html</url>
    <content type="text"><![CDATA[CSS3的animation属性可以绘制各种复杂的动画，animation属性由以下8种属性的简写形式： animation-name，animation-duration，animation-timing-function，animation-delay，animation-iteration-count，animation-direction 和 animation-fill-mode。下面一一介绍这八种属性。animation-nameCSS3中使用@keyframes定义动画的名称以及具体动画的关键帧。而animation-name属性则是用于指定使用哪个动画，比如使用@keyframes定义一个简单的动画：1234@-webkit-keyframes demo&#123; from &#123; left: 0; &#125; to &#123; left: 400px ;&#125;&#125;也可以使用百分比来定义关键帧位置：12345@-webkit-keyframes demo&#123; 0% &#123; left: 0; &#125; 50% &#123; left: 200px; &#125; 100% &#123; left: 400px; &#125;&#125;然后使用animation-name属性指定使用demo动画：123div &#123; -webkit-animation-name: demo;&#125;animation-durationanimation-duration指定对象动画的持续时间。属性值为正数，单位可以是秒(s)或者毫秒(ms)。默认值为0，表明动画不执行。比如：See the Pen QgRQgM by wuyouzhuguli (@mrbird) on CodePen.animation-timing-function设置对象动画的过渡类型，如果提供多个属性值，以逗号进行分隔。类似于transition-timing-function。语法如下：1animation-timing-function: linear | ease | ease-in | ease-out | ease-in-out | step-start | step-end | steps(&lt;number&gt;[, [ start | end ] ]?) | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) [, linear | ease | ease-in | ease-out | ease-in-out | step-start | step-end | steps(&lt;number&gt;[, [ start | end ] ]?) | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) ]*;属性可取的值有：ease：缓解效果，等同于cubic-bezier(0.25,0.1,0.25,1.0)函数，既立方贝塞尔。linear：线性效果，等同于cubic-bezier(0.0,0.0,1.0,1.0)函数。ease-in：渐显效果，等同于cubic-bezier(0.42,0,1.0,1.0)函数。ease-out：渐隐效果，等同于cubic-bezier(0,0,0.58,1.0)函数。ease-in-out：渐显渐隐效果，等同于cubic-bezier(0.42,0,0.58,1.0)函数。step-start：马上转跳到动画结束状态。step-end：保持动画开始状态，直到动画执行时间结束，马上转跳到动画结束状态。steps(&lt;number&gt;[, [ start | end ] ]?)：第一个参数number为指定的间隔数，即把动画分为n步阶段性展示，第二个参数默认为end，设置最后一步的状态，start为结束时的状态，end为开始时的状态，若设置与animation-fill-mode的效果冲突，而以animation-fill-mode的设置为动画结束的状态。cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)：特殊的立方贝塞尔曲线效果。各种效果对比：See the Pen WOBzLm by wuyouzhuguli (@mrbird) on CodePen.animation-delay设置动画延迟执行的时间。默认值0表示立即执行，正数为动画延迟一定时间，负数为截断一定时间内的动画。单位为秒(s)或毫秒(s)。具体实例：See the Pen zzQjOK by wuyouzhuguli (@mrbird) on CodePen.animation-iteration-count指定对象动画循环播放的次数。语法如下：1animation-iteration-count: &lt;number&gt;|infinite;值为number：自定义动画执行次数，设置值可为0或正整数。infinite：无限循环。See the Pen dREeoJ by wuyouzhuguli (@mrbird) on CodePen.animation-direction置对象动画循环播放次数大于1次时，动画是否反向运动。语法如下：1animation-direction: normal | reverse | alternate | alternate-reverse [, normal | reverse | alternate | alternate-reverse ]*;属性可取的值有：normal：正常方向。reverse：动画反向运行,方向始终与normal相反。（FF14.0.1以下不支持）。alternate：动画会循环正反方向交替运动，奇数次（1、3、5……）会正常运动，偶数次（2、4、6……）会反向运动，即所有相关联的值都会反向。alternate-reverse：动画从反向开始，再正反方向交替运动，运动方向始终与alternate定义的相反。（FF14.0.1以下不支持）。各个效果对比：See the Pen QgRrEL by wuyouzhuguli (@mrbird) on CodePen.animation-fill-mode设置对象动画时间之外的状态。语法如下：1animation-fill-mode: none | forwards | backwards | both;属性可取的值有：none：默认值。不设置对象动画之外的状态。forwards：结束后保持动画结束时的状态，但当animation-direction为0，则动画不执行，持续保持动画开始时的状态。backwards：结束后返回动画开始时的状态。both：结束后可遵循forwards和backwards两个规则。See the Pen KqLRap by wuyouzhuguli (@mrbird) on CodePen.animation-play-state设置对象动画的状态，语法如下：1animation-play-state: running | paused其中running为默认值，表示运行动画中；paused表示暂停动画。例如：See the Pen owRdwd by wuyouzhuguli (@mrbird) on CodePen.参考自http://isux.tencent.com/css3]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 transition]]></title>
    <url>%2FCSS3-transition.html</url>
    <content type="text"><![CDATA[transform呈现的是一种变形结果，而Transation呈现的是一种过渡，通俗点说就是一种动画转换过程，如渐显、渐弱、动画快慢等。transition可以和Transform同时使用。transition是一个复合属性，可以同时定义transition-property、transition-duration、transition-timing-function、transition-delay子属性值。transition-propertytransition-property设置要以动画方式变换的CSS属性。默认值all表示变换所有的属性，如果只针对单个或者多个CSS属性进行变换，就可以用这个属性来进行单独设置。语法如下：1transition-property: all | none | &lt;property&gt;[ ,&lt;property&gt; ]*例如：See the Pen ModvYa by wuyouzhuguli (@mrbird) on CodePen.transition-durationtransition-duration用来定义转换动画的时间长度，即从旧属性换到新属性花费的时间，单位为秒。默认情况下动画过渡时间为0秒。语法如下：1transition-duration:&lt;time&gt;[ ,&lt;time&gt;]*;例如：See the Pen OgYjXq by wuyouzhuguli (@mrbird) on CodePen.transition-delaytransition-delay可以设置动画延迟执行的时间，默认值0表示立即执行，时间可以是正数也可以是负数，负数表示截断规定时间内的动画。单位是秒，也可以是毫秒。语法如下：1transition-delay:&lt;time&gt;[ ,&lt;time&gt;]*;time的取值：0：不延迟，直接执行。正数：按照设置的时间延迟。负数：设置时间前的动画将被截断。See the Pen dREzWK by wuyouzhuguli (@mrbird) on CodePen.transition-timing-functiontransition-timing-function可以设置动画的过渡效果，默认值ease。语法如下：1transition-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)[ ,linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) ]* ;属性可取的值如下：ease：缓解效果，等同于cubic-bezier(0.25,0.1,0.25,1.0)函数，既立方贝塞尔。linear：线性效果，等同于cubic-bezier(0.0,0.0,1.0,1.0)函数。ease-in：渐显效果，等同于cubic-bezier(0.42,0,1.0,1.0)函数。ease-out：渐隐效果，等同于cubic-bezier(0,0,0.58,1.0)函数。ease-in-out：渐显渐隐效果，等同于cubic-bezier(0.42,0,0.58,1.0)函数。cubic-bezier：特殊的立方贝塞尔曲线效果。各种效果对比：See the Pen LLojdr by wuyouzhuguli (@mrbird) on CodePen.多个值的运用CSS3里头的动画属性可以对应多个值，也就是说可以对进行动画的不同的属性来设置不一样的值。举个例子说明：See the Pen ZyNXxj by wuyouzhuguli (@mrbird) on CodePen.可以看出第一个元素所有的属性都是在同样的时间内完成了动画，而第二个元素的left,top,background是在不同的时间内完成动画，这就是对变换时间设置了多个值的效果，每个进行动画的属性对应了相应的变换时间。参考自http://isux.tencent.com/css3]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 transform]]></title>
    <url>%2FCSS3-transform.html</url>
    <content type="text"><![CDATA[transform属性能对元素对象进行变形操作，主要包括以下几种：旋转rotate、缩放scale、移动translate、倾斜skew以及矩阵变形matrix。基本语法：1transform: none | &lt;transform-function&gt;[&lt;transform-function&gt;]*none表示不进行变换；&lt;transform-function&gt;表示一个或多个变换函数，以空格分开，因此可以同时对一个元素进行transform的多种属性操作。包括：rotate(&lt;angle&gt;)：旋转元素。scale(&lt;number&gt;[, &lt;number&gt;])：缩放元素。translate(&lt;translation-value&gt;[, &lt;translation-value&gt;])：移动元素。skew(&lt;angle&gt; [,&lt;angle&gt;])：倾斜元素。matrix(&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;,&lt;number&gt;)：矩阵变形。perspective(length)：透视。rotate()rotate()函数能够旋转元素，它主要是在二维空间内进行操作，通过一个角度参数值，来设定旋转的幅度。如果对元素本身或者元素设置了perspective值，那么rotate3d()函数可以实现一个3维空间内的旋转。基本语法：1transform:rotate(&lt;angle&gt;);取值如下：rotate(&lt;angle&gt;)：&lt;angle&gt;为一个角度值，单位deg，可以为正数或者负数，正数是顺时针旋转，负数是逆时针旋转。rotateX(angele)：相当于rotate3d(1,0,0,angle)指定在3维空间内的X轴旋转。rotateY(angele)：相当于rotate3d(0,1,0,angle)指定在3维空间内的Y轴旋转。rotateZ(angele)：相当于rotate3d(0,0,1,angle)指定在3维空间内的Z轴旋转。具体示例如下：See the Pen JJqbzj by wuyouzhuguli (@mrbird) on CodePen.关于perspective见下文介绍。scale()scale()函数能够缩放元素。语法如下：1transform:scale(&lt;number&gt;[, &lt;number&gt;]);取值如下：scale(&lt;number&gt;[, &lt;number&gt;])表示使元素在X轴和Y轴同时缩放。&lt;number&gt;表示缩放倍数，可以是正数，负数和小数。负数是先翻转元素然后再缩放，X值为负，绕Y轴旋转；Y值为负，绕X轴旋转。包含两个参数，如果缺少第二个参数，那么第二个参数的值等于第一个参数。scaleX(&lt;number&gt;)表示只在X轴(水平方向)缩放元素。scaleY(&lt;number&gt;)表示只在Y轴(垂直方向)缩放元素。scaleZ(&lt;number&gt;)表示只在Z轴缩放元素。前提是元素本身或者元素的父元素设定了透视值。具体示例如下：See the Pen yXWgLG by wuyouzhuguli (@mrbird) on CodePen.translate()translate()函数能够移动元素。语法如下：1transform:translate(&lt;translation-value&gt;[, &lt;translation-value&gt;]);取值如下：translate(&lt;translation-value&gt;[, &lt;translation-value&gt;])表示使元素在X轴和Y轴同时移动，&lt;translation-value&gt;表示位移量。包含两个参数，如果省略了第二个参数则第二个参数为0；如果参数为负，则表示往相反的方向移动。translateX(&lt;translation-value&gt;)表示只在X轴(水平方向)移动元素。translateY(&lt;translation-value&gt;)表示只在Y轴(垂直方向)移动元素。translateZ(&lt;translation-value&gt;)表示只在Z轴移动元素，前提是元素本身或者元素的父元素设定了透视值。具体示例如下：See the Pen mwYRPw by wuyouzhuguli (@mrbird) on CodePen.skew()skew()函数能够让元素倾斜显示。语法如下：1transform:skew(&lt;angle&gt; [,&lt;angle&gt;]);取值如下：skew(&lt;angle&gt; [, &lt;angle&gt;])包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。skewX(&lt;angle&gt;)表示只在X轴(水平方向)倾斜。skewY(&lt;angle&gt;)表示只在Y轴(垂直方向)倾斜。See the Pen GEarWO by wuyouzhuguli (@mrbird) on CodePen.perspectiveperspective为透视的意思，用于设定查看元素的位置，营造一种3D的空间感，值越大，感觉上离得越远；值越小，感觉是离得越近。这对3D变换的元素来说是必须的属性。写法有两种：单独作为一个属性：div { perspective: 100px}。配合transform：div { transform: perspective(100px) rotateX(60deg) }。对比具有perspective值及没有perspective值的区别：See the Pen webgNR by wuyouzhuguli (@mrbird) on CodePen.对比persepctive值的大小对3D效果的影响：See the Pen vZwgwR by wuyouzhuguli (@mrbird) on CodePen.上面结果印证了：值越大，感觉上离得越远；值越小，感觉是离得越近的结论。transform-origintransform的参照点默认为元素的中心点，如果要改变这个参照点，可以是用transform-origin属性进行自定义。该属性提供2个参数值，第一个用于横坐标，第二个用于纵坐标；如果只提供一个，该值将用于横坐标，纵坐标将默认为50%：percentage：用百分比指定坐标值。可以为负值。length：用长度值指定坐标值。可以为负值。left center right是水平方向取值，而top center bottom是垂直方向的取值。查看设置不同中心点的旋转效果：See the Pen OgYpJd by wuyouzhuguli (@mrbird) on CodePen.backface-visibilitybackface-visibility属性可用于隐藏内容的背面。默认情况下，背面可见，这意味着即使在翻转后，变换的内容仍然可见。但当backface-visibility设置为 hidden 时，旋转后内容将隐藏，因为旋转后正面将不再可见。See the Pen OgYpyq by wuyouzhuguli (@mrbird) on CodePen.transform-style设置内嵌的元素在 3D 空间如何呈现。有两个值：flat：所有子元素在 2D 平面呈现。preserve-3d：保留3D空间。比如：See the Pen ZyNeJL by wuyouzhuguli (@mrbird) on CodePen.参考自http://isux.tencent.com/css3/]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3背景属性]]></title>
    <url>%2FCSS3%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[background-sizebackground-size属性用来控制背景图片的大小。参数的值可以是数值也可以是百分数，还可以是cover和contain。如果只有一个参数，此值用来规定背景图片的宽度，这个时候背景图片的高度是按照宽度进行等比例缩放；如果有两个参数，第一个参数用来规定背景图片的宽度，第二个参数用来规定背景图片的高度。数值或百分比例如：See the Pen pwBKrV by wuyouzhuguli (@mrbird) on CodePen.当设置background-size为120%时，尺寸超过容器，图片将会被裁切。cover属性值设置为cover之后，背景图像会等比缩放到完全覆盖容器，背景图像有可能超出容器，不过超出的部分将会被裁切。例如：See the Pen PjgaEp by wuyouzhuguli (@mrbird) on CodePen.containcontain与cover的区别是，contain只挑横向或者纵向任意一个方位将容器填充满：See the Pen yXrEER by wuyouzhuguli (@mrbird) on CodePen.background-originbackground-origin属性用于指定背景图片从什么地方开始绘制，但并不限制绘制区域。默认值为padding-box语法如下：1background-origin:border-box|padding-box|content-boxborder-box此属性值规定背景图片从border区域开始绘制（包括border）。比如：See the Pen gRyKQR by wuyouzhuguli (@mrbird) on CodePen.可以看出背景图片是从边框开始渲染的，包括边框区域。padding-box规定背景图片是从padding开始绘制的，包括padding区域，例如：See the Pen JJVZzd by wuyouzhuguli (@mrbird) on CodePen.可见背景图片是从padding区域开始绘制的。content-box此属性值规定，背景图片是从内容区域开始绘制的，所谓内容区域就是出去border和padding区域，比如：See the Pen WOWyWy by wuyouzhuguli (@mrbird) on CodePen.可见，背景图片是从内容区域开始绘制的。但右下角padding和border区域都有背景图片的显示，因为background-origin属性从名字可以看出，它只规定图片的起源位置，而并不关心图片的结束位置。要限制图片的结束位置，可以使用background-clip属性。background-clipbackground-clip属性规定背景图片在哪些区域可以显示。语法如下：1background-clip:border-box|padding-box|content-box|text|no-clipborder-boxborder-box属性值规定，背景图片可以在边框范围内显示，例如：See the Pen zzXLOY by wuyouzhuguli (@mrbird) on CodePen.可看到，虽然规定背景图可在边框内显示，但左上区域边框下却没有背景图，因为background-origin属性的默认值为padding-box！padding-boxpadding-box属性值规定，背景图片可以在padding范围内显示，不能在border区域显示，例如：See the Pen LLvBYZ by wuyouzhuguli (@mrbird) on CodePen.content-boxcontent-box属性值规定背景图片可以在content区域，也就是除去padding和border的区域内显示，例如：See the Pen XgQBJr by wuyouzhuguli (@mrbird) on CodePen.可以看出，背景图片这个时候只能够在content范围内显示了。text从前景内容的形状（比如文字）作为裁剪区域向外裁剪，也就是说只有前景内容的形状内显示背景图片，例如只有文字内显示背景。比如：See the Pen PjgBqQ by wuyouzhuguli (@mrbird) on CodePen.参考自：http://www.softwhy.com/]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3边框相关属性]]></title>
    <url>%2FCSS3%E8%BE%B9%E6%A1%86%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[CSS3标准发布之前，对边框的样式的设定是非常单调的。CSS3标准发布之后，我们可以使用图片来定制边框，可以设置元素的阴影以及选择使用哪种盒子模型等。border-imageborder-image属性可以用图片作为边框样式。border-image属性可以拆分为5个属性：12345border-image-source // 边框图片源border-image-slice // 边框图片切割尺寸border-image-width // 边框图片宽度border-image-outset // 边框图片区域超出元素边框的尺寸border-image-repeat // 边框图片中间部分在元素对应部分的存在方式border-image-source设置边框图片的源，用url()方式规定图片路径，相对和绝对路径都可。语法如下：1border-image-source : none | &lt;url&gt;border-image-sliceborder-image-slice用来规定图片的切割位置。语法如下：1border-image-slice: [ &lt;number&gt; | &lt;percentage&gt;]&#123;1,4&#125;属性值可以为number，也可以是percentage。如果是percentage方式，则是相对于图片的尺寸。比如有如下一个边框图片：每一个小方块的尺寸是27px，那么此图片的长宽尺寸是(27*3)像素。使用如下代码进行切割：1border-image-slice:27px 27px 27px 27px;结果如下图所示：图片被切割后，会被划分为九个区域，这个九个区域会与元素的九个区域是一一对应的。border-image-widthborder-image-width用来规定边框图片宽度，语法如下：1border-image-width : [ &lt;length&gt; | &lt;percentage&gt; | &lt;number&gt; | auto ]&#123;1,4&#125;此属性可以省略，此时边框图片区域与元素的border宽度是一致的。此属性可以有1-4值，取值方式和border-width类似，同时也遵循上右下左方式。border-image-outsetborder-image-outset此属性用来规定边框图片区域超出元素边框的尺寸，语法如下：1border-image-outset : [ &lt;length&gt; | &lt;number&gt; ]&#123;1,4&#125;border-image-repeatborder-image-repeat用来规定，切割后的边框图片中间部分（演示图片中的黄色部分）在元素对应部分的存在方式。语法如下：1border-image-repeat: [ stretch | repeat | round ]&#123;1,2&#125;三种值的含义如下：stretch：图片以延展方式来填充该区域。repeat：图片以重复平铺方式来填充该区域。round：图片以重复平铺方式来填充该区域。如果没有以整数的倍数来填充该区域，图片会进行缩放以便于整数性倍数的平铺填充。一般都是采用round。具体实例示例1：See the Pen border-image-one by wuyouzhuguli (@mrbird) on CodePen.以上代码中，border-image-slice设置为27，由于没有规定border-image-width，那么将以边框的尺寸为标准，又由于没有规定border-image-repeat属性，则默认采用stretch方式，也就是拉伸被切割的中间区域（也即是演示图中的黄色区域）。示例2：See the Pen border-image-two by wuyouzhuguli (@mrbird) on CodePen.边框设置为54px，边框图片将会自适应。示例3：See the Pen border-image-three by wuyouzhuguli (@mrbird) on CodePen.round方式可以自动调整切割后边框图片中间部分（演示图黄色部分）尺寸方式实现重复平铺效果，所以不会出现repeat那样的残缺现象。box-shadowbox-shadow用来设置元素的投影效果。语法如下：1box-shadow:h-shadow v-shadow blur spread color inset;每个参数的具体意义：h-shadow：必需，设置元素阴影水平偏移量，可以为负值，单位是像素。v-shadow：必需，设置元素阴影垂直偏移量，可以为负值，单位是像素。blur：可选，阴影模糊半径，只能够为正值，如果为0，表示不具有模糊效果，单位像素。spread：可选，阴影的扩展半径尺寸，可以为负值，单位是像素。color：可选，设置阴影的颜色；省略此参数，浏览器选取默认颜色，各个浏览器的默认可能不同，有的为透明。inset：可选，可以将外部阴影改为内部阴影。具体实例示例1，只设置水平和垂直的偏移量：See the Pen box-shadow-one by wuyouzhuguli (@mrbird) on CodePen.示例2，新增模糊半径和阴影颜色：See the Pen box-shadow-two by wuyouzhuguli (@mrbird) on CodePen.示例3，设置多个阴影：See the Pen box-shadow-three by wuyouzhuguli (@mrbird) on CodePen.box-sizingbox-sizing属性用于指定元素采用哪种盒子模型。语法如下：1box-sizing ：content-box || border-box || inherit如果属性值是content-box，那么将采用标准盒模型；如果属性值是border-box，那么将采用怪异模式盒模型；如果属性值是inherit，那么将采用继承方式。盒子模型目前安装W3C的标准可以分为两种：标准盒子模型和怪异盒子模型。标准盒子模型，最常见的盒子模型，在这种盒子模型下，元素实际占宽为：width+padding+border+margin；实际占高为：height+padding+border+margin。怪异盒子模型，实际占宽：width+margin；实际占高：height+margin。其中width和height包含content，padding，border。标准盒子模型下元素的width和height构成了元素的内容区域，而这个区域对应着怪异盒子模型下content。具体实例See the Pen box-sizing by wuyouzhuguli (@mrbird) on CodePen.以上代码中，有一个box容器和两个子div，由于精确设定了左右两个子div的宽度，恰好和box容器宽度相同，且采用浮动，所以两个子div可以水平排列。现在给浮动的两个元素添加padding属性值，观察结果：See the Pen box-sizing-two by wuyouzhuguli (@mrbird) on CodePen.由于默认采用标准盒子模型，给元素添加了padding属性后，元素实际占宽度改变了（比如宽度为width+padding+border+margin，因为增加了padding，所以总体的值变大了），并且大于父元素的宽度，所以导致了换行。我们可以采用怪异盒子模型来解决这个问题：See the Pen RgOMaL by wuyouzhuguli (@mrbird) on CodePen.怪异盒子模型下，元素的width没有改变，所以实际占宽没变（width+margin）。而width在怪异盒子模型下的值为：content+padding+border，因为总体的值没变，border不变，padding变大，所以使得content变小。参考自：http://www.softwhy.com/]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootstrapValidator指南]]></title>
    <url>%2FBootstrapValidator%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[BootstrapValidator是一款基于jQuery的Bootstrap表单校验插件，提供了非常丰富的校验规则。准备工作要使用BootstrapValidator，需要先引入必要的文件：12345&lt;link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrap-3.0.3.min.css"/&gt;&lt;link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrapValidator-0.5.2.min.css"/&gt;&lt;script type="text/javascript" src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="bootstrap/js/bootstrap-3.0.3.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="bootstrap/js/bootstrapValidator-0.5.2.min.js"&gt;&lt;/script&gt;其中需要注意的是jQuery版本必须大于1.9.1。文件下载地址：https://drive.google.com/open?id=1FVhZT899gewytpLVTwD-4x2uR1tSXFkN。需要校验的表单必须由&lt;form&gt;&lt;/form&gt;标签包裹，并且需要验证的字段由&lt;div class=&quot;form-group&quot;&gt;&lt;/div&gt;包裹，并且有name属性。比如：123456&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;labelName&lt;/label&gt; &lt;input type="text" class="form-control" name="fieldName"/&gt; &lt;/div&gt;&lt;/form&gt;绑定校验规则对form元素绑定校验规则：1234567891011121314151617181920212223242526272829303132333435363738$("form").bootstrapValidator(&#123; // 指定不验证的情况 // 值可设置为以下三种类型： // 1、String ':disabled, :hidden, :not(:visible)' // 2、Array 默认值 [':disabled', ':hidden', ':not(:visible)'] // 3、带回调函数 // [':disabled', ':hidden', function($field, validator) &#123; // $field 当前验证字段dom节点 // validator 验证实例对象 // 可以再次自定义不要验证的规则 // 必须要return，return true or false; return !$field.is(':visible'); &#125;] // excluded: [':disabled', ':hidden', ':not(:visible)'], // 生效规则 // enabled:字段值发生变化就触发验证 // disabled/submitted:点击提交时触发验证 live: 'disabled', // 图标 feedbackIcons: &#123; valid: 'glyphicon glyphicon-ok', invalid: 'glyphicon glyphicon-remove', validating: 'glyphicon glyphicon-refresh' &#125;, fields: &#123; field1: &#123; // 字段名 validators: &#123; // ... &#125; &#125;, field2: &#123; validators: &#123; // ... &#125; &#125; &#125;&#125;);下面具体介绍各种校验规则。非空校验非空校验是最常见的一种校验之一，比如对name属性为userName的字段进行非空校验：1234567userName: &#123; // name属性值 validators: &#123; notEmpty: &#123; // 非空校验 message: '用户名不能为空!' &#125; &#125;&#125;,文本长度校验比如对userName的长度进行控制：123456789userName: &#123; validators: &#123; stringLength: &#123; // 长度校验 min: 3, max: 10, message: '用户名长度%s~%s个字符！' &#125; &#125;&#125;,这里userName的长度被限制为3~10个字符（包含3和10）。%s分别表示3和10。正则校验BootstrapValidator支持正则表达式校验，比如：12345678userName: &#123; validators: &#123; regexp: &#123; //正则校验 regexp: /^[a-zA-Z0-9_]+$/, message:'用户名仅支数字，字母和下划线的组合' &#125;, &#125;&#125;,远程校验远程校验使用Ajax异步请求从服务端进行校验，比如校验userName的值是否已经存在。如：1234567891011121314userName: &#123; validators: &#123; remote: &#123; url: "user/confirmUserName.do", message: "用户名已存在", type: "get", data: function()&#123; // 额外的数据，默认为当前校验字段,不需要的话去掉即可 return &#123; "name": $("input[name='userName']").val().trim() &#125;; &#125; &#125; &#125;&#125;,假如userName字段填写的值为123，则参数格式为：userName=123&amp;name=123，所以如果无需额外参数的话，data属性可以略去。服务端：123456789101112@RequestMapping("user/confirmUserName")@ResponseBodypublic Map&lt;String,Boolean&gt; confirmUserName(String name) &#123; Map&lt;String,Boolean&gt; map = new HashMap&lt;String, Boolean&gt;(); map.put("valid", true); // 模拟数据库中已经存在“Mike” if(name.equals("Mike"))&#123; // 设置校验不通过 map.put("valid", false); &#125; return map;&#125;当valid为true的时候，表示Mike用户名可用；当valid为false的时候，表示Mike已被注册。邮箱校验BootstrapValidator提供了邮箱校验的方法，可以不用手动编写邮箱的正则表达式：1234567email: &#123; validators: &#123; emailAddress: &#123; // 可以不用自己写正则 message: '邮箱格式不正确' &#125; &#125;&#125;,对比校验对比校验就是指当前字段的值和别的字段的值相比较，产生校验结果。常用于密码字段，比如有如下form表单：12345678910&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;请输入密码&lt;/label&gt; &lt;input type="text" class="form-control" name="password"/&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;请再次输入密码&lt;/label&gt; &lt;input type="text" class="form-control" name="confirmPassword"/&gt; &lt;/div&gt;&lt;/form&gt;常用的校验规则如下：12345678910111213141516171819202122password: &#123; validators: &#123; notEmpty: &#123; message: '请输入密码' &#125;, different: &#123; // 比较是否不同，否的话校验不通过 field: 'userName', // 和userName字段比较 message: '密码不能与用户名相同！' &#125; &#125;&#125;,confirmPassword: &#123; validators: &#123; notEmpty: &#123; message: '请再次确认密码！' &#125;, identical: &#123; // 比较是否相同，否的话校验不通过 field: 'password', // 和password字段比较 message: '两次密码输入不一致' &#125; &#125;&#125;,复选框校验复选框校验用于控制复选框的选中个数：1234567891011121314151617181920212223&lt;div class="form-group"&gt; &lt;label&gt;兴趣爱好&lt;/label&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" name="hobbies" value="swimming" /&gt; 游泳 &lt;/label&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" name="hobbies" value="fitness" /&gt; 健身 &lt;/label&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" name="hobbies" value="football" /&gt; 足球 &lt;/label&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" name="hobbies" value="sleep" /&gt; 睡觉 &lt;/label&gt; &lt;/div&gt;&lt;/div&gt;校验规则：123456789hobbies: &#123; validators: &#123; choice: &#123; min: 1, max: 3, message: '请选择1~3项兴趣爱好' &#125; &#125;&#125;,数字范围校验数字范围校验类似与文本长度校验，不过其一般用于数字类型的长度校验，比如限制年龄范围为1~150：123456789age: &#123; validators: &#123; between: &#123; min: 0, max: 150, message: '请输入正常的年龄,范围为%s到%s', &#125; &#125;&#125;,除了使用between外，还可以使用lessThan和greaterThan来实现和between类似的效果：1234567891011121314age: &#123; validators: &#123; lessThan: &#123; value: 150, inclusive: true, // 是否包含150，true为包含 message: '年龄必须小于等于%s' &#125;, greaterThan: &#123; value: 0, inclusive: false, 不包含0 message: '年龄必须大于%s' &#125; &#125;&#125;,文件校验文件校验用于对上传的附件类型，大小等进行限制，常用的规则如下：12345678910files: &#123; validators: &#123; file: &#123; maxSize: 1024*1024, // 文件大小，单位为b，这里为1mb extension: 'jpg,png', // 格式 type: 'image/jpeg,image/png', // 对应的MIME type message: '文件不合法，必须小于1MB，并且格式为jpg或png' &#125; &#125;&#125;,更详细的校验规则如下表所示：选项HTML属性类型描述extensiondata-fv-file-extensionString允许的扩展名，用逗号分隔maxFilesdata-fv-file-maxfilesNumber最大文件数maxSizedata-fv-file-maxsizeNumber最大文件大小（以字节为单位）maxTotalSizedata-fv-file-maxtotalsizeNumber所有文件的最大大小（以字节为单位）minFilesdata-fv-file-minfilesNumber文件的最小数量minSizedata-fv-file-minsizeNumber最小文件大小（以字节为单位）minTotalSizedata-fv-file-mintotalsizeNumber所有文件的最小大小（以字节为单位）messagedata-fv-file-messageString错误消息typedata-fv-file-typeString允许的MIME类型，以逗号分隔。例如：设置image/jpeg,image/png,application/pdf只允许上传JPEG，PNG图像和PDF文档。下表显示了常见的MIME类型。对于其他MIME类型，可以参考https://www.sitepoint.com/mime-types-complete-list/。MIME类型文件扩展名application/msworddocapplication/pdfpdfapplication/rtfrtfapplication/vnd.ms-excelxlsapplication/vnd.ms-powerpointpptapplication/x-rar-compressedrarapplication/x-shockwave-flashswfapplication/zipzipaudio/midimid midi karaudio/mpeg,audio/mp3mp3audio/oggoggaudio/x-m4am4aaudio/x-realaudioraimage/gifgifimage/jpegjpeg jpgimage/pngpngimage/tifftif tiffimage/vnd.wap.wbmpwbmpimage/x-iconicoimage/x-jngjngimage/x-ms-bmpbmpimage/svg+xmlsvg svgzimage/webpwebptext/csscsstext/htmlhtml htm shtmltext/plaintxttext/xmlxmlvideo/3gpp3gpp 3gpvideo/mp4mp4video/mpegmpeg mpgvideo/quicktimemovvideo/webmwebmvideo/x-flvflvvideo/x-m4vm4vvideo/x-ms-wmvwmvvideo/x-msvideoavicallback验证callback用于校验验证码等类型，比如要实现下面这样的效果：HTML代码：1234&lt;div class="form-group"&gt; &lt;label id="question"&gt;&lt;/label&gt; &lt;input type="text" class="form-control" name="answer" /&gt;&lt;/div&gt;生成数学算式：1234function randomNumber(min, max) &#123; return Math.floor(Math.random() * (max - min + 1) + min);&#125;;$('#question').html([randomNumber(1, 100), '+', randomNumber(1, 200), '='].join(' '));校验规则：123456789101112answer: &#123; validators: &#123; callback: &#123; message: "答案不正确！", callback: function(value, validator)&#123; // 验证答案是否正确，value为用户输入的值 var items = $('#question').html().split(' '); var sum = parseInt(items[0]) + parseInt(items[2]); return value == sum; &#125; &#125; &#125;&#125;实际中，可以将上面的校验规则组合在一起，实现更复杂的校验。常用事件手动触发校验手动触发校验包含触发单个字段和触发整个表单：1234// 整个表单$("form").bootstrapValidator('validate');// 单个字段$("form").data('bootstrapValidator').validateField('fieldName');获取当前表单校验结果获取当前表单校验状态，校验通过返回true，否则返回false：1234var bootstrapValidators = $("form").data('bootstrapValidator');if(bootstrapValidators.isValid()) &#123; // todo&#125;重置校验12$('form').data('bootstrapValidator').resetForm(true); // 重置校验$('form')[0].reset();// 表单清空]]></content>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的块级作用域]]></title>
    <url>%2FJavaScript%E4%B8%AD%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[所谓的块级作用域通俗的讲就是使用{}创造一个代码块，然后在这之中声明的变量在代码块之外都是不可访问的。在ES6标准发布之前，JavaScript表面上并没有的块级作用域的概念，但其实际包含一些隐式的块级作用域：函数作用域和try/catch。ES6中新增了let关键字，也可以显式的创造块级作用域。JavaScript中，for循环和if等语句都可以创建“块”，但其并不是块级作用域：123456789101112// for for (var i = 0; i &lt;= 3; i++) &#123; var a = 5;&#125;console.log(i); // 4console.log(a); // 5// ifif (true) &#123; var b = 6;&#125;console.log(b); // 6可见在块里面声明的变量都被泄漏到外部作用域中了。函数作用域函数作用域实际上就是一个块级作用域：1234function foo() &#123; var a = 3;&#125;console.log(a); // ReferenceError: a is not defined在函数外部对a的RHS查询失败，所以抛出ReferenceError异常。try/catchES3 规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。123456try &#123; throw 2;&#125; catch (a) &#123; console.log(a); // 2&#125;console.log(a); // ReferenceError: a is not definedletES6引入的let关键字配合{}可以显示地创建块级作用域：12345&#123; let a = 3; console.log(a); // 3&#125;console.log(a); // ReferenceError: a is not definedconst关键字也可以创建块级作用域，只不过const用于声明常量罢了。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的提升]]></title>
    <url>%2FJavaScript%E6%8F%90%E5%8D%87.html</url>
    <content type="text"><![CDATA[对于var a = 3我们一般认为这是一个声明，但实际上JavaScript引擎并不这么认为。它将var a和a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 考虑如下代码段：123a = 3;var a;console.log(a);可能你会觉得上述代码将输出undefined，但其实际上它能够如愿的输出3。因为上述代码在经过JavaScript引擎编译之后，变成了这样：123var a;a = 3;console.log(a);这种对变量的声明被拉到其作用域的最顶端的过程就是提升。再如有如下代码段：12console.log(a);var a = 3;上述代码将输出undefined，而非ReferenceError异常，如上所述，在经过JavaScript引擎编译之后，var a被提升到了作用于顶部：123var a;console.log(a);a = 3;所以对a的RHS查询并不会失败，只不过a为undefined罢了。函数的声明也可以被提升，比如：12345foo(); // 3function foo() &#123; var a = 3; console.log(a);&#125;实际上为：12345function foo() &#123; var a = 3; console.log(a);&#125;foo(); // 3函数声明的提升需要注意一点：函数优先原则：函数声明和变量声明都会被提升。但函数声明将先被提升：123456789foo(); // 4var foo = function() &#123; var a = 3; console.log(a);&#125;function foo() &#123; var a = 4; console.log(a);&#125;经过JavaScript引擎编译之后，代码变成：123456789function foo() &#123; var a = 4; console.log(a);&#125;foo();foo = function() &#123; var a = 3; console.log(a);&#125;其中var foo这个重复的声明已经被略去。《你不知道的JavaScript上卷》读书笔记]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的IIFE]]></title>
    <url>%2FJavaScript%E4%B8%AD%E7%9A%84IIFE.html</url>
    <content type="text"><![CDATA[IIFE(Immediately Invoked Function Expression)指的是立即执行函数表达式，常见的形式有两种：(function(){ .. })()和(function(){ .. }())。IIFE的存在一般是为了减少命名污染的问题。考虑如下代码：12345function foo() &#123; var a = 3; console.log(a);&#125;foo(); // 3假如函数foo()只执行一次，我们更加关注的是函数所实现的功能而并不在意函数叫什么（因为并不需要在别的地方被调用），这时候建议使用IIFE来代替：1234(function() &#123; var a = 3; console.log(a); // 3&#125;)();或者1234(function()&#123; var a = 3; console.log(a); // 3&#125;());为了提高函数的可读性，你可能会给这个匿名函数表达式加上一个名称，比如：1234(function foo()&#123; var a = 3; console.log(a); // 3&#125;());对IIFE的具名并不会污染其外部的词法作用域，你可以继续在外部声明一个名称为foo的函数，比如：123456789function foo() &#123; var a = 4; console.log(a); &#125;(function foo()&#123; var a = 3; console.log(a); // 3&#125;());foo(); // 4IIFE还被常用于JS模块化设计，比如：123456789101112131415161718192021var modules = (function() &#123; // 私有变量 var msg = "hello world"; var msgArr = ['h', 'e', 'l', 'l', 'o']; function helloWorld() &#123; console.log(msg); &#125; function sayHello() &#123; console.log(msgArr.join('')); &#125; // 暴露方法 return &#123; helloWorld: helloWorld, sayHello: sayHello &#125;&#125;)();modules.helloWorld(); // hello worldmodules.sayHello(); // helloconsole.log(modules.msg); // undefined可见在外部无法访问模块化内部参数，这避免了内部参数被私自篡改以及变量污染等问题。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3渐变]]></title>
    <url>%2FCSS3%E6%B8%90%E5%8F%98.html</url>
    <content type="text"><![CDATA[在CSS3标准发布之前，网页上的渐变效果一般都是设计师使用图形化设计软件生成图片，然后作为页面背景实现的。在CSS3标准发布之后，我们可以直接编写CSS代码来轻松实现渐变效果。渐变主要包含线性渐变和径向渐变。线性渐变线性渐变（Linear Gradients）包含向下/向上/向左/向右/对角方向的颜色渐变。基本语法：1background: linear-gradient(direction, color-stop1, color-stop2, ...); ​direction为渐变方向，color-stop1为渐变起始颜色，color-stop2为渐变结束颜色。从上到下（默认情况下）默认情况下，线性渐变方向就是从左到右，所以这个时候direction属性可以略去。例如：See the Pen liner-graident by wuyouzhuguli (@mrbird) on CodePen.为了兼容webkit内核浏览器，实际的代码应该为：123456div &#123; height: 200px; width: 200px; background: linear-gradient(#FFFFCC,#FF6666); background: -webkit-gradient(linear,left top, left bottom,from(#FFFFCC),to(#FF6666));&#125;关于CSS3属性兼容性前缀，可以使用sublime text 3的Autoprefixer插件来自动生成。除此之外，还可以指定起止颜色的起始位置，比如下面这个例子：See the Pen linear-gradient(location) by wuyouzhuguli (@mrbird) on CodePen.从渐变方向10%长度开始到渐变方向60%长度之间，颜色从#FFC渐变到#F66。小于10%部分背景颜色完全为#FFC，大于60%部分背景颜色完全为#F66。从左到右从左到右只需将direction属性值设为to right，例如：See the Pen liner-gradient(to right) by wuyouzhuguli (@mrbird) on CodePen.对角方向可以通过指定水平和垂直的起始位置来制作一个对角渐变。例如从左上角到右下角方向渐变：See the Pen liner-gradient(对角) by wuyouzhuguli (@mrbird) on CodePen.使用任意角度如果想要在渐变的方向上做更多的控制，你可以定义一个角度，而不用预定义方向（to bottom、to top、to right、to left、to bottom right，等等）。语法：1background: linear-gradient(angle, color-stop1, color-stop2); ​angle指水平线和渐变线之间的角度，逆时针方向计算。换句话说，0deg将创建一个从下到上的渐变，90deg将创建一个从左到右的渐变。但是，请注意很多浏览器(Chrome,Safari,firefox等)的使用了旧的标准，即 0deg 将创建一个从左到右的渐变，90deg 将创建一个从下到上的渐变。换算公式 90 - x = y 其中 x 为标准角度，y为非标准角度。下面的实例演示了如何在线性渐变上使用角度：See the Pen liner-gradient(use angle) by wuyouzhuguli (@mrbird) on CodePen.使用多个颜色结点除了设置一组起始颜色和结束颜色外，我们还可以设置多组渐变颜色。比如：See the Pen liner-gradient(repeat) by wuyouzhuguli (@mrbird) on CodePen.使用透明度CSS3 渐变也支持透明度（transparency），可用于创建减弱变淡的效果。为了添加透明度，我们使用 rgba() 函数来定义颜色结点。比如：See the Pen liner-gradient(opacity) by wuyouzhuguli (@mrbird) on CodePen.重复的线性渐变repeating-linear-gradient()函数用于重复线性渐变，语法和linear-gradient()相同，例如：See the Pen repeating-linear-gradient by wuyouzhuguli (@mrbird) on CodePen.上面例子中，有一个白色条纹从0到.25em线性渐变，接着一条#FF6颜色条纹从.25em到.75em。（#FF6颜色条纹宽度 = .75em - .25em = .5em = 白色条纹宽度的两倍 ＝ .25em * 2）。径向渐变径向渐变指的是从圆心向外扩散的渐变，为了创建一个径向渐变，必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（原型或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。颜色结点均匀分布（默认情况下）如下所示：See the Pen radial-gradient by wuyouzhuguli (@mrbird) on CodePen.颜色结点不均匀分布如下所示：See the Pen radial-gradient1 by wuyouzhuguli (@mrbird) on CodePen.重复的径向渐变如下所示：See the Pen repeating-dadial-gradient by wuyouzhuguli (@mrbird) on CodePen.]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调教Sublime Text 3]]></title>
    <url>%2F%E8%B0%83%E6%95%99sublime-text3.html</url>
    <content type="text"><![CDATA[Sublime Text 3 是一款编辑器软件，自带语法高亮，代码提示，自动补全等让开发者爱不释手的功能。并且启动速度极快，支持自定义主题和安装第三方插件。不过刚下载的Sublime Text不仅图标巨丑，主题还难看，建议对其进行一番调教。调教包括配置主题，安装插件，了解快捷键和配置云同步等。调教之前需要安装Package Control。使用快捷键Ctrl+Shift+P呼出Command Palette，然后输入install Package Control，然后Enter即可安装。官方Package Control市场：https://packagecontrol.io/。安装主题Sublime Text包含很多优秀的第三方主题，不过个人还是比较喜欢Boxy Theme。在Command Palette中输入install，选择Package Control: install Package：点击Enter呼出Package Control后输入Boxy Theme后点击Enter即可安装。控制台提示安装成功后，使用快捷键Ctrl+Shift+P呼出Command Palette，输入boxy，选择Boxy Theme:Activation即可在Boxy Theme自带的几款主题中进行切换：个人比较喜欢Yesterday这款主题：Yesterday相关配置（Preferences→settings）：12345678910111213141516171819202122232425&#123; "color_scheme": "Packages/Boxy Theme/schemes/Boxy Yesterday.tmTheme", "font_size": 11, "ignored_packages": [ "Vintage" ], "theme": "Boxy Yesterday.sublime-theme", // Settings "theme_accent_sky": true, "theme_button_rounded": true, "theme_find_panel_close_hidden": true, "theme_find_panel_size_xs": true, "theme_grid_border_size_lg": true, "theme_icon_button_highlighted": true, "theme_icons_atomized": true, "theme_popup_border_visible": true, "theme_quick_panel_size_md": true, "theme_scrollbar_rounded": true, "theme_sidebar_disclosure": true, "theme_sidebar_indent_top_level_disabled": true, "theme_statusbar_size_md": true, "theme_tab_rounded": true, "theme_tab_selected_prelined": true&#125;还可以安装与该主题配套的Mono File Icons插件，用于美化不同格式文件的图标样式。安装方法同上，不再赘述。效果如下：图标替换可以在Dribbble中搜索Sublime Text，然后下载喜欢的图标。不过大多数素材都是Mac的icns格式的，可以在https://iconverticons.com/online/网站中在线转换为windows中的ico格式。安装插件推荐几款常用的插件：Autoprefixer在编写CSS代码的时候，经常需要为了兼容不同内核的浏览器而在属性前编写-webkit-，-ms-,-moz-等前缀。使用这款插件可以替代我们自动完成这件事。 插件地址https://packagecontrol.io/packages/Autoprefixer。安装方式和主题的安装一致，不再赘述，下面插件将不再描述安装方法。安装完成后，可以配置快捷键（Preferences→key Bindings）：123456[ &#123; "keys": ["alt+shift+p"], "command": "autoprefixer" &#125;]或者直接在Command Palette中输入auto，选择第一项：效果如下：QuoteHTMLQuoteHTML可将HTML片段转换为字符串片段，在操作DOM的时候非常方便，省去了自己手动拼接的时间。比如有如下HTML片段：1234567&lt;select class="form-control" id="typeSel" style="width:260px;padding: 0px 6px;"&gt; &lt;option value="1"&gt;option_1&lt;/option&gt; &lt;option value="2"&gt;option_2&lt;/option&gt; &lt;option value="3"&gt;option_3&lt;/option&gt; &lt;option value="4"&gt;option_4&lt;/option&gt; &lt;option value="5"&gt;option_5&lt;/option&gt;&lt;/select&gt;在Command Palette中输入q：可根据实际需求自由选择，这里选择第二项然后敲击Enter，效果如下：真是极其方便的说！也可以自己设置快捷键。JsFormatJsFormat插件可以将压缩后的JS代码格式化，默认绑定快捷键Ctrl+Alt+F,也可以自己设置快捷键：123456789&#123; "keys": ["ctrl+alt+f"], "command": "js_format", "context": [&#123; "key": "selector", "operator": "equal", "operand": "source.javascript" &#125;]&#125;或者在Command Palette中输入format：值得一提的是，它也可以格式化JSON数据。CSSFormat和JsFormat类似的是，CSSFormat用于格式化压缩后的CSS代码。安装完成后，右键选择CSS Format可看到对应的几个选项，不同选项格式化的样式不一样，可自行体验。也可以在Command Palette中输入format css并按下Enter来格式化CSS代码：HTML-CSS-JS PrettifyHTML-CSS-JS Prettify是一款基于node.js的HTML/CSS/JS 代码美化插件。因为是基于node.js，所以安装前需要配置好node.js环境。安装好后，需要在插件设置里配置本地node.js的安装路径，右键选择HTML/CSS/JS Prettify → Plugin Options - Default：现有如下一段格式混乱的js代码：右键选择HTML/CSS/JS Prettify → Prettify Code：效果如下所示：MinifyMinify是一款可以压缩Js，CSS，HTML，JSON，SVG等格式文件的插件。安装完插件后打开cmd输入下面命令安装：1npm install -g clean-css uglifycss js-beautify html-minifier uglify-js minjson svgo如果你已经安装过其中的一些的话可以用下面命令更新：1npm update -g clean-css uglifycss js-beautify html-minifier uglify-js minjson svgo然后右键中就有Minify的选项了：Color​HelperColorHelper提供CSS颜色预览，提供颜色转换，并允许在调色板中存储和访问喜爱的颜色。安装该插件后，CSS中颜色属性值前会出现一个相应颜色的小方块，如下图所示：点击小方块，可以进行颜色格式的转换，如16进制转RGB,RGBA,HSL和HSLA：也可以在调色板中获取自己喜欢的颜色，并插入：Better Completion相比Sublime Text 3自带的代码补全功能，Better Completion可以提供更好自动补全功能，支持JavaScript，jQuery，Lodash，Underscore，HTML5，CSS3和Bootstrap等。安装完后在Command Palette输入sbc，然后按下Enter键：在弹出的文件中输入如下配置，并且将那些需要开启自动补全功能语言的选项后的false改为true：123456789101112131415161718192021222324252627282930313233343536&#123; // `true` means enable it. // `false` means disable it. "completion_active_list": &#123; // build-in completions "css-properties": true, "gruntjs-plugins": false, "html": true, "lodash": false, "javascript": true, "jquery": true, "jquery-sq": false, // Single Quote "php": false, "phpci": false, "sql": true, "twitter-bootstrap": true, "twitter-bootstrap-less-variables": true, "twitter-bootstrap3": true, "twitter-bootstrap3-sass-variables": false, "underscorejs": false, "react": false, // Your own completions? // ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/User/sbc-api-my-angularjs.sublime-settings "my-angularjs": false, // ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/User/sbc-api-my-glossary.sublime-settings "my-glossary": false, // ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/User/sbc-api-my-html.sublime-settings "my-html": false, // ~/Library/Application\ Support/Sublime\ Text\ 3/Packages/User/sbc-api-my-javascript.sublime-settings "my-javascript": false &#125;&#125;jQuery自动补全的效果图如下：ModificModific突出显示行自上次提交以来的更改情况（支持Git，SVN等版本控制工具）。安装完后，如果在版本控制管理目录下修改了文件行，新增的部分以三角标显示，修改的部分以菱形显示，如下图所示：WakaTimeWakaTime插件用于在Dashboard中显示你这周的编程时间，编写代码种类占比等信息。安装完插件后，在Sublime Text编辑器下方会要求您输入密匙并按下Enter即可，密匙获取地址：https://wakatime.com/settings/account#apikey：在编写一段时间后，就可以去https://wakatime.com/dashboard中查看你的编码情况啦：常用快捷键这里只列出了Sublime Text在window中一些比较常用的自带快捷键：12345678910111213141516171819202122232425262728293031323334353637Alt+R : 开启正则表达式功能Alt+Enter: 找到匹配目标后全部选择Ctrl+R：前往 methodCtrl+M：跳转到对应括号按Ctrl+Shift+上下键，可替换行Ctrl+D：选择单词，重复可增加选择下一个相同的单词Ctrl+L：选择行，重复可依次增加选择下一行Ctrl+Shift+P：打开命令面板Ctrl+G：跳转到第几行Ctrl+W：关闭当前打开文件Ctrl+KK：删除当前行光标后的所有内容Ctrl+Shift+W：关闭所有打开文件Ctrl+Shift+V：粘贴并格式化Ctrl+Shift+L：选择多行Ctrl+Shift+Enter：在当前行前插入新行Ctrl+Shift+K：删除当前行Ctrl+U：软撤销，撤销光标位置Ctrl+J：选择标签内容Ctrl+F：查找内容Ctrl+Shift+F：查找并替换Ctrl+H：替换Ctrl+N：新建窗口Ctrl+K+B：开关侧栏Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身Ctrl+F2：设置/删除标记Ctrl+/：注释当前行Ctrl+Shift+/：当前位置插入注释Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的Ctrl+Shift+A：选择当前标签前后，修改标签用的F11：全屏Shift+F11：全屏免打扰模式，只编辑当前文件Alt+F3：选择所有相同的词Alt+.：闭合标签Alt+Shift+数字：分屏显示Alt+数字：切换打开第N个文件Ctrl+shift+D: 备份多个当前行Ctrl+shift+T: 恢复已经关闭的标签在不同设备下同步个人配置可以使用Git同步Packages/User/文件夹（可以在Preferences→Browse Packages…打开）下的内容，此文件夹包含Package Control.sublime-settings文件，其中包含所有已安装软件包的列表。使用Git同步到另一台机器，下次启动Sublime Text时，Package Control 将安装任何丢失的软件包的正确版本。有些插件安装后需要重启Sublime Text才能生效。插件安装多了，可能引起快捷键的冲突，需要引起注意。]]></content>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支管理]]></title>
    <url>%2FGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[git branch命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：1234$ git branch develop* master test带*表示当前所在分支。使用命令git branch -v则可以查看各个分支最后一个提交对象的信息：1234$ git branch -v develop ef993bc update About.html* master 0986092 [ahead 26] update index.html test 19fffc0 add test file使用命令git branch --merged可以查看哪些分支与当前分支进行了合并操作：123$ git branch --merged develop* master与之相反的命令为git branch --no-merged:12$ git branch --no-merged testtest分支中还包含着尚未合并进来的工作成果，所以简单地用git branch -d删除该分支会提示错误，因为那样做会丢失数据：123$ git branch -d testerror: The branch 'test' is not fully merged.If you are sure you want to delete it, run 'git branch -D test'.Git提示可以用大写的删除选项 -D 强制执行。]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支的创建与合并]]></title>
    <url>%2FGit%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6.html</url>
    <content type="text"><![CDATA[假设目前正在开发公司网站，并且使用Git管理项目代码，常见的流程大体如下:1.开发公司网站。2.为了开发某个新功能新建一个分支（假如叫develop），并在该分支上进行开发。3.接到测试组的Bug反馈，返回主分支，新建一个新的分支（bugFix），在该分支上修复Bug，然后与主分支master合并。4.将分支切换回develop，继续开发新功能，结束后和主分支master合并。分支的新建与切换假如公司网站项目已经开发了一段时间，并且使用Git提交了几次更新，提交历史如下图所示： 为了开发新功能，新建分支develop并切换到该分支：1234$ git branch develop$ git checkout developSwitched to branch 'develop'也可以使用命令git checkout -b直接新建并切换：12$ git checkout -b developSwitched to a new branch 'develop'执行上述命令后，仓库历史大致如下所示： Git新建了一个分支指针develop，然后将HEAD指向develop。接下来在该分支上开心的开发新功能，比如新建了公司网站About页面，添加了内容然后提交了此次修改：12345678$ vim About.html$ git add About.html$ git commit -a -m "add About.html page"[develop b462691] add About.html page 1 file changed, 12 insertions(+) create mode 100644 About.html此时，仓库历史如下图所示： 这时候接到测试组公司网站主页index.html的Bug反馈，于是将分支切换回主分支master，然后新建分支bugFix，修复Bug，并提交该修复：1234567891011$ git checkout masterSwitched to branch 'master'$ git checkout -b "bugFix"Switched to a new branch 'bugFix'$ vim index.html$ git commit -a -m "update index.html page"[bugFix 11a3074] update index.html page 1 file changed, 2 insertions(+), 2 deletions(-)此时，仓库历史如下图所示： 假如确定Bug修复后，可以切换回master分支，然后将bugFix和master分支合并：12345$ git merge bugFixUpdating e7ad858..11a3074Fast-forward index.html | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-)合并时出现了“Fast forward”的提示。如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。此时bugFix分支已经完成了历史使命，可以使用命令git branch -d将其删除：12$ git branch -d bugFixDeleted branch bugFix (was 11a3074).合并master与bugFix，并删除bugFix分支后，仓库历史如下图所示： Bug修复后，切换回develop分支继续开发新的功能，并且提交：12345678$ git checkout developSwitched to branch &apos;develop&apos;$ vim About.html$ git commit -a -m &quot;add copyright&quot;[develop df8d879] add copyright 1 file changed, 1 insertion(+)此时，仓库历史如下图所示： 分支合并和合并master分支与bugFix分支那样，合并master与develop分支过程也差不多：1234567$ git checkout masterSwitched to branch 'master'$ git merge developMerge made by the 'recursive' strategy. About.html | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)由于master指向的C4并不是develop指向C5的直接祖先C2，所以合并方式不是“Fast forward”，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。合并master和develop后，仓库历史如下图所示： 解决合并冲突假如在不同分支中都对同一个文件进行了修改，那么合并的时候就会发生冲突。比如在master分支和develop分支上都修改了About.html页面，然后进行分支合并：1234$ git merge developAuto-merging About.htmlCONFLICT (content): Merge conflict in About.htmlAutomatic merge failed; fix conflicts and then commit the result.Git作了合并，但没有提交，它会停下来等你解决冲突。可是使用命令git status查看哪些文件存在冲突：123456789101112$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run "git commit") (use "git merge --abort" to abort the merge)Unmerged paths: (use "git add &lt;file&gt;..." to mark resolution) both modified: About.htmlno changes added to commit (use "git add" and/or "git commit -a")任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。编辑About.html页面，可看到文件包含类似下面部分的内容：123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD &lt;footer&gt;2016~2017 All Rights Reserved&lt;/footer&gt;======= &lt;footer&gt;&amp;copy;2016~2017&lt;/footer&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop可以看到 ======= 隔开的上半部分，是HEAD（即 master 分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在develop分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。1&lt;footer&gt;&amp;copy; 2016~2017 All Rights Reserved&lt;/footer&gt;《pro git》学习笔记]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git撤销操作]]></title>
    <url>%2FGit%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[修改最后一次提交如果提交后发现想要修改提交信息，可以直接使用 git commit --amend 命令，使用该命令后，Git会启动文本编辑器，然后可看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才的提交信息：1$ git commit --amend如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交：12$ git add forgotten_file$ git commit --amend取消已经暂存的文件123456789$ git statusOn branch masterYour branch is ahead of 'origin/master' by 8 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.config modified: README.md使用命令 git reset HEAD README.config 将README.config移出暂存区：123456789101112131415161718$ git reset HEAD README.configUnstaged changes after reset:M README.config$ git statusOn branch masterYour branch is ahead of 'origin/master' by 8 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.mdChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: README.config可看到，README.config已经为Changes not staged for commit状态。取消对文件的修改将README.config移出暂存区后，可以进一步使用命令 git checkout -- README.config 取消对README.config的修改。123456789101112131415$ cat README.confighello$ git checkout -- README.config$ git statusOn branch masterYour branch is ahead of 'origin/master' by 8 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: README.md$ cat README.config《pro git》学习笔记]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git远程仓库]]></title>
    <url>%2FGit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html</url>
    <content type="text"><![CDATA[远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。 管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。查看当前的远程库使用 git remote 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：1234567891011$ git clone git://github.com/schacon/ticgit.gitCloning into 'ticgit'...remote: Counting objects: 1857, done.remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857Receiving objects: 100% (1857/1857), 331.41 KiB | 89.00 KiB/s, done.Resolving deltas: 100% (837/837), done.$ cd ticgit$ git remoteorigin使用 git remote -v 命令可以显示出远程仓库的地址：123$ git remote -vorigin git://github.com/schacon/ticgit.git (fetch)origin git://github.com/schacon/ticgit.git (push)添加远程仓库要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]：12345$ git remote add paul git://github.com/paulboone/ticgit.git$ git remoteoriginpaul从远程仓库抓取数据1.抓取并但不合并分支，使用命令 git fetch [remote-name] [branch-name]。1234567$ git fetch paul masterremote: Counting objects: 19, done.remote: Total 19 (delta 11), reused 11 (delta 11), pack-reused 8Unpacking objects: 100% (19/19), done.From git://github.com/paulboone/ticgit * branch master -&gt; FETCH_HEAD * [new branch] master -&gt; paul/master2.抓取并且自动合并分支，使用命令 git pull [remote-name] [branch-name]。1234$ git pull origin masterFrom git://github.com/schacon/ticgit * branch master -&gt; FETCH_HEADAlready up-to-date.推送数据到远程仓库使用命令 git push [remote-name] [branch-name] 把本地的 master 分支推送到 origin 服务器上 :1$ git push origin master符合下面两种情况才能成功推送：拥有远程仓库写的权限。在符合1的情况下，如果其他人已经向远程仓库推送了更新，必须先更新抓取到本地，合并到自己的项目中，然后才可以再次推送。查看远程仓库信息123456789101112$ git remote show origin* remote origin Fetch URL: git://github.com/schacon/ticgit.git Push URL: git://github.com/schacon/ticgit.git HEAD branch: master Remote branches: master tracked ticgit tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date)远程仓库的删除和重命名使用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 paul 改成 paulboone：12345$ git remote rename paul paulboone$ git remoteoriginpaulboone对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 paul/master 分支现在成了 paulboone/master使用命令 git remote rm 删除在本地的远程仓库地址：1234$ git remote rm paulboone$ git remoteorigin《Pro Git》学习笔记]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git版本回退]]></title>
    <url>%2FGit%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80.html</url>
    <content type="text"><![CDATA[Git中，每次commit提交都会生成一个历史纪录。使用 git log 查看commit历史：12345678910$ git log --oneline ec88247 modifyed bar.html,foo.txt add new.txt47384c8 modify bar.html in clone again31e1f6f modify foo.txt in original again8747b24 Merge branch 'master' of /home/mrbird/projects/first-project27b76ec modify foo.txt in original796e40d modify bar.html in clone8e1b132 modify foo.txt,add 'hello msg'94418b1 add bar.html,modify foo.txt,delete bar.txtc2e4810 add foo.txt bar.txt每个记录都有一个与之对应的commit id，所以可以使用命令git reset --hard commit_id来回退到相应的版本。除此之卡，在Git中，使用HEAD来代表当前版本，如需回退到前一个版本，可以使用命令git reset --hard HEAD^，前两个版本则用HEAD~2表示，以此类推。当前版本id为ec88247…比如，现要回退到commit_id为47384c8…的版本，可以使用如下命令：12$ git reset --hard 47384c8HEAD is now at 47384c8again modify bar.html in clone或：12$ git reset --hard HEAD^HEAD is now at 47384c8 modify bar.html in clone again再次查看commit历史：123456789$ git log --oneline 47384c8 modify bar.html in clone again31e1f6f modify foo.txt in original again8747b24 Merge branch 'master' of /home/mrbird/projects/first-project27b76ec modify foo.txt in original796e40d modify bar.html in clone8e1b132 modify foo.txt,add 'hello msg'94418b1 add bar.html,modify foo.txt,delete bar.txtc2e4810 add foo.txt bar.txt可发现，commit_id为ec88247…的记录已经不见了，如果要回退到这个版本，又忘记了与之对应的commit_id该怎么办呢。这时候可以使用git reflog命令来查看操作历史：1234$ git reflog47384c8 HEAD@&#123;0&#125;: reset: moving to 47384c8ec88247 HEAD@&#123;1&#125;: reset: moving to ec88247...可看到，回退到commit_id为47384c8…的上一个版本的commit_id为ec88247…，所以，使用如下命令即可回到一开始回退前的版本：12$ git reset --hard ec88247HEAD is now at ec88247 modifyed bar.html,foo.txt add new.txt]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git状态跟踪]]></title>
    <url>%2FGit%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA.html</url>
    <content type="text"><![CDATA[对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。1.已提交：表示该文件已经被安全地保存在版本库中了。2.已修改：表示修改了某个文件，但还没有提交到暂存区。3.已暂存：表示把已修改的文件已经放到暂存区了，下次提交时一并被保存到版本库中。检查当前文件状态要确定哪些文件当前处于什么状态，可以用 git status 命令。1234$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.nothing to commit, working tree clean说明现在的工作目录相当干净，并且当前所在分支为master。在当前目录下创建一个README文件，然后运行 git status 会看到该文件出现在未跟踪文件列表中：123456789$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) READMEnothing added to commit but untracked files present (use "git add" to track)未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件。跟踪新文件使用命令 git add 开始跟踪文件README：1$ git add README再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：1234567$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: README只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。暂存已修改文件修改已跟踪过的文件 README，然后再次运行 git status 命令：12345678910111213$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: READMEChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: READMEREADME文件出现了两次，一次是未暂存，一次是一暂存。如果现在提交的话，那么提交的将是已暂存的README，对README的修改并不会被提交。重新运行 git add 把最新版本README重新暂存起来：12345678$ git add README$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: README忽略某些文件如日志文件，编译缓存文件等没必要纳入Git管理的文件，我们可以创建一个.gitignore文件来将这些文件排除在外。比如：123$ cat .gitignore*.[oa]*~第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件。文件 .gitignore 的格式规范如下：所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。可以使用标准的 glob 模式匹配（glob指shell简化后的正则表达式）。匹配模式最后跟反斜杠（/）说明要忽略的是目录。要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。看一个 .gitignore 文件的例子：12345678910111213# 此为注释 – 将被 Git 忽略# 忽略所有 .a 结尾的文件*.a# 但 lib.a 除外!lib.a# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO/TODO# 忽略 build/ 目录下的所有文件build/# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txtdoc/*.txt# ignore all .txt files in the doc/ directorydoc/**/*.txt查看已暂存和未暂存的更新再次修改README文件，但不添加到暂存区。现在README已经修改了两次，第一次添加内容“hello git”并且使用 git add 添加到了暂存区。第二次添加内容“hello world”，但并未添加到暂存区。若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff --staged命令：12345678$ git diff --stageddiff --git a/README b/READMEnew file mode 100644index 0000000..8d0e412--- /dev/null+++ b/README@@ -0,0 +1 @@+hello git直接使用 git diff 命令查看已暂存和未暂存文件之间的差异：12345678$ git diffdiff --git a/README b/READMEindex 8d0e412..05fe86c 100644--- a/README+++ b/README@@ -1 +1,2 @@ hello git+hello world可看到，对于README文件来说，未暂存和已暂存文件相比，添加了一行“hello world”。提交更新使用 git commit -m 命令来提交更新：1234$ git commit -m '创建README文件，内容为hello git'[master 1f9882d] 创建README文件，内容为hello git 1 file changed, 1 insertion(+) create mode 100644 README跳过暂存区假如你觉得 git add 过程繁琐，可以使用 git commit -a 命令来跳过添加文件到暂存区的步骤，直接提交。比如，对于README的第二次修改，我们还未将其添加到暂存区，所以第一次使用 git commit 命令只是提交了对README文件的第一次修改：1234567891011$ git statusOn branch masterYour branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: READMEno changes added to commit (use "git add" and/or "git commit -a")使用 git commit -a 命令直接将README文件的第二次修改提交到版本库：123$ git commit -a -m "添加hello world"[master db06721] 添加hello world 1 file changed, 1 insertion(+)移除文件移除文件分为两种情况：从版本库和本地工作目录中移除；仅从版本库移除。1.从版本库和本地工作目录中移除。使用 git rm 命令来移除README:123456$ git rm READMErm 'README'$ git commit -m '删除README'[master 99a0462] 删除README 1 file changed, 3 deletions(-) delete mode 100644 README到本地工作目录下查看，会发现README文件已经不存在了。这里有种情况，假如README文件还在暂存区并未提交，使用 git rm 命令将会出错：1234$ git rm READMEerror: the following file has changes staged in the index: README(use --cached to keep the file, or -f to force removal)Git提示我们使用 git rm -f 命令来删除。12$ git rm -f temp.logrm 'temp.log'2.仅从版本库移除。比如现在不小心将temp.log文件添加并提交到版本库中了：12345$ git add temp.log$ git commit -m "add temp.log"[master fa31ea5] add temp.log 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 temp.log现在想将其从版本库中删除，但并不删除本地文件，而是随后将其添加到.gitignore文件中，可以使用命令git rm --cached：1234567$ git rm --cached temp.logrm 'temp.log'$ git commit -m "delete temp.log"[master e512a82] delete temp.log 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 temp.log移动文件（重命名）git mv 命令用来重命名文件，比如将REAME文件重命名为README.config：123456789$ git mv README README.config$ git statusOn branch masterYour branch is ahead of 'origin/master' by 7 commits. (use "git push" to publish your local commits)Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) renamed: README -&gt; README.config其过程类似于：123$ mv README README.config$ git rm README$ git add README.config《Pro Git》学习笔记]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父子页面元素的获取与方法的调用[转]]]></title>
    <url>%2F%E7%88%B6%E5%AD%90%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.html</url>
    <content type="text"><![CDATA[javaScript子页面调用父页面方法：格式：parent.父页面方法实例：parent.pClick(); // pClick 为父页面 js 方法子页面获取父页面元素：格式：window.parent.document.getElementById(“父窗口元素ID”);实例：window.parent.document.getElementById(“pBtnOk”);// pBtnOk为父页面标签 idjQuery父页面获取子页面元素：格式：$(“#iframe的ID”).contents().find(“#iframe中的控件ID”).click();实例：$(“#ifm”).contents().find(“#iBtnOk”).click(); // ifm 为 &lt;iframe&gt; 标签 id; iBtnOk 为子页面按钮 id父页面调用子页面方法：格式：$(“#iframe的ID”)[0].contentWindow.iframe方法();实例：$(“#ifm”)[0].contentWindow().iClick(); // ifm 为 &lt;iframe&gt; 标签 id; iClick为子页面 js 方法子页面获取父页面元素：格式：$(“#父页面元素id” , parent.document);实例：$(“#pBtnOk” , parent.document).click(); // pBtnOk 为父页面标签 id转自http://www.cnblogs.com/it-xcn/p/5896231.html]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3颜色属性]]></title>
    <url>%2FCSS3%E9%A2%9C%E8%89%B2%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[opacityopacity用来设置元素的透明度。取值范围为0~1，0表示完全透明，1表示不透明。RGBARGBA是在RGB基础上增加了控制alpha透明度的参数。基本语法如下：1rgba(R,G,B,A)参数解析:（1）R(red)：红色值。正整数 | 百分数。（2）G(green)：绿色值。正整数 | 百分数。（3）B(blue)：蓝色值。正整数 | 百分数。（4）A(Alpha)：Alpha透明度，取值0~1之间。R、G、B三个参数的正整数取值是0-255，百分比取值是0.0% - 100.0%。需要特别注意的是，并非所有的浏览器都支持百分数参数值。简单示例如下：See the Pen rgba by wuyouzhuguli (@mrbird) on CodePen.HSL()HSL就是色调(Hue)、饱和度(Saturation)和亮度(Lightness)的缩写。通过三个颜色通道的叠加实现调节颜色的功能。H：0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360。S：取值为：0.0% - 100.0%；0% 意味着灰色，而 100% 是全彩。L：取值为：0.0% - 100.0%；0% 是黑色，100% 是白色。HSLA()HSLA()在HSL()基础上增加了一个透明度效果。currentColor此属性代表当前元素被应用上的color颜色值，也可以说当前元素的文本颜色值。例如：See the Pen currentColor by wuyouzhuguli (@mrbird) on CodePen.参考自蚂蚁部落]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3文本属性]]></title>
    <url>%2FCSS3%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[text-shadow该属性用于设置文字阴影效果，基本语法如下：1text-shadow:[颜色 x轴 y轴 模糊半径],[颜色 x轴 y轴 模糊半径]...语法注释:（1）颜色：表示阴影的颜色值。（2）x轴：水平方向的偏移量，单位是像素。（3）y轴：垂直方向的偏移量，单位是像素。（4）模糊半径：阴影的影响范围，不能为负值，值越大越模糊。代码实例：x轴偏移量演示：See the Pen text-shadow by wuyouzhuguli (@mrbird) on CodePen.多层阴影:所谓多层引用，就是给文字施加多个阴影样式即可，之间用逗号分隔。text-stroketext-stroke属性可以设置文字的描边效果。语法如下：1text-stroke：[ text-stroke-width ] || [ text-stroke-color ]语法注释：（1）text-stroke-width：设置元素中文本的描边厚度。（2）text-stroke-color：设置元素中文本的描边颜色。代码实例：See the Pen text-stroke by wuyouzhuguli (@mrbird) on CodePen.text-stroke是一个复合属性，也可以将它们拆开单独设置：See the Pen text-stroke1 by wuyouzhuguli (@mrbird) on CodePen.text-overflow该属性用于控制文本溢出样式，基本语法如下：1text-overflow：clip | ellipsis语法注释：（1）clip：此属性值表示直接裁切，并不显示省略标记(…)。（2）ellipsis：此属性可以设置当文本溢出时将显示省略标记(…)。需要与overflow:hidden和white-space:nowrap配合使用才能够生效。代码实例：See the Pen text-overflow by wuyouzhuguli (@mrbird) on CodePen.text-fill-color设置文字的填充颜色，同时设置text-fill-color和color，text-fill-color将会覆盖color属性。代码实例：使用text-fill-color和text-stroke属性来制造镂空文字效果：See the Pen text-fill-color by wuyouzhuguli (@mrbird) on CodePen.word-wrap该属性提供换行的功能，基本语法：1word-wrap: normal | break-word语法注释：（1）normal：默认值，保持浏览器的默认处理，只在允许的断字点换行，也就是非连续的英文字符数字或者汉字可以进行换行。（2）break-word：此属性值可以实现内容换行，也就是可以实现在边界内换行，不能够超出边界。代码实例：See the Pen word-wrap by wuyouzhuguli (@mrbird) on CodePen.@font-face该属性用于引入网络中的字体，基本语法：123456@font-face &#123; font-family: &lt;YourWebFontName&gt;; src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*; [font-weight: &lt;weight&gt;]; [font-style: &lt;style&gt;];&#125;语法注释：（1）YourWebFontName：必需，自定义字体的名称。（2）source：必需，规定自定义字体的路径，可以是相对路径也可以是绝对路径。（3）format：可选，规定自定义字体的格式，用来帮助浏览器识别，主要类型:truetype(.ttf)，opentype(.otf)，truetype-aat，embedded-opentype(.eot)，svg(.svg)等。（4）font-weight：可选，规定字体是否为粗体。（5）font-style：可选，规定字体的样式，比如斜体。代码实例：12345678@font-face &#123; font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125;参考自蚂蚁部落]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leanote博客添加过渡动画]]></title>
    <url>%2FLeanote%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[为了提高博客用户体验，我们可以为其添加一些动画效果。这篇博文主要介绍如何添加页面切换动画以及页面加载动画。需要用到的插件：Animsition.js：http://git.blivesta.com/animsition/Loader.css：https://connoratherton.com/loaders页面切换动画首先从https://github.com/blivesta/animsition上下载插件包，解压后在博客主题中引入animsition.css和animsition.js：12&lt;script src="&#123;&#123;$.themeBaseUrl&#125;&#125;/animsition.js"&gt;&lt;/script&gt;&lt;link href="&#123;&#123;$.themeBaseUrl&#125;&#125;/animsition.css" rel="stylesheet"&gt;这里不引入压缩版的原因是为了方便待会修改源码。 然后找到博客主题中的body标签，添加 class=&quot;animsition&quot;：1&lt;body class="animsition"&gt;接着找到博客主题中所有的a标签，添加class=&quot;animsition-link&quot;。 最后调用Animsition动画：123456789101112131415161718192021$(document).ready(function() &#123; $(".animsition").animsition(&#123; inClass: 'fade-in', outClass: 'fade-out', inDuration: 400, outDuration: 400, linkElement: '.animsition-link', loading: true, loadingParentElement: 'html', loadingClass: 'line-scale-pulse-out-rapid', loadingInner: '', timeout: false, timeoutCountdown: 5000, onLoadEvent: true, browser: [ 'animation-duration', '-webkit-animation-duration'], overlay : false, overlayClass : 'animsition-overlay-slide', overlayParentElement : 'html', transition: function(url)&#123; window.location.href = url; &#125; &#125;); &#125;inClass和outClass指定了页面载入和离开时候所展示的动画，这里使用淡入淡出的效果。Animsition提供了许多动画效果，可根据自己的喜好更换。inDuration和outDuration指定了动画的持续时间，单位为毫秒。linkElement指定超链接元素，这里是我们上面添加了class=&quot;animsition-link&quot;的a标签。页面加载动画Loader.css是一个纯CSS加载动画插件。Animsition插件自带的加载动画不太美观，所以使用该插件替换。 首先从https://github.com/ConnorAtherton/loaders.css上下载插件包，解压后打开loaders.css-master/demo/demo.html可看到许多美观的加载动画。选择一个自己喜欢的动画，然后F12查看其HTML源代码，比如：从源码中可知道，这个动画对应的class名称为line-scale-pulse-out-rapid然后修改一开始引入的animsition.js，找到并修改addLoading函数：12345addLoading: function(n) &#123; var html = '&lt;div class="' + n.loadingClass + '"&gt;'; html += '&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;'; t(n.loadingParentElement).append(html);&#125;,这里loadingClass属性名称是在 $(&quot;.animsition&quot;).animsition({})函数中指定的，细心的你可能会发现，我已经在上面的例子中将loadingClass属性值指定为line-scale-pulse-out-rapid了。接下来修改animsition.css，找到和.animsition-loading有关的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* loading option */.animsition-loading,.animsition-loading:after &#123; width: 32px; height: 32px; position: fixed; top: 50%; left: 50%; margin-top: -16px; margin-left: -16px; border-radius: 50%; z-index: 100;&#125; .animsition-loading &#123; background-color: transparent; border-top: 5px solid rgba(0, 0, 0, 0.2); border-right: 5px solid rgba(0, 0, 0, 0.2); border-bottom: 5px solid rgba(0, 0, 0, 0.2); border-left: 5px solid #eee; -webkit-transform: translateZ(0); transform: translateZ(0); -webkit-animation-iteration-count:infinite; animation-iteration-count:infinite; -webkit-animation-timing-function: linear; animation-timing-function: linear; -webkit-animation-duration: .8s; animation-duration: .8s; -webkit-animation-name: animsition-loading; animation-name: animsition-loading;&#125; @-webkit-keyframes animsition-loading &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125; @keyframes animsition-loading &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;这段代码是Animsition插件自带的加载动画，将其删除。然后从loaders.css-master/loader.css中找到和.line-scale-pulse-out-rapid有关的CSS代码：12345678910111213141516171819202122232425262728293031323334353637383940@-webkit-keyframes line-scale-pulse-out-rapid &#123; 0% &#123; -webkit-transform: scaley(1); transform: scaley(1); &#125; 80% &#123; -webkit-transform: scaley(0.3); transform: scaley(0.3); &#125; 90% &#123; -webkit-transform: scaley(1); transform: scaley(1); &#125; &#125; @keyframes line-scale-pulse-out-rapid &#123; 0% &#123; -webkit-transform: scaley(1); transform: scaley(1); &#125; 80% &#123; -webkit-transform: scaley(0.3); transform: scaley(0.3); &#125; 90% &#123; -webkit-transform: scaley(1); transform: scaley(1); &#125; &#125; .line-scale-pulse-out-rapid &gt; div &#123; background-color: #fff; width: 4px; height: 35px; border-radius: 2px; margin: 2px; -webkit-animation-fill-mode: both; animation-fill-mode: both; display: inline-block; vertical-align: middle; -webkit-animation: line-scale-pulse-out-rapid 0.9s -0.5s infinite cubic-bezier(0.11, 0.49, 0.38, 0.78); animation: line-scale-pulse-out-rapid 0.9s -0.5s infinite cubic-bezier(0.11, 0.49, 0.38, 0.78); &#125;.line-scale-pulse-out-rapid &gt; div:nth-child(2), .line-scale-pulse-out-rapid &gt; div:nth-child(4) &#123; -webkit-animation-delay: -0.25s !important; animation-delay: -0.25s !important; &#125;.line-scale-pulse-out-rapid &gt; div:nth-child(1), .line-scale-pulse-out-rapid &gt; div:nth-child(5) &#123; -webkit-animation-delay: 0s !important; animation-delay: 0s !important; &#125;将这段代码添加到animsition.css中。这里.line-scale-pulse-out-rapid &gt; div 的背景色是白色的（background-color: #fff），所以我们要将其修改为自己需要的颜色，比如博主将其替换为浅绿色：1234.line-scale-pulse-out-rapid &gt; div &#123; background-color: #6db33f; ...&#125;最后一步，我们需要修改加载动画模块div的定位方式为固定定位并且居中：12345.line-scale-pulse-out-rapid &#123; position: fixed; top: 50%; left: 50%&#125;将上面的步骤依次做完后，在加载包含较多图片的博客或者网络不佳的情况下，我们可以看到如下的加载动画：Animsition插件还有添加覆盖物overlay功能，博主没有使用这个功能，所以不再介绍，具体可查阅官方API。]]></content>
      <tags>
        <tag>Leanote</tag>
        <tag>theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用入门]]></title>
    <url>%2FGit%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[准备Git环境首先在ubuntu中查看是否安装了Git：123$ gitThe program 'git' is currently not installed. You can install it by typing:sudo apt install gitlinux提示尚未安装Git，并提供了安装的指令：sudo apt install git。第一次使用Git需要设置个人信息，如用户名邮箱等：12$ git config --global user.name "mrbird"$ git config --global user.email "mrbird@leanote.com"创建Git项目首先创建一个projects目录，然后在projects下创建first-project项目，包含foo.txt和bar.txt两个文件：12345678910111213$ mkdir projects$ cd projects/$ mkdir first-project$ cd first-project/$ vi foo.txt$ vi bar.txt$ tree -A projects/projects/└── first-project ├── bar.txt └── foo.txt 1 directory, 2 files创建版本库首先，我们需要在first-project下创建一个Git版本库，用于存储项目本身及其历史。对于一个带有版本库的项目目录，一般称之为工作区。123$ cd first-project/$ git initInitialized empty Git repository in /home/mrbird/projects/first-project/.git/再次使用tree命令就可以看到，在first-project目录下多了个.git隐藏目录，该目录就是Git用于跟踪并管理版本库用的：1234567$ tree -aA projects/projects/└── first-project ├── bar.txt ├── foo.txt └── .git...首次提交接下来，需要将foo.txt和bar.txt添加到版本库中去。在Git中，通常将项目的一个版本称之为一次提交。提交分为两个步骤：使用git add命令来确定下次提交前应该包含的文件；使用git commit命令将这些文件传送到版本库中，并生成散列值以标识这次更新。123456$ git add foo.txt bar.txt $ git commit -m "add foo.txt bar.txt"[master (root-commit) c2e4810] add foo.txt bar.txt 2 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 bar.txt create mode 100644 foo.txt检查状态现在将first-project目录下的bar.txt文件删除，添加bar.html文件，修改foo.txt文件内容。然后使用git status命令查看状态：123456789101112131415$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) deleted: bar.txt modified: foo.txt Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) bar.html no changes added to commit (use "git add" and/or "git commit -a")因为还没有使用git add命令将bar.html添加到版本库，所以显示为未跟踪状态（Untracked）。 我们也可以使用git diff命令来查看被修改的文件具体修改了啥：1234567$ git diff foo.txtdiff --git a/foo.txt b/foo.txtindex e69de29..3f9a7b1 100644--- a/foo.txt+++ b/foo.txt@@ -0,0 +1 @@+foo file可以看出，foo.txt文件添加了一行内容：foo file。提交修改将上述的修改归档成一次新的提交，即添加foo.txt和新文件bar.html，删除bar.txt：123$ git add foo.txt bar.html $ git rm bar.txt rm 'bar.txt'再次使用git status命令查看当前状态：12345678$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: bar.html deleted: bar.txt modified: foo.txt这时候我们就可以放心的使用git commit来提交这些修改：12345$ git commit -m "add bar.html,modify foo.txt,delete bar.txt"[master 94418b1] add bar.html,modify foo.txt,delete bar.txt 3 files changed, 2 insertions(+) create mode 100644 bar.html delete mode 100644 bar.txt显示历史使用git log命令可以查看所有提交的历史，并按时间顺序倒序排列：123456789101112$ git logcommit 94418b10e64f46bc4f48049037fadcb12efc5d10Author: mrbird &lt;mrbird@leanote.com&gt;Date: Sat May 27 14:09:51 2017 +0800 add bar.html,modify foo.txt,delete bar.txt commit c2e48100c4f2fc8afaed2b1cac90deaf6a7e34ecAuthor: mrbird &lt;mrbird@leanote.com&gt;Date: Sat May 27 11:08:29 2017 +0800 add foo.txt bar.txtGit协作功能假如现在还有另外一位开发者也参与开发first-project这个项目，为了方便实验，现在在projects目录下开辟另外一个工作区first-project-clone，供第二位开发者使用。克隆版本库现使用git clone来克隆first-project，该版本库副本包含了所有原始信息和整个项目的历史信息：123$ git clone projects/first-project/ projects/first-project-cloneCloning into 'projects/first-project-clone'...done.克隆后，观察项目结构：123456789101112$ tree -aA projects/projects/├── first-project│ ├── bar.html│ ├── foo.txt│ └── .git│ ├── ...└── first-project-clone ├── bar.html ├── foo.txt └── .git ├── ...从另一个版本库中获取修改现在，在first-project/foo.txt文件中插入一行信息”hello world,hello git”，并且提交修改：123456$ cd projects/first-project$ vi foo.txt $ git add foo.txt $ git commit -m "modify foo.txt in original"[master 8e1b132] modify foo.txt in original 1 file changed, 1 insertion(+)同时修改克隆版本库first-project-clone中的bar.html，并且提交修改：1234$ git add bar.html$ git commit -m "modify bar.html in clone"[master 796e40d] modify bar.html in clone 1 file changed, 1 insertion(+)现在，新的提交已经被存入到了first-project版本库中，但是其克隆版本库first-project-clone并没有取得这次修改（即foo.txt还是保持原样）。如果克隆版本库也要获取原版本库中的修改，我们可以使用git pull命令来获取：12345678910111213141516$ cd ../first-project-clone/$ cat foo.txt foo file$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From /home/mrbird/projects/first-project 8e1b132..27b76ec master -&gt; origin/masterMerge made by the 'recursive' strategy. foo.txt | 1 + 1 file changed, 1 insertion(+)$ cat foo.txt foo filehello world,hello git由于在创建克隆版本库的时候，原版本库的路径就已经被存储到克隆版本库中了。所以在克隆版本库中使用git pull命令，不带路径的话，默认就是从原版本库中取回修改。 从结果中可以看出，Git从原版本库中取回了修改，与克隆体中的修改进行了比对，并且合并了这些修改。这个过程称为合并（merge）。在pull过程中，如果发生了冲突，比如两位开发者同时对foo.txt文件进行了修改，Git不会自动去处理这些冲突，必须手动去做修改。在pull取回修改，并且merge合并之后，可以使用git log --graph命令来查看图形化日志：12345678 $ git log --graph --oneline * 8747b24 Merge branch 'master' of /home/mrbird/projects/first-project|\ | * 27b76ec modify foo.txt in original* | 796e40d modify bar.html in clone|/ * 94418b1 add bar.html,modify foo.txt,delete bar.txt* c2e4810 add foo.txt bar.txt从上面可以清晰的看出，分支合并的情况。从任意版本库中取回修改git pull带上仓库路径的话就可以从任意一个版本库中取回修改了，现在在原版本库first-project中取回其克隆版本库first-project-clone对bar.html的修改：1234567891011$ git pull ../first-project-clone/remote: Counting objects: 5, done.remote: Compressing objects: 100% (4/4), done.remote: Total 5 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (5/5), done.From ../first-project-clone * branch HEAD -&gt; FETCH_HEADUpdating 27b76ec..8747b24Fast-forward bar.html | 1 + 1 file changed, 1 insertion(+)创建共享版本库除了使用git pull命令从别的版本库取回修改外，我们还可以使用git push命令将本地修改传送给其他版本库。 不过，git push命令只适用于那些没有开发者在上面具体工作的版本库。通常的做法是创建一个没有工作区的版本库，也称之为裸版本库。裸版本库就是单纯用于存放各个开发这提交（push）的修改，方便别的开发者取回（pull）这些修改。现使用git clone --bare命令来创建裸版本库：123$ git clone --bare first-project first-project-bareCloning into bare repository 'first-project-bare'...done.使用push向裸版本库提交修改再次修改原版本库first-project中的foo.txt文件，并且提交修改：1234$ git add foo.txt $ git commit -m "modify foo.txt in original again"[master 31e1f6f] modify foo.txt in original again 1 file changed, 1 insertion(+), 1 deletion(-)现在使用git push向裸版本库提交这次修改，push需要指定目标版本库路径以及其分支。1234567$ git push ../first-project-bare/ masterCounting objects: 3, done.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 316 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To ../first-project-bare/ 8747b24..31e1f6f master -&gt; master如果另一位开发者在我们之前就已经push了修改，那此次的push操作将会被拒绝，必须先pull回修改，才能push我们的修改。使用pull从裸版本库取回修改123456789101112$ cd ../first-project$ git pull ../first-project-bare/ masterremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3/3), done.From ../first-project-bare * branch master -&gt; FETCH_HEADUpdating 8747b24..31e1f6fFast-forward foo.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的Deferred和Promise]]></title>
    <url>%2FjQuery%E4%B8%AD%E7%9A%84Deferred%E5%92%8CPromise.html</url>
    <content type="text"><![CDATA[jQuery中的Deferred和Promise有助于我们处理Ajax这样的异步过程，以jQuery中的\$.ajax()为例，当嵌套多个\$.ajax()异步函数时，代码就成了下面这样：12345678910111213141516171819202122$.ajax(&#123; url: "myUrl1.do", success:function()&#123; $.ajax(&#123; url: "myUrl2.do", success:function()&#123; $.ajax(&#123; url: "myUrl3.do", success:function()&#123; $.ajax(&#123; url: "myUrl4.do", success:function(r)&#123; console.log("假如你愿意一层一层剥开我的心...") console.log(r); &#125; &#125;); &#125; &#125;); &#125; &#125;); &#125;&#125;);这种“金字塔”式的代码就是所谓的“回调地狱”。这种风格的代码使得调试变得很困难，使用jQuery中Promise对象可以很好的处理这个问题。使用Promise改写\$.ajax()回调实际上，$.ajax()返回的就是Promise对象，如：12345678910var promise = $.ajax(&#123;url:'myUrl.do'&#125;);promise.done(function()&#123; // 成功时，执行该函数&#125;)promise.fail(function()&#123; // 失败时，执行该函数&#125;)promise.always(function()&#123; // 无论成功或失败，都执行该函数&#125;)我们也可以用then()方法把done()和fail()合并到一起。12345promise.then(function()&#123; // done&#125;, function()&#123; // fail&#125;)第一个参数表示done方法，第二个方法表示fail方法；如果只传递一个参数的话，就表示done方法。所以，现在来改写一下上面的“金字塔”代码：1234567891011var promise1 = $.ajax(&#123;url:"myUrl1.do"&#125;);var promise2 = promise1.then(function()&#123; return $.ajax(&#123;url:"myUrl2.do"&#125;);&#125;);var promise3 = promise2.then(function()&#123; return $.ajax(&#123;url:"myUrl3.do"&#125;);&#125;);var promise4 = promise3.then(function()&#123; return $.ajax(&#123;url:"myUrl4.do"&#125;);&#125;);promise4.then(function(r)&#123;console.log(r);&#125;);是不是好了很多？jQuery中的$.when()当多个Ajax请求都成功的时候，执行某个回调函数，这时候就可以使用$.when()方法。如：123456789$.when( $.ajax(&#123;url:'myUrl1.do'&#125;), $.ajax(&#123;url:'myUrl2.do'&#125;)).done(function(result1, result2)&#123; console.log(result1); console.log(result2);&#125;).fail(function(r)&#123; console.log("error");&#125;)在这个例子中，只有当两个Ajax请求都成功时，才会调用done方法。否则就调用fail方法。$.Deferred()$.Deferred().promise()方法可以返回一个Promise对象。$.Deferred()包含了三种状态：pending：等待状态resolved：成功（解决）状态rejected：失败（拒绝）状态默认的状态为pending，可以使用resolve和reject方法来改变状态：12345var deferred = $.Deferred();console.log(deferred.state()); //pendingdeferred.reject();console.log(deferred.state()); //rejected或者：12345var deferred = $.Deferred();console.log(deferred.state()); //pendingdeferred.resolve();console.log(deferred.state()); //resolved当状态为rejected时，执行fail方法。当状态为resolved时，执行done方法。而always方法无论成功与失败都会执行。例如，下面这个例子三秒后弹出success：See the Pen deferred by wuyouzhuguli (@mrbird) on CodePen.]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery函数attr()和prop()的区别 [转]]]></title>
    <url>%2FjQuery%E5%87%BD%E6%95%B0attr-%E5%92%8Cprop-%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%BD%AC.html</url>
    <content type="text"><![CDATA[在jQuery中，attr()函数和prop()函数都用于设置或获取指定的属性，它们的参数和用法也几乎完全相同。 但不得不说的是，这两个函数的用处却并不相同。下面我们来详细介绍这两个函数之间的区别。操作对象不同很明显，attr和prop分别是单词attribute和property的缩写，并且它们均表示”属性”的意思。不过，在jQuery中，attribute和property却是两个不同的概念。attribute表示HTML文档节点的属性，property表示JS对象的属性。1234567 &lt;!-- 这里的id、class、data_id均是该元素文档节点的attribute --&gt;&lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt;// 这里的name、age、url均是obj的propertyvar obj = &#123; name: "CodePlayer", age: 18, url: "http://www.365mini.com/" &#125;;&lt;/script&gt;在jQuery中，prop()函数的设计目标是用于设置或获取指定DOM元素（指的是JS对象，Element类型）上的属性property；attr()函数的设计目标是用于设置或获取指定DOM元素所对应的文档节点上的属性attribute。12345678&lt;!-- attr()函数针对的是该文档节点的attribute --&gt;&lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt;// prop()函数针对的是该DOM元素(msg)自身的propertyvar msg = document.getElementById("message");var $msg = $(msg);&lt;/script&gt;当然，在jQuery的底层实现中，函数attr()和prop()的功能都是通过JS原生的Element对象（如上述代码中的msg）实现的。attr()函数主要依赖的是Element对象的getAttribute()和setAttribute()两个方法。prop()函数主要依赖的则是JS中原生的对象属性获取和设置方式。1234567891011121314151617181920212223&lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var msg = document.getElementById("message");var $msg = $(msg); /* attr()依赖的是Element对象的element.getAttribute( attribute ) * 和 element.setAttribute( attribute, value ) */ // 相当于 msg.setAttribute("data_id", 145);$msg.attr("data_id", 145);// 相当于 msg.getAttribute("data_id");var dataId = $msg.attr("data_id"); // 145 /* prop()依赖的是JS原生的 element[property] * 和 element[property] = value; */ // 相当于 msg["pid"] = "pid值";$msg.prop("pid", "pid值");// 相当于 msg["pid"];var testProp = $msg.prop("pid"); // pid值&lt;/script&gt;当然，jQuery对这些操作方式进行了封装，使我们操作起来更加方便(比如以对象形式同时设置多个属性)，并且实现了跨浏览器兼容。此外，虽然prop()针对的是DOM元素的property，而不是元素节点的attribute。不过DOM元素某些属性的更改也会影响到元素节点上对应的属性。例如，property的id对应attribute的id，property的className对应attribute的class。12345678910&lt;div id="message" class="test" data_id="123"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var msg = document.getElementById("message");var $msg = $(msg); console.log( $msg.attr("class") ); // test$msg.prop("className", "newTest");// 修改className(property)导致class(attitude)也随之更改console.log( $msg.attr("class") ); // newTest&lt;/script&gt;应用版本不同attr()是jQuery 1.0版本就有的函数，prop()是jQuery 1.6版本新增的函数。毫无疑问，在1.6之前，你只能使用attr()函数；1.6及以后版本，你可以根据实际需要选择对应的函数。用于设置的属性值类型不同由于attr()函数操作的是文档节点的属性，因此设置的属性值只能是字符串类型，如果不是字符串类型，也会调用其toString()方法，将其转为字符串类型。 prop()函数操作的是JS对象的属性，因此设置的属性值可以为包括数组和对象在内的任意类型。123456789101112&lt;input id="uid" type="checkbox" checked="true" value="1"&gt;&lt;script type="text/javascript"&gt;// 当前jQuery版本为1.11.1var uid = document.getElementById("uid");var $uid = $(uid); console.log($uid.attr("checked")); // checkedconsole.log(typeof $uid.attr("checked")); // string console.log($uid.prop("checked")); // trueconsole.log(typeof $uid.prop("checked")); //boolean&lt;/script&gt;其他细节问题在jQuery 1.6之前，只有attr()函数可用，该函数不仅承担了attribute的设置和获取工作，还同时承担了property的设置和获取工作。例如：在jQuery 1.6之前，attr()也可以设置或获取tagName、className、nodeName、nodeType等DOM元素的property。直到jQuery 1.6新增prop()函数，并用来承担property的设置或获取工作之后，attr()才只用来负责attribute的设置和获取工作。此外，对于表单元素的checked、selected、disabled等属性，在jQuery 1.6之前，attr()获取这些属性的返回值为Boolean类型：如果被选中（或禁用）就返回true，否则返回false。但是从1.6开始，使用attr()获取这些属性的返回值为String类型，如果被选中（或禁用）就返回checked、selected或disabled，否则（即元素节点没有该属性）返回undefined。并且，在某些版本中，这些属性值表示文档加载时的初始状态值，即使之后更改了这些元素的选中（或禁用）状态，对应的属性值也不会发生改变。因为jQuery认为：attribute的checked、selected、disabled就是表示该属性初始状态的值，property的checked、selected、disabled才表示该属性实时状态的值（值为true或false）。因此，在jQuery 1.6及以后版本中，请使用prop()函数来设置或获取checked、selected、disabled等属性。对于其它能够用prop()实现的操作，也尽量使用prop()函数。12345678910111213141516171819&lt;input id="uid" type="checkbox" checked="checked" value="1"&gt; &lt;script type="text/javascript"&gt;// 当前jQuery版本为1.11.1var uid = document.getElementById("uid");var $uid = $(uid); console.log( $uid.attr("checked") ); // checkedconsole.log( $uid.prop("checked") ); // true // 取消复选框uid的选中(将其设为false即可)// 相当于 uid.checked = false;$uid.prop("checked", false); // attr()获取的是初始状态的值，即使取消了选中，也不会改变console.log( $uid.attr("checked") ); // checked// prop()获取的值已经发生变化console.log( $uid.prop("checked") ); // false&lt;/script&gt;转自CodePlayer]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi编辑器的三种模式]]></title>
    <url>%2Fvi%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[通常来说，vi编辑器有三种模式，分别是一般指令模式、编辑模式与指令行命令模式。 这三种模式的作用分别是：一般指令模式（command mode）以 vi 打开一个文件就直接进入一般指令模式了（这是默认的模式，也简称为一般模式）。在这个模式中， 你可以使用上下左右按键来移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、黏贴来处理你的文件数据。编辑模式（insert mode）编辑模式可以对内容进行编辑，按下i, I, o, O, a, A, r, R等任何一个字母之后即可进入编辑模式。如果要回到一般指令模式时， 则必须要按下Esc这个按键即可退出编辑模式。命令行模式（command-line mode）在一般模式当中，输入:, /, ? 三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中， 可以提供你搜寻资料的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等等的动作则是在此模式中达成的！ 总之，三者的关系可以用下图来概况：各模式下的快捷键一般指令模式移动光标的方法h 或 向左箭头键(←)光标向左移动一个字符j 或 向下箭头键(↓)光标向下移动一个字符k 或 向上箭头键(↑)光标向上移动一个字符l 或 向右箭头键(→)光标向右移动一个字符hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以 使用 “30j” 或 “30↓” 的组合按键，亦即加上想要进行的次数（数字）后，按下动作即可！[Ctrl] + [f]屏幕向下移动一页，相当于 [Page Down]按键[Ctrl] + [b]屏幕向上移动一页，相当于 [Page Up] 按键&nbsp;[Ctrl] + [d]&nbsp;屏幕向下移动半页[Ctrl] + [u]&nbsp;屏幕向上移动半页n&lt;space&gt;n 表示数字，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个 字符。例如 20 则光标会向后面移动 20 个字符距离。0 或功能键[Home]移动到这一行的最前面字符处$ 或功能键[End]&nbsp;移动到这一行的最后面字符处H &nbsp;&nbsp;光标移动到这个屏幕的最上方那一行的第一个字符M&nbsp;光标移动到这个屏幕的中央那一行的第一个字符L&nbsp;光标移动到这个屏幕的最下方那一行的第一个字符G移动到这个文件的最后一行nGn 为数字。移动到这个文件的第 n 行。例如 20G 则会移动到这个文件的第 20 行gg &nbsp;移动到这个文件的第一行n&lt;Enter&gt;&nbsp;n 为数字。光标向下移动 n 行搜索与替换/word&nbsp;向光标之下寻找一个名称为 word 的字符串?word&nbsp;向光标之上寻找一个字符串名称为 word 的字符串n&nbsp;重复前一个搜寻的动作N&nbsp;与 n 刚好相反，为反向进行前一个搜寻动作。 例如 /word 后，按下 N 则表示 ?word:n1,n2s/word1/word2/gn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代 为 word2 ， 比如：在 100 到 200 行之间搜寻 null并取代为 NULL&nbsp;则 :100,200s/null/NULL/g:1,$s/word1/word2/g&nbsp;从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2&nbsp;:1,$s/word1/word2/gc&nbsp;从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 。且在取代前显示提示字符 给用户确认 (confirm) 是否需要取代删除，复制与黏贴x, X&nbsp;在一行字当中，x 为向后删除一个字符， X 为向前删除一个字符nx&nbsp;n为数字，连续向后删除 n 个字符dd&nbsp;删除游标所在的那一整行ndd&nbsp;n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行d1G&nbsp;删除光标所在到第一行的所有数据dG删除光标所在到最后一行的所有数据d$&nbsp;删除游标所在处，到该行的最后一个字符d0&nbsp;删除游标所在处，到该行的第一个字符yy&nbsp;复制游标所在的那一行nyy&nbsp;n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行y1G&nbsp;复制光标所在行到第一行的所有数据yG&nbsp;复制光标所在行到最后一行的所有数据y0&nbsp;复制光标所在的那个字符到该行行首的所有数据y$&nbsp;复制光标所在的那个字符到该行行尾的所有数据p, P&nbsp;p 为将已复制的数据黏贴到光标下一行，P 则为黏贴到上一行J&nbsp;将光标所在行与下一行的数据结合成同一行u&nbsp;回退，类似于Ctrl+z[Ctrl]+r&nbsp;前进，类似于Ctrl+y.重复前一个动作。 如果你想要重复删除、重复黏贴等动作，按下小数点.就好了一般指令模式切换到编辑模式的可用的快捷键进入INSERT或REPLACE模式i, I &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;进入插入模式(Insert mode)： i 为从目前光标所在处插入，I 为在目前所在行的第一个非空格符处开始插入a, A&nbsp;进入插入模式(Insert mode)： a 为从目前光标所在的下一个字符处开始插入， A 为从光标所在行的最后一个字符处开始插入o, O&nbsp;进入插入模式(Insert mode)： o 为在目前光标所在的下一行处插入新的一行； O 为在目前光标所在处的上一行插入新的一行r, R&nbsp;进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 ESC 为止[Esc]&nbsp;退出编辑模式，回到一般指令模式中一般指令模式切换到命令行模式可用的快捷键命令行模式的存储，离开等指令:w &nbsp; &nbsp;&nbsp;将编辑的数据写入硬盘文件中（保存）:w!&nbsp;若文件属性为只读时，强制写入该文件。不过，到底能不能写入，还是跟你对该文件的文件权限有关:q &nbsp;离开 vi:q!&nbsp;若曾修改过文件，又不想储存，使用 ! 为强制离开不储存文件:wq&nbsp;储存后离开，若为 :wq! 则为强制储存后离开ZZ&nbsp;若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！:w filename将编辑的数据储存成另一个文件:r filename在编辑的数据中，读入另一个文件的数据。亦即将filename这个文件内容加到游标所在行后面:n1,n2 w filename&nbsp;将 n1 到 n2 的内容储存成 filename 这个文件:! command&nbsp;暂时离开 vi 到指令行模式下执行 command 的显示结果。例如 :! ls /home即可在 vi 当中察看 /home 底下以 ls 输出的文件信息vim 环境的变更:set nu&nbsp;显示行号，设定之后，会在每一行的前缀显示该行的行号:set nonu&nbsp;与:set nu 相反，为取消行号《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery效果函数]]></title>
    <url>%2FjQuery%E6%95%88%E6%9E%9C%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[基本show()用于显示所有匹配的元素。此外，你还可以指定元素显示的过渡动画效果。 如果元素本身是可见的，则不对其作任何改变。如果元素是隐藏的，则使其可见。 常用语法：jQueryObject.show( [ duration ] [, easing ] [, complete ] )。参数描述duration可选/String/Number类型指定过渡动画运行多长时间（毫秒数），默认值为400。该参数也可以为字符串”fast”（=200）或”slow”（=600）。easing可选/String类型指定使用何种动画效果，默认为”swing”，还可以设为”linear”或其他自定义的动画样式的函数名称。complete可选/Function类型元素显示完毕后需要执行的函数。函数内的 this指向当前DOM元素。 比如显示p元素，过渡动画为600ms：12$("p").show(600); // 或者 $("p").show("slow"); $("p").show( &#123; duration: 1000 &#125; );显示p元素，过度动画为200ms，动画效果为linear：1$("p").show(600,"linear");显示p元素，并添加回调函数：1$("p").show(function()&#123; alert('显示完毕') &#125;);hide()用于隐藏所有匹配的元素。作用和show()相反，语法一样，这里不再赘述。 例如隐藏p元素，动画速度为fast，并添加回调：1$("p").hide("fast",function()&#123; alert('隐藏完毕') &#125;);滑动slideDown()用于显示所有匹配的元素，并带有向下滑动的过渡动画效果。 向下滑动的动画效果，即元素可见区域的高度从0逐渐增大到其原有高度(向下逐渐展开)。 如果元素本身是可见的，则不对其作任何改变。如果元素是隐藏的，则使其可见。 语法和show()一致，不再赘述。slideUp()效果和slideUp()相反，语法一致，不再赘述。slideToggle()用于切换所有匹配的元素，并带有滑动的过渡动画效果。 所谓”切换”，也就是如果元素当前是可见的，则将其隐藏（向上滑动）；如果元素当前是隐藏的，则使其显示（向下滑动）。 语法和show()一致，不再赘述。 例如，向上或向下滑动下拉框div元素，并添加回调：12345678$("div").slideToggle(function()&#123; var $this = $(this); if($this.is(":visible"))&#123; alert("向下滑动展开"); &#125;else&#123; alert("向上滑动隐藏"); &#125;&#125;);淡入淡出fadeIn()用于显示所有匹配的元素，并带有淡入的过渡动画效果。 淡入的动画效果，即元素的不透明度的比例从0%逐渐增加到100%。 如果元素本身是可见的，则不对其作任何改变。如果元素是隐藏的，则使其可见。 语法和show()一致，不再赘述。fadeOut()用于隐藏所有匹配的元素，并带有淡出的过渡动画效果。效果和fadeIn()相反，语法和show()一致，不再赘述。fadeTo()以渐进的方式把元素从当前透明的过渡到指定的透明度。可以指定过渡时长，目标透明度，回调函数等。 常用语法：fadeTo(duration,opacity [,complete])。 例如，将p元素的透明的调整为.5，时长200ms，并添加回调：123$( "p" ).fadeTo( "slow" , 0.5, function() &#123; // Animation complete.&#125;);fadeToggle()用于切换所有匹配的元素，并带有淡入/淡出的过渡动画效果。 所谓”切换”，即如果元素当前是可见的，则将其隐藏（淡出）；如果元素当前是隐藏的，则使其显示（淡入）。语法和show()一致，不再赘述。自定义animate()用于执行一个基于css属性的自定义动画。 你可以为匹配的元素设置css样式，animate()函数将会执行一个从当前样式到指定的css样式的一个过渡动画。 常用语法：jQueryObject.animate( cssProperties [, duration ] [, easing ] [, complete ] )。参数描述cssPropertiesObject类型一个或多个css属性的键值对所构成的Object对象。duration可选/String/Number类型指定动画运行多长时间（毫秒数），默认值为400。该参数也可以为字符串”fast”（=200）或”slow”（=600）。easing可选/String类型指定使用何种动画效果，默认为”swing”，还可以设为 “linear”或其他自定义的动画样式函数。complete可选/Function类型元素显示完毕后需要执行的函数。函数内的this指向当前DOM元素。大多数非数值的css属性都无法用来执行动画。例如：width、height、left、top都可用于动画，但color、background-color无法用于动画（除非使用jQuery.Color()插件）。除非你为属性值指定了单位（例如：px、em、%），否则默认的数值单位为像素（px）。速写的css属性可能无法获得完整全面的支持，例如：border、margin等，因此不推荐使用。你还可以将css属性值设为一些特定的字符串，例如：”show”、”hide”、”toggle”，则jQuery会调用该属性默认的动画形式。此外，css属性值也可以是相对的，你可以为属性值加上前缀”+=”或”-=”，以便于在原来的属性值上增加或减少指定的数值。例如：{ &quot;height&quot;: &quot;+=100px&quot; }，表示在原有高度的基础上增加100px。例如，给div高度调整为300px，宽度调整为400px，动画时长为slow：1$("div").animate( &#123; width: "400px", height: "300px" &#125;, "slow" );根据div高度切换显示/隐藏，显示时高度从0增加到原高度，隐藏时高度从原高度减小到0：1$("div").animate( &#123; height: "toggle" &#125;);stop()用于停止当前匹配元素上正在运行的动画。比如div绑定了三个animate动画函数：123var $myDiv = $("div");$myDiv.animate( &#123; height: "+=300px" &#125;, 2000 ); // 动画1$myDiv.animate( &#123; width: "50%" &#125;, 1000 ); // 动画2假设当前div元素正在执行第一个动画，此时执行以下stop()函数时，效果为：1234$myDiv.stop( ); // 马上停止动画1，继续按顺序执行动画2和动画3$myDiv.stop( true ); // 马上停止动画1，并且不再执行动画2和动画3$myDiv.stop( "fx", true ); // 效果和$myDiv.stop( true );一样$myDiv.stop( true, true ); // 立刻马上执行完动画1，并不再执行动画2和动画3delay()用于延迟队列中下一项的执行。delay()可以将队列中等待执行的下一个动画延迟指定的时间后才执行。它常用在队列中的两个jQuery效果函数之间，从而在上一个动画效果执行后延迟下一个动画效果的执行时间。 如果下一项不是效果动画（比如show()就不是效果动画），则它不会被加入效果队列中，因此该函数不会对它进行延迟调用。 比如：123var $myDiv = $("div");$myDiv.slideUp( 1000 ).delay( 5000 ).slideDown( 1500 );//先执行slideUp()，然后等待5s，在执行slideDown()finish()停止当前正在运行的动画，删除所有队列中的动画，直接显示最终动画执行完毕的效果。比如div绑定了三个animate动画函数：1234var $myDiv = $("div");$myDiv.animate( &#123; height: "+=300px" &#125;, 2000 ); // 动画1$myDiv.animate( &#123; width: "50%" &#125;, 1000 ); // 动画2$myDiv.animate( &#123; width: "200px", height: "100px" &#125;, 1000 ); // 动画3假设当前div元素正在执行第一个动画，此时执行finish()函数时，立刻停止当前动画，并且div直接变为最终状态（width: &quot;200px&quot;, height: &quot;100px&quot;）。设置jQuery.fx.interval用于设置jQuery动画每隔多少毫秒绘制一帧图像，该值越小，则动画的触发次数越多，动画效果也更明显、更平滑，当然也就越耗费性能，默认值为13。设置帧数为5：1$.fx.interval = 5;jQuery.fx.off关闭页面上所有的动画。把这个属性设置为true可以立即关闭所有动画（所有效果会立即执行完毕）。 有些情况下可能需要这样，比如你在配置比较低的电脑上使用jQuery。当把这个属性设成false之后，可以重新开启所有动画。 禁用动画效果：1$.fx.off = true; // 禁用动画效果参考网站：http://www.365mini.com/http://caibaojian.com/jquery/]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery工具函数]]></title>
    <url>%2FjQuery%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[数组和对象操作$.each()用于遍历对象或数组：jQuery.each(array,callback)或jQuery.each(object,callback)。 例如，遍历数组：123$.each([ 27, 41 ], function( index, value ) &#123; console.log( index + ": " + value );&#125;);遍历对象：1234567var obj = &#123; "name": "mrbird", "age": "24"&#125;;$.each( obj, function( key, value ) &#123; console.log( key + ": " + value );&#125;)$.extend()将一个或多个对象的内容合并到第一个对象中。有两种构造函数：jQuery.extend( target [, object1 ] [, objectN... ] )和jQuery.extend( [ deep ], target , object1 [, objectN... ] )。如果多个对象具有相同的属性，则后者会覆盖前者的属性值。参数描述deep可选Boolean类型 指示是否深度合并对象，默认为false，不能明写false。如果该值为true，且多个对象的某个同名属性也都是对象，则该”属性对象”的属性也将进行合并。targetObject类型目标对象，其他对象的成员属性将被复制到该对象上。object1可选/Object类型第一个被合并的对象。objectN可选/Object类型第N个被合并的对象。例如，合并两个对象，修改第一个对象：123456789101112var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;;$.extend( object1, object2 );console.log(JSON.stringify( object1 )); // &#123;"apple":0,"banana":&#123;"price":200&#125;,"cherry":97,"durian":100&#125;递归合并两个对象，修改第一个对象：12$.extend( true, object1, object2 );// &#123;"apple":0,"banana":&#123;"weight":52,"price":200&#125;,"cherry":97,"durian":100&#125;$.grep()函数用于使用指定的函数过滤数组中的元素，并返回过滤后的数组。 源数组不会受到影响，过滤结果只反映在返回的结果数组中。语法如下：1jQuery.grep( array, function [, invert ] )参数描述arrayArray类型 将被过滤的数组。functionFunction类型 指定的过滤函数。invert可选/Boolean类型 默认值为 false 。指定是否反转过滤结果。例如：12345678$.grep( [ 0, 1, 2 ], function( n, i ) &#123; return n &gt; 0;&#125;);// [1, 2]$.grep( [ 0, 1, 2 ], function( n, i ) &#123; return n &gt; 0;&#125;,true);// [0]$.makeArray()将一个类数组对象转换为真正的数组对象。例如：1234var obj = &#123; 0: "mrbird", 1: "blog", 2: true &#125;;console.log(obj instanceof Array); // falsevar arr = $.makeArray(obj);console.log(arr instanceof Array); // true$.map()用于处理数组中的每个元素(或对象的每个属性)，并将处理结果封装为新的数组返回。例如：将数组中的每个值+4，并返回：1234var arr = $.map( [ 0, 1, 2 ], function( n ) &#123; return n + 4;&#125;);console.log(arr); // [4, 5, 6]数组中大于0的值+1，小于0的删除：1234var arr = $.map( [ -3, 0, 1, 5 ], function( n ) &#123; return n &gt; 0 ? n + 1 : null;&#125;);console.log(arr); // [2, 6]将原始数组映射到新的数组，每个元素都加上其原始值和值加1：1234var arr = $.map( [ 0, 1, 2 ], function( n ) &#123; return [ n, n + 1 ];&#125;);console.log(arr); // [ 0, 1, 1, 2, 2, 3 ]将对象的键映射到数组：12345var obj = &#123; width: 10, height: 15, length: 20 &#125;;var keys = $.map( obj, function( value, key ) &#123; return key;&#125;);console.log(obj); // [ "width", "height", "length" ]$.inArray()用于在数组中搜索指定的值，并返回其索引值。如果数组中不存在该值，则返回 -1。1234var arr = [ 4, "Pete", 8, "John" ];console.log($.inArray( "John", arr )); // 3console.log($.inArray( 4, arr )); // 0console.log($.inArray( "mrbird", arr )); // -1$merge()将两个数组的内容合并到第一个数组中。例如：12var arr = $.merge( [ 0, 1, 2 ], [ 2, 3, 4 ] )console.log(arr); // [0, 1, 2, 2, 3, 4]函数操作$.noop()函数为一个空函数，什么也不做。其源码为：1noop: function() &#123;&#125;$.proxy()用于改变函数的上下文。你可以将指定函数传入该函数，该函数将返回一个新的函数，其执行代码不变，但函数内部的上下文this已经被更改为指定值。 例如：12345678function test()&#123; console.log(this); &#125;test(); // Window var object = &#123; name : "mrbird", age : 100 &#125;var proxy = $.proxy(test,object);proxy(); // Object测试操作$.contains()用于判断指定元素内是否包含另一个元素。 简而言之，该函数用于判断另一个DOM元素是否是指定DOM元素的后代。jQuery.contains()仅用于比较两个DOM元素，不能用于比较nodeList或者jQuery对象。例如：123456&lt;div id="n1"&gt; &lt;p id="n2"&gt; &lt;span id="n3"&gt;leanote&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;p id="n4"&gt;mrbird's blog&lt;/p&gt;12345678var $n1 = $("#n1")[0];var $n2 = $("#n2")[0];var $n3 = $("#n3")[0];var $n4 = $("#n4")[0]; console.log( $.contains( $n1, $n2 ) ); // trueconsole.log( $.contains( $n1, $n3 ) ); // trueconsole.log( $.contains( $n1, $n4 ) ); // false$.type()用于确定JavaScript内置对象的类型，并返回小写形式的类型名称。JavaScript也自带有一个typeof运算符，可以确定数据的类型。不过对于绝大多数对象而言，typeof运算符都返回Object，无法区分具体的类型。$.type()可以更加精确地确定JS内置对象的类型。123456789101112131415161718192021console.log( $.type( undefined ) ); // undefinedconsole.log( $.type( null ) ); // nullconsole.log( $.type( true ) ); // booleanconsole.log( $.type( new Boolean(false) ) ); // booleanconsole.log( $.type( 3 ) ); // numberconsole.log( $.type( new Number(3) ) ); // numberconsole.log( $.type( "test" ) ); // stringconsole.log( $.type( new String("test") ) ); // stringconsole.log( $.type( function()&#123;&#125; ) ); // functionconsole.log( $.type( new Function() ) ); // functionconsole.log( $.type( [] ) ); // arrayconsole.log( $.type( new Array() ) ); // arrayconsole.log( $.type( new Date() ) ); // dateconsole.log( $.type( new Error() ) ); // errorconsole.log( $.type( /test/ ) ); // regexpconsole.log( $.type( new RegExp("\\d+") ) ); // regexp /* 除上述类型的对象外，其他对象一律返回"object" */console.log( $.type( &#123;&#125; ) ); // objectfunction User() &#123; &#125;console.log( $.type( new User() ) ); // object$.isArray()用于判断指定参数是否是一个数组。$.isFunction()用于判断指定参数是否是一个函数。$.isEmptyObject()用于判断指定参数是否是一个空对象。123console.log( $.isEmptyObject( &#123; &#125; ) ); // trueconsole.log( $.isEmptyObject( new Object() ) ); // trueconsole.log( $.isEmptyObject( new Function() ) ); // true$.isPlainObject()用于判断指定参数是否是一个纯粹的对象。 所谓“纯粹的对象”，就是该对象是通过{}或new Object创建的。123456console.log( $.isPlainObject( &#123; &#125; ) ); // trueconsole.log( $.isPlainObject( new Object() ) ); // trueconsole.log( $.isPlainObject( &#123; name: "CodePlayer"&#125; ) ); // trueconsole.log( $.isPlainObject( &#123; sayHi: function()&#123;&#125; &#125; ) ); // true console.log( $.isPlainObject( new Function() ) ); // false$.isWindow()判断当前对象是否为浏览器内置的Window对象。12console.log( $.isWindow( this ) ); // trueconsole.log( $.isWindow( window ) ); // true$.isNumeric()用于判断指定参数是否是一个数字值。字符串操作$.trim()该函数可以去除字符串开始和末尾两端的空白字符(直到遇到第一个非空白字符串为止)。它会清除包括换行符、空格、制表符等常见的空白字符。如果参数str不是字符串类型，该函数将自动将其转为字符串（一般调用其toString()方法）。如果参数str为null或undefined，则返回空字符串。URL$.param()用于将一个JS数组或纯粹的对象序列化为字符串值，以便用于URL查询字符串或AJAX请求。如果传入的不是数组或“纯粹的对象”，则返回空字符串；如果传入的是null、undefined等无法访问属性的值，则直接报错。所谓“纯粹的对象”，就是通过{}或new Object()自行创建的对象。JS内置的Boolean、Number、String、Date、RegExp、Function、Window等类型的对象都不算是“纯粹的对象”。返回的字符串已经过URL编码处理（采用的字符集为UTF-8）。看一些例子：123// 字符串将被看作一个字符数组console.log( $.param( "mrbird" )); // 0=m&amp;1=r&amp;2=b&amp;3=i&amp;4=r&amp;5=dconsole.log( $.param( &#123; name:"mrbird", job:"Coder" &#125; )); // name=mrbird&amp;job=Coder如果参数是一个数组Array，那么它的每个元素都必须是一个包含name属性和value属性的对象，其他属性不会被处理（value属性可以没有，默认其值为undefined，将被转换为空字符串）。例如：123456var array = [ &#123; name: "name", value: "mrbird" &#125;, &#123; name: "age", value: 100, extra: "ignore" &#125;, &#123; name: "grade" &#125;];console.log( $.param( array )); // name=mrbird&amp;age=100&amp;grade=编写插件$.error()用于为每个匹配元素的error事件绑定处理函数。例如图片加载失败时，弹出框提醒：123$("img").error( function()&#123; alert( "图片加载失败!" );&#125; );我们还可以为事件处理函数传递一些附加的数据，并用Event对象获取：123456var newImageURL = "../img/test.png"; $("img").error( newImageURL, function(event)&#123; this.src = event.data; console.log(event.data); // ../img/test.png&#125; );$.fn.jquery用于返回当前jQuery库的版本号。1console.log($.fn.jquery); // 1.11.1或者使用任意jQuery对象的jquery属性访问：1console.log($("body").jquery); // 1.11.1参考网站：http://www.365mini.com/http://jquery.com/http://caibaojian.com/jquery/]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leanote博客主题Summer]]></title>
    <url>%2FLeanote%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98Summer.html</url>
    <content type="text"><![CDATA[夏天到了，所以主题名字就叫Summer吧。主题参考自https://cn.vuejs.org/v2/api/。emoji作者ColinXu。由于每个人单页的迥异，所以我把自定义的单页去掉了。单页样式自定义可以参考下面的思路：123456&#123;&#123;if eq $.single.Title "Friends"&#125;&#125; &#123;&#123;template "friends.html" $&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;if eq $.single.Title "Music"&#125;&#125; &#123;&#123;template "music.html" $&#125;&#125;&#123;&#123;end&#125;&#125;关于警告框，在笔记编辑器里选中文字加下划线就可以了。主题已上架主题市场，有什么问题欢迎留言。最新地址：github]]></content>
      <tags>
        <tag>Leanote</tag>
        <tag>theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery筛选操作]]></title>
    <url>%2FjQuery%E7%AD%9B%E9%80%89%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[jQuery提供了一系列的筛选函数来对jQuery选择器选择的结果进行筛选。筛选函数大致可分为三个类别：过滤，查找和串联。过滤eq(index)获取第N个元素。index为元素位置，为正数时表示从第一个元素开始，从0算起；为负数时表示从最后一个元素开始，从-1开始。例如，获取匹配的第二个元素：12&lt;p&gt; This is just a test.&lt;/p&gt;&lt;p&gt; So is this&lt;/p&gt;1$("p").eq(1); // &lt;p&gt; So is this&lt;/p&gt; ​获取倒数第二个元素：1$("p").eq(-2); //&lt;p&gt; This is just a test.&lt;/p&gt;first()获取第一个元素。例如，获取ul的第一个li：1234567&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt;&lt;/ul&gt;1$('ul&gt;li').first(); // &lt;li&gt;list item 1&lt;/li&gt;last()和first()相反，获取最后一个元素。hasClass(class)hasClass()方法检查被选元素是否包含指定的class。例如，判断选中元素是否含有happy类：1&lt;div class="happy"&gt;&lt;/div&gt;1var a = $("div").hasClass("happy"); //truefilter(selector,[fn])filter()方法将匹配元素集合缩减为匹配指定选择器的元素。selector：字符串值，包含供匹配当前元素集合的选择器表达式。fn：回调函数，可选。例如，保留带有select类的元素：123&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;p class="selected"&gt;And Again&lt;/p&gt;1$("p").filter(".selected"); //&lt;p class="selected"&gt;And Again&lt;/p&gt;使用回调函数实现：123$("p").filter(function(index)&#123; return $(this).hasClass('selected'); &#125;);this指当前遍历的元素，返回true的元素将被保留。保留第一个或带有select类的元素：1$("p").filter(".selected,:first"); // &lt;p&gt;Hello&lt;/p&gt;, &lt;p class="selected"&gt;And Again&lt;/p&gt;is(selector,[fn])is()根据选择器、元素或 jQuery 对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true。fn：回调函数，可选。例如，判断input的父元素是否为form：123&lt;form&gt; &lt;input type="checkbox" /&gt;&lt;/form&gt;1$("input[type='checkbox']").parent().is("form") //true使用回调函数实现：123$("input[type='checkbox']").parent().is(function()&#123; return $(this)[0].nodeName == 'FORM'; &#125;);map(callback(index,domElement))map()把每个元素通过函数传递到当前匹配集合中，生成包含返回值的新的 jQuery 对象。例如，有如下表单，要获取以逗号分隔的复选框列表ID：1234567891011121314151617181920&lt;form method="post" action=""&gt; &lt;fieldset&gt; &lt;div&gt; &lt;label for="two"&gt;2&lt;/label&gt; &lt;input type="checkbox" value="2" id="two" name="number[]"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="four"&gt;4&lt;/label&gt; &lt;input type="checkbox" value="4" id="four" name="number[]"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="six"&gt;6&lt;/label&gt; &lt;input type="checkbox" value="6" id="six" name="number[]"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for="eight"&gt;8&lt;/label&gt; &lt;input type="checkbox" value="8" id="eight" name="number[]"&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt;123$(':checkbox').map(function() &#123; return this.id;&#125;).get().join(','); //"two,four,six,eight"has(selector)has()将匹配元素集合缩减为拥有匹配指定选择器或 DOM 元素的后代的子集。例如，有如下嵌套的列表：1234567891011&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2 &lt;ul&gt; &lt;li&gt;list item 2-a&lt;/li&gt; &lt;li&gt;list item 2-b&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt;&lt;/ul&gt;现在给包含ul的li添加红色背景色：1$( "li" ).has( "ul" ).css( "background-color", "red" );not()not()从匹配元素集合中删除元素。例如有如下列表：1234567&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li id="notli"&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt;&lt;/ul&gt;给除了list item 3外的li添加红色背景色：1$( "li" ).not("#notli").css( "background-color", "red" );slice(selector,end) ​slice()把匹配元素集合缩减为指定的指数范围的子集。参数描述selector基于 0 的整数值，指示开始选取元素的位置；如果是负数，则指示从集合末端开始的偏移量。end基于 0 的整数值，指示结束选取元素的位置；如果是负数，则指示从集合末端开始的偏移量。 如果省略，则选取范围会在集合末端结束。例如，给第一第二个p元素加粗：123456&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;1$("p").slice(0, 2).wrapInner("&lt;b&gt;&lt;/b&gt;");给倒数第二个p元素加粗：1$("p").slice(-2, -1).wrapInner("&lt;b&gt;&lt;/b&gt;");给第三个及其以后的p元素加粗：1$("p").slice(2).wrapInner("&lt;b&gt;&lt;/b&gt;");查找children()返回匹配元素集合中每个元素的子元素，添加可选参数可通过选择器进行过滤。例如：找到div的所有包含selected类的子元素，然后将其置为蓝色：123456&lt;div&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;p class="selected"&gt;Hello Again&lt;/p&gt; &lt;div class="selected"&gt;And Again&lt;/div&gt; &lt;p&gt;And One Last Time&lt;/p&gt;&lt;/div&gt;1$( "div" ).children( ".selected" ).css( "color", "blue" );closest(selector)closest()方法获得匹配选择器的第一个祖先元素，从当前元素开始沿 DOM 树向上。例如，当列表被点击的时候添加背景色，其余的移除背景色：123$( document ).bind("click", function( e ) &#123; $( e.target ).closest("li").addClass("hilight").siblings().removeClass("hilight");&#125;);find(selector)find()方法获得当前元素集合中每个元素的后代，通过选择器、jQuery 对象或元素来筛选。例如：搜索所有段落中的后代 span 元素，并将其颜色设置为红色：1$("p").find("span").css('color','red');next(selector)next()获得匹配元素集合中每个元素紧邻的同胞元素。如果提供选择器，则取回匹配该选择器的下一个同胞元素。例如，有如下简单列表：1234567&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class="third-item"&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt;&lt;/ul&gt;将list item 4添加红色背景色：1$('li.third-item').next().css('background-color', 'red');将list item 3添加红色背景色：1$('li').next('.third-item').css('background-color', 'red');等价于：1$('ul').find('.third-item').css('background-color', 'red');nextAll(selector)查找当前元素之后所有的同辈元素。还是上面的例子，给list item 3之后的所有同级li添加红色背景色：1$('li.third-item').nextAll().css('background-color', 'red');选择器用法，给含有red类的li添加红色背景色：12345678910&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class="red"&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li class="red"&gt;list item 5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $('li').nextAll('.red').css('background-color', 'red');&lt;/script&gt;nextUntil()查找当前元素之后所有的同辈元素，直到遇到匹配的那个元素为止。例如，有如下列表：1234567891011121314&lt;dl&gt; &lt;dt id="term-1"&gt;term 1&lt;/dt&gt; &lt;dd&gt;definition 1-a&lt;/dd&gt; &lt;dd&gt;definition 1-b&lt;/dd&gt; &lt;dd&gt;definition 1-c&lt;/dd&gt; &lt;dd&gt;definition 1-d&lt;/dd&gt; &lt;dt id="term-2"&gt;term 2&lt;/dt&gt; &lt;dd&gt;definition 2-a&lt;/dd&gt; &lt;dd&gt;definition 2-b&lt;/dd&gt; &lt;dd&gt;definition 2-c&lt;/dd&gt; &lt;dt id="term-3"&gt;term 3&lt;/dt&gt; &lt;dd&gt;definition 3-a&lt;/dd&gt; &lt;dd&gt;definition 3-b&lt;/dd&gt;&lt;/dl&gt;找到跟随 &lt;dt id=&quot;term-1&quot;&gt; 的同胞元素，直到 &lt;dt id=&quot;term-3&quot;&gt;，并为它们设置蓝色文本颜色：1$("#term-1").nextUntil("#term-3").css("color", "blue");效果如图：找到跟随 &lt;dt id=&quot;term-1&quot;&gt; 的&lt;dd&gt;同胞元素，直到 &lt;dt id=&quot;term-3&quot;&gt;，并为它们设置蓝色文本颜色：1$("#term-1").nextUntil("#term-3",'dd').css("color", "blue"); 获得被定位的最近祖先元素。这些定位包括relative，absolute或fixed。例如，有如下html：1234567891011121314151617&lt;ul class="level-1"&gt; &lt;li class="item-i"&gt;I&lt;/li&gt; &lt;li class="item-ii" style="position: relative;"&gt;II &lt;ul class="level-2"&gt; &lt;li class="item-a"&gt;A&lt;/li&gt; &lt;li class="item-b"&gt;B &lt;ul class="level-3"&gt; &lt;li class="item-1"&gt;1&lt;/li&gt; &lt;li class="item-2"&gt;2&lt;/li&gt; &lt;li class="item-3"&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="item-c"&gt;C&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class="item-iii"&gt;III&lt;/li&gt;&lt;/ul&gt;给&lt;li class=&quot;item-a&quot;&gt;最近的被定位父元素，即&lt;li class=&quot;item-ii&quot; style=&quot;position: relative;&quot;&gt;添加红色背景色：1$('li.item-a').offsetParent().css('background-color', 'red');parent(selector)获取匹配元素最近的父元素。接着上面的例子，给&lt;li class=&quot;item-a&quot;&gt;的父元素，即&lt;ul class=&quot;level-2&quot;&gt;添加红色背景色：1$('li.item-a').parent().css('background-color', 'red'); ​再如有如下html：12&lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&lt;div class="selected"&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;/div&gt;1$("p").parent(".selected").css("background", "yellow");结果只有Hello Again拥有黄色背景色。parents(selector)获取匹配元素的符合筛选器selector所有层级的父元素。有如下html：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;span&gt; &lt;b&gt;&lt;/b&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;12345678var a = $("b").parents().map(function()&#123; return this.nodeName;&#125;).get().join(',');console.log(a); //SPAN,P,DIV,BODY,HTMLvar b = $("b").parents("p").map(function()&#123; return this.nodeName;&#125;).get().join(',');console.log(b); //PparentsUntil(selector)查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。接着上面的html，有如下js代码：1234var parentEls = $("b").parentsUntil('div').map(function()&#123; return this.nodeName;&#125;).get().join(',');console.log(parentEls); // SPAN,Pprev(selector)和next(selector)相反。prevAll(selector)和nextAll(selector)相反。prevUntil(selector)和nextUntil()相反。siblings(selector)匹配集合中每个元素的同胞。串联add()add() 方法将元素添加到匹配元素的集合中。例如，查找所有div并添加边框。然后将所有p添加到jQuery对象中并将其背景设置为黄色。1$( "div" ).css( "border", "2px solid red" ).add( "p" ).css( "background", "yellow" );这里只有div添加了边框！给所有p和span添加黄色背景色：1$( "p" ).add( "span" ).css( "background", "yellow" );addBack()该函数用于替代1.8版本之前的andSelf()函数。通过一个例子来洞察其作用：1234567&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class="third-item"&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt;&lt;/ul&gt;12345678var a = $('li.third-item').nextAll().map(function()&#123; return this.innerHTML&#125;).get().join(',');var b = $('li.third-item').nextAll().addBack().map(function()&#123; return this.innerHTML&#125;).get().join(',');console.log(a); // list item 4,list item 5console.log(b); // list item 3,list item 4,list item 5contents()contents()方法获得匹配元素集合中每个元素的子节点，包括文本和注释节点。例如：找到p中的所有文本节点，并用粗体标签包装它们：1$("p").contents().filter(function()&#123; return this.nodeType != 1; &#125;).wrap("&lt;b/&gt;");下表为html中nodeType的取值：节点类型描述1Element代表元素2Attr代表属性3Text代表元素或属性中的文本内容。4CDATASection代表文档中的 CDATA 部分（不会由解析器解析的文本）。5EntityReference代表实体引用。6Entity代表实体。7ProcessingInstruction代表处理指令。8Comment代表注释。9Document代表整个文档（DOM 树的根节点）。10DocumentType向为文档定义的实体提供接口11DocumentFragment代表轻量级的 Document 对象，能够容纳文档的某个部分12Notation代表 DTD 中声明的符号。end()end()方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为一开始的状态。例如，现有如下html：12345&lt;ul class="first"&gt; &lt;li class="foo"&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li class="bar"&gt;list item 3&lt;/li&gt;&lt;/ul&gt; ​12$('ul.first').find('.foo').css('background-color', 'red') .end().find('.bar').css('background-color', 'green');这条链式的jQuery操作代码首先选取了类名为first的ul，然后使用find(&#39;.foo&#39;)找到&lt;li class=&quot;foo&quot;&gt;list item 1&lt;/li&gt;，给其添加了红色背景色。随后，end()方法将jQuery对象还原为一开始的状态，即(&#39;ul.first&#39;)，再使用find(&#39;.bar&#39;)找到&lt;li class=&quot;bar&quot;&gt;list item 3&lt;/li&gt;，给其添加绿色背景色。效果如下图所示：如果去除end()函数，会因找不到&lt;li class=&quot;bar&quot;&gt;list item 3&lt;/li&gt;，添加绿色背景色失败。去除end()效果如下：一般为了视觉上的对称，上面的代码末端也加上end()：12345$('ul.first').find('.foo') .css('background-color', 'red') .end().find('.bar') .css('background-color', 'green') .end();参考网站http://api.jquery.com/http://www.w3school.com.cn/jqueryhttp://caibaojian.com/jquery]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery操作文档新姿势]]></title>
    <url>%2FjQuery%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3%E6%96%B0%E5%A7%BF%E5%8A%BF.html</url>
    <content type="text"><![CDATA[现要在body下插入一张包含一些属性的图片，使用jQuery操作document传统的做法是：12345678var html = ' &lt;img src="../images/little.bear.png" alt="Little Bear"'+ ' title="I woof in your general direction" '+ ' onclick="showTitle($(this));"&gt;&lt;img/&gt;'$(html).appendTo('body');function showTitle(val)&#123; var $this = val; alert($this.attr('title'));&#125;现使用更优雅的方法来实现这个操作：123456789$('&lt;img&gt;',&#123; src: '../images/little.bear.png', alt: 'Little Bear', title:'I woof in your general direction', click: function() &#123; alert($(this).attr('title')); &#125;&#125;).appendTo('body');注：$(&#39;&lt;img&gt;&#39;)等同于$(&#39;&lt;img&gt;&lt;/img&gt;&#39;)或$(&#39;&lt;img/&gt;&#39;)《jQuery实战 第三版》读书笔记]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义jQuery选择器]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89jQuery%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[jQuery自身提供了许多选择器，除此之外其还允许我们自定义选择器。下面这种自定义选择器的方法仅适用于1.8及其以后的版本。考虑有如下html片段：123456&lt;ul class="levels"&gt; &lt;li data-level="1" data-points="1" data-technologies="javascript node grunt"&gt;Level 1&lt;/li&gt; &lt;li data-level="2" data-points="10" data-technologies="jquery requirejs"&gt;Level 2&lt;/li&gt; &lt;li data-level="3" data-points="100" data-technologies="php composer"&gt;Level 3&lt;/li&gt; &lt;li data-level="4" data-points="1000" data-technologies="javascript jquery"&gt;Level 4&lt;/li&gt;&lt;/ul&gt;假如我们需要选择出data-level属性值大于2，data-points大于100并且data-technologies属性包含”jquery”的li，传统的做法是：12345678910111213//先筛选出data-technologies属性包含"jquery"的livar $levels = $('.levels li[data-technologies~="jquery"]');var matchedLevels = [];//循环遍历$levels，将符合条件的li塞到matchedLevels数组里for (var i = 0; i &lt; $levels.length; i++) &#123; if ($levels[i].getAttribute('data-level') &gt; 2 &amp;&amp; $levels[i].getAttribute('data-points') &gt; 100) &#123; matchedLevels.push($levels[i]); &#125;&#125;console.log(matchedLevels.length); // 1如果需要多次使用，我们可以创建自定义选择器，让代码更优雅：1234567$.expr[':'].requiredLevel = $.expr.createPseudo(function (filterParam) &#123; return function (element, context, isXml) &#123; return element.getAttribute('data-level') &gt; 2 &amp;&amp; element.getAttribute('data-points') &gt; 100 &amp;&amp; element.getAttribute('data-technologies').indexOf('jquery') &gt;= 0; &#125;;&#125;);createPseudo方法用于创造自定义选择器，可向其传递参数filterParam，参数名可以另起其名，这里需求固定，所以不必传参。element表示当前处理的元素，isXML用于指定是否为XML文本，默认为false。context默认为整个document，可以指定范围来增强性能：比如查找div内的p元素：12$("div p") 或$("p","div")结果一致，第二种写法效率更高。言归正传，使用上述定义的选择器来查询满足条件的li：123var $requiredLevels = $('li:requiredLevel','.levels ');console.log($requiredLevels.length); // 1console.log($requiredLevels.html()); // Level 4传递参数假如将需求改为，查找出data-points大于某个整数值的li，要怎么做呢？这时候就可以用上filterParam了：1234567$.expr[':'].pointsHigherThan = $.expr.createPseudo(function (filterParam) &#123; // 缓存参数，以供闭包使用 var points = parseInt(filterParam, 10); return function (element, context, isXml) &#123; return element.getAttribute('data-points') &gt; points; &#125;;&#125;);测试：12var $higherPointsLevels = $('li:pointsHigherThan(50)','.levels ');console.log($higherPointsLevels.length); // 2《jQuery实战 第三版》读书笔记]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas与渐变色]]></title>
    <url>%2Fcanvas%E4%B8%8E%E6%B8%90%E5%8F%98%E8%89%B2.html</url>
    <content type="text"><![CDATA[线性渐变绘制线性渐变，需要用到图形上下文的createLinearGradient方法来创建gradient对象，方法签名如下：1var gradient = context.createLinearGradient(x0,y0,x1,y1);(x0,y0)为渐变起始点的坐标，(x1,y1)为渐变结束的的坐标。接下来需要指定渐变的颜色，可以通过gradient对象的addColorStop方法来设定，方法签名如下：1gradient.addColorStop(stop,color);其中stop为介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置；color为绘制时使用的颜色。最后需要做的就是将gradient对象赋予给fillStyle属性：1context.fillStyle = gradient;绘制一个渐变色矩形：12345678910var canvas = document.getElementById("canvas");var context = canvas.getContext("2d");//设定渐变范围var g = context.createLinearGradient(0,0,250,150);//设置渐变起点颜色g.addColorStop(0,'#FF9999');//设置渐变终点颜色g.addColorStop(1,'#FFFF99');context.fillStyle = g;context.fillRect(0,0,250,150);显示效果：径向渐变径向渐变指的是沿着圆形的半径方向向外扩散的渐变方式。绘制径向渐变使用的是图形上下文的createRadialGradient方法来创建gradient对象，方法签名如下：1var gradient = context.createRadialGradient(x0,y0,r0,x1,y1,r1);(x0,y0)为渐变的开始圆心坐标，r0为渐变开始圆的半径；(x1,y1)为渐变的结束圆心坐标，r1为渐变结束圆的半径。剩余的操作和线性渐变一致，不再赘述。这里绘制一个径向渐变的圆：1234567var g = context.createRadialGradient(100,100,0,100,100,100);g.addColorStop(0,'#FFFF99');g.addColorStop(1,'#FF9999');context.beginPath();context.arc(100,100,100,0,Math.PI*2,false);context.fillStyle = g;context.fill();显示效果：《HTML5与CSS3权威指南》读书笔记]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas绘制简单图形]]></title>
    <url>%2Fcanvas%E7%BB%98%E5%88%B6%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2.html</url>
    <content type="text"><![CDATA[canvas是HTML5中专门用来绘制图形的元素。在页面上放置一个canvas元素就相当于创建了一个画布。绘制过程由JS脚本完成。首先在页面上添加一个canvas元素：12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;html5&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas" width="500" height="400"/&gt;&lt;/body&gt;&lt;/html&gt;基本步骤使用canvas绘制图形的几个基本步骤：1.获取canvas对象：1var canvas = document.getElementById("canvas");2.取得上下文context，其包含许多绘制的方法：1var context = canvas.getContext("2d");目前仅有2d参数可选。3.设置绘图样式：绘图样式主要包含图形填充样式fillStyle，图形边框样式strokeStyle和线宽lineWidth。123456//设置填充样式为红色context.fillStyle = "red";//设置边框为黄色context.strokeStyle = "yellow";//设置线宽为1pxcontext.lineWidth = 1;4.开始绘制图形：具体绘制方法下面陆续展开。绘制矩形使用fillRect方法与strokeRect方法来绘制矩形和矩形边框：12context.fillRect(x,y,width,height);context.strokeRect(x,y,width,height);​x，y为矩形左上角起点坐标，width为矩形宽，height为矩形高。开始绘制：1234567891011121314var canvas = document.getElementById("canvas");var context = canvas.getContext("2d");// 设置canvas画布颜色context.fillStyle = "#F7F7F7";context.fillRect(0,0,300,300);//设置填充颜色，边框颜色context.fillStyle = "#E4F0C3";context.strokeStyle = "#F06560";//设置线宽context.lineWidth = 1;//绘制矩形context.fillRect(50,50,100,100);//绘制矩形边框context.strokeRect(50,50,150,150);结果：关于矩形，还有一个clearRect方法，用于清除指定矩形区域像素：1context.clearRect(x,y,width,height);在上面的JS脚本中加入下面这行代码：1context.clearRect(50,50,50,50);效果：绘制圆形，扇形，椭圆绘制圆形主要多了开始创建路径beginPath和关闭路径closePath这两个过程。主要步骤：1.开始创建路径：1context.beginPath();2.绘制圆形路径：方法：1context.arc(x,y,r,sAngle,eAngle,anticlockwise);其中x，y为绘制圆形的起点坐标即圆心，r为圆形半径，sAngle（起始角）和eAngle（结束角）决定了圆的弧度，两者的连线决定了圆的形状，anticlockwise表示是否按逆时针方向绘制，为boolean类型。3.关闭路径：1context.closePath();设置填充样式。绘制圆形示例：1234567891011121314var canvas = document.getElementById("canvas");var context = canvas.getContext("2d");for(var i = 0;i &lt; 6; i++)&#123; //开始创建路径 context.beginPath(); //绘制圆，Math.PI*2为2π弧度 context.arc(i*25,i*25,i*10,0,Math.PI*2,true); //关闭路径 context.closePath(); //设置填充颜色 context.fillStyle = "rgba(66,185,131,0.4)"; //进行填充 context.fill();&#125;度与弧度换算：1° = 1/180π rad效果如下图所示：假如不关闭路径会怎样呢？将上面的代码改为：12345678for(var i = 0;i &lt; 6; i++)&#123; //绘制圆，Math.PI*2为2π弧度 context.arc(i*25,i*25,i*10,0,Math.PI*2,true); //设置填充颜色 context.fillStyle = "rgba(66,185,131,0.4)"; //进行填充 context.fill();&#125;效果如下图所示：不关闭路径将会导致再绘制第二个圆的时候，第一个圆会根据之前的路径再次绘制一次。所以在这个例子中，第一个圆绘制了5次，第二个圆绘制了4次，以此类推，以至于第一个圆的颜色最深。关于弧度的参考可见下图：顺时针和逆时针的差别举个例子说明：顺时针，弧度为0.5rad：1234567context.beginPath();context.arc(100,100,100,0,Math.PI*0.5,false);context.closePath();context.fillStyle = "rgba(66,185,131,0.4)";context.strokeStyle = "#F06560";context.fill();context.stroke();效果如下图：将false改为true，即逆时针时：椭圆的绘制公式如下：1context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);其中x，y为起始坐标，radiusX为椭圆横向半径，radiusY为椭圆纵向半径，rotation为椭圆顺时针旋转角度，startAngle（起始角）和endAngle（结束角）决定了圆的弧度，两者的连线决定了圆的形状，anticlockwise表示是否按逆时针方向绘制，为boolean类型。绘制一个简单的椭圆：12345context.beginPath();context.ellipse(100,100,50,90,Math.PI*0.25,0,Math.PI*2,false);context.closePath();context.fillStyle = "rgba(66,185,131,0.4)";context.fill();效果图：绘制直线与绘制直线有关的方法主要有两个：1context.moveTo(x,y);moveTo方法将绘制光标移动到x，y位置。1context.lineTo(x,y);lineTo方法将从当前光标位置开始，到x，y位置间绘制一条直线。多次调用该方法，则下一次的起点为上一次lineTo的终点。使用lineTo方法结合数学公式，绘制一个复杂的图案：123456789101112131415var dx = 150;var dy = 150;var s = 100;context.beginPath();context.fillStyle = "rgba(230,177,163,.5)";context.strokeStyle = "#e96900";var dig = Math.PI/15*11;for(var i = 0;i &lt; 30 ; i++)&#123; var x = Math.sin(i*dig); var y = Math.cos(i*dig); context.lineTo(dx+x*s,dy+y*s);&#125;context.closePath();context.fill();context.stroke();效果图：图形上下文的lineCap属性可为直线添加线帽，可用的属性有：butt，默认值，不为直线添加线帽。round，添加圆形线帽。square，添加方形线帽。例如：1234567context.strokeStyle = "rgba(66,185,131,0.6)";context.lineWidth = "10";context.beginPath();context.moveTo(50,50);context.lineTo(50,150);context.lineCap = "round";context.stroke();效果：图形上下文的lineJoin属性指定两条线交汇处的形状，可用的值有：miter，默认值，尖角拐角。round，圆角拐角。bevel，斜角拐角。例如：12345678context.strokeStyle = "rgba(66,185,131,0.6)";context.lineWidth = "10";context.beginPath();context.moveTo(50,50);context.lineTo(50,150);context.lineTo(150,150);context.lineJoin = "bevel";context.stroke();效果图：图形上下文的setLineDash方法可设置虚线的样式：1context.setLineDash(segments);segments为一个数组。数组长度可分为4种情况：1.当数组长度为1时：1context.setLineDash([5]);表示线段长度为5，线段间距离也为5。2.当数组长度为2时：1context.setLineDash([5,10]);表示线段长度为5，线段间距离为10。3.当数组长度为大于2的偶数时：1context.setLineDash([5,10,15,20]);第奇数个数值表示线段长度，第偶数个数值表示线段间距。4.当数组长度为大于1的奇数时：1context.setLineDash([5,10,15]);浏览器会将其解析为：1context.setLineDash([5,10,15,5,10,15]);画个虚线试试：1234567context.strokeStyle = "rgba(66,185,131,0.9)";context.lineWidth = 2;context.beginPath();context.moveTo(10,50);context.lineTo(250,50);context.setLineDash([15,5]);context.stroke();效果：绘制曲线绘制曲线使用arcTo方法：1context.fillRect(x1,y1,x2,y2,radiusX[radiusY,rotation]);关于坐标参数，可以参考下面这张图：其中x0，y0为当前点的坐标，x1，y1为绘制圆弧时使用的控制坐标，x2，y2为重点坐标。radiusX为圆弧的半径。radiusY和rotation为隐藏参数，前者表示纵向半径，后者表示顺时针旋转角度。绘制个曲线图：1234567891011context.strokeStyle = "rgba(66,185,131,0.9)";context.lineWidth = 2;context.beginPath();context.moveTo(10,50);//曲线的起点context.lineTo(100,50);//(150,50)曲线的控制点，(150,100)曲线的终点，曲线半径为50context.arcTo(150,50,150,100,50);//再来一条context.arcTo(100,100,100,50,50);context.stroke();效果图：图形上下文的bezierCurveTo方法用以三次绘制贝塞尔曲线。1context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); ​其中cp1x为第一个贝塞尔控制点的 x 坐标，cp1y为第一个贝塞尔控制点的 y 坐标。cp2x为第二个贝塞尔控制点的 x 坐标，cp2y为第二个贝塞尔控制点的 y 坐标。x，y为终点坐标。例如：123456context.strokeStyle = "rgba(66,185,131,0.9)";context.lineWidth = 2;context.beginPath();context.moveTo(50, 150);context.bezierCurveTo(150, 100, 150, 200, 250, 150);context.stroke();效果图：贝塞尔曲线在线生成工具：http://www.j--d.com/bezier图形上下文的quadraticCurveTo方法用以二次绘制贝塞尔曲线：1context.quadraticCurveTo(cpx,cpy,x,y);相较于bezierCurveTo方法，其只有一个控制点。cpx，cpy为控制点的坐标，x，y为终点坐标。一个简单的例子：123456context.strokeStyle = "rgba(66,185,131,0.9)";context.lineWidth = 2;context.beginPath();context.moveTo(50, 50);context.quadraticCurveTo(250, 150, 150, 50);context.stroke();效果图：《HTML5与CSS3权威指南》读书笔记]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux打包指令tar]]></title>
    <url>%2FLinux%E6%89%93%E5%8C%85%E6%8C%87%E4%BB%A4tar.html</url>
    <content type="text"><![CDATA[gzip, bzip2, xz 也能够针对目录来进行压缩，不过它们都是对目录下的文件逐个压缩的。而tar指令则可以将这些文件先打包成一个大文件，然后再进行压缩操作。仅用tar命令打包不压缩的文件，称为tarfile，既打包又压缩的文件，如file.tar.gz则成为tarball。tar指令的选项非常多，一般只是用几个常用的，基本语法如下：12345678910111213141516tar [-z|-j|-J] [cv] [-f 待建立的文件名] filename... &lt;==打包与压缩tar [-z|-j|-J] [tv] [-f 已有的tar格式文件名] &lt;==查看文件名tar [-z|-j|-J] [xv] [-f 已有的tar格式文件名] [-C 目录] &lt;==解压缩选项与参数：-c ：建立打包文件，可搭配 -v 来察看过程中被打包的档名(filename)-t ：察看打包文件的内容含有哪些档名，重点在察看『档名』就是了；-x ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开。特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。-z ：透过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz-j ：透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2-J ：透过 xz 的支持进行压缩/解压缩：此时档名最好为 *.tar.xz。特别留意， -z, -j, -J 不可以同时出现在一串指令列中-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！-f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-p(小写) ：保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件-P(大写) ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；--exclude=FILE：在压缩的过程中，不要将 FILE 打包！一般来说，tar命令只要记住下面这个范例就行了：压 缩：tar -jcv -f filename.tar.bz2要被压缩的文件或目录名称查 询：tar -jtv -f filename.tar.bz2解压缩：tar -jxv -f filename.tar.bz2 -C欲解压缩的目录filename.tar.bz2 是我们自己取的文件名，tar 并不会自动帮我们生成打包压缩后的文件名。文件命名最好符合规范。示例：使用tar命令打包/etc/目录，然后使用-z，-j，-J选项进行压缩，并观察结果与耗时1234567891011121314151617181920212223242526272829root@ubuntu:/temp# time tar -zpcv -f etc.tar.gz /etctar: Removing leading `/' from member names/etc//etc/ucf.conf/etc/selinux//etc/selinux/semanage.conf... real 0m0.848s //耗时0.848秒user 0m0.456ssys 0m0.080s root@ubuntu:/temp# time tar -jpcv -f etc.tar.bz2 /etctar: Removing leading `/' from member names/etc//etc/ucf.conf/etc/selinux//etc/selinux/semanage.conf... real 0m1.781s //耗时1.781秒user 0m1.220ssys 0m0.060s root@ubuntu:/temp# time tar -Jpcv -f etc.tar.xz /etc real 0m7.700s //耗时7.700秒user 0m5.428ssys 0m0.456s查阅 tar 文件的数据内容12345root@ubuntu:/temp# tar -ztv -f etc.tar.gz drwxr-xr-x root/root 0 2017-04-13 09:31 etc/-rw-r--r-- root/root 1260 2016-03-17 04:58 etc/ucf.confdrwxr-xr-x root/root 0 2016-04-21 06:07 etc/selinux/...可发现，每个文件名都没了根目录。正如备份的时候出现的警告：tar: Removing leading `/‘ from member names那样。这种做法主要是为了防止解压缩的时候出现覆盖源文件的情况。如果要保留文件的根目录/，则可以使用-P（大写）选项。指定目录解压缩如果直接在当前目录下执行命令：tar -jxv -f /root/etc.tar.bz2，则目录下会多出个etc的目录。如果要指定解压缩的目录，可以使用-C选项。如将/temp/etc.tar.gz解压到/tmp目录下1root@ubuntu:/temp# tar -zxv -f etc.tar.gz -C /tmp指定解压某个文件除了一次性全部解压，我们还可以指定解压某个文件。比如我要解压etc.tar.gz下的etc/shadow，可以使用如下命令：12root@ubuntu:/temp# tar -zxv -f etc.tar.gz etc/shadowetc/shadow打包某目录，但不含该目录下的某些文件比如我想打包/etc目录，但是不想包含目录下的ppp和qqq文件：1root@ubuntu:/temp# tar -zcv -f etc.tar.gz --exclude=/etc/ppp --exclude=/etc/qqq /etc或者：1root@ubuntu:/temp# vi exclude-file里面输入12/etc/ppp/etc/qqq然后使用命令：1root@ubuntu:/temp# tar -zcvf etc.tar.gz --exclude-from exclude-file /etc仅备份比某个时刻还要新的文件比如，仅备份比/etc/passwd文件新的文件（mtime）：123456789root@ubuntu:/temp# ls -l /etc/passwd-rw-r--r-- 1 root root 2243 Apr 13 09:30 /etc/passwdroot@ubuntu:/temp# tar -zcv -f etc.newer.passwd.tar.gz --newer-mtime="2017/04/13 09:30" /etc/*tar: Option --newer-mtime: Treating date '2017/04/13 09:30' as 2017-04-13 09:30:00tar: Removing leading `/' from member names/etc/acpi/tar: /etc/acpi/asus-wireless.sh: file is unchanged; not dumpedtar: /etc/acpi/asus-keyboard-backlight.sh: file is unchanged; not dumped...《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用压缩指令]]></title>
    <url>%2FLinux%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4.html</url>
    <content type="text"><![CDATA[Linux 上常见的压缩指令有 gzip，bzip2 以及最新的 xz。压缩率从高到低为xz，bzip2，gzip。压缩率越高，压缩所花的时间就越长。所以实际工作中需要根据具体情况在压缩率和压缩时间中做出抉择。以下为几个常见的压缩文件扩展名：123456789*.Z compress 程序压缩的文件；*.zip zip 程序压缩的文件；*.gz gzip 程序压缩的文件；*.bz2 bzip2 程序压缩的文件；*.xz xz 程序压缩的文件；*.tar tar 程序打包的数据，并没有压缩过；*.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩*.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩compress指令已经过时了，取而代之的是gzip。gzip, zcat/zmore/zless/zgrepgzip可以解开 compress，zip 与 gzip 等软件所压缩 的文件。 gzip 所建立的压缩文件为 *.gz，gzip语法：12345678gzip [-cdtv#] 文件名zcat 文件名.gz选项与参数：-c ：将压缩的数据输出到屏幕上，可透过数据流重导向来处理；-d ：解压缩的参数；-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；-v ：可以显示出原文件/压缩文件案的压缩比等信息；-# ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6示例：使用gzip压缩/temp/services文件，并查看压缩比：12345root@ubuntu:/temp# gzip -v services services: 61.6% -- replaced with services.gzroot@ubuntu:/temp# ls -lh /etc/services services.gz -rw-r--r-- 1 root root 20K Oct 25 2014 /etc/services-rw-r--r-- 1 root root 7.4K Apr 17 16:15 services.gz因为services是文本文件，所以可以使用zcat/zmore/zless 去读取 ：1234567root@ubuntu:/temp# zcat services.gz # Network services, Internet style## Note that it is presently the policy of IANA to assign a single well-known# port number for both TCP and UDP; hence, officially ports have two entries# even if the protocol doesn't support UDP operations....将services.gz解压缩：1root@ubuntu:/temp# gzip -d services.gz使用gzip指令以最好的压缩比压缩services，并保留原文件：1gzip -9 -c services &gt; services.gz-c 可以将原本要转成压缩文件的资料内容，将它变成文字类型从屏幕输出， 然后我们可以透过大于 (&gt;) 这个符号，将原本应该由屏幕输出的数据，转成输出到文件而不是屏幕，所以就能够建立出压缩文件了。只是文件名也要自己写， 当然最好还是遵循 gzip 的压缩文件名规范。bzip2, bzcat/bzmore/bzless/bzgrepbzip2则是为了取代 gzip 并提供更佳的压缩比而来的，语法和gzip差不多：123456789bzip2 [-cdkzv#] 文件名bzcat 文件名.bz2选项与参数：-c ：将压缩的过程产生的数据输出到屏幕上。-d ：解压缩的参数。-k ：保留源文件，而不会删除原始的文件。-z ：压缩的参数 (默认值，可以不加)。-v ：可以显示出原文件/压缩文件案的压缩比等信息。-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！示例：使用bzip2命令压缩services文件：12root@ubuntu:/temp# bzip2 -v services services: 2.712:1, 2.950 bits/byte, 63.13% saved, 19605 in, 7229 out.xz, xzcat/xzmore/xzless/xzgrepbzip2 已经具有很棒的压缩比，不过显然某些自由软件开发者还不满足，因此后来还推出了 xz 这个压缩比更高的软件。xz的语法：123456789xz [-dtlkc#] 文件名xcat 文件名.xz选项与参数：-d ：就是解压缩-t ：测试压缩文件的完整性，看有没有错误-l ：列出压缩文件的相关信息-k ：保留原本的文件不删除-c ：同样的，就是将数据由屏幕上输出的意思-# ：同样的，也有较佳的压缩比的意思对比分别使用gzip，bzip2和xz命令默认压缩比对service文件进行压缩，并查看时间：12345678910111213root@ubuntu:/temp# time gzip -c services &gt; services.gz;time bzip2 -k services;time xz -k services real 0m0.003suser 0m0.000ssys 0m0.000s real 0m0.004suser 0m0.000ssys 0m0.000s real 0m0.076suser 0m0.016ssys 0m0.020s查看压缩后的文件大小：12345root@ubuntu:/temp# ls -l services services.gz services.bz2 services.xz -rw-r--r-- 1 root root 19605 Apr 17 16:42 services-rw-r--r-- 1 root root 7554 Apr 17 16:43 services.gz-rw-r--r-- 1 root root 7229 Apr 17 16:42 services.bz2-rw-r--r-- 1 root root 7156 Apr 17 16:42 services.xz《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些JS技巧[转]]]></title>
    <url>%2F%E4%B8%80%E4%BA%9BJS%E6%8A%80%E5%B7%A7-%E8%BD%AC.html</url>
    <content type="text"><![CDATA[使用+将字符串转换成数字这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：12345function toNumber(strNumber) &#123; return +strNumber;&#125;console.log(toNumber("1234")); // 1234console.log(toNumber("ACB")); // NaN这个也适用于 Date，在本例中，它将返回的是时间戳数字：1console.log(+new Date()) // 1461288164385并条件符如果你写了一段这样的代码：123if (conected) &#123; login();&#125;你也可以将变量简写，并且使用&amp;&amp;和函数连接在一起，比如上面的示例，可以简写成这样：1conected &amp;&amp; login();使用 || 运算符在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用||操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为 false，那么第二个值将会认为是一个默认值。如下面这个示例：123456789101112function User(name, age) &#123; this.name = name || "Oliver Queen"; this.age = age || 27;&#125; var user1 = new User();console.log(user1.name); // Oliver Queenconsole.log(user1.age); // 27 var user2 = new User("Barry Allen", 25);console.log(user2.name); // Barry Allenconsole.log(user2.age); // 25检测对象中属性当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用 document.querySelector() 来选择一个 id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：12345if ('querySelector' in document) &#123; document.querySelector("#id");&#125; else &#123; document.getElementById("id");&#125;在这个示例中，如果 document 不存在 querySelector 函数，那么就会调用 docuemnt.getElementById(&quot;id&quot;)。获取数组中最后一个元素Array.prototype.slice(begin,end)用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：12345var array = [1,2,3,4,5,6]; console.log(array.slice(-1)); // [6]console.log(array.slice(-2)); // [5,6]console.log(array.slice(-3)); // [4,5,6]数组截断这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过 array.length=5 来截断数组。如下这个示例：123456var array = [1,2,3,4,5,6];console.log(array.length); // 6 array.length = 3;console.log(array.length); // 3console.log(array); // [1,2,3]合并数组如果你要合并两个数组，一般情况之下你都会使用Array.concat()函数：1234var array1 = [1,2,3];var array2 = [4,5,6]; console.log(array1.concat(array2)); // [1,2,3,4,5,6];然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用 Array.pus().apply(arr1,arr2)来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：1234var array1 = [1,2,3];var array2 = [4,5,6]; console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];将NodeList转换成数组如果你运行 document.querySelectorAll(“p”) 函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如 sort()、reduce()、map()、ilter() 等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用 [].slice.call(elements) 来实现：123var elements = document.querySelectorAll("p"); // NodeListvar arrayElements = [].slice.call(elements); // 将NodeList转化为数组var arrayElements = Array.from(elements); // 另一种方式将NodeList转化为数组HTML5 DOM 选择器1234567// querySelector() 返回匹配到的第一个元素var item = document.querySelector('.item');console.log(item); // querySelectorAll() 返回匹配到的所有元素，是一个nodeList集合var items = document.querySelectorAll('.item');console.log(items[0]);鼠标滚轮事件12345678910111213$('#content').on("mousewheel DOMMouseScroll", function (event) &#123; // chrome &amp; ie || // firefox var delta = (event.originalEvent.wheelDelta &amp;&amp; (event.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) || (event.originalEvent.detail &amp;&amp; (event.originalEvent.detail &gt; 0 ? -1 : 1)); if (delta &gt; 0) &#123; // 向上滚动 console.log('mousewheel top'); &#125; else if (delta &lt; 0) &#123; // 向下滚动 console.log('mousewheel bottom'); &#125; &#125;);检测浏览器是否支持svg1234567function isSupportSVG() &#123; var SVG_NS = 'http://www.w3.org/2000/svg'; return !!document.createElementNS &amp;&amp;!!document.createElementNS(SVG_NS, 'svg').createSVGRect; &#125; // 测试console.log(isSupportSVG());检测浏览器是否支持canvas12345678910function isSupportCanvas() &#123; if(document.createElement('canvas').getContext)&#123; return true; &#125;else&#123; return false; &#125;&#125; // 测试console.log(isSupportCanvas());转自http://www.mrfront.com/]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件与指令搜索]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E4%B8%8E%E6%8C%87%E4%BB%A4%E6%90%9C%E7%B4%A2.html</url>
    <content type="text"><![CDATA[当我们要对Linux下的某个文件做修改的时候，必须先知道文件的位置，这时候就可以使用文件搜索指令来完成。而指令的搜索则可以知道该指令文件的实际存放位置。指令搜索which通过which可以知道指令的完整文件名放在哪里。语法：123which [-a] command选项或参数：-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称简单示例：123456mrbird@ubuntu:~$ which ls/bin/lsmrbird@ubuntu:~$ which passwd/usr/bin/passwdmrbird@ubuntu:~$ which which/usr/bin/whichtype指令也可以实现指令搜索：1234mrbird@ubuntu:~$ type passwdpasswd is hashed (/usr/bin/passwd)mrbird@ubuntu:~$ type whichwhich is hashed (/usr/bin/which)文件档名的搜寻whereis (由一些特定的目录中寻找文件文件名)：whereis 只找系统中某些特定目录底下的文件 ，基本语法：1234567whereis [-bmsu] 文件或目录名选项与参数：-l :可以列出 whereis 会去查询的几个主要目录而已-b :只找 binary 格式的文件-m :只找在说明文件 manual 路径下的文件-s :只找 source 来源文件-u :搜寻不在上述三个项目当中的其他特殊文件示例：1234567891011121314151617#查看whereis搜寻的目录：mrbird@ubuntu:~$ whereis -lbin: /usr/binbin: /usr/sbinbin: /usr/libbin: /binbin: /sbinbin: /etcbin: /libbin: /lib64... mrbird@ubuntu:~$ whereis passwdpasswd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1ssl.gz /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz#只查找在说明文件 manual 路径下的文件mrbird@ubuntu:~$ whereis -m passwdpasswd: /usr/share/man/man1/passwd.1ssl.gz /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gzlocate / updatedb：locate则是利用数据库来搜寻文件名，并且没有实际的搜寻硬盘内的文件系统态。locate语法：1234567locate [-ir] keyword选项与参数：-i ：忽略大小写的差异；-c ：不输出档名，仅计算找到的文件数量-l ：仅输出几行的意思，例如输出五行则是 -l 5-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等-r ：后面可接正规表示法的显示方式示例：123456789101112131415#找出系统中所有与passwd相关的档名，且只列出5个mrbird@ubuntu:~$ locate -l 5 passwd/etc/passwd/etc/passwd-/etc/cron.daily/passwd/etc/init/passwd.conf/etc/pam.d/chpasswd #列出locate查询所使用的数据库文件之文件名与各数据数量mrbird@ubuntu:~$ locate -SDatabase /var/lib/mlocate/mlocate.db: 22,021 directories 218,810 files 11,880,406 bytes in file names 5,267,885 bytes used to store database为 locate 寻找的数据是由已建立的数据库 /var/lib/mlocate/里面的数据所搜寻到的， 所以不用直接在去硬盘当中存取数据。而数据库的建立默认是在每天执行一次，所以当你新建立起来的文件， 却还在数据库更新之前搜寻该文件，那么 locate 会告诉你找不到！可以使用updatedb指令手动更新数据库，因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间。find：find指令直接搜索硬盘，所以具体搜索时间根据硬盘性能而定。基本语法：与时间有关的选项：1234567find [PATH] [option] [action]选项与参数：1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明 -mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的文件； -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的文件档名； -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的文件档名。 -newer file ：file 为一个存在的文件，列出比 file 还要新的文件档名举个例子，当n为4时：+4 代表大于等于 5 天前的档名；-4 代表小于等于 4 天内的文件档名； 4 则是代表 4-5 那一天的文件档名。示例：12345678910#列出24小时内有更改过内容（mtime）的文件档名：root@ubuntu:~# find / -mtime 0 #寻找/etc底下的文件，如果文件日期比/etc/passwd新就列出root@ubuntu:~# find /etc -newer /etc/passwd/etc/etc/apparmor.d/etc/apparmor.d/cache/etc/apparmor.d/cache/.features/etc/gshadow与使用者或组名有关的参数：12345678910选项与参数：2. 与使用者或组名有关的参数： -uid n ：n 为数字，这个数字是用户的账号 ID，亦即 UID ，这个 UID 是记录在 /etc/passwd 里面与账号名称对应的数字。 -gid n ：n 为数字，这个数字是组名的 ID，亦即 GID，这个 GID 记录在/etc/group。 -user name ：name 为使用者账号名称。例如 mrbird。 -group name：name 为组名，例如 users 。 -nouser ：寻找文件的拥有者不存在 /etc/passwd 的人。 -nogroup ：寻找文件的拥有群组不存在于 /etc/group 的文件。 当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的。在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。示例：12345678#搜寻/home底下属于mrbird用户的文件root@ubuntu:~# find /home -user mrbird/home/mrbird/home/mrbird/.sudo_as_admin_successful... #搜寻系统中不属于任何人的文件root@ubuntu:~# find / -nouser与文件权限及名称有关的参数：1234567891011121314151617选项与参数：3. 与文件权限及名称有关的参数： -name filename：搜寻文件名为 filename 的文件； -size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的文件。这个 SIZE 的规格有： c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB还要大的文件， 就是『 -size +50k 』 -type TYPE ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 (f), 装置文件 (b, c), 目录 (d), 连结档 (l), socket (s), 及 FIFO (p) 等属性。 -perm mode ：搜寻文件权限『刚好等于』 mode 的文件，这个 mode 为类似 chmod 的属性值，举例来说， -rwxr-xr-x 的属性为 0755。 -perm -mode ：搜寻文件权限『必须要全部囊括 mode 的权限』的文件，举例来说，我 们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744， 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来， 因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。 -perm /mode ：搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻 -rwxr-xr-x ，亦即 -perm /755 时，当一个文件属性为 -rw------- 也会被列出来，因为他有 -rw.... 的属性存在.示例：12345678910111213141516171819202122232425262728#找出档名为passwd这个文件root@ubuntu:~# find / -name passwd/usr/share/lintian/overrides/passwd/usr/share/doc/passwd/usr/share/bash-completion/completions/passwd...#找出文件名包含了passwd这个关键词的文件root@ubuntu:~# find / -name *passwd*/usr/share/app-install/desktop/kdepasswd:kde4__kdepasswd.desktop/usr/share/app-install/desktop/usermode:redhat-userpasswd.desktop/usr/share/lintian/overrides/base-passwd... #找出/run目录下，文件类型为Socket的文件root@ubuntu:~# find /run -type s/run/NetworkManager/private-dhcp/run/cups/cups.sock/run/uuidd/request/run/avahi-daemon/socket... #搜寻文件权限为666的文件root@ubuntu:~# find / -perm 666/dev/vsock/dev/net/tun/dev/ptmx...额外可进行的操作：1234选项与参数：4. 额外可进行的动作： -exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。 -print ：将结果打印到屏幕上，这个动作是预设动作。示例：12345678#搜寻/run目录下文件权限为666的文件，并用ls -l命令查看其信息root@ubuntu:~# find /run -perm 666 -exec ls -l &#123;&#125; \;srw-rw-rw- 1 root root 0 Apr 13 10:34 /run/cups/cups.socksrw-rw-rw- 1 root root 0 Apr 13 10:34 /run/uuidd/requestsrw-rw-rw- 1 root root 0 Apr 13 10:34 /run/avahi-daemon/socketsrw-rw-rw- 1 root root 0 Apr 13 10:34 /run/acpid.socketsrw-rw-rw- 1 root root 0 Apr 13 10:34 /run/dbus/system_bus_socket...{}代表的是由 find 找到的内容，-exec 一直到\;是执行额外动作的指令。这里不能用管线来代替-exec：12root@ubuntu:~# find /run -perm 666 | ls -ltotal 0《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件预设权限umask]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E9%A2%84%E8%AE%BE%E6%9D%83%E9%99%90umask.html</url>
    <content type="text"><![CDATA[当我们在Linux下创建一个新的目录或文件的时候，它都会有个默认的权限。这个权限的设定和umask有关，umask指的是：目前用户在建立文件或目录时候的权限默认值。查阅当前用户umask方式有两种，一种可以直接输入 umask ，就可以看到数字型态的权限设定分数， 一种则是 加入 -S (Symbolic) 这个选项，就会以符号类型的方式来显示出权限了：1234root@ubuntu:~# umask0022root@ubuntu:~# umask -Su=rwx,g=rx,o=rxumask的第一个值为特殊权限。剩下的三个值分别就代表了r，w，x了。Linux中，文件的预设权限为-rw-rw-rw-，目录的预设权限为drwxrwxrwx。要注意的是，umask 的分数指的是该默认值需要减掉的权限！所以如果umask的值为022的时候，在创建新文件或目录的时候，其权限的计算方式为：建立文件时：(-rw-rw-rw-) - (—–w–w-) ==&gt; -rw-r–r–建立目录时：(drwxrwxrwx) - (—–w–w-) ==&gt; drwxr-xr-x验证一下：12345678root@ubuntu:~# cd /temproot@ubuntu:/temp# umask0022root@ubuntu:/temp# touch file1root@ubuntu:/temp# mkdir dir1root@ubuntu:/temp# ls -ld file1 dir1drwxr-xr-x 2 root root 4096 Apr 13 14:35 dir1-rw-r--r-- 1 root root 0 Apr 13 14:35 file1改变umask的值：123root@ubuntu:/temp# umask 033root@ubuntu:/temp# umask0033《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件隐藏属性]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[Linux文件或目录除了rwxrwxrwx九个权限设定外，还有隐藏的属性。设置文件或目录的隐藏属性可以指令chattr，而显示文件或目录的隐藏属性则用指令lsattr。chattr：语法：123456789101112131415chattr [+-=][ASacdistu] 文件或目录名称选项与参数：+ ：增加某一个特殊参数，其他原本存在参数则不动。- ：移除某一个特殊参数，其他原本存在参数则不动。= ：设定一定，且仅有后面接的参数A ：当设定了 A 这个属性时，若你有存取此文件(或目录)时，他的访问时间 atime 将不会被修改，可避免 I/O 较慢的机器过度的存取磁盘。S ：一般文件是异步写入磁盘的，如果加上 S 这个属性时，当你进行任何文件的修改，该更动会『同步』写入磁盘中。a ：当设定 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有 root 才能设定这属性c ：这个属性设定之后，将会自动的将此文件『压缩』，在读取的时候将会自动解压缩，但是在储存的时候，将会先进行压缩后再储存。d ：当 dump 程序被执行的时候，设定 d 属性将可使该文件(或目录)不会被 dump 备份i ：他可以让一个文件『不能被删除、改名、设定连结也无法写入或新增数据』对于系统安全性有相当大的帮助。只有 root 能设定此属性。s ：当文件设定了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，所以如果误删了，完全无法救回来了。u ：与 s 相反的，当使用 u 来配置文件案时，如果该文件被删除了，则数据内容其实还存在磁盘中，可以使用来救援该文件。注意 1：属性设定常见的是 a 与 i 的设定值，而且很多设定值必须要身为 root 才能设定。注意 2：xfs 文件系统仅支援 AadiS 而已。示例：在/temp下新建一个文件，并加入i选项，然后尝试删除：1234root@ubuntu:/temp# touch file2root@ubuntu:/temp# chattr +i file2root@ubuntu:/temp# rm file2rm: cannot remove 'file2': Operation not permitted操作被拒绝，只有移除i选项后，才能够删除：12root@ubuntu:/temp# chattr -i file2root@ubuntu:/temp# rm file2lsattr：语法：12345lsattr [-adR] 文件或目录选项与参数：-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来。示例：1234root@ubuntu:/temp# touch file2root@ubuntu:/temp# chattr +iA file2root@ubuntu:/temp# lsattr file2----i--A-----e-- file2《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件时间类型]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[Linux文件有三个主要的变动时间：modification time (mtime)： 当该文件的『内容数据』变更时，就会更新这个时间。内容数据指的是文件的内容，而不是文件的属性或权限。status time (ctime)： 当该文件的『状态 (status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间。access time (atime)： 当『该文件的内容被取用』时，就会更新这个读取时间 (atime)。举例来说，我们使用 cat 去读取/etc/ltrace.conf， 就会更新该文件的atime 。查看/etc/ltrace.conf文件的相关时间：12345root@ubuntu:/home/mrbird# date;ls -l /etc/ltrace.conf;ls -l --time=atime /etc/ltrace.conf;ls -l --time=ctime /etc/ltrace.conf Wed Apr 12 02:32:27 PDT 2017-rw-r--r-- 1 root root 14867 Apr 11 2016 /etc/ltrace.conf-rw-r--r-- 1 root root 14867 Apr 12 00:31 /etc/ltrace.conf-rw-r--r-- 1 root root 14867 Apr 11 03:20 /etc/ltrace.conf默认的情况下，ls 显示出来的是该文件的 mtime。要修改文件相关时间属性，可以使用touch指令。语法：1234567touch [-acdmt] 文件选项与参数：-a ：仅修订 access time；-c ：仅修改文件的时间，若该文件不存在则不建立新文件；-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date="日期或时间"-m ：仅修改 mtime ；-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]新建一个空文件，并查看其时间：123root@ubuntu:/temp# touch testouchroot@ubuntu:/temp# ls -l testouch-rw-r--r-- 1 root root 0 Apr 12 02:40 testouch修改testouch的mtime为两天前：12root@ubuntu:/temp# ls -l testouch-rw-r--r-- 1 root root 0 Apr 10 02:45 testouch修改testouch的atime为2017/01/01 00:00：123root@ubuntu:/temp# touch -a -t 201701010000 testouch root@ubuntu:/temp# ls -l --time=atime testouch -rw-r--r-- 1 root root 0 Jan 1 00:00 testouch《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件内容查阅]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E9%98%85.html</url>
    <content type="text"><![CDATA[Linux文件内容查阅主要使用以下命令：cat：由第一行开始显示文件内容。tac：从最后一行开始显示，可以看出 tac 是 cat 的倒着写。nl：显示的时候，顺道输出行号。more：一页一页的显示文件内容。less：与 more 类似，但是比 more 更好的是，他可以往前翻页。head：只看头几行。tail：只看尾巴几行。od：以二进制的方式读取文件内容。直接检视文件内容cat：cat 是 Concatenate (连续) 的简写，主要的功能是将一个文件的内容连续的印出在屏幕上面。语法：12345678cat [-AbEnTv]选项与参数：-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字符 $ 显示出来；-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符示例：使用cat命令查阅/etc/legal文件内容，并加上行号：123456789root@ubuntu:~# cat -n /etc/legal 1 2 The programs included with the Ubuntu system are free software; 3 the exact distribution terms for each program are described in the 4 individual files in /usr/share/doc/copyright. 5 6 Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by 7 applicable law. 8tac（反向列示）：tac 刚好是将 cat 反写过来，所以他的功能就跟 cat 相反。cat 是由第一行到最后一行连续显示在屏幕上，而 tac 则是由最后一行到第一行反向在屏幕上显示出来。使用tac命令查阅/etc/legal文件内容：12345678root@ubuntu:~# tac /etc/legal applicable law.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by individual files in /usr/share/doc/copyright.the exact distribution terms for each program are described in theThe programs included with the Ubuntu system are free software;nl（添加行号打印）：nl可以将输出的文件内容自动的加上行号。其预设的结果与cat -n有点不太一样， nl可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。语法：12345678910nl [-bnw] 文件选项与参数：-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种： -n ln ：行号在屏幕的最左方显示； -n rn ：行号在自己字段的最右方显示，且不加 0 ； -n rz ：行号在自己字段的最右方显示，且加 0 ；-w ：行号字段的占用的字符数示例：使用nl显示/etc/legal文件内容：12345678root@ubuntu:~# nl /etc/legal 1 The programs included with the Ubuntu system are free software; 2 the exact distribution terms for each program are described in the 3 individual files in /usr/share/doc/copyright. 4 Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by 5 applicable law.可见，空行并没有显示行号，可以使用-b a选项显示空行行号：123456789root@ubuntu:~# nl -b a /etc/legal 1 2 The programs included with the Ubuntu system are free software; 3 the exact distribution terms for each program are described in the 4 individual files in /usr/share/doc/copyright. 5 6 Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by 7 applicable law. 8可翻页查阅当文件内容较多的时候，可以使用more和less命令来翻页显示文件内容。more：使用more查阅/etc/ltrace.conf，页面最后一行会显示出目前显示的百分比：还可以在最后一行输入一些有用的指令：123456空格键 (space)：代表向下翻一页；Enter ：代表向下翻一行；/字符串 ：代表在这个显示的内容当中，向下搜寻『字符串』这个关键词；:f ：立刻显示出文件名以及目前显示的行数；q ：代表立刻离开 more ，不再显示该文件内容；b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 ​less：less 的用法比起 more 又更加的有弹性，less可用的指令有： bash 空格键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字符串 ：向下搜寻『字符串』的功能； ?字符串 ：向上搜寻『字符串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关) N ：反向的重复前一个搜寻 (与 / 或 ? 有关) g ：前进到这个资料的第一行去； G ：前进到这个数据的最后一行去 (注意大小写)； q ：离开 less 这个程序。 ​12345678## 以行为单位查阅### head（取出前面几行）：语法：```bashhead [-n number] 文件 选项与参数：-n ：后面接数字，代表显示几行的意思示例：12345678910#使用head指令查阅/etc/ltrace.conf，默认输出前10行root@ubuntu:~# head /etc/ltrace.conf ; ltrace.conf;; ~/.ltrace.conf will also be read, if it exists. The -F option may be...#只查看前1行root@ubuntu:~# head -n 1 /etc/ltrace.conf ; ltrace.conf如果数字是负数的话，如使用指令head -n -100 /etc/file 则表示输出file文件去除后100行后的所有行。即如果file文件有150行，使用该指令后，只会输出前50行。tail（取出后面几行）：语法：12345tail [-n number] 文件 选项与参数：-n ：后面接数字，代表显示几行的意思-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c 才会结束 tail 的侦测使用方法和head类似。如果要查阅/etc/ltrace.conf第11行到20行的数据，我们可以使用管线 (|)连接head和tail指令。管线的意思是：前面的指令所输出的讯息，请透过管线交由后续 的指令继续使用。1234567891011root@ubuntu:~# head -n 20 /etc/ltrace.conf | tail -n 10typedef in_addr = struct(hex(uint));int inet_aton(string, +in_addr*);hex(uint) inet_addr(string);hex(uint) inet_network(string);string inet_ntoa(in_addr);in_addr inet_makeaddr(hex(int), hex(int));hex(uint) inet_lnaof(in_addr);hex(uint) inet_netof(in_addr); ; bfd.h加上行号：1234567891011root@ubuntu:~# cat -n /etc/ltrace.conf | head -n 20 | tail -n 10 11 typedef in_addr = struct(hex(uint)); 12 int inet_aton(string, +in_addr*); 13 hex(uint) inet_addr(string); 14 hex(uint) inet_network(string); 15 string inet_ntoa(in_addr); 16 in_addr inet_makeaddr(hex(int), hex(int)); 17 hex(uint) inet_lnaof(in_addr); 18 hex(uint) inet_netof(in_addr); 19 20 ; bfd.h非纯文本档： od当查阅非文本文件的时候，应该使用od命令。语法：123456789od [-t TYPE] 文件选项或参数：-t ：后面可以接各种『类型 (TYPE)』的输出，例如： a ：利用默认的字符来输出； c ：使用 ASCII 字符来输出 d[size] ：利用十进制(decimal)来输出数据，每个整数占用 size bytes ； f[size] ：利用浮点数(floating)来输出数据，每个数占用 size bytes ； o[size] ：利用八进制(octal)来输出数据，每个整数占用 size bytes ； x[size] ：利用十六进制(hexadecimal)来输出数据，每个整数占用 size bytes ；示例：将/usr/bin/passwd 的内容使用 ASCII 方式来展现：123456789od -t c /usr/bin/passwd 0000000 177 E L F 002 001 001 \0 \0 \0 \0 \0 \0 \0 \0 \00000020 003 \0 &gt; \0 001 \0 \0 \0 0 &gt; \0 \0 \0 \0 \0 \00000040 @ \0 \0 \0 \0 \0 \0 \0 360 314 \0 \0 \0 \0 \0 \00000060 \0 \0 \0 \0 @ \0 8 \0 \t \0 @ \0 034 \0 033 \00000100 006 \0 \0 \0 005 \0 \0 \0 @ \0 \0 \0 \0 \0 \0 \00000120 @ \0 \0 \0 \0 \0 \0 \0 @ \0 \0 \0 \0 \0 \0 \00000140 370 001 \0 \0 \0 \0 \0 \0 370 001 \0 \0 \0 \0 \0 \0...将/etc/issue 这个文件的内容以 8 进位列出储存值与 ASCII 的对照表：123456root@ubuntu:~# od -t oCc /etc/issue0000000 125 142 165 156 164 165 040 061 066 056 060 064 056 062 040 114 U b u n t u 1 6 . 0 4 . 2 L0000020 124 123 040 134 156 040 134 154 012 012 T S \ n \ l \n \n0000032《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件与目录简单操作]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[Linux下几个特殊的目录：12345. 代表此层目录.. 代表上一层目录- 代表前一个工作目录~ 代表『目前用户身份』所在的家目录~mrbird 代表 mrbird 这个用户的家目录目录相关操作几个常见的处理目录的指令：cd：变换目录；pwd：显示当前目录；mkdir：建立一个新的目录；rmdir：删除一个空的目录。cd (change directory, 变换目录)：1234567891011#切换到var目录下mrbird@ubuntu:~$ cd /var#回到刚刚那个目录mrbird@ubuntu:/var$ cd -/home/mrbird#切换到用户mrbird的家目录mrbird@ubuntu:~$ cd ~mrbird#上一层目录mrbird@ubuntu:~$ cd ..#当前目录mrbird@ubuntu:/home$ cd .pwd (Print Working Directory，显示目前所在的目录)：语法：123pwd [-P]选项与参数：-P ：显示出确实的路径，而非使用链接 (link) 路径。示例：1234567root@ubuntu:/home/mrbird# pwd/home/mrbirdroot@ubuntu:/home/mrbird# cd /var/lockroot@ubuntu:/var/lock# pwd/var/lockroot@ubuntu:/var/lock# pwd -P/run/lock加入-p选项后，显示出了/var/lock的真实路径，因为它是个链接档。mkdir (make directory，建立新目录)：语法：1234mkdir [-mp] 目录名称选项与参数：-m ：配置文件案的权限！直接设定，不需要看预设权限 (umask) 的脸色-p ：帮助你直接将所需要的目录(包含上层目录)递归建立起来。 ​示例：1234567891011121314#创建目录temproot@ubuntu:~# mkdir /temproot@ubuntu:~# cd /temp#直接创建多层级目录报错root@ubuntu:/temp# mkdir test1/test2/test3mkdir: cannot create directory 'test1/test2/test3': No such file or directory#加入-p递归创建root@ubuntu:/temp# mkdir -p test1/test2/test3#创建目录test2，权限为711root@ubuntu:/temp# mkdir -m 711 test2root@ubuntu:/temp# ls -altotal 16...drwx--x--x 2 root root 4096 Apr 11 18:43 test2rmdir (删除『空』的目录)：语法：123rmdir [-p] 目录名称选项与参数：-p ：连同『上层』『空的』目录也一起删除示例：12345678910#删除空目录test2root@ubuntu:/temp# rmdir test2root@ubuntu:/temp# lstest1#删除非空目录test1，提示无法删除root@ubuntu:/temp# rmdir test1rmdir: failed to remove 'test1': Directory not empty#使用-p递归删除root@ubuntu:/temp# rmdir -p test1/test2/test3root@ubuntu:/temp# ls文件与目录管理相关的命令有：ls：显示属性；cp：拷贝；rm：删除文件；mv移动目录或文件等。ls（list）文件与目录的检视：语法：123456789101112131415161718192021222324ls [-aAdfFhilnrRSt] 文件名或目录名称..ls [--color=&#123;never,auto,always&#125;] 文件名或目录名称..ls [--full-time] 文件名或目录名称..选项与参数：-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)-A ：全部的文件，连同隐藏档，但不包括 . 与 .. 这两个目录-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！)-F ：根据文件、目录等信息，给予附加数据结构，例如： *:代表可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；-h ：将文件容量以人类较易读的方式(例如 GB, KB 等等)列出来；-i ：列出 inode 号码，inode 的意义下一章将会介绍；-l ：长数据串行出，包含文件的属性与权限等等数据；(常用)-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID 与 GID 会在账号管理提到！)-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小；-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；-S ：以文件容量大小排序，而不是用档名排序；-t ：依时间排序，而不是用档名。--color=never ：不要依据文件特性给予颜色显示；--color=always ：显示颜色--color=auto ：让系统自行依据设定来判断是否给予颜色--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出--time=&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 (ctime) 而非内容变更时间 (modification time)ls命令很常用，这里仅示例--color，--full-time，--time参数：--color参数的使用：ls默认显示根据文件特性显示颜色，可以使用--color=never关闭！--full-time参数的使用：12345678root@ubuntu:/var# ls --full-timetotal 48drwxr-xr-x 2 root root 4096 2017-04-11 18:07:45.485003705 -0700 backupsdrwxr-xr-x 15 root root 4096 2017-04-11 03:49:17.681766424 -0700 cachedrwxrwsrwt 2 root whoopsie 4096 2017-04-11 04:17:29.961240226 -0700 crashdrwxr-xr-x 64 root root 4096 2017-04-11 04:56:56.702320395 -0700 libdrwxrwsr-x 2 root staff 4096 2016-04-12 13:14:23.000000000 -0700 local...该完整的呈现了文件的修改时间 (modification time)。cp（copy）复制文件或目录：语法：1234567891011121314[root@study ~]# cp [-adfilprsu] 来源文件(source) 目标文件(destination)[root@study ~]# cp [options] source1 source2 source3 .... directory选项与参数：-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；(常用)-d ：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非文件本身；-f ：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；-i ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用)-l ：进行硬式连结(hard link)的连结档建立，而非复制文件本身；-p ：连同文件的属性(权限、用户、时间)一起复制过去，而非使用默认属性(备份常用)；-r ：递归持续复制，用于目录的复制行为；(常用)-s ：复制成为符号链接文件 (symbolic link)，亦即『快捷方式』文件；-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。 最后需要注意的，如果来源档有两个以上，则最后一个目的文件一定要是『目录』才行。不同权限用户使用cp命令会产生不同的结果，下面举几个实例：12345678910111213141516171819202122232425262728293031323334353637383940#用 root 身份，将家目录下的 .bashrc 复制到 /tmp 下，并更名为 bashrcroot@ubuntu:~# cp ~/.bashrc /temp/bashrc#使用-i选项，当目标文件已经存在时，会进行操作询问root@ubuntu:~# cp -i ~/.bashrc /temp/bashrccp: overwrite '/temp/bashrc'? y &lt;==n 不覆盖，y 为覆盖 root@ubuntu:/var/log# cd /temp#复制/var/log/wtmp 到当前（/temp）目录，别忘记了加.root@ubuntu:/temp# cp /var/log/wtmp .root@ubuntu:/temp# lsbashrc wtmp #使用ls -l命令观察源文件和复制文件的权限，可见两者并不一致root@ubuntu:/temp# ls -l /var/log/wtmp wtmp-rw-rw-r-- 1 root utmp 8448 Apr 11 18:11 /var/log/wtmp-rw-r--r-- 1 root root 8448 Apr 11 19:08 wtmp#使用-a选项，连同权限一起复制root@ubuntu:/temp# cp -a /var/log/wtmp wtmp1root@ubuntu:/temp# ls -l /var/log/wtmp wtmp wtmp1-rw-rw-r-- 1 root utmp 8448 Apr 11 18:11 /var/log/wtmp-rw-r--r-- 1 root root 8448 Apr 11 19:08 wtmp-rw-rw-r-- 1 root utmp 8448 Apr 11 18:11 wtmp1 #配合-r选项将/var/log/目录下的所有内容复制到/temp目录下root@ubuntu:/temp# cp -ar /var/log/ .root@ubuntu:/temp# lsbashrc log wtmp wtmp1root@ubuntu:/temp# ls logXorg.0.log auth.log dmesg gpu-manager.log lightdm ... #建立一个bashrc文件的连结档 (symbolic link)root@ubuntu:/temp# cp -s bashrc bashrc_slinkroot@ubuntu:/temp# cp -l bashrc bashrc_hlinkroot@ubuntu:/temp# ls -ltotal 36-rw-r--r-- 2 root root 3106 Apr 11 19:04 bashrc-rw-r--r-- 2 root root 3106 Apr 11 19:04 bashrc_hlinklrwxrwxrwx 1 root root 6 Apr 11 19:24 bashrc_slink -&gt; bashrc...最后一个例子中，使用 -l 及 -s 都会建立所谓的连结档(link file)，但是这两种连结档却有不一样的情况。那个 -l 就是所谓的实体链接(hard link)，至于 -s 则是符号链接(symbolic link)， 简单来说，bashrc_slink 是一个『快捷方式』，这个快捷方式会连结到 bashrc 去。所以你会看到档名右侧会有个指向(-&gt;)的符号。bashrc_hlink 文件与 bashrc 的属性与权限完全一模一样，与尚未进行连结前的差异则是第二栏的 link 数由 1 变成 2。rm（remove）移除文件或目录：语法：12345rm [-fir] 文件或目录选项与参数：-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除，这是非常危险的选项！！示例：12345678910111213141516171819202122232425#删除/temp目录下的bashrc文件root@ubuntu:/temp# rm -i bashrcrm: remove regular file 'bashrc'? y #删除/temp/log目录root@ubuntu:/temp# rmdir logrmdir: failed to remove 'log': Directory not empty#非空目录，使用rm -r命令递归删除，无需询问的话去掉-i选项即可root@ubuntu:/temp# rm -ri logrm: descend into directory 'log'? yrm: descend into directory 'log/vmware'? yrm: remove regular file 'log/vmware/rc.local.log'? ^C #删除一个带有 - 开头的文件root@ubuntu:/temp# touch ./-aaa-root@ubuntu:/temp# ls-aaa- bashrc_hlink bashrc_slink log wtmp wtmp1root@ubuntu:/temp# rm -aaa-rm: invalid option -- 'a'Try 'rm ./-aaa-' to remove the file '-aaa-'. &lt;== bash给的建议Try 'rm --help' for more information.#因为-是选项的意思，系统误判，使用转义符解决：root@ubuntu:/temp# rm ./-aaa-root@ubuntu:/temp# lsbashrc_hlink bashrc_slink log wtmp wtmp1最后一个例子中，使用命令rm -- -aaa-也可以删除-aaa-文件。mv（move）移动文件与目录，或重命名：语法：123456mv [-fiu] source destinationmv [options] source1 source2 source3 .... directory选项与参数：-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新 (update)示例：1234567891011121314151617#在/temp下新建目录tmp，然后将bashrc文件移动到该目录下root@ubuntu:/temp# mkdir tmproot@ubuntu:/temp# mv bashrc tmproot@ubuntu:/temp# lsbashrc_hlink bashrc_slink log tmp wtmp wtmp1root@ubuntu:/temp# ls tmpbashrc #将目录tmp重命名为tmp1root@ubuntu:/temp# mv tmp tmp1root@ubuntu:/temp# lsbashrc_hlink bashrc_slink log tmp1 wtmp wtmp1 #将log目录下的wtmp和vmware文件一起移动到tmp1目录下root@ubuntu:/temp# mv log/wtmp log/vmware tmp1root@ubuntu:/temp# ls tmp1bashrc vmware wtmp查看文件类型如果你想要知道某个文件的基本数据，例如是属于ASCII 或者是data 文件，或者是 binary等，可以利用 file 这个指令来查看：1234567mrbird@ubuntu:/temp$ file bashrc_hlink bashrc_hlink: ASCII textmrbird@ubuntu:/temp$ file wtmpwtmp: datamrbird@ubuntu:/temp$ file /usr/bin/passwd /usr/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=40a9016718f4247f09acc62e1bbf056372bf31f5, stripped《鸟哥的Linux私房菜》读书笔记]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS优先级规则]]></title>
    <url>%2FCSS%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%84%E5%88%99.html</url>
    <content type="text"><![CDATA[特殊性如果一个元素有两个以上冲突的属性声明，那么特殊性（specificity）高的声明将会胜出。特殊性的值表述为四个部分，如0,0,0,0，具体规则：1.选择器中给定的各个ID属性值，加0,1,0,0。2.选择器中给定的各个类属型值，属性选择和伪类，加0,0,1,0。3.选择器中给定的各个元素和伪元素，加0,0,0,1。4.通配符对特殊性没有任何贡献，加0,0,0,0。比如：1234567h1 &#123;color: red;&#125; /* specificity = 0,0,0,1 */p em &#123;color: purple;&#125; /* specificity = 0,0,0,2 */*.grape &#123;color: purple;&#125; /* specificity = 0,0,1,0 */.bright &#123;color: purple;&#125; /* specificity = 0,0,0,1 */p.bright em.dark &#123;color: maroon;&#125; /* specificity = 0,0,2,2 */#drop-down &#123;color: green;&#125; /* specificity = 0,1,0,0 */div#sidebar *[href] &#123;color: black;&#125; /* specificity = 0,1,1,1 */特殊性大小的比较规则为从左到右，数值大的越大。举个例子，考虑有如下规则的html：12345678910111213&lt;style&gt; h1 + p &#123;color: black; font-style: italic&#125; /* specificity = 0,0,0,2 */ p &#123;color: gray; background: white; font-style: normal&#125; /* specificity = 0,0,0,1 */ *.aside &#123;color: black; background: silver&#125; /* specificity = 0,0,1,0 */&lt;/style&gt;&lt;body&gt; &lt;h1&gt;Greeting!&lt;/h1&gt; &lt;p class="aside"&gt;It's a fine way to start a day.&lt;/p&gt; &lt;p&gt;There are many ways to greet a man.&lt;/p&gt; &lt;h1&gt;Salutations&lt;/h1&gt; &lt;p&gt;There is nothing finer than a hearty welcome from ...&lt;/p&gt; &lt;p class="aside"&gt;Although a thick and juicy hamburger with...&lt;/p&gt;&lt;/body&gt;最终显示如下图所示：内联样式特殊性特殊性值的第一位是为内联样式保留的，每个内联样式的特殊性都为1,0,0,0，比如下面的h1元素将显示为绿色：12h1#meadow &#123;color: red&#125;&lt;h1 id="meadow" style="color: green;"&gt;The title&lt;/h1&gt;重要性对于某个非常重要的声明，可以在这些声明的结束分号前插入!important。如果一个非重要声明和重要声明冲突，胜出的总是重要声明。如：1234567&lt;style&gt; h1 &#123;color: green !important;&#125; h1.title &#123;color: red&#125;&lt;/style&gt;&lt;body&gt; &lt;h1 class="title"&gt;Greeting!&lt;/h1&gt;&lt;/body&gt;最终h1为绿色。继承对于继承的值没有特殊性，而非0特殊性。举个例子：12345678&lt;style&gt; * &#123;color: lightcoral&#125; h1.title &#123;color: black&#125;&lt;/style&gt;&lt;body&gt; &lt;h1 class="title"&gt;Meerkat &lt;em&gt;Central&lt;/em&gt;&lt;/h1&gt; &lt;p&gt;Welcome to the best place on the web...&lt;/p&gt;&lt;/body&gt;显示如下图所示：结果证明了0特殊性比无特殊性要强。按权重和来源排序一般来说，权重由大到小的顺序为：1.读者的重要声明。2.创作人员的重要声明。3.创作人员的正常声明。4.读者的正常声明。5.用户代理声明。CSS中的样式一共有三种来源：创作人员、读者和用户代理。创作人员（author’s+style）样式应该是我们最熟悉的，如果你是一个前端开发者，那么你写的那些样式就叫做创作人员样式。用户代理样式（agent’s+style）。用户代理也就是我们通常所说的浏览器（IE、Firefox等等），这些浏览器会提供一些默认的样式。读者样式（reader’s+style）。所谓读者自然就是浏览网页的用户，有些时候这些用户里可能会有人不满意网页的配色，或者字体大小，这时候他们就是通过浏览器提供的接口为网站添加读者样式。比如：12p em &#123;color: black;&#125; /* author's style sheet*/ p em &#123;color: yellow;&#125; /* reader's style sheet*/第一条规则将胜出。12p em &#123;color: black !important;&#125; /* author's style sheet*/ p em &#123;color: yellow !important;&#125; /* reader's style sheet*/第二条规则将胜出。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04搭建Java开发环境]]></title>
    <url>%2Fubuntu16-04%E6%90%AD%E5%BB%BAJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[安装JDKJDK1.8下载地址：http://pan.baidu.com/s/1qYPORRA，JDK安装步骤：1.将下载的包解压到/opt/jvm：12sudo mkdir /opt/jvmsudo tar zxvf jdk-8u77-linux-x64.tar.gz -C /opt/jvm如果提示失败，是因为目录权限不足，可以使用chmod改变权限：1sudo chmod 777 /opt /opt/jvm2.配置jdk的环境变量，打开 /etc/profile文件（sudo vim /etc/profile），在文件末尾添加下语句：1234export JAVA_HOME=/opt/jvm/jdk1.8.0_77export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH点击Esc，输入:wq保存退出。3.使其生效：1sudo source /etc/profile如若提示sudo: source：找不到命令，可以切换为root，再次执行，操作如下：12sudo -s -Hsource /etc/profile检查是否成功：1234mrbird@mrbird-xps13:~$ java -versionjava version "1.8.0_77"Java(TM) SE Runtime Environment (build 1.8.0_77-b03)Java HotSpot(TM) 64-Bit Server VM (build 25.77-b03, mixed mode)安装eclipseeclipse下载，官网：https://www.eclipse.org/downloads/eclipse-packages/?osType=linux&amp;release=undefined，或者百度云：http://pan.baidu.com/s/1pKMmRR9。eclipse安装步骤：1.下载后切换到下载目录，将其解压到/opt/文件夹中：1sudo tar zxvf eclipse-jee-neon-3-linux-gtk-x86_64.tar.gz -C /opt2.然后到/opt/eclipse目录下双击eclipse即可，为了方便，建议将其锁定到启动器。安装MySQL1.在Ubuntu 16.04上安装MySQL：1sudo apt-get install mysql-server mysql-client2.安装过程中需要你输入MySQL 管理员用户（root）密码 。3.运行MySQL初始化安全脚本：1sudo mysql_secure_installation4.根据提示信息设置：更改root密码、移除MySQL的匿名用户、禁止root远程登录、删除test数据库。检查是否成功：123456789101112131415161718192021222324252627mrbird@mrbird-xps13:~$ mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.17-0ubuntu0.16.04.1 (Ubuntu) Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. mysql&gt; show databases -&gt; ;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) mysql&gt;]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XPS13安装win10 ubuntu双系统]]></title>
    <url>%2FXPS13%E5%AE%89%E8%A3%85win10-ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[这几天被安装双系统折腾得够呛，昨天终于安装成功，所以撰写此文以备忘。安装和启动方式均为UEFI，进行以下操作时先进行数据备份！博主电脑为Dell XPS13 9350，不同电脑进入BIOS快捷键可能不一样，请自行百度。安装win10win10选择的是家庭中文版1607 64bit，因为序列号是烧在主板上的，所以安装完联网就自动激活了，而且对于我来说家庭版和专业版没有太大区别…win10镜像文件下载地址：http://pan.baidu.com/s/1dF3Q8Id，下载后用UltraISO将镜像文件刻录到U盘里：1.打开UltralISO，选择文件→打开，选中下载好的win10镜像文件： 2.选择启动→写入硬盘映像，硬盘驱动器选择插入的U盘：3.点击便捷启动→写入新的驱动器引导扇区→Windows9x，弹出框：4.点击确定，然后点击写入，等待写入完毕。写入完毕后重启电脑，出现品牌Logo的时候按F2进如BIOS设置界面。进行如下设置：• 将Security Boot 设置为Disabled• 启动方式设置为UEFI保存设置重启电脑，出现品牌Logo的时候按F12进入启动选择界面，然后选择UEFI模式下的U盘选项，接下来根据提示操作即可。安装途中，可能出现无法将windows安装到磁盘0的分区1错误提示，解决办法为：按住“shift+f10”，呼出“cmd”命令符输入如下命令：1234567diskpart //回车执行，进入diskpart命令模式list disk //回车执行，显示磁盘信息select disk 0 //回车执行，选择第0个磁盘（电脑的硬盘编号是从0开始的）clean //回车执行，删除磁盘分区&amp;格式化（所以说要做好备份！）convert mbr //回车执行，将当前磁盘分区设置为mbr形式convert gpt //回车执行，将将当前磁盘分区设置为gpt形式exit //回车执行，退出刷新磁盘，即可继续安装。安装Ubuntu16.04镜像文件在ubuntu官网下载：https://www.ubuntu.com/download/desktop。安装前，先在win10下压缩出100GB的磁盘空间（我的磁盘大小为256GB，所以分100GB给ubuntu，保持未分配状态）。同样使用UltralISO将ubuntu镜像文件刻录进U盘里（U盘先格式化为FAT32模式，然后刻录时写入新的驱动器引导扇区为syslinux）。刻录完重启电脑，出现品牌Logo的时候按F12进入启动选择界面，选择UEFI模式下的U盘选项，然后Install ubuntu。安装过程中不要选择“与其它系统共存”那一项，而选择最后那个“其它选项（创建自己的分区）”，然后选择空闲分区（就是刚刚分出来的100GB），下面依次点击新建分区表来挂载分区：1.新建efi系统分区，选中逻辑分区和空间起始位置，分配512MB。2.挂载“/home”，类型为EXT4日志文件系统，选中逻辑分区和空间起始位置，分配20GB。3.挂载“/usr”，类型为EXT4日志文件系统，选中逻辑分区和空间起始位置，分配45GB。4.挂载“/”，类型为EXT4日志文件系统，选中逻辑分区和空间起始位置，分配20GB。5.swap交换空间，这个也就是虚拟内存的地方，选择主分区和空间起始位置，剩下的内存都分配给它。分配好各个挂载点后，选择“安装引导启动器的设备”，选择第一步创建的efi系统分区！！！！！安装成功后，拔掉U盘并且重启，出现品牌Logo的时候按F2进如BIOS设置界面开启Secure Boot，保存退出启动电脑就可以看到系统选择界面了。最后贴两张安装好后的系统截图：win10ubuntu：]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.html</url>
    <content type="text"><![CDATA[Linux 最优秀的地方之一就在于他的多人多任务环境。而为了让各个使用者具有较保密的文件数，因此文件的权限管理就变得很重要了。Linux一般将文件可存取的身份分为三个类别：owner/group/others，且三种身份各有read/write/execute等权限。文件属性使用ls命令查看当前目录下文件的属性：12345678910111213mrbird@mrbird-xps13:~$ ls -alh总用量 196Kdrwxr-xr-x 32 mrbird mrbird 4.0K 3月 26 11:34 .drwxr-xr-x 4 root root 4.0K 3月 25 03:31 ..drwxrwxr-x 4 mrbird mrbird 4.0K 3月 26 10:58 .audacity-data-rw------- 1 mrbird mrbird 5.5K 3月 26 11:18 .bash_history-rw-r--r-- 1 mrbird mrbird 220 3月 25 03:31 .bash_logout-rw-r--r-- 1 mrbird mrbird 3.7K 3月 25 03:31 .bashrcdrwx------ 25 mrbird mrbird 4.0K 3月 26 11:34 .cachedrwx------ 30 mrbird mrbird 4.0K 3月 26 10:51 .configdrwxrwxr-x 4 mrbird mrbird 4.0K 3月 25 20:19 .cxofficedrwx------ 3 mrbird mrbird 4.0K 3月 25 11:35 .dbus...文件属性分为7个部分，从左到右依次是：文件类型和权限，连接数，拥有者，群组，文件容量，修改日期和文件名。1.文件的类型与权限（permission）：如：drwxrwxr-x我们拆分为d rwx rwx r-x 四个部分，第一部分代表文件类型，类型有：• 当为[ d ]则是目录，例如上面文件名为『.config』的那一行。• 当为[ - ]则是文件，例如上表档名为『.bash_history』那一行。• 若是[ l ]则表示为连结档（link file）。• 若是[ b ]则表示为装置文件里面的可供储存的接口设备（可随机存取装置）。• 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标（一次性读取装置）。剩余的三个部分分别表示文件拥有者可具备的权限，加入此群组账号的权限和非本人且没有加入本群组之其他账号的权限。其中rwx分别表示：[ r ]代表可读（read）、[ w ]代表 可写（write）、[ x ]代表可执行（execute）。如果没有权限，就用减号[ - ]表示。2.连接数（i-node）：每个文件都会将他的权限与属性记录到文件系统的 i-node 中，不过我们使用的目录树却是使用文件名来记录，因此每个档名就会连结到一个 i-node。这个属性记录的就是有多少不同的档名连结到相同的一个 i-node 号码了。3.拥有者：表示这个文件(或目录)的『拥有者账号』。4.群组：在 Linux 系统下，你的账号会加入于一个或多个的群组中。例如p1，p2，p3均属于 people 这个群组，假设某个文件所属的群组为 people，且该文件的权限为（-rwxrwx---），则p1，p2，p3三人对于该文件都具有可读、可写、可执行的权限（看群组权限）。 但如果是不属于people群组的其他账号，对于此文件就不具有任何权限了。5.文件容量：代表文件的容量大小，默认单位为 bytes。6.修改日期：代表文件创建或最后修改的日期。7.文件名：如果为隐藏文件，则以.开头。更改文件属性和权限涉及的指令：chgrp：改变文件所属群组，chown：改变文件拥有者，chmod：改变文件的权限。1.chgrp（change group）：语法：1234chgrp [-R] dirname/filename ...选项与参数:-R : 进行递归（recursive）的持续变更，亦即连同次目录下的所有文件、 目录都更新成为这个群组之意。常常用在变更某一目录内所有的文件的情况。比如，改变文件examples.desktop的群组为root：123456789root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-r--r-- 1 mrbird mrbird 8.8K 3月 25 03:31 examples.desktop...root@mrbird-xps13:/home/mrbird# chgrp root examples.desktop root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-r--r-- 1 mrbird root 8.8K 3月 25 03:31 examples.desktop...2.chown（change owner）：chown不但可以改变文件拥有者，也可以改变群组！语法如下：1234chown [-R] 账号名称 文件或目录chown [-R] 账号名称:组名 文件或目录选项与参数:-R : 进行递归(recursive)的持续变更,亦即连同次目录下的所有文件都变更例：将examples.desktop的拥有者改为root：123456789root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-r--r-- 1 mrbird mrbird 8.8K 3月 25 03:31 examples.desktop...root@mrbird-xps13:/home/mrbird# chown root examples.desktop root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-r--r-- 1 root mrbird 8.8K 3月 25 03:31 examples.desktop...例：将examples.desktop的拥有者和群组都改为root：12345root@mrbird-xps13:/home/mrbird# chown root:root examples.desktop root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-r--r-- 1 root root 8.8K 3月 25 03:31 examples.desktop...3.chmod：改变权限有两种方式：数字类型和符号类型。• 数字类型改变文件权限：rwx分别代表421，例如当权限为: [-rwxrwx---] 分数 则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0数字类型改变权限语法：1234chmod [-R] xyz 文件或目录选项与参数:xyz : 就是刚刚提到的数字类型的权限属性,为 rwx 属性数值的相加。-R : 进行递归(recursive)的持续变更,亦即连同次目录下的所有文件都会变更例：将examples.desktop的权限都启用：123456789root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-r--r-- 1 root root 8.8K 3月 25 03:31 examples.desktop...root@mrbird-xps13:/home/mrbird# chmod 777 examples.desktop root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rwxrwxrwx 1 root root 8.8K 3月 25 03:31 examples.desktop...• 符号类型改变文件权限在符号类型改变权限的规则中，我们使用u，g，o来代表user，group和owner三种身份的权限。此外，a 则代表 all 亦即全部的身份。相应规则可看下表：chmodugoa+(加入)-(除去)=(设定)rwx文件或目录例如，将文件examples.desktop的权限改为-rw-r--r--：12345root@mrbird-xps13:/home/mrbird# chmod u=rw,go=r examples.desktop root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-r--r-- 1 root root 8.8K 3月 25 03:31 examples.desktop...例如，增加文件examples.desktop每个人均可写入的权限：12345root@mrbird-xps13:/home/mrbird# chmod a+w examples.desktop root@mrbird-xps13:/home/mrbird# ls -lh总用量 48K-rw-rw-rw- 1 root root 8.8K 3月 25 03:31 examples.desktop...权限的意义1.对于文件来说，rwx代表：• r (read)：可读取此一文件的实际内容,如读取文本文件的文字内容等。• w (write)：可以编辑、新增或者是修改该文件的内容（但不含删除该文件）。• x (eXecute)：该文件具有可以被系统执行的权限（类似与window中的exe，bat等）。2.对于目录来说，rwx代表：• r (read contents in directory)：表示具有读取目录结构列表的权限，所以当你具有读取（r）一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来。• w (modify contents of directory)：表示你具有异动该目录结构列表的权限，也就是可以对该目录或者其下的文件进行曾删改操作！• x (access directory)：目录的 x 代表的是用户能否进入该目录成为工作目录，所谓的工作目录（work directory）就是你目前所在的目录。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leanote博客主题Material Design]]></title>
    <url>%2FLeanote%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98Material-Design.html</url>
    <content type="text"><![CDATA[Material Design（卡片式材料设计）是谷歌在I/O 2014上发布的新的设计语言。在Material的扁平化设计中，它使用了分层元素来营造三维空间。该主题有Light和Dark两种显示模式，可通过toolBar右侧的按钮切换。博客可在主题文件theme.json中作简单的修改，theme.json文件内容如下：12345678910111213&#123; ... "WebImgName": "leanote.png", "Color": "blue", "ColorStrength": "300", "BlogImg": "material.jpg", "FriendLinks": [ &#123;"Title": "My Note", "Url": "https://leanote.com/note"&#125;, &#123;"Title": "Leanote Home", "Url": "https://leanote.com"&#125;, &#123;"Title": "Leanote BBS", "Url": "http://bbs.leanote.com"&#125;, &#123;"Title": "Leanote Github", "Url": "https://github.com/leanote/leanote"&#125; ]&#125;主题预览：theme.json文件中，WebImgName 为网页小图标图片名称+格式名， BlogImg为博客标题背景图+格式名，标题的背景图尺寸建议为350X130，Color为博客颜色（比如toolBar和按钮等组件的颜色），ColorStrength为颜色的浓度。下面为所有可取的值： 这里有一点需要注意，颜色名称必须为全小写，比如Blue应写为blue。如有问题，欢迎留言。2017年3月20日修复了几处在火狐浏览器下的bug。2017年3月23日修复Markdown下点击文章导航不跳转问题。最新主题包下载地址：github]]></content>
      <tags>
        <tag>Leanote</tag>
        <tag>theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SSM (Spring+SpringMVC+MyBatis)]]></title>
    <url>%2F%E6%90%AD%E5%BB%BASSM-Spring-SpringMVC-MyBatis.html</url>
    <content type="text"><![CDATA[Spring+SpringMVC的搭建参考博文 —— 搭建SpringMVC。这里主要记录SpringMVC与MyBatis的整合。准备工作数据库使用MySql，创建一张测试表：1234567 CREATE TABLE `emp` ( `ID` int(4) NOT NULL AUTO_INCREMENT, `NAME` varchar(50) COLLATE utf8_unicode_ci NOT NULL, `AGE` int(11) DEFAULT NULL, `BIRTHDAY` date DEFAULT NULL, PRIMARY KEY (`ID`))引入依赖：123456789101112131415161718192021222324252627282930313233343536&lt;!-- spring事务 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;!-- spring jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql数据库连接包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据库连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybaits-spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;Spring配置文件在applicationContext.xml文件中配置数据库：12345678910111213&lt;!-- 属性占位符 --&gt;&lt;context:property-placeholder location="classpath:/config.properties" /&gt;&lt;!--配置数据源--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxPoolSize" value="40" /&gt; &lt;property name="minPoolSize" value="1" /&gt; &lt;property name="initialPoolSize" value="10" /&gt; &lt;/bean&gt;配置SqlSessionFactory以及sqlSessionTemplate：12345678910&lt;!-- mybatis 的SqlSessionFactory --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean" scope="prototype"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 指定mybaits配置文件路径 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"/&gt;&lt;/bean&gt;&lt;!-- sqlSessionTemplate --&gt;&lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate" scope="prototype"&gt; &lt;constructor-arg index="0" ref="sqlSessionFactory"/&gt;&lt;/bean&gt;配置事务：1234567&lt;!-- 事物管理器配置 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!-- 开启注解事务 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt;配置扫描mapper：123456&lt;!-- 采用自动扫描的方式创建mapper bean --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="ssm"/&gt; &lt;property name="sqlSessionTemplateBeanName" value="sqlSessionTemplate"/&gt; &lt;property name="annotationClass" value="org.springframework.stereotype.Repository"/&gt;&lt;/bean&gt;MyBatis配置文件mybaits-config.xml：123456789101112131415161718192021 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;setting name="defaultExecutorType" value="REUSE"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="defaultStatementTimeout" value="25000"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!--给实体类起一个别名 --&gt; &lt;typeAlias type="ssm.mrbird.entity.Emp" alias="emp" /&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;!--RoleMapper.xml装载进来 同等于把'mapper'的实现装载进来 --&gt; &lt;mapper resource="ssm/mrbird/mapper/EmpMapper.xml" /&gt; &lt;/mappers&gt; &lt;/configuration&gt;创建实体创建库表对应实体Emp：12345678910import java.io.Serializable;import java.sql.Date; public class Emp implements Serializable&#123; private long id; private String name; private int age; private Date birthday; // get set 略&#125;接口与映射创建一个包含基本CRUD的接口EmpMapper：12345678910import org.springframework.stereotype.Repository;import ssm.mrbird.entity.Emp; @Repositorypublic interface EmpMapper &#123; public void insertEmp(Emp emp); public void updateEmp(Emp emp); public void deleteEmp(long id); public Emp getEmp(long id);&#125;其对应的映射文件EmpMapper.xml：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="ssm.mrbird.mapper.EmpMapper"&gt; &lt;insert id="insertEmp" parameterType="emp"&gt; insert into emp(name,age,birthday) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;birthday&#125;) &lt;/insert&gt; &lt;update id="updateEmp" parameterType="emp"&gt; update emp &lt;set&gt; &lt;if test="name != null"&gt;name = #&#123;name&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;age = #&#123;age&#125;,&lt;/if&gt; &lt;if test="birthday != null"&gt;birthday = #&#123;birthday&#125;&lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteEmp" parameterType="long"&gt; delete from emp where id = #&#123;id&#125; &lt;/delete&gt; &lt;select id="getEmp" parameterType="long" resultType="emp"&gt; select id,name,age,birthday from emp where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;配置服务层首先创建接口EmpService：12345678import ssm.mrbird.entity.Emp; public interface EmpService &#123; public void insertEmp(Emp emp); public void updateEmp(Emp emp); public void deleteEmp(long id); public Emp getEmp(long id); &#125;其实现类EmpServiceImpl：123456789101112131415161718192021222324252627282930313233343536import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional; import ssm.mrbird.entity.Emp;import ssm.mrbird.mapper.EmpMapper;@Service@Transactional(propagation=Propagation.SUPPORTS,readOnly=true)public class EmpServiceImpl implements EmpService&#123; @Autowired private EmpMapper empMapper; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false) public void insertEmp(Emp emp) &#123; this.empMapper.insertEmp(emp); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false) public void updateEmp(Emp emp) &#123; this.empMapper.updateEmp(emp); &#125; @Override @Transactional(propagation=Propagation.REQUIRED,readOnly=false) public void deleteEmp(long id) &#123; this.empMapper.deleteEmp(id); &#125; @Override public Emp getEmp(long id) &#123; return this.empMapper.getEmp(id); &#125;&#125;这里采用注解的方式配置事务。关于事务，可参考博文 —— Spring事务管理。测试最终，工程的目录结构为：测试创建Emp：1234567891011121314151617181920@Controllerpublic class TestController &#123; @Autowired private EmpService empService; @RequestMapping(value="/insert",method=RequestMethod.GET) @ResponseBody public String insertEmp()&#123; try &#123; Emp emp = new Emp(); emp.setName("mrbird"); emp.setAge(100); this.empService.insertEmp(emp); return "success"; &#125; catch (Exception e) &#123; e.printStackTrace(); return "fail"; &#125; &#125;&#125;启动项目，访问：http://localhost:8080/ssm/insert查询数据库：1234567mysql&gt; select * from emp;+----+--------+------+----------+| ID | NAME | AGE | BIRTHDAY |+----+--------+------+----------+| 1 | mrbird | 100 | NULL |+----+--------+------+----------+1 row in set (0.00 sec)插入成功。测试getEmp：12345678910@RequestMapping(value="/get",method=RequestMethod.GET)@ResponseBodypublic String getEmp()&#123; try &#123; return this.empService.getEmp(1l).getName(); &#125; catch (Exception e) &#123; e.printStackTrace(); return "fail"; &#125;&#125;访问：http://localhost:8080/ssm/get测试updateEmp：12345678910111213@RequestMapping(value="/update",method=RequestMethod.GET)@ResponseBodypublic String updateEmp()&#123; try &#123; Emp emp = this.empService.getEmp(1l); emp.setAge(250); this.empService.updateEmp(emp); return "success"; &#125; catch (Exception e) &#123; e.printStackTrace(); return "fail"; &#125;&#125;访问：http://localhost:8080/ssm/update查询数据库：1234567mysql&gt; select * from emp;+----+--------+------+----------+| ID | NAME | AGE | BIRTHDAY |+----+--------+------+----------+| 1 | mrbird | 250 | NULL |+----+--------+------+----------+1 row in set (0.00 sec)更新成功。测试deleteEmp：1234567891011@RequestMapping(value="/delete",method=RequestMethod.GET)@ResponseBodypublic String deleteEmp()&#123; try &#123; this.empService.deleteEmp(1l); return "success"; &#125; catch (Exception e) &#123; e.printStackTrace(); return "fail"; &#125;&#125;访问：http://localhost:8080/ssm/delete查询数据库：12mysql&gt; select * from emp;Empty set (0.00 sec)删除成功。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>MyBatis</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SSH (Spring+SpringMVC+Hibernate)]]></title>
    <url>%2F%E6%90%AD%E5%BB%BASSH-Spring-SpringMVC-Hibernate.html</url>
    <content type="text"><![CDATA[Spring+SpringMVC的搭建参考博文 —— 搭建SpringMVC。这里主要记录SpringMVC与Hibernate的整合。准备工作数据库使用MySql，创建一张测试表：1234567CREATE TABLE `emp` ( `ID` int(4) NOT NULL AUTO_INCREMENT, `NAME` varchar(50) COLLATE utf8_unicode_ci NOT NULL, `AGE` int(11) DEFAULT NULL, `BIRTHDAY` date DEFAULT NULL, PRIMARY KEY (`ID`))引入依赖：12345678910111213141516171819202122232425262728293031&lt;!-- spring事务 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;!-- spring orm --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- hibernate --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql数据库连接包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; &lt;!-- 数据库连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;配置数据库在applicationContext.xml中配置数据库：1234567891011121314151617181920&lt;!-- 属性占位符 --&gt;&lt;context:property-placeholder location="classpath:/config.properties" /&gt; &lt;!--配置数据源--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;!--数据库连接驱动--&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;" /&gt; &lt;!--数据库地址--&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;!--用户名--&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;!--密码--&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!--最大连接数--&gt; &lt;property name="maxPoolSize" value="40" /&gt; &lt;!--最小连接数--&gt; &lt;property name="minPoolSize" value="1" /&gt; &lt;!--初始化连接池内的数据库连接--&gt; &lt;property name="initialPoolSize" value="10" /&gt; &lt;/bean&gt;其中，config.properties配置文件内容如下：12345678910#database connection configjdbc.driver = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8jdbc.username = rootjdbc.password = 123456 #hibernate confighibernate.dialect = org.hibernate.dialect.MySQLDialecthibernate.show_sql = truehibernate.format_sql = true配置sessionFactory在applicationContext.xml中配置sessionFactory：12345678910111213141516&lt;!--配置session工厂--&gt;&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 指定实体类扫描路径 --&gt; &lt;property name="packagesToScan" value="ssh.mrbird.entity" /&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!--指定数据库方言--&gt; &lt;prop key="hibernate.dialect"&gt;$&#123;hibernate.dialect&#125;&lt;/prop&gt; &lt;!--在控制台显示执行的数据库操作语句--&gt; &lt;prop key="hibernate.show_sql"&gt;$&#123;hibernate.show_sql&#125;&lt;/prop&gt; &lt;!--在控制台显示执行的数据库操作语句（格式）--&gt; &lt;prop key="hibernate.format_sql"&gt;$&#123;hibernate.format_sql&#125;&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;使用spring的事务管理机制：123456&lt;!-- 事物管理器配置 --&gt;&lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt;&lt;!-- 开启注解事务 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt;创建库表实体123456789101112131415161718192021222324252627282930import java.io.Serializable;import java.sql.Date; import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table; @Entity@Table(name = "Emp")public class Emp implements Serializable&#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = "ID") private long id; @Column(name = "NAME") private String name; @Column(name = "AGE") private int age; @Column(name = "BIRTHDAY") private Date birthday; // get set 略&#125;数据库访问层创建EmpDao接口，包含基本的CRUD方法：12345678import ssh.mrbird.entity.Emp; public interface EmpDao &#123; Emp findEmpById(long id); void deleteEmpById(long id); void updateEmp(Emp emp); void saveEmp(Emp emp);&#125;其实现类EmpDaoImpl：123456789101112131415161718192021222324252627282930313233343536import org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional; import ssh.mrbird.entity.Emp; @Repository@Transactional(propagation=Propagation.SUPPORTS,readOnly=true)public class EmpDaoImpl implements EmpDao&#123; //注入SessionFactory @Autowired private SessionFactory sessionFactory; //获取session private Session getCurrentSession() &#123; return this.sessionFactory.getCurrentSession(); &#125; public Emp findEmpById(long id) &#123; return (Emp) getCurrentSession().get(Emp.class, id); &#125; @Transactional(propagation=Propagation.REQUIRED,readOnly=false) public void deleteEmpById(long id) &#123; Emp emp = findEmpById(id); getCurrentSession().delete(emp); &#125; @Transactional(propagation=Propagation.REQUIRED,readOnly=false) public void updateEmp(Emp emp) &#123; getCurrentSession().update(emp); &#125; @Transactional(propagation=Propagation.REQUIRED,readOnly=false) public void saveEmp(Emp emp) &#123; getCurrentSession().save(emp); &#125;&#125;使用注解的方式控制事务，关于事务，可参考博文 —— Spring事务管理。测试最终，工程的目录结构为：applicationContext.xml完整配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd"&gt; &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package="ssh"/&gt; &lt;!-- 启用Spring mvc --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置viewResolver --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/views/" p:suffix=".jsp"&gt; &lt;/bean&gt; &lt;!-- 属性占位符 --&gt; &lt;context:property-placeholder location="classpath:/config.properties" /&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxPoolSize" value="40" /&gt; &lt;property name="minPoolSize" value="1" /&gt; &lt;property name="initialPoolSize" value="10" /&gt; &lt;/bean&gt; &lt;!--配置session工厂--&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 指定实体类扫描路径 --&gt; &lt;property name="packagesToScan" value="ssh.mrbird.entity" /&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;$&#123;hibernate.dialect&#125;&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;$&#123;hibernate.show_sql&#125;&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;$&#123;hibernate.format_sql&#125;&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 事物管理器配置 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 开启注解事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt;&lt;/beans&gt;编写测试Controller：1234567891011121314151617181920212223242526272829303132333435363738394041@Controllerpublic class TestController &#123; @Autowired private EmpDaoImpl empDao; @RequestMapping(value="/saveEmp",method=RequestMethod.GET) @ResponseBody public String saveEmp()&#123; //直接模拟数据 try&#123; Emp emp = new Emp(); emp.setName("mrbird"); emp.setAge(100); empDao.saveEmp(emp); return "success"; &#125;catch(Exception e)&#123; e.printStackTrace(); return "fail"; &#125; &#125; @RequestMapping(value="/findEmp",method=RequestMethod.GET) @ResponseBody public String findEmp()&#123; Emp emp = empDao.findEmpById(1); return emp.getName(); &#125; @RequestMapping(value="/updateEmp",method=RequestMethod.GET) @ResponseBody public String updateEmp()&#123; Emp emp = empDao.findEmpById(1l); emp.setAge(250); empDao.updateEmp(emp); return "success"; &#125; @RequestMapping(value="/deleteEmp",method=RequestMethod.GET) @ResponseBody public String deleteEmp()&#123; empDao.deleteEmpById(1l); return "success"; &#125;&#125;启动工程，访问：http://localhost:8080/ssh/saveEmp查询数据库：1234567mysql&gt; select * from emp;+----+--------+------+----------+| ID | NAME | AGE | BIRTHDAY |+----+--------+------+----------+| 1 | mrbird | 100 | NULL |+----+--------+------+----------+1 row in set (0.00 sec)数据插入成功，剩下的测试略。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet状态管理]]></title>
    <url>%2FServlet%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[Servlet状态管理：将客户端(浏览器)与服务器之间多次交互（一次请求，一次响应）当做一个整体来看待，并且将多次交互所涉及的数据（即状态）保存下来。如何进行状态管理？1.客户端状态管理技术：即将状态保存在客户端，有代表性的是cookie技术。2.服务器端状态管理技术：即将状态保存在服务器端，有代表性的是session技术。cookie浏览器向web服务器发送请求时，服务器会将少量的数据以set-cookie消息头的方式发送给浏览器，浏览器会将这些数据保存下来。当浏览器再次访问服务器时，会将这些数据以cookie消息头的方式发送给服务器。创建cookie：12Cookie c = new Cookie(String name,String value);response.addCookie(c);查询cookie：1234567Cookie[] cookies = request.getCookies();if(cookies != null)&#123; for(Cookie c : cookies)&#123; String cookieName = c.getName(); String cookieValue = c.getValue(); &#125;&#125;编码问题：cookie只能保存合法的ascii字符，如果要保存中文，需要将中文转换成合法的ascii字符（编码）。1String str = URLEncoder.encode("北京","utf-8");encode方法先将”北京”按照”utf-8”进行编码（编码之后会得到一个字节数组），然后将字节数组转换成一个字符串。类似于%AD%EF%88%DD%AF%48%。12// 将字符串还原String decodeValue = URLDecoder.decode(str,"utf-8");生存时间：默认情况下，浏览器会将cookie保存在内存里面，只要浏览器不关闭，cookie会一直存在。也可以用代码指定其生存时间：1cookie.setMaxAge(int seconds);注意seconds单位是秒。seconds取值有三种情况：1.seconds &gt; 0：浏览器保存cookie的最长时间为设置的参数值，如果超过指定的时间，浏览器会删除这个cookie。浏览器会将cookie保存在硬盘上。2.seconds = 0：删除cookie。比如，要删除一个名称为”addr”的cookie：123Cookie c = new Cookie("addr","");c.setMaxAge(0);response.addCookie(c);3.sencods &lt; 0：缺省值,浏览器会将cookie放到内存里面。修改cookie：所谓Cookie的修改，本质是获取到要变更值的Cookie，通过setValue方法将新的数据存入到cookie中，然后由response响应对象发回到客户端，对原有旧值覆盖后即实现了修改。session服务器为不同的客户端在内存中创建了用于保存数据的Session对象，并将用于标识该对象的唯一Id发回给与该对象对应的客户端。当浏览器再次发送请求时，SessionId也会被发送过来，服务器凭借这个唯一Id找到与之对应的Session对象。在服务器端维护的这些用于保存与不同客户端交互时的数据的对象叫做Session。Session对象可以保存更复杂的对象类型数据了，不像Cookie只能保存字符串。获得session对象：1.方式一：1HttpSession session = request.getSession(boolean flag);flag为true时：先查看请求当中有没有sessionId，如果没有，服务器要创建一个session对象；如果有sessionId，服务器会依据sessionId查找对应的session对象，如果找到了则返回，找不到服务器会创建一个新的session对象。flag为false时：先查看请求当中有没有sessionId，如果没有，服务器不会创建session对象，返回null。如果有sessionId，服务器会依据sessionId查找对应的session对象，如果找到了则返回，找不到返回null。2.方式二：12HttpSession session = request.getSession();// 等价于 request.getSession(true)。使用session对象绑定数据：1void session.setAttribute(String name,Object obj);获取绑定数据或移除绑定数据的代码如下：12void session.getAttribute(String name);void session.removeAttribute(String name);session超时：什么是session超时？web服务器会将空闲时间过长的session对象删除掉（为了节省内存空间资源）。web服务器缺省的超时时间限制，一般是30分。可以修改缺省的超时时间限制，比如，可以修改tomcat的web.xml：123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;使用编程的方式来修改：1session.setMaxInactiveInterval(int seconds);立即删除session对象：1session.invalidate();session优缺点：session对象的数据由于保存在服务器端，并不在网络中进行传输，所以安全一些，并且能够保存的数据类型更丰富，同时Session也能够保存更多的数据，Cookie只能保存大约4kb的字符串。session的安全性是以牺牲服务器资源为代价的，如果用户量过大，会严重影响服务器的性能。]]></content>
      <tags>
        <tag>servlet&amp;jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 文档查询]]></title>
    <url>%2FMongoDB-%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[MongoDB查询涵盖以下几个方面：1.使用find或者findOne函数和查询文档对数据库执行查询；2.使用$条件查询实现范围查询，数据集包含查询，不等式查询，以及其它一些查询；3.查询将会返回一个数据库游标，游标只会在你需要时才将需要的文档批量返回；4.针对游标执行的元操作，包括忽略一定数量的结果，或者限定返回结果的数量，以及对结果排序。find简介指定需要返回的键比如，我只对blog集合的博文post感兴趣，可以使用以下查询语句：1234&gt; db.blog.find(&#123;&#125;,&#123;"post":1&#125;)&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "post" : "MongoDB文档CUD" &#125;&#123; "_id" : ObjectId("58acf64b3c8ad0b0d9d65f4a"), "post" : "MongoDB shell" &#125;&#123; "_id" : ObjectId("58acf65d3c8ad0b0d9d65f4d"), "post" : "start Spring Boot" &#125;如果不希望返回“_id”，可以这样：1234&gt; db.blog.find(&#123;&#125;,&#123;"post":1,"_id":0&#125;)&#123; "post" : "MongoDB文档CUD" &#125;&#123; "post" : "MongoDB shell" &#125;&#123; "post" : "start Spring Boot" &#125;查询条件比较操作符MongoDB中的比较操作符有五种，其中$gt，$gte，$lt，$lte分别对应&gt;，&gt;=，&lt;，&lt;=，比如查询blog阅读量pageview大于5的文档：123456789&gt; db.blog.find(&#123;"pageview":&#123;"$gte":5&#125;&#125;).pretty()&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "name" : "mrbird's blog", "post" : "MongoDB文档CUD", "pageview" : 5, "like" : 2, "date" : ISODate("2017-02-22T05:45:03.006Z")&#125;这四种操作符也可用于日期比较，比如：123456&gt; var date = new Date("01/01/2017")&gt; db.blog.find(&#123;"date":&#123;"$gte":date&#125;&#125;,... &#123;"post":1,"date":1,"_id":0&#125;)&#123; "post" : "MongoDB文档CUD", "date" : ISODate("2017-02-22T05:45:03.006Z") &#125;&#123; "post" : "MongoDB shell", "date" : ISODate("2017-02-22T05:45:03.006Z") &#125;&#123; "post" : "start Spring Boot", "date" : ISODate("2017-02-22T05:45:03.006Z") &#125;另外一个比较操作符为$ne，not equal，可以用于所有类型，比如：1234&gt; db.blog.find(&#123;"post":&#123;"$ne":"MongoDB shell"&#125;&#125;,... &#123;"post":1&#125;)&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "post" : "MongoDB文档CUD" &#125;&#123; "_id" : ObjectId("58acf65d3c8ad0b0d9d65f4d"), "post" : "start Spring Boot" &#125;OR查询$in操作符可以查询一个键的多个值，比如：1234&gt; db.blog.find(&#123;"post":&#123;"$in":["MongoDB文档CUD","MongoDB shell"]&#125;&#125;,... &#123;"post":1,"_id":0&#125;)&#123; "post" : "MongoDB文档CUD" &#125;&#123; "post" : "MongoDB shell" &#125;其中数组中的值可以是不同类型的。与$in相反的是$nin，如：123&gt; db.blog.find(&#123;"post":&#123;"$nin":["MongoDB文档CUD","MongoDB shell"]&#125;&#125;,... &#123;"post":1,"_id":0&#125;)&#123; "post" : "start Spring Boot" &#125;$or操作符和SQL中的含义类似，比如查询post为MongoDB文档CUD或者pageview为3的文档：12345&gt; db.blog.find(&#123;"$or":[&#123;"post":"MongoDB文档CUD"&#125;,&#123;"pageview":3&#125;]&#125;,...&#123;"post":1,"pageview":1,"_id":0&#125;).pretty()&#123; "post" : "MongoDB文档CUD", "pageview" : 5 &#125;&#123; "post" : "MongoDB shell", "pageview" : 3 &#125;&#123; "post" : "start Spring Boot", "pageview" : 3 &#125;$not$mod为取模运算符，比如查询pageview为3的倍数的博文：123&gt; db.blog.find(&#123;"pageview":&#123;"$mod":[3,0]&#125;&#125;,&#123;"post":1,"pageview":1,"_id":0&#125;)&#123; "post" : "MongoDB shell", "pageview" : 3 &#125;&#123; "post" : "start Spring Boot", "pageview" : 3 &#125;$not运算符用于取反，比如取pageview不为3的倍数的博文：123&gt; db.blog.find(&#123;"pageview":&#123;"$not":&#123;"$mod":[3,0]&#125;&#125;&#125;, ...&#123;"post":1,"pageview":1,"_id":0&#125;)&#123; "post" : "MongoDB文档CUD", "pageview" : 5 &#125;$and$and操作符和SQL中的含义类似，比如查找post为MongoDB文档CUD且pageview大于3的文档：123&gt; db.blog.find(&#123;"$and":[&#123;"post":"MongoDB文档CUD"&#125;,&#123;"pageview":&#123;"$gt":3&#125;&#125;]&#125;,... &#123;"post":1,"pageview":1,"_id":0&#125;)&#123; "post" : "MongoDB文档CUD", "pageview" : 5 &#125;特定类型的查询null。查询文档某个键的值为null，会将不包含该键的文档也查询出来，比如：1234567&gt; db.blog.find(&#123;&#125;,&#123;"post":1,"like":1,"_id":0&#125;)&#123; "post" : "MongoDB文档CUD", "like" : 2 &#125;&#123; "post" : "MongoDB shell" &#125;&#123; "post" : "start Spring Boot", "like" : null &#125;&gt; db.blog.find(&#123;"like":null&#125;,&#123;"post":1,"like":1,"_id":0&#125;)&#123; "post" : "MongoDB shell" &#125;&#123; "post" : "start Spring Boot", "like" : null &#125;可以通过$exists条件判断键是否存在，比如：123&gt; db.blog.find(&#123;"like":&#123;"$in":[null],"$exists":true&#125;&#125;, ...&#123;"post":1,"like":1,"_id":0&#125;)&#123; "post" : "start Spring Boot", "like" : null &#125;MongoDB查询也支持键值的正则表达式匹配，这里就懒得记录了。查询数组先看个栗子：1234567&gt; db.food.find()&#123; "_id" : ObjectId("58ad45986596dd54570ce1ed"), "fruit" : [ "西瓜", "香蕉", "桃子" ] &#125;&#123; "_id" : ObjectId("58ad45c76596dd54570ce1ee"), "fruit" : [ "西瓜", "芒果", "杨桃" ] &#125;&#123; "_id" : ObjectId("58ad45f76596dd54570ce1ef"), "fruit" : [ "哈密瓜", "葡萄", "樱桃" ] &#125;&gt; db.food.find(&#123;"fruit":"西瓜"&#125;)&#123; "_id" : ObjectId("58ad45986596dd54570ce1ed"), "fruit" : [ "西瓜", "香蕉", "桃子" ] &#125;&#123; "_id" : ObjectId("58ad45c76596dd54570ce1ee"), "fruit" : [ "西瓜", "芒果", "杨桃" ] &#125;查找既包含西瓜又包含芒果的文档，使用$all操作符：12&gt; db.food.find(&#123;"fruit":&#123;"$all":["西瓜","芒果"]&#125;&#125;)&#123; "_id" : ObjectId("58ad45c76596dd54570ce1ee"), "fruit" : [ "西瓜", "芒果", "杨桃" ] &#125;其中，数组中值的顺序不重要。如果不使用$all 就是精准匹配了，比如下面这个查询将查询不出任何结果：1&gt; db.food.find(&#123;"fruit":["西瓜","芒果"]&#125;)也可以根据数组的下标进行查询，比如：12&gt; db.food.find(&#123;"fruit.1":"葡萄"&#125;)&#123; "_id" : ObjectId("58ad45f76596dd54570ce1ef"), "fruit" : [ "哈密瓜", "葡萄", "樱桃" ] &#125;$size操作符用于根据数组的长度进行查询匹配，比如查找fruit数组长度为3的文档：1234&gt; db.food.find(&#123;"fruit":&#123;"$size":3&#125;&#125;)&#123; "_id" : ObjectId("58ad45986596dd54570ce1ed"), "fruit" : [ "西瓜", "香蕉", "桃子" ] &#125;&#123; "_id" : ObjectId("58ad45c76596dd54570ce1ee"), "fruit" : [ "西瓜", "芒果", "杨桃" ] &#125;&#123; "_id" : ObjectId("58ad45f76596dd54570ce1ef"), "fruit" : [ "哈密瓜", "葡萄", "樱桃" ] &#125;注意：$size操作符不能$gt等比较操作符一起使用！$slice操作符可以返回某个键匹配的数组元素的一个子集，比如：1234&gt; db.food.find(&#123;&#125;,&#123;"fruit":&#123;"$slice":2&#125;&#125;)&#123; "_id" : ObjectId("58ad45986596dd54570ce1ed"), "fruit" : [ "西瓜", "香蕉" ] &#125;&#123; "_id" : ObjectId("58ad45c76596dd54570ce1ee"), "fruit" : [ "西瓜", "芒果" ] &#125;&#123; "_id" : ObjectId("58ad45f76596dd54570ce1ef"), "fruit" : [ "哈密瓜", "葡萄" ] &#125;如果想返回数组的后两个元素，可以这样：1234&gt; db.food.find(&#123;&#125;,&#123;"fruit":&#123;"$slice":-2&#125;&#125;)&#123; "_id" : ObjectId("58ad45986596dd54570ce1ed"), "fruit" : [ "香蕉", "桃子" ] &#125;&#123; "_id" : ObjectId("58ad45c76596dd54570ce1ee"), "fruit" : [ "芒果", "杨桃" ] &#125;&#123; "_id" : ObjectId("58ad45f76596dd54570ce1ef"), "fruit" : [ "葡萄", "樱桃" ] &#125;$slice也可以指定偏移量，比如：1234&gt; db.food.find(&#123;&#125;,&#123;"fruit":&#123;"$slice":[1,3]&#125;&#125;)&#123; "_id" : ObjectId("58ad45986596dd54570ce1ed"), "fruit" : [ "香蕉", "桃子" ] &#125;&#123; "_id" : ObjectId("58ad45c76596dd54570ce1ee"), "fruit" : [ "芒果", "杨桃" ] &#125;&#123; "_id" : ObjectId("58ad45f76596dd54570ce1ef"), "fruit" : [ "葡萄", "樱桃" ] &#125;[1,1]表示跳过前1个元素，返回第2~3个元素，如果没有那么多元素，就返回第2个元素之后的所有元素。数组的范围查询数组的范围查询需要注意一个问题，如：12345678&gt; db.test.find()&#123; "_id" : ObjectId("58b0eca3a263b332501bc7b5"), "x" : 5 &#125;&#123; "_id" : ObjectId("58b0eca9a263b332501bc7b6"), "x" : 15 &#125;&#123; "_id" : ObjectId("58b0ecaea263b332501bc7b7"), "x" : 25 &#125;&#123; "_id" : ObjectId("58b0ecbda263b332501bc7b8"), "x" : [ 5, 25 ] &#125; &gt; db.test.find(&#123;"x":&#123;"$gt":10,"$lt":20&#125;&#125;)&#123; "_id" : ObjectId("58b0eca9a263b332501bc7b6"), "x" : 15 &#125;&#123; "_id" : ObjectId("58b0ecbda263b332501bc7b8"), "x" : [ 5, 25 ] &#125;查询结果不符合预期，因为数组中的5符合$lt:20，25符合$gt:10。要对数组元素进行范围查询，可借助$elemMatch操作符：12&gt; db.test.find(&#123;"x":&#123;"$elemMatch":&#123;"$gt":10,"$lt":20&#125;&#125;&#125;)&gt; //查询不到任何结果这个查询没有任何结果，因为{ &quot;_id&quot; : ObjectId(&quot;58b0eca9a263b332501bc7b6&quot;), &quot;x&quot; : 15 }文档x的值不是数组类型，并且$elemMatch操作符使得数组元素的每一个值都必须与条件相匹配。查询内嵌文档12345678910111213141516171819202122232425&gt; db.blog.find().pretty()&#123; "_id" : ObjectId("58b11d0ca263b332501bc7b9"), "title" : "MongoDB查询", "like" : "2", "comments" : &#123; "name" : "ltsc", "comment" : "good post" &#125;&#125;&#123; "_id" : ObjectId("58b11daca263b332501bc7ba"), "title" : "MongoDB shell", "like" : "3", "comments" : [ &#123; "name" : "ltsc", "comment" : "good post" &#125;, &#123; "name" : "xiaohema", "comment" : "不明觉厉" &#125; ]&#125;要查询包含名为”xiaohema”，并且评论为”不明觉厉的”博文，可以使用以下查询：12345678910111213141516&gt; db.blog.find(&#123;"comments":&#123;"$elemMatch":&#123;"name":"xiaohema","comment":"不明觉厉"&#125;&#125;&#125;).pretty()&#123; "_id" : ObjectId("58b11daca263b332501bc7ba"), "title" : "MongoDB shell", "like" : "3", "comments" : [ &#123; "name" : "ltsc", "comment" : "good post" &#125;, &#123; "name" : "xiaohema", "comment" : "不明觉厉" &#125; ]&#125;$where查询当一般查询都不能满足查询要求的时候，可以考虑使用$where操作符，比如有如下文档：123&gt; db.food.find(&#123;&#125;,&#123;"_id":0&#125;)&#123; "草莓蛋糕" : 4, "芝士蛋糕" : 5, "巧克力蛋糕" : 4 &#125;&#123; "摩卡咖啡" : 3, "拿铁咖啡" : 6, "热巧克力" : 1 &#125;现要查询含有相同数量食物的文档，可以使用$where操作符：12345678910&gt; db.food.find(&#123;"$where":function()&#123;... for(var current in this)&#123;... for(var next in this)&#123;... if(current != next &amp;&amp; this[current] == this[next])&#123;... return true;... &#125;... &#125;... &#125;... &#125;&#125;,&#123;"_id":0&#125;)&#123; "草莓蛋糕" : 4, "芝士蛋糕" : 5, "巧克力蛋糕" : 4 &#125;但是在实际情况下，出于对性能和安全的考虑，应该尽量不使用$where。游标MongoDB使用游标返回find查询结果，使用hasNext函数判断游标中是否还有其他结果，使用next函数来迭代结果，如：123456789101112131415&gt; function create()&#123;... db.test.drop();... for(var i = 0;i&lt;100;i++)&#123;... db.test.insert(&#123;"x":i&#125;);... &#125;&#125;&gt; create()&gt; var cursor = db.test.find()&gt; cursor.hasNext()true&gt; cursor.next()&#123; "_id" : ObjectId("58b12834a263b332501bc7bd"), "x" : 0 &#125;&gt; cursor.next()&#123; "_id" : ObjectId("58b12834a263b332501bc7be"), "x" : 1 &#125;&gt; cursor.next()&#123; "_id" : ObjectId("58b12834a263b332501bc7bf"), "x" : 2 &#125;游标还实现了JavaScript的迭代器接口，可以使用forEach循环来迭代输出结果：12345678910111213&gt; cursor.forEach(function(x)&#123;... print(x.x);... &#125;)34567...9899&gt; cursor.hasNext()falselimit，skip和sortlimit用于限制返回结果的数量，比如：1234&gt; db.test.find().limit(3)&#123; "_id" : ObjectId("58b12834a263b332501bc7bd"), "x" : 0 &#125;&#123; "_id" : ObjectId("58b12834a263b332501bc7be"), "x" : 1 &#125;&#123; "_id" : ObjectId("58b12834a263b332501bc7bf"), "x" : 2 &#125;要是匹配的数量还不到3个，则返回匹配的数量。skip则是用于跳过N个数量后，返回剩下的查询结果，比如：1234&gt; db.test.find().skip(97)&#123; "_id" : ObjectId("58b12834a263b332501bc81e"), "x" : 97 &#125;&#123; "_id" : ObjectId("58b12834a263b332501bc81f"), "x" : 98 &#125;&#123; "_id" : ObjectId("58b12834a263b332501bc820"), "x" : 99 &#125;sort则是用于对返回结果的排序，-1表示降序，1表示升序，如：12345&gt; db.test.find().limit(4).sort(&#123;"x":-1&#125;)&#123; "_id" : ObjectId("58b12834a263b332501bc820"), "x" : 99 &#125;&#123; "_id" : ObjectId("58b12834a263b332501bc81f"), "x" : 98 &#125;&#123; "_id" : ObjectId("58b12834a263b332501bc81e"), "x" : 97 &#125;&#123; "_id" : ObjectId("58b12834a263b332501bc81d"), "x" : 96 &#125;当使用skip略过较多数量文档时，速度会变得很慢，比如常用的分页需求：123&gt; var page1 = db.test.find().limit(100)&gt; var page2 = db.test.find().skip(100).limit(100)&gt; var page3 = db.test.find().skip(200).limit(100)正如前面所说的，这会导致速度很慢，可以使用下面这种思路取代，比如使用date降序来显示文档列表：1&gt; var page1 = db.test.find().sort(&#123;"date":-1&#125;).limit(100)然后可以使用最后一个文档的date作为查询条件，如：1234567var latest = nullwhile(page1.hasNext())&#123; latest = page1.next();&#125;//获取下一页var page2 = db.test.find(&#123;"date":&#123;"$gt":&#123;latest.date&#125;&#125;&#125;);page2.sort(&#123;"date":-1&#125;).limit(100);获取的一致性看个栗子：123456var cursor = db.test.find();while(cursor.hasNext())&#123; var current = curosr.next(); var modify = process(current); db.test.save(modify);&#125;其中process为某个修改文档函数。这样做当文档较大的时候，游标可能会多次返回同一个文档，而并不能预期的进行遍历。因为当保存文档的时候，如果文档较大，文档间的空隙又不足，这时候文档无法预期的保存回数据库，MongoDB会将其挪至集合的末尾，为了避免这种情况，我们可以对查询添加快照。使用查询快照后，查询会对”_id”进行遍历，这就保证了每个文档只会返回一次，修改上述查询：1var cursor = db.test.find().snapshot();《MongoDB权威指南》读书笔记]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB文档CUD]]></title>
    <url>%2FMongoDB%E6%96%87%E6%A1%A3CUD.html</url>
    <content type="text"><![CDATA[插入文档使用insert向集合中插入一个文档：1234&gt; db.test.insert(&#123;"name":"mrbird"&#125;)WriteResult(&#123; "nInserted" : 1 &#125;)&gt; db.test.findOne()&#123; "_id" : ObjectId("58a99b8168e0d7b9f6992c69"), "name" : "mrbird" &#125;插入的文档没有“_id”键的话，这个操作会自动为文档添加一个“_id”键。 批量插入文档则需使用insertMany函数，函数接收一个文档数组：123456789101112&gt; db.test.insertMany([&#123;"name":"Jane"&#125;,&#123;"name":"KangKang"&#125;])&#123; "acknowledged" : true, "insertedIds" : [ ObjectId("58a99d6468e0d7b9f6992c6b"), ObjectId("58a99d6468e0d7b9f6992c6c") ]&#125;&gt; db.test.find()&#123; "_id" : ObjectId("58a99b8168e0d7b9f6992c69"), "name" : "mrbird" &#125;&#123; "_id" : ObjectId("58a99d6468e0d7b9f6992c6b"), "name" : "Jane" &#125;&#123; "_id" : ObjectId("58a99d6468e0d7b9f6992c6c"), "name" : "KangKang" &#125;要查看一个文档的大小，可以使用Object.bsonsize(doc)函数（单位为字节）：12&gt; Object.bsonsize(db.test.find(&#123;"name":"mrbird"&#125;))1215删除文档删除文档使用remove函数，接收一个查询文档，所有匹配的文档都将会被删除：12345&gt; db.test.remove(&#123;"name":"mrbird"&#125;)WriteResult(&#123; "nRemoved" : 1 &#125;)&gt; db.test.find()&#123; "_id" : ObjectId("58a99d6468e0d7b9f6992c6b"), "name" : "Jane" &#125;&#123; "_id" : ObjectId("58a99d6468e0d7b9f6992c6c"), "name" : "KangKang" &#125;要清空整个集合的话，可以使用drop函数：123&gt; db.test.drop()true&gt; db.test.find()更新文档使用update函数更新文档，接收两个参数，查询文档和修改器文档，如：1234567891011121314151617&gt; db.test.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird.leanote.com"&#125;&gt; var mrbird = db.test.findOne(&#123;"name":"mrbird"&#125;)&gt; mrbird.blog = "mrbird's blog"mrbird's blog&gt; db.test.update(&#123;"name":"mrbird"&#125;,mrbird)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.test.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog"&#125;$inc修改器用来增加或减少已有的键值，如果该键不存在则创造一个。比如：123456789101112131415161718192021222324252627282930313233 &gt; db.test.findOne(&#123;"name":"mrbird"&#125;) &#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog"&#125;&gt; db.test.update(&#123;"name":"mrbird"&#125;,&#123;"$inc":&#123;"pageview":1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.test.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog", "pageview" : 1&#125;&gt; db.test.update(&#123;"name":"mrbird"&#125;,&#123;"$inc":&#123;"pageview":100&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.test.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog", "pageview" : 101&#125;&gt; db.test.update(&#123;"name":"mrbird"&#125;,&#123;"$inc":&#123;"pageview":-50&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.test.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog", "pageview" : 51&#125;$inc只能用于整型，长整型或双精度浮点型的值。$set用于修改文档的字段值，当这个字段不存在的时候就创建一个。如：123456789101112131415161718&gt; db.test.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog", "pageview" : 51&#125;&gt; db.test.update(&#123;"_id":ObjectId("58a9ace92363ff29a7d881e9")&#125;, ... &#123;"$set":&#123;"note":"love leanote!!"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.test.findOne(&#123;"_id":ObjectId("58a9ace92363ff29a7d881e9")&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog", "pageview" : 51, "note" : "love leanote!!"&#125;$set还可以修改键的类型，比如将note键的值改为数组类型：1234567891011121314&gt; db.test.update(&#123;"_id":ObjectId("58a9ace92363ff29a7d881e9")&#125;,... &#123;"$set":&#123;"note":["love leanote","the fun of code"]&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.test.findOne(&#123;"_id":ObjectId("58a9ace92363ff29a7d881e9")&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog", "pageview" : 51, "note" : [ "love leanote", "the fun of code" ]&#125;$set也可以修改内嵌文档，比如：12345678910111213141516171819202122&gt; db.blog.findOne()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb", "comment" : &#123; "name" : "xiaohema", "msg" : "学习了，感谢分享" &#125;&#125;&gt; db.blog.update(&#123;"name":"mrbird's blog"&#125;,... &#123;"$set":&#123;"comment.msg":"好，支持威武有希望了"&#125;&#125;)&gt; db.blog.findOne()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb", "comment" : &#123; "name" : "xiaohema", "msg" : "好，支持威武有希望了" &#125;&#125;使用$unset可删除键，比如：12345678910&gt; db.test.update(&#123;"_id":ObjectId("58a9ace92363ff29a7d881e9")&#125;,... &#123;"$unset":&#123;"note":1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.test.findOne(&#123;"_id":ObjectId("58a9ace92363ff29a7d881e9")&#125;)&#123; "_id" : ObjectId("58a9ace92363ff29a7d881e9"), "name" : "mrbird", "blog" : "mrbird's blog", "pageview" : 51&#125;数组修改器$push会向已有的数组末尾添加一个值，如果数组不存在，则创建该数组。比如：123456789101112131415161718192021&gt; db.blog.findOne()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb"&#125;&gt; db.blog.update(&#123;"name":"mrbird's blog"&#125;, &#123;"$push":...&#123;"comments": &#123;"name":"ltsc","msg":"不明觉厉"&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.blog.findOne()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb", "comments" : [ &#123; "name" : "ltsc", "msg" : "不明觉厉" &#125; ]&#125;如果要一次性向数组中添加多个值，可以使用$push结合$each修改器。比如：123456789101112131415161718192021222324&gt; db.blog.update(&#123;"name":"mrbird's blog"&#125;,... &#123;"$push":&#123;"comments":&#123;"$each":[... &#123;"name":"Althars","msg":"siguoyi"&#125;,... &#123;"name":"jint","msg":"厉害了我的哥"&#125;]&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.blog.findOne()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb", "comments" : [ &#123; "name" : "ltsc", "msg" : "不明觉厉" &#125;, &#123; "name" : "Althars", "msg" : "siguoyi" &#125;, &#123; "name" : "jint", "msg" : "厉害了我的哥" &#125; ]$slice可以在为数组添加值的时候截取数组，但必须配合$push和$each一起使用，否则报语法错误，比如：123456789101112131415161718192021222324252627&gt; db.user.findOne()&#123; "_id" : ObjectId("58aa5e8a6a294f5543ff66eb"), "name" : "KangKang", "sex" : "male", "habbit" : [ "basketball", "football", "swimming", "running" ]&#125;&gt; db.user.update(&#123;"name":"KangKang"&#125;,... &#123;"$push":&#123;"habbit":&#123;"$each":... ["eating"],"$slice":-3&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.findOne()&#123; "_id" : ObjectId("58aa5e8a6a294f5543ff66eb"), "name" : "KangKang", "sex" : "male", "habbit" : [ "swimming", "running", "eating" ]&#125;从结果可以看出，$slice截取了数组最新的三个值。注意，$slice的值必须是负整数。现在有这么一种情况，$push修改器可以向一个数组中添加重复的值，如：12345678910111213141516171819&gt; db.user.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58aa7cb06a294f5543ff66ec"), "name" : "mrbird", "email" : [ "mrbird@qq.com" ]&#125;&gt; db.user.update(&#123;"name":"mrbird"&#125;, &#123;"$push":&#123;"email":"mrbird@qq.com"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58aa7cb06a294f5543ff66ec"), "name" : "mrbird", "email" : [ "mrbird@qq.com", "mrbird@qq.com" ]&#125;如果希望数组中添加的值不重复的话，可以使用$addToSet修改器：12345678910111213141516&gt; db.user.update(&#123;"name":"mrbird"&#125;, &#123;"$unset":&#123;"email":1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58aa7cb06a294f5543ff66ec"), "name" : "mrbird" &#125;&gt; db.user.update(&#123;"name":"mrbird"&#125;, ... &#123;"$addToSet":&#123;"email":&#123;"$each":["mrbird@qq.com","mrbird@qq.com","mrbird@gmail.com"]&#125;&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58aa7cb06a294f5543ff66ec"), "name" : "mrbird", "email" : [ "mrbird@qq.com", "mrbird@gmail.com" ]&#125;删除数组元素有几种方法，比如$pop，{“$pop”:{&quot;key&quot;:1}}表示从数组尾部删除元素，-1则表示从头部删除：1234567891011121314151617181920&gt; db.user.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58aa7cb06a294f5543ff66ec"), "name" : "mrbird", "email" : [ "mrbird@qq.com", "mrbird@gmail.com" ]&#125;&gt; db.user.update(&#123;"name":"mrbird"&#125;,... &#123;"$pop":&#123;"email":1&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.findOne(&#123;"name":"mrbird"&#125;)&#123; "_id" : ObjectId("58aa7cb06a294f5543ff66ec"), "name" : "mrbird", "email" : [ "mrbird@qq.com" ]&#125;另外一个删除数组元素的修改器为$pull，该操作符会将所有匹配的元素从数组中删除。比如：12345678910111213141516171819202122232425262728&gt; db.user.update(&#123;"name":"KangKang"&#125;,... &#123;"$push":&#123;"habbit":"eating"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.findOne(&#123;"name":"KangKang"&#125;)&#123; "_id" : ObjectId("58aa5e8a6a294f5543ff66eb"), "name" : "KangKang", "sex" : "male", "habbit" : [ "swimming", "running", "eating", "eating" ]&#125;&gt; db.user.update(&#123;"name":"KangKang"&#125;,... &#123;"$pull":&#123;"habbit":"eating"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.findOne(&#123;"name":"KangKang"&#125;)&#123; "_id" : ObjectId("58aa5e8a6a294f5543ff66eb"), "name" : "KangKang", "sex" : "male", "habbit" : [ "swimming", "running" ]&#125;还可以通过数组的下标修改数组内容，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; db.blog.find(&#123;"name":"mrbird's blog"&#125;).pretty()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb", "comments" : [ &#123; "name" : "ltsc", "msg" : "不明觉厉" &#125;, &#123; "name" : "Althars", "msg" : "siguoyi" &#125;, &#123; "name" : "jint", "msg" : "厉害了我的哥" &#125; ]&#125;&gt; db.blog.update(&#123;"name":"mrbird's blog"&#125;,... &#123;"$set":&#123;"comments.1.msg":"四国以"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.blog.find(&#123;"name":"mrbird's blog"&#125;).pretty()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb", "comments" : [ &#123; "name" : "ltsc", "msg" : "不明觉厉" &#125;, &#123; "name" : "Althars", "msg" : "四国以" &#125;, &#123; "name" : "jint", "msg" : "厉害了我的哥" &#125; ]&#125;这种做法有局限性，就是必须先知道待修改字段的数组下标，可以使用另外一种方法，下面这种方法只需要知道待修改字段就行了：1234567891011121314151617181920212223&gt; db.blog.update(&#123;"comments.msg":"四国以"&#125;,... &#123;"$set":&#123;"comments.$.msg":"看完此文，犹如醍醐灌顶"&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.blog.find(&#123;"name":"mrbird's blog"&#125;).pretty()&#123; "_id" : ObjectId("58aa47f645b899838bfb6114"), "name" : "mrbird's blog", "post" : "mongodb", "comments" : [ &#123; "name" : "ltsc", "msg" : "不明觉厉" &#125;, &#123; "name" : "Althars", "msg" : "看完此文，犹如醍醐灌顶" &#125;, &#123; "name" : "jint", "msg" : "厉害了我的哥" &#125; ]&#125;update函数的第三个参数为upsert，设置为true时，新一个文档，没有找到匹配的查询文档时，插入该文档，找到了就更新，比如：1234567891011121314151617&gt; db.blog.findOne(&#123;"name":"mrbrid","post":"MongoDB文档CUD"&#125;)null&gt; db.blog.update(&#123;"name":"mrbrid","post":"MongoDB文档CUD"&#125;,... &#123;"$inc":&#123;"pageview":1&#125;&#125;,true)WriteResult(&#123; "nMatched" : 0, "nUpserted" : 1, "nModified" : 0, "_id" : ObjectId("58acf0743c8ad0b0d9d65f45")&#125;)&gt; db.blog.findOne(&#123;"name":"mrbrid","post":"MongoDB文档CUD"&#125;)&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "name" : "mrbrid", "post" : "MongoDB文档CUD", "pageview" : 1&#125;update函数的第四个参数为multi，设置为true的时候，批量更新和查询文档匹配的文档，比如将mrbird’s blog集合中所有文档的pageview增加1：1234567891011121314151617181920212223242526272829303132333435363738394041&gt; db.blog.find().pretty()&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "name" : "mrbird's blog", "post" : "MongoDB文档CUD", "pageview" : 1&#125;&#123; "_id" : ObjectId("58acf64b3c8ad0b0d9d65f4a"), "name" : "mrbird's blog", "post" : "MongoDB shell", "pageview" : 1&#125;&#123; "_id" : ObjectId("58acf65d3c8ad0b0d9d65f4d"), "name" : "mrbird's blog", "post" : "start Spring Boot", "pageview" : 1&#125;&gt; db.blog.update(&#123;"name":"mrbird's blog"&#125;,&#123;"$inc":&#123;"pageview":1&#125;&#125;,... false,true)WriteResult(&#123; "nMatched" : 3, "nUpserted" : 0, "nModified" : 3 &#125;)&gt; db.blog.find().pretty()&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "name" : "mrbird's blog", "post" : "MongoDB文档CUD", "pageview" : 2&#125;&#123; "_id" : ObjectId("58acf64b3c8ad0b0d9d65f4a"), "name" : "mrbird's blog", "post" : "MongoDB shell", "pageview" : 2&#125;&#123; "_id" : ObjectId("58acf65d3c8ad0b0d9d65f4d"), "name" : "mrbird's blog", "post" : "start Spring Boot", "pageview" : 2&#125;另外，调用getLastError可查看最近一次更新的文档数量，如：12345678910&gt; db.runCommand(&#123;getLastError:1&#125;)&#123; "connectionId" : 1, "updatedExisting" : true, "n" : 3, "syncMillis" : 0, "writtenTo" : null, "err" : null, "ok" : 1&#125;拥有类似事务特性的更新与查询操作findAndModify。它是原子性的，会返回符合查询条件的更新后的文档。一次最多只更新一个文档，也就是条件query条件，且执行sort后的第一个文档。语法如下：123456789db.COLLECTION_NAME.findAndModify(&#123; query:&#123;&#125;, update:&#123;&#125;, remove:true|false, new:true|false, sort:&#123;&#125;, fields:&#123;&#125;, upsert:true|false&#125;); ​query是查询选择器，与findOne的查询选择器相同。update是要更新的值，不能与remove同时出现。remove表示删除符合query条件的文档，不能与update同时出现。new为true：返回更新后的文档，false：返回更新前的，默认是false。sort：排序条件，与sort函数的参数一致。fields:投影操作，与find的第二个参数一致。upsert:与update的upsert参数一样。例子：12345678910111213141516171819202122232425262728293031&gt; db.blog.findAndModify(&#123;... "query":&#123;"name":"mrbird's blog"&#125;,... "update":&#123;... "$inc":&#123;"pageview":1&#125;,... "$set":&#123;"like":1&#125;&#125;&#125;)&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "name" : "mrbird's blog", "post" : "MongoDB文档CUD", "pageview" : 3&#125;&gt; db.blog.find().pretty()&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "name" : "mrbird's blog", "post" : "MongoDB文档CUD", "pageview" : 4, "like" : 1&#125;&#123; "_id" : ObjectId("58acf64b3c8ad0b0d9d65f4a"), "name" : "mrbird's blog", "post" : "MongoDB shell", "pageview" : 3&#125;&#123; "_id" : ObjectId("58acf65d3c8ad0b0d9d65f4d"), "name" : "mrbird's blog", "post" : "start Spring Boot", "pageview" : 3&#125;可发现，执行findAndModify后，返回被更新前（默认显示更新前的）的文档，并且只更新了匹配的第一条文档。如果要返回被更新后的文档，我们设置new 为true：1234567891011&gt; db.blog.findAndModify(&#123; ..."query":&#123;"name":"mrbird's blog"&#125;, ..."update":&#123; "$inc":&#123;"pageview":1&#125;, "$set":&#123;"like":2&#125;&#125;,..."new":true&#125;)&#123; "_id" : ObjectId("58acf0743c8ad0b0d9d65f45"), "name" : "mrbird's blog", "post" : "MongoDB文档CUD", "pageview" : 5, "like" : 2&#125;《MongoDB权威指南》读书笔记]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leanote博客主题Conciseness]]></title>
    <url>%2FLeanote%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98Conciseness.html</url>
    <content type="text"><![CDATA[主题Conciseness已上架Leanote博客主题市场。该主题修改自roomcar的pure主题。主题预览图如下所示：该主题可自行修改，这里做几点介绍。修改图片编辑主题，找到theme.json文件以下字段：12345..."BlogImgName": "blogImg.jpg","WebImgName": "webImg.png","ErrorImgName": "robot.png", ...BlogImgName为博客About Me图片，WebImgName为网页小图标，ErrorImgName为404页面图片。假如现在您想将About Me的图片换为自己上传的名为handsomeBoy.png的照片，只需将theme.json文件的BlogImgName字段值换位“handsomeBoy.png”即可。修改About Me连接编辑主题，找到theme.json文件以下字段：123"QQ": "123456","Weico": "http://weibo.com/","Facebook": "https://www.facebook.com/",可将属性值换为自己的连接即可。修改音乐音乐插件来自：32空间。修改音乐只需修改theme.json文件中的MusicUrl 属性即可。该属性的值为一个数组，格式如下所示：1&#123;"title": "musicTitle","artist":"artist","mp3": "musicUrl","cover": "musicCover"&#125;,title为歌曲名，artist为歌手名，mp3为音乐连接，cover为专辑封面。关于这几个值的获取方法，下面做详细介绍：1.比如在网易云音乐中搜索莫文蔚的《当你老了》，可得到音乐链接为：http://music.163.com/#/song?id=30621954&amp;userid=3425798。其中song的id为30621954。2.复制该id，打开链接：http://music.163.com/api/song/detail/?id=yourId&amp;ids=%5ByourId%5D&amp;csrf_token=。3.将链接中的yourId更改为第一条复制的音乐id，然后回车，可看到页面解析出一个json格式内容：123456789101112131415161718192021222324252627282930313233343536373839&#123;"songs": [ &#123; "name": "当你老了", "id": 30621954,... "artists": [ &#123; "name": "莫文蔚", "id": 8926, "picId": 0, "img1v1Id": 0, "briefDesc": "", "picUrl": "http://p3.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg", "img1v1Url": "http://p4.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg", "albumSize": 0, "alias": [], "trans": "", "musicSize": 0 &#125; ], "album": &#123; "name": "当你老了", "id": 3104146, "type": "EP/Single", "size": 1, "picId": 7860408627221136, "blurPicUrl": "http://p3.music.126.net/2nJOdPf1RlGY_tQdB5ZdPA==/7860408627221136.jpg", "companyId": 0, "pic": 7860408627221136, "picUrl": "http://p4.music.126.net/2nJOdPf1RlGY_tQdB5ZdPA==/7860408627221136.jpg", "publishTime": 1424188800007,... "mp3Url": "http://m2.music.126.net/tQ0pNmpsiHIsxEl-CnMmJg==/7897792022607979.mp3" &#125; ],"equalizers": &#123;&#125;,"code": 200&#125;一大段json数据，和我们有关的就几个，其中title这里我们填写为“当你老了”，artist为“莫文蔚”，mp3为json数据中的mp3Url字段，这里为：http://m2.music.126.net/tQ0pNmpsiHIsxEl-CnMmJg==/7897792022607979.mp3。cover为json文件中的album的picUrl字段值，这里为：http://p4.music.126.net/2nJOdPf1RlGY_tQdB5ZdPA==/7860408627221136.jpg。所以最终的这首歌的代码为：123456 &#123; "title": "当你老了", "artist":"莫文蔚", "mp3": "http://m2.music.126.net/tQ0pNmpsiHIsxEl-CnMmJg==/7897792022607979.mp3", "cover": "http://p4.music.126.net/2nJOdPf1RlGY_tQdB5ZdPA==/7860408627221136.jpg"&#125;,将这段代码加到theme.json文件中的musicUrl属性中即可。输入特效在搜索以及评论框内加如了插件activate-power-mode.js特效，如果不需要可以找到0-c.html第55行：12345&lt;script&gt; POWERMODE.colorful = true; POWERMODE.shake = false; document.body.addEventListener('input', POWERMODE);&lt;/script&gt;将这几行代码删掉即可。弹出层页面弹出层使用的是sweetAlert.js插件。当删除评论以及未登录状况下点击博文的评论和点赞按钮即可触发，如：相应API可查看sweetAlert插件官网。在主题share_comment.js文件中可找到相关代码。如果有疑问，欢迎留言。2017年3月27日修复一些bug，样式调整。最新安装包：github]]></content>
      <tags>
        <tag>Leanote</tag>
        <tag>theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB shell]]></title>
    <url>%2FMongoDB-shell.html</url>
    <content type="text"><![CDATA[启动MongoDB安装好MongoDB，将其bin目录配置到系统环境变量path后，在磁盘上创建一个数据库保存目录，比如D:\MongoDB，然后打开命令窗口输入如下命令启动MongoDB服务：1&gt; mongod --dbpath=d:\mongodb当看到输出如下信息，表明启动成功，端口号为27017：12...[thread1] waiting for connections on port 27017打开另外一个命令窗口作为客户端，输入mongo即可连上服务：1234&gt; mongoMongoDB shell version v3.4.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.2语法糖MongoDB shell自带了一些语法糖：123456show dbs 列出所有DBuse dbname 切换当前DBshow tables 或 show collections 列出当前DB的所有表/集合show users 列出当前DB的所有用户show profile 列出当前DB的所有慢查询show logs 列出运行日志使用shell执行脚本假如在C:\Program Files\MongoDB\Server\3.4\bin目录下创建一个test.js脚本文件：1print("hello MnogoDB")有两种方式让MongoDB执行该脚本：连上服务前123456789&gt; exitbye C:\Users\Dell&gt;cd ../../program files/mongodb/server/3.4/binC:\Program Files\MongoDB\Server\3.4\bin&gt;mongo test.jsMongoDB shell version v3.4.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.2hello MnogoDB可看到，shell页面执行了test.js脚本并如期输出hello MongoDB（路径必须和脚本所在路径一致）。连上服务后连上服务后，可使用load()函数执行脚本：123&gt; load("test.js")hello MnogoDBtrue另外一个就是可以在shell中初始化一些辅助函数，比如定义一个hello.js：12345var hello = function()&#123; var world = ["handsome","charming"]; var index = Math.floor(Math.random()*2); print("hello mrbird,you are so "+world[index]);&#125;在shell中加载这个脚本，hello函数就可以使用了：12345678&gt; typeof helloundefined&gt; load("hello.js")true&gt; typeof hellofunction&gt; hello()hello mrbird,you are so charming.mongorc.js对于一些常用的脚本，如果每次启动服务后都用load()手动加载，这将很繁琐。对于这些常用的脚本，我们可以将其放在.mongorc.js文件中，因为MongoDB启动的时候，会自动加载该脚本。比如在.mongorc.js加入一句问候语：1print("Hello mrbird,welcome to use mongoDB")连接服务时，shell窗口输出：12345&gt; mongoMongoDB shell version v3.4.2connecting to: mongodb://127.0.0.1:27017MongoDB server version: 3.4.2Hello mrbird,welcome to use mongoDB也可以加如一些实用功能，比如添加防止自己误删的js脚本：123456789var no = function()&#123; print("Please don't");&#125;;// 禁止删除数据库db.dropDatabases = DB.prototype.dropDatabases = no;// 禁止删除集合DBCollection.prototype.drop = no;// 禁止删除索引DBCollection.prototype.dropIndex = no;测试一下：123456&gt; show collectionsblog&gt; db.blog.drop();Please don't&gt; show collectionsblog配合编辑器在shell中编辑文档是一件麻烦的事情，我们可以在.mongorc.js文件中加入自己的脚本编辑器：1EDITOR = "\"D:\\Program Files (x86)\\Notepad++\\notepad++.exe\""这里指定编辑器为notepad++，然后在shell中即可实用edit命令来编辑一个变量：123456789&gt; db.blog.findOne()&#123; "_id" : ObjectId("58a86088eb4ef940034d2733"), "title" : "mongodb shell", "content" : "mongodb超级有趣", "date" : ISODate("2017-02-18T14:55:39.679Z")&#125;&gt; var msg = db.blog.findOne()&gt; edit msg界面弹出：在编辑器中修改content内容后，保存并退出编辑器，变量就会被重新解析然后加载回shell：123456789&gt; db.blog.update(&#123;title: "mongodb shell"&#125;,msg)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.blog.findOne()&#123; "_id" : ObjectId("58a86088eb4ef940034d2733"), "title" : "mongodb shell", "content" : "mongodb is interesting", "date" : ISODate("2017-02-18T14:55:39.679Z")&#125;可看到，文档已修改。《MongoDB权威指南》读书笔记]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 开发环境配置]]></title>
    <url>%2FIntelliJ-IDEA-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[IntelliJ IDEA 主要用于支持 Java、Scala、Groovy 等语言的开发工具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和 Web 应用的开发。最近使用后觉得比eclipse强太多。初次使用要配置各种开发环境，所以记之。配置Git1.在官网https://git-scm.com/下载Git for windows并安装。2.打开IntelliJ IDEA的设置界面，选择Version Control → Git：将Path to Git executable设置为Git安装路径。配置GitHub1.打开IntelliJ IDEA的设置界面，选择Version Control → GitHub。2.填写账号密码，并测试是否登陆成功：配置Maven1.首先配置Maven本地资源库存放路径(拷贝Maven自带settings.xml，打开修改存放路径)：1&lt;localRepository&gt;D:\MyMaven\repository&lt;/localRepository&gt;2.打开IntelliJ IDEA的设置界面，选择Build,Execution,Deployment → Build Tools → Maven：选择相应settings.xml文件即可。]]></content>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security保护方法]]></title>
    <url>%2FSpring-Security%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[Spring Security提供了三种不同的安全注解：1.Spring Security自带的@Secured注解；2.JSR-250的@RolesAllowed注解；3.表达式驱动的注解，包括@PreAuthorize、@PostAuthorize、@PreFilter和 @PostFilter。@Secured在Spring-Security.xml中启用@Secured注解：1&lt;global-method-security secured-annotations="enabled"/&gt;例如只有拥有权限“ROLE_ADMIN”的用户才能访问下面这个方法：1234@Secured("ROLE_ADMIN")public void test()&#123; ...&#125;权限不足时，方法抛出Access Denied异常。@Secured注解会使用一个String数组作为参数。每个String值是一个权限，调用这个方法至少需要具备其中的一个权限。如：1234@Secured(&#123;"ROLE_ADMIN","ROLE_USER"&#125;)public void test()&#123; ...&#125;@RolesAllowed@RolesAllowed注解和@Secured注解在各个方面基本上都是一致的。启用@RolesAllowed注解：1&lt;global-method-security jsr250-annotations="enabled"/&gt;栗子：1234@RolesAllowed("ROLE_ADMIN")public void test()&#123; ...&#125;SpEL注解启用该注解：1&lt;global-method-security pre-post-annotations="enabled"/&gt;@PreAuthorize该注解用于方法前验证权限，比如限制非VIP用户提交blog的note字段字数不得超过1000字：1234@PreAuthorize("hasRole('ROLE_ADMIN') and #form.note.length() &lt;= 1000 or hasRole('ROLE_VIP')")public void writeBlog(Form form)&#123; ...&#125;表达式中的#form部分直接引用了方法中的同名参数。这使得Spring Security能够检查传入方法的参数，并将这些参数用于认证决策的制定。@PostAuthorize方法后调用权限验证，比如校验方法返回值：12345@PreAuthorize("hasRole(ROLE_USER)")@PostAuthorize("returnObject.user.userName == principal.username")public User getUserById(long id)&#123; ... &#125;Spring Security在SpEL中提供了名为returnObject 的变量。在这里方法返回一个User对象，所以这个表达式可以直接访问user对象中的userName属性。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security JSP标签库]]></title>
    <url>%2FSpring-Security-JSP%E6%A0%87%E7%AD%BE%E5%BA%93.html</url>
    <content type="text"><![CDATA[Spring Security提供了一套JSP标签库用于保护JSP视图。该库比较小，只提供了三个标签。要使用这个库，先在JSP页首加入：1&lt;%@ taglib uri="http://www.springframework.org/security/tags" prefix="sec" %&gt;该库包含的三个标签如下：&lt;security:accesscontrollist&gt;：如果用户通过访问控制列表授予了指定的权限，那么渲染该标签体中的内容。&lt;security:authentication&gt;：渲染当前用户认证对象的详细信息。&lt;security:authorize&gt;：如果用户被授予了特定的权限或者SpEL表达式的计算结果为true，那么渲染该标签体中的内容。认证用户信息使用&lt;security:authentication&gt; JSP标签可以访问用户的认证详情：principal：用户的基本信息对象。使用admin登陆，查看其用户认证详情：1&lt;sec:authentication property="principal"/&gt;页面显示内容如下：12345678org.springframework.security.core.userdetails.User@586034f: Username: admin; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_ADMIN,ROLE_USER还可以将其赋值给变量，并指定作用域：1&lt;sec:authentication property="principal" var="principal" scope="request"/&gt;details：认证的附加信息（IP地址、证件序列号、会话ID等）。查看admin用户的details属性：1&lt;sec:authentication property="details"/&gt;页面显示内容如下：123org.springframework.security.web.authentication.WebAuthenticationDetails@21a2c: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: D45BA834E227E0DA5596FF8C56FB9CA1authorities：一组用于表示用户所授予权限的GrantedAuthority对象。查看admin用户的authorities属性：1&lt;sec:authentication property="authorities"/&gt;页面显示内容如下：1[ROLE_ADMIN, ROLE_USER]credentials：用于核实用户的凭证（通常，这会是用户的密码）。根据权限展示JSP页面的内容也可以根据用户的权限进行有条件的展示，比如只让admin看到admin I love u信息：123&lt;sec:authorize access="hasRole('ROLE_ADMIN')"&gt; admin i love u&lt;/sec:authorize&gt;测试过程中发现程序报错：No WebApplicationContext found: no ContextLoaderListener registered?。修改web.xml加入ContextLoaderListener配置：123456789101112131415161718192021&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;...结果抛出新异常：Could not open ServletContext resource [/WEB-INF/spring-servlet.xml]。在WEB-INF下创建一个spring-servlet.xml文件即可：1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!-- some tags --&gt;&lt;/beans&gt;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于数据库用户认证]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81.html</url>
    <content type="text"><![CDATA[实际开发中用户的信息一般存放在数据库表里，所以我们使用元素替代现使用Mysql数据库演示，表结构如下：123456789101112131415161718192021CREATE TABLE `role` ( `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '角色编号', `name` varchar(60) NOT NULL COMMENT '角色', `note` varchar(100) DEFAULT NULL COMMENT '描述', PRIMARY KEY (`id`));CREATE TABLE `user` ( `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '用户编号', `username` varchar(60) NOT NULL COMMENT '用户名', `password` varchar(60) NOT NULL COMMENT '密码', `status` int(20) NOT NULL COMMENT '状态', `note` varchar(100) DEFAULT NULL COMMENT '描述', PRIMARY KEY (`id`));CREATE TABLE `user_role` ( `role_id` int(20) NOT NULL COMMENT '角色编号', `user_id` int(20) NOT NULL COMMENT '用户编号', PRIMARY KEY (`role_id`,`user_id`), CONSTRAINT `user_role_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`), CONSTRAINT `user_role_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `role` (`id`));插入测试数据：1234567INSERT INTO `role` VALUES ('1', 'ROLE_ADMIN', '管理员角色');INSERT INTO `role` VALUES ('2', 'ROLE_USER', '用户角色');INSERT INTO `user` VALUES ('1', 'admin', 'admin', '1', '管理员');INSERT INTO `user` VALUES ('2', 'user', 'user', '1', '普通用户');INSERT INTO `user_role` VALUES ('1', '1');INSERT INTO `user_role` VALUES ('1', '2');INSERT INTO `user_role` VALUES ('2', '2');加入spring-jdbc以及mysql-connector依赖：12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;修改spring-security配置：123456789101112131415161718&lt;bean id="datasource" class="org.springframework.jdbc.datasource.DriverManagerDataSource" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/security?useUnicode=true&amp;characterEncoding=UTF-8" p:username="root" p:password="123456"/&gt;&lt;jdbc-user-service id="user_service" data-source-ref="datasource" users-by-username-query="select username,password,status as enabled from user where username=?" authorities-by-username-query="select u.username,r.name as authority from user u join user_role ur on u.id=ur.user_id join role r on r.id=ur.role_id where u.username=?"/&gt;users-by-username-query为根据用户名查找用户，系统通过传入的用户名查询当前用户的登录名，密码和是否被禁用这一状态。authorities-by-username-query为根据用户名查找权限，系统通过传入的用户名查询当前用户已被授予的所有权限。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Spring Security登录页]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89Spring-Security%E7%99%BB%E5%BD%95%E9%A1%B5.html</url>
    <content type="text"><![CDATA[虽然Spring Security框架给我们赠送了个登录页面，但这个页面过于简单，Spring Security允许我们自定义登录页。准备工作第一步在maven中加入Spring Security相关依赖（Spring MVC已搭建好）。123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;3.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;3.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;3.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;为了在项目中使用 Spring Security 控制权限，首先要在web.xml 中配置过滤器，这样我们就可以控制对这个项目的每个请求了。12345678&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;applicationContext.xml的配置如下：12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd"&gt; &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package="spring"/&gt; &lt;!-- 启用Spring mvc --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置viewResolver --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/views/" p:suffix=".jsp" p:viewClass="org.springframework.web.servlet.view.JstlView"&gt; &lt;/bean&gt; &lt;mvc:resources location="/css/" mapping="/css/**"/&gt; &lt;!-- 引入spring-security.xml --&gt; &lt;import resource="spring-security.xml"/&gt;&lt;/beans&gt;在applicationContext.xml中，使用&lt;import/&gt;标签引入了spring-security.xml配置。spring-security.xml先简单配置如下：123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;b:beans xmlns:b="http://www.springframework.org/schema/beans" xmlns="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd"&gt; &lt;!-- 设置免验证路径 --&gt; &lt;http pattern="/**/*.css" security="none"/&gt; &lt;http pattern="/**/*.jpg" security="none"/&gt; &lt;http pattern="/**/*.jpeg" security="none"/&gt; &lt;http pattern="/checkCode" security="none"/&gt; &lt;http auto-config="true"&gt; &lt;intercept-url pattern="/login" access="IS_AUTHENTICATED_ANONYMOUSLY" /&gt; &lt;intercept-url pattern="/admin" access="ROLE_ADMIN"/&gt; &lt;intercept-url pattern="/**" access="ROLE_USER"/&gt; &lt;form-login login-page="/login"/&gt; &lt;custom-filter ref="loginfilter" before="FORM_LOGIN_FILTER" /&gt; &lt;/http&gt; &lt;b:bean id="loginfilter" class="spring.security.web.MrbirdUsernamePasswordAuthenticationFilter"&gt; &lt;b:property name="filterProcessesUrl" value="/j_spring_security_check"/&gt; &lt;!-- 登入页面form mothed 必须是post --&gt; &lt;b:property name="postOnly" value="true"/&gt; &lt;b:property name="authenticationManager" ref="authenticationManager" /&gt; &lt;b:property name="continueChainBeforeSuccessfulAuthentication" value="false"/&gt; &lt;/b:bean&gt; &lt;user-service id="user_service"&gt; &lt;user name="admin" password="123456" authorities="ROLE_USER,ROLE_ADMIN"/&gt; &lt;user name="user" password="123456" authorities="ROLE_USER"/&gt; &lt;/user-service&gt; &lt;authentication-manager alias="authenticationManager"&gt; &lt;authentication-provider user-service-ref="user_service"/&gt; &lt;/authentication-manager&gt;&lt;/b:beans&gt;上述配置中主要干了几件事：1.声明在xml 中使用Spring Security 提供的命名空间xmlns=”http://www.springframework.org/schema/security&quot;。2.设置一些免验证资源或者路径。3.利用intercept-url来判断用户需要具有何种权限才能访问对应的url资源，可以在pattern中指定一个特定的url资源，access指明需要的权限。比如url “/admin” 必须拥有ROLE_ADMIN的用户才能访问。在实际使用中，Spring Security采用的是一种就近原则，就是说当用户访 问的url 资源满足多个intercepter-url 时，系统将使用第一个符合条件的 intercept-url 进行权限控制。4.access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;指定匿名用户也可以访问。5.&lt;form-login/&gt;标签的login-page=”/login”属性表示登录页面的请求，由控制器去处理。6.&lt;custom-filter/&gt;标签引用了一个名为loginfilter的过滤器，用于登录的时候进行验证。7.接下来定义了id为loginfilter的bean，其filterProcessesUrl设定了登录页表单提交时的请求；authenticationManager属性指向authenticationManager。该bean对应的类下文再做介绍。8.user-service中定义了两个用户，admin 和user，password属性定义其密码，authorities属性为其分配权限。9.&lt;authentication-manager/&gt;标签注册了一个认证管理器，并通过 &lt;authentication-provider/&gt;标签的user-service-ref属性将之前定义的用户装配起来。除此之外，还可以使用SpEL表达式进行url的拦截。启用SpEL启用SpEL：123&lt;http auto-config="true" use-expressions="true"&gt; ...&lt;/http&gt;Spring Security支持的所有SpEL表达式如下：安全表达式计算结果authentication用户的认证对象denyAll结果始终为falsehasAnyRole(list of&nbsp;roles)如果用户被授予了列表中任意的指定角色，结果为truehasRole(role)如果用户被授予了指定的角色，结果为truehasIpAddress(IP Address)如果请求来自指定IP的话，结果为trueisAnonymous()如果当前用户为匿名用户，结果为trueisAuthenticated()如果当前用户进行了认证的话，结果为trueisFullyAuthenticated()如果当前用户进行了完整认证的话（不是通过Remember-me功能进行的认 证），结果为trueisRememberMe()如果当前用户是通过Remember-me自动认证的，结果为truepermitAll结果始终为trueprincipal用户的principal对象使用SpEL改写的access属性：123456&lt;http auto-config="true" access-denied-page="/deny" use-expressions="true"&gt; &lt;intercept-url pattern="/login" access="permitAll" /&gt; &lt;intercept-url pattern="/admin" access="hasRole('ROLE_ADMIN')"/&gt; &lt;intercept-url pattern="/**" access="hasRole('ROLE_USER')"/&gt; ...&lt;/http&gt;接下来自己编写个登录页。自定义登录页login.jsp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/&gt; &lt;title&gt;login page&lt;/title&gt; &lt;link href="&lt;c:url value='/css/bootstrap.min.css'/&gt;" rel="stylesheet" type="text/css"&gt; &lt;link href="&lt;c:url value='/css/bootstrap-theme.min.css'/&gt;" rel="stylesheet" type="text/css"&gt; &lt;link href="&lt;c:url value='/css/templatemo_style.css'/&gt;" rel="stylesheet" type="text/css"&gt; &lt;/head&gt;&lt;body class="templatemo-bg-gray"&gt;&lt;div class="container"&gt; &lt;div class="col-md-12"&gt; &lt;h1 class="margin-bottom-15"&gt;Login Page&lt;/h1&gt; &lt;form action="&lt;s:url value='/j_spring_security_check'/&gt;" class="form-horizontal templatemo-container templatemo-login-form-1 margin-bottom-30" role="form" method="post"&gt; &lt;div class="form-group"&gt; &lt;div class="col-xs-12"&gt; &lt;div class="control-wrapper"&gt; &lt;span class="form-text"&gt;username&lt;/span&gt; &lt;input type="text" class="form-control" name="j_username"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-12"&gt; &lt;div class="control-wrapper"&gt; &lt;span class="form-text"&gt;password&lt;/span&gt; &lt;input type="password" class="form-control" name="j_password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-12"&gt; &lt;div class="control-wrapper"&gt; &lt;span class="form-text"&gt;validateCode&lt;/span&gt; &lt;input type="password" class="form-control" name="validateCode"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-12"&gt; &lt;div class="control-wrapper"&gt; &lt;input type="submit" value="Log in" class="btn btn-info"&gt; &lt;input type="reset" value="Reset" class="btn btn-info"&gt; &lt;img id="checkCodeImg" title="验证码不区分大小写" src="checkCode" onclick="changeValidateCode()" style="cursor: pointer;"&gt; &lt;a href="javascript:;" onclick="changeValidateCode()"&gt;看不清？&lt;/a&gt; &lt;span class="form-error"&gt; $&#123;sessionScope['SPRING_SECURITY_LAST_EXCEPTION'].message&#125; &lt;/span&gt; &lt;span class="form-error"&gt; $&#123;SPRING_SECURITY_403_EXCEPTION.message&#125; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; function changeValidateCode()&#123; document.getElementById("checkCodeImg").src = "checkCode"+ "?nocache=" + new Date().getTime(); &#125; &lt;/script&gt;&lt;/html&gt;与Spring Security相关的就几个：1./j_spring_security_check，提交登录信息的URL地址。2.j_username，输入登录名的参数名称。3.j_password，输入密码的参数名称。4.${sessionScope[&#39;SPRING_SECURITY_LAST_EXCEPTION&#39;].message}和${SPRING_SECURITY_403_EXCEPTION.message}用于输出登录失败的异常信息。login.jsp页面尾部添加了验证码验证。验证码对应的controller如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@Controllerpublic class CodeController &#123; @RequestMapping(value="/checkCode") public void createCheckCode(HttpServletRequest request, HttpServletResponse response) throws IOException&#123; //设置不缓存图片 response.setHeader("Pragma", "No-cache"); response.setHeader("Cache-Control", "No-cache"); response.setDateHeader("Expires", 0); //指定生成的响应类型及格式-图片jpg response.setContentType("image/jpeg"); //指定生成验证码的宽度和高度 int width=66,height=30; //创建BufferedImage对象,其作用相当于一图片 BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //创建Graphics对象,其作用相当于画笔 Graphics g=image.getGraphics(); //创建Grapchics2D对象 Graphics2D g2d=(Graphics2D)g; Random random=new Random(); //定义字体样式 Font mfont=new Font("楷体",Font.BOLD,20); g.setColor(getRandColor(200,250)); //绘制背景 g.fillRect(0, 0, width, height); //设置字体 g.setFont(mfont); g.setColor(getRandColor(180,200)); //绘制20条颜色和位置全部为随机产生的线条,该线条为2f for(int i=0;i&lt;20;i++)&#123; int x=random.nextInt(width-1); int y=random.nextInt(height-1); int x1=random.nextInt(6)+1; int y1=random.nextInt(12)+1; //定制线条样式 BasicStroke bs=new BasicStroke(2f,BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL); Line2D line=new Line2D.Double(x,y,x+x1,y+y1); g2d.setStroke(bs); //绘制直线 g2d.draw(line); &#125; String sRand=""; String ctmp=""; String[] rBase=&#123;"1","2","3","4","5","6","7","8","9", "a","b","c","d","e","f","g", "h","i","j","k", "m","n", "o","p","q", "r","s","t", "u","v","w", "x","y","z", "A","B","C","D","E","F","G", "H", "J","K","L","M","N", "O","P","Q", "R","S","T", "U","V","W", "X","Y","Z"&#125;; //制定输出的验证码为四位 for(int i=0;i&lt;4;i++)&#123; int index = random.nextInt(rBase.length-1); ctmp = rBase[index]; sRand+=ctmp; Color color=new Color(20+random.nextInt(110),20+random.nextInt(110), random.nextInt(110)); g.setColor(color); /*将文字旋转制定角度*/ Graphics2D g2d_word=(Graphics2D)g; AffineTransform trans=new AffineTransform(); //trans.rotate((45)*3.14/180,15*i+8,7); /*缩放文字*/ float scaleSize=random.nextFloat()+0.8f; if(scaleSize&gt;1f) scaleSize=1f; trans.scale(scaleSize, scaleSize); g2d_word.setTransform(trans); g.drawString(ctmp, 12*i+12, 22); &#125; HttpSession session=request.getSession(true); session.setAttribute("validateCode", sRand); //释放g所占用的系统资源 g.dispose(); //输出图片 ImageIO.write(image,"JPEG",response.getOutputStream()); &#125; /*该方法主要作用是获得随机生成的颜色*/ public Color getRandColor(int s,int e)&#123; Random random=new Random (); if(s&gt;255) s=255; if(e&gt;255) e=255; int r,g,b; r=s+random.nextInt(e-s); g=s+random.nextInt(e-s); b=s+random.nextInt(e-s); return new Color(r,g,b); &#125; &#125;接下来编写index.jsp，成功登录后跳转到该页面：12345678910111213141516171819&lt;%@ taglib uri="http://www.springframework.org/security/tags" prefix="sec" %&gt;&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/&gt; &lt;title&gt;index page&lt;/title&gt; &lt;link href="&lt;c:url value='/css/templatemo_style.css'/&gt;" rel="stylesheet" type="text/css"&gt; &lt;/head&gt;&lt;body class="templatemo-bg-gray"&gt; &lt;div class="index-div"&gt; &lt;span class="index-text"&gt;hello:&lt;sec:authentication property="name"/&gt;&lt;/span&gt;&lt;br/&gt; &lt;hr&gt; &lt;a href="&lt;s:url value='/admin'/&gt;"&gt;admin.jsp&lt;/a&gt; &lt;a href="j_spring_security_logout"&gt;logout&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;编写admin.jsp用于测试权限控制：1234567891011121314&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/&gt; &lt;title&gt;admin page&lt;/title&gt; &lt;link href="&lt;c:url value='/css/templatemo_style.css'/&gt;" rel="stylesheet" type="text/css"&gt; &lt;/head&gt;&lt;body class="templatemo-bg-gray"&gt; &lt;div class="index-div"&gt; &lt;span class="index-text"&gt;welcome admin!&lt;/span&gt;&lt;br/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;页面跳转controller：123456789101112131415161718import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping; @Controllerpublic class LoginController &#123; @RequestMapping(value="/login") public String login()&#123; return "login"; &#125; @RequestMapping(value="/admin") public String admin()&#123; return "admin"; &#125; @RequestMapping(value="/index") public String index()&#123; return "index"; &#125;&#125;处理登录在spring-security.xml文件中定义的loginfilter过滤器对应的类如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession; import org.springframework.security.authentication.AuthenticationServiceException;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication .UsernamePasswordAuthenticationFilter;import org.springframework.util.StringUtils; public class MrbirdUsernamePasswordAuthenticationFilter extends UsernamePasswordAuthenticationFilter&#123; private boolean postOnly = true; public static final String VALIDATE_CODE = "validateCode"; public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (postOnly &amp;&amp; !request.getMethod().equals("POST")) &#123; throw new AuthenticationServiceException( "Authentication method not supported: " + request.getMethod()); &#125; //获取输入的用户名和密码 String username = obtainUsername(request); String password = obtainPassword(request); //校验 if (username == null || StringUtils.isEmpty(username.trim())) &#123; //校验不通过时抛出相应的异常 throw new AuthenticationServiceException( messages.getMessage("Auth.usernameIsNull")); &#125; if (password == null || StringUtils.isEmpty(password.trim())) &#123; throw new AuthenticationServiceException( messages.getMessage("Auth.passwordIsNull")); &#125; //校验验证码 checkValidateCode(request); username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); setDetails(request, authRequest); //不做用户的验证工作，因为在org.springframework.security.web.access //.intercept.FilterSecurityInterceptor中会做验证。不需要重复验证。 return this.getAuthenticationManager().authenticate(authRequest); &#125; protected void checkValidateCode(HttpServletRequest request) &#123; HttpSession session = request.getSession(); String sessionValidateCode = obtainSessionValidateCode(session); //让上一次的验证码失效 session.setAttribute(VALIDATE_CODE, null); String validateCodeParameter = obtainValidateCodeParameter(request); if (StringUtils.isEmpty(validateCodeParameter) || !sessionValidateCode.equalsIgnoreCase(validateCodeParameter)) &#123; throw new AuthenticationServiceException("验证码错误！"); &#125; &#125; private String obtainValidateCodeParameter(HttpServletRequest request) &#123; Object obj = request.getParameter(VALIDATE_CODE); return null == obj ? "" : obj.toString().toLowerCase(); &#125; protected String obtainSessionValidateCode(HttpSession session) &#123; Object obj = session.getAttribute(VALIDATE_CODE); return null == obj ? "" : obj.toString().toLowerCase(); &#125; &#125;MrbirdUsernamePasswordAuthenticationFilter继承自UsernamePasswordAuthenticationFilter，主要工作是获取用户在登录界面输入的用户名和密码，并判断是否为空，以及判断验证码的正确性。UsernamePasswordAuthenticationToken 中有2个参数Object principal（主要的身份认证信息），Object credentials（用于证明principal是正确的信息，比如密码）在一个带有username和password的权限认证请求中，principal就会被赋值username，credentials就会被赋值password。我们还可以在Spring Security.xml中的loginfilter bean配置登录成功与失败的过滤器：1234567891011121314151617181920&lt;b:bean id="loginfilter" class="spring.security.web.MrbirdUsernamePasswordAuthenticationFilter"&gt; ... &lt;!-- 验证成功后的处理--&gt; &lt;b:property name="authenticationSuccessHandler" ref="authenticationSuccessHandler"/&gt; &lt;!-- 验证失败后的处理--&gt; &lt;b:property name="authenticationFailureHandler" ref="authenticationFailureHandler"/&gt; ...&lt;/b:bean&gt;&lt;!-- 登入信息验证失败后，退回到登入页面 --&gt;&lt;b:bean id="authenticationFailureHandler" class="org.springframework.security.web.authentication .SimpleUrlAuthenticationFailureHandler"&gt; &lt;b:property name="defaultFailureUrl" value="/login?error=true"/&gt; &lt;/b:bean&gt; &lt;!-- 登入信息验证成功后，登入系统主页 --&gt;&lt;b:bean id="authenticationSuccessHandler" class="spring.security.web.MrbirdLoginSuccessHandler"&gt; &lt;b:property name="defaultTargetUrl" value="/index"/&gt;&lt;/b:bean&gt;其中，MrbirdLoginSuccessHandler用于处理登录成功后的操作，比如生成日志等：1234567891011121314151617181920212223import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.User;import org.springframework.security.web.authentication .SavedRequestAwareAuthenticationSuccessHandler; public class MrbirdLoginSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler &#123; public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,Authentication authentication) throws ServletException, IOException&#123; System.out.println("登录成功！"); //获取登录人信息 User user = (User) authentication.getPrincipal(); System.out.println(user.getUsername()+user.getAuthorities()); //跳转到主页面 super.onAuthenticationSuccess(request, response, authentication); &#125;&#125;处理登出同样，我们可以添加登出过滤器，在Spring Security.xml中的中配置登出过滤器：12345678910&lt;http auto-config="true"&gt; ... &lt;logout invalidate-session="true" logout-url="/j_spring_security_logout" success-handler-ref="logoutSuccessHandler"/&gt; &lt;/http&gt; &lt;!-- 登出成功，处理类 --&gt;&lt;b:bean id="logoutSuccessHandler" class="spring.security.web.MrbirdLogoutSuccessHandler"&gt; &lt;b:property name="defaultTargetUrl" value="/login"/&gt;&lt;/b:bean&gt;logoutSuccessHandler对应的类MrbirdLogoutSuccessHandler：12345678910111213141516171819202122232425import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.User;import org.springframework.security.web.authentication .AbstractAuthenticationTargetUrlRequestHandler;import org.springframework.security.web.authentication.logout .LogoutSuccessHandler; public class MrbirdLogoutSuccessHandler extends AbstractAuthenticationTargetUrlRequestHandler implements LogoutSuccessHandler&#123; public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println("登出成功！"); User user = (User) authentication.getPrincipal(); System.out.println(user.getUsername()+user.getAuthorities()); //跳转到登录页 super.handle(request, response, authentication); &#125;&#125;异常信息本地化Spring Security自带的异常信息显示是纯英文的，但Spring Security支持异常信息本地化，这些信息包括认证失败、访问被拒绝等。在Spring Security.xml中配置：12345678910&lt;b:bean id="loginfilter" class="spring.security.web.MrbirdUsernamePasswordAuthenticationFilter"&gt; ... &lt;b:property name="messageSource" ref="messageSource"/&gt; &lt;/b:bean&gt;&lt;!-- 定义登录页面异常信息的本地化 --&gt; &lt;b:bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;b:property name="basename" value="classpath:messages_zh_CN"/&gt; &lt;/b:bean&gt;其中，messages_zh_CN.properties配置如下：123AbstractUserDetailsAuthenticationProvider.badCredentials=\u8D26\u53F7\u6216\u5BC6\u7801\u9519\u8BEFAuth.usernameIsNull=\u8D26\u53F7\u4E0D\u80FD\u4E3A\u7A7AAuth.passwordIsNull=\u5BC6\u7801\u4E0D\u80FD\u4E3A\u7A7AAbstractUserDetailsAuthenticationProvider.badCredentials定义了账户或密码不匹配时候的异常信息，Auth.usernameIsNull和Auth.passwordIsNull则是MrbirdUsernamePasswordAuthenticationFilter中抛出的异常。自定义限制页面当页面因为用户权限不足而受限的时候，显示的是403 Access is Denied页面，我们可以自定义这个受限页面。修改配置spring security.xml文件的元素，添加自定义访问拒绝页面的地址：123&lt;http auto-config="true" access-denied-page="/deny" &gt; ...&lt;/http&gt;在LoginController中添加：12345...@RequestMapping(value="/deny")public String deny()&#123; return "deny";&#125;deny.jsp123456789101112131415&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/&gt; &lt;title&gt;deny page&lt;/title&gt; &lt;link href="&lt;c:url value='/css/templatemo_style.css'/&gt;" rel="stylesheet" type="text/css"&gt; &lt;/head&gt;&lt;body class="templatemo-bg-gray"&gt; &lt;div class="index-div"&gt; &lt;span class="index-text-deny" style='color:#C7425C;font-size:28px;'&gt; sorry,Insufficient authority +_+ &lt;/span&gt;&lt;br/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;测试最终，工程的目录结构为：spring security.xml最终配置如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;b:beans xmlns:b="http://www.springframework.org/schema/beans" xmlns="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd"&gt; &lt;!-- 设置免验证路径 --&gt; &lt;http pattern="/**/*.css" security="none"/&gt; &lt;http pattern="/**/*.jpg" security="none"/&gt; &lt;http pattern="/**/*.jpeg" security="none"/&gt; &lt;http pattern="/checkCode" security="none"/&gt; &lt;http auto-config="true" access-denied-page="/deny" use-expressions="true"&gt; &lt;intercept-url pattern="/login" access="permitAll" /&gt; &lt;intercept-url pattern="/admin" access="hasRole('ROLE_ADMIN')"/&gt; &lt;intercept-url pattern="/**" access="hasRole('ROLE_USER')"/&gt; &lt;form-login login-page="/login"/&gt; &lt;custom-filter ref="loginfilter" before="FORM_LOGIN_FILTER" /&gt; &lt;logout invalidate-session="true" logout-url="/j_spring_security_logout" success-handler-ref="logoutSuccessHandler"/&gt; &lt;/http&gt; &lt;b:bean id="loginfilter" class="spring.security.web.MrbirdUsernamePasswordAuthenticationFilter"&gt; &lt;b:property name="filterProcessesUrl" value="/j_spring_security_check"/&gt; &lt;!-- 登入页面form mothed 必须是post --&gt; &lt;b:property name="postOnly" value="true"/&gt; &lt;!-- 权限管理器 --&gt; &lt;b:property name="authenticationManager" ref="authenticationManager" /&gt; &lt;b:property name="continueChainBeforeSuccessfulAuthentication" value="false"/&gt; &lt;!-- 验证成功后的处理--&gt; &lt;b:property name="authenticationSuccessHandler" ref="authenticationSuccessHandler"/&gt; &lt;!-- 验证失败后的处理--&gt; &lt;b:property name="authenticationFailureHandler" ref="authenticationFailureHandler"/&gt; &lt;b:property name="messageSource" ref="messageSource"/&gt; &lt;/b:bean&gt; &lt;!-- 定义登录页面异常信息的本地化 --&gt; &lt;b:bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;b:property name="basename" value="classpath:messages_zh_CN"/&gt; &lt;/b:bean&gt; &lt;!-- 登入信息验证失败后，退回到登入页面 --&gt; &lt;b:bean id="authenticationFailureHandler" class="org.springframework.security.web.authentication .SimpleUrlAuthenticationFailureHandler"&gt; &lt;b:property name="defaultFailureUrl" value="/login?error=true"/&gt; &lt;/b:bean&gt; &lt;!-- 登入信息验证成功后，登入系统主页 --&gt; &lt;b:bean id="authenticationSuccessHandler" class="spring.security.web.MrbirdLoginSuccessHandler"&gt; &lt;b:property name="defaultTargetUrl" value="/index"/&gt; &lt;/b:bean&gt; &lt;!-- 登出成功，处理类 --&gt; &lt;b:bean id="logoutSuccessHandler" class="spring.security.web.MrbirdLogoutSuccessHandler"&gt; &lt;b:property name="defaultTargetUrl" value="/login"/&gt; &lt;/b:bean&gt; &lt;user-service id="user_service"&gt; &lt;user name="admin" password="123456" authorities="ROLE_USER,ROLE_ADMIN"/&gt; &lt;user name="user" password="123456" authorities="ROLE_USER"/&gt; &lt;/user-service&gt; &lt;authentication-manager alias="authenticationManager"&gt; &lt;authentication-provider user-service-ref="user_service"/&gt; &lt;/authentication-manager&gt;&lt;/b:beans&gt;启动工程，访问：http://localhost:8080/spring-security/login当登录失败时，页面如下：admin成功登录后：控制台输出：12登录成功！admin[ROLE_ADMIN, ROLE_USER]点击admin.jsp：点击logout回到登录页面，使用user登录：点击admin.jsp：访问受限。source code]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carrying data across redirect requests]]></title>
    <url>%2FCarrying-data-across-redirect-requests.html</url>
    <content type="text"><![CDATA[重定向请求传递数据主要有URL和flash两种方式：URL123456@RequestMapping(value="/redirect",method=RequestMethod.GET)public String redirect(Model model)&#123; model.addAttribute("name", "KangKang"); model.addAttribute("id", 1l); return "redirect:/index/redirect/&#123;name&#125;";&#125;重定向 URL路径将会是“/index/redirect/KangKang?id=1l”。重定向方法：1234@RequestMapping(value="/redirect/&#123;name&#125;")public String getValue(@PathVariable String name,Long id)&#123; // do something&#125;通过断点，可看到name的值为KangKang，id为1l。flashURL只能传递String等简单类型值，而flash则可传递Java对象等复杂的值。Spring提供了通过RedirectAttributes设置flash属性的方法，这是Spring 3.1引入的Model 的一个子接口。RedirectAttributes提供了Model的所有功能。12345678@RequestMapping(value="/redirect",method=RequestMethod.GET)public String redirect(RedirectAttributes model)&#123; User user = new User(); user.setId(2l); user.setName("Jane"); model.addFlashAttribute(user); return "redirect:/index/redirect/flash";&#125;重定向方法：1234@RequestMapping(value="/redirect/flash")public String getValue(Model model)&#123; return "testRedirect";&#125;testRedirect.jsp页面可以直接用EL访问User对象。如果要在方法中获取User对象的属性，可以使用@ModelAttribute(“user”)标签。]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring multipart上传下载]]></title>
    <url>%2FSpring-multipart%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD.html</url>
    <content type="text"><![CDATA[加入依赖Apache Commons FileUpload：12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;maven tomcat设置URI编码为UTF-8：123456789&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt;&lt;/plugin&gt;multipart解析器12345678&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="utf-8"/&gt; &lt;!-- 单位为字节,这里为100MB --&gt; &lt;property name="maxUploadSize" value="104857600"/&gt; &lt;!-- 临时目录 --&gt; &lt;property name="uploadTempDir" value="/WEB-INF/temp"/&gt;&lt;/bean&gt;form表单12345&lt;form action='&lt;s:url value="/upload"/&gt;' method="post" enctype="multipart/form-data"&gt; 选择文件:&lt;input type="file" name="upload"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;处理multipart请求123456789101112131415161718192021222324252627282930313233343536373839404142434445@Controller@RequestMapping("/")public class FileUploadController &#123; @RequestMapping(value="upload",method=RequestMethod.GET) public String upload() &#123; return "upload"; &#125; @RequestMapping(value="upload",method=RequestMethod.POST) //@RequestPart("upload")对于input框的name属性 public String processUpload(@RequestPart("upload") MultipartFile file, HttpServletRequest request,Model model) &#123; try&#123; if(file != null &amp;&amp; !file.isEmpty())&#123; // 保存的文件名未UUID+上传文件名，并且过滤文件名特殊字符 String fileName = makeFileName(StringFilter(file.getOriginalFilename())); String filePath = request.getSession().getServletContext() .getRealPath("/") + "/WEB-INF/upload/" + fileName; File uploadFile = new File(filePath); if(!uploadFile.exists())&#123; uploadFile.mkdirs(); &#125; // 转存文件 file.transferTo(uploadFile); model.addAttribute("name",file.getOriginalFilename()); return "result"; &#125;else&#123; return "fail"; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); return "fail"; &#125; &#125; String makeFileName(String filename) &#123; return UUID.randomUUID().toString() + "_" + filename; &#125; String StringFilter(String str) throws PatternSyntaxException &#123; String regEx = "[`~!@#$%^&amp;*+=|&#123;&#125;':; ',//[//]&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。，、？]"; Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(str); return m.replaceAll("").trim(); &#125;&#125;多文件上传的话，只需将MultipartFile file改为MultipartFile[] files，input标签加上multiple=”multiple”即可。处理下载当文件上传成功后，页面跳转到result.jsp：12&lt;p&gt;上传成功&lt;/p&gt;&lt;a href="&lt;s:url value='/download?fileName=$&#123;name &#125;'/&gt;"&gt;$&#123;name &#125;&lt;/a&gt;现处理下载请求：123456789101112131415161718192021222324@RequestMapping(value="download") public void processDownload(String fileName,HttpServletResponse response, HttpServletRequest request) throws UnsupportedEncodingException&#123; String realFileName = fileName.substring(fileName.indexOf("_") + 1); try &#123; response.setCharacterEncoding("utf-8"); response.setContentType("multipart/form-data"); response.setHeader("Content-Disposition", "attachment;fileName=" + java.net.URLEncoder.encode(realFileName,"utf-8")); String filePath = request.getSession().getServletContext().getRealPath("/") + "WEB-INF/upload/" + fileName; InputStream inputStream = new FileInputStream(new File(filePath)); OutputStream os = response.getOutputStream(); byte[] b = new byte[2048]; int length; while ((length = inputStream.read(b)) &gt; 0) &#123; os.write(b, 0, length); &#125; os.close(); inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;异步处理异步处理multipart可以使用jQuery.form.js插件来完成：12345678$("#form_id").ajaxSubmit(&#123; url: "url.do", type: "post", dataType: "json", success: function(r)&#123; // your code here. &#125;&#125;);form表单代码：123&lt;form enctype="multipart/form-data"&gt; 选择文件:&lt;input type="file" name="upload"&gt; &lt;/form&gt;后端代码不变。]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中使用Apache Tiles布局]]></title>
    <url>%2FSpring-Apache-Tiles.html</url>
    <content type="text"><![CDATA[假设我们想为应用中的所有页面定义一个通用的头部和底部。最原始的方式就是查找每个JSP模板，并为其添加头部和底部的HTML。但是这种方法的扩展性并不好，也难以维护。更好的方式是使用布局引擎，如Apache Tiles，定义适用于所有页面的通用页面布局。Spring MVC以视图解析器的形式为Apache Tiles提供了支持。配置Tiles视图解析器首先引入依赖：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt; &lt;artifactId&gt;tiles-jsp&lt;/artifactId&gt; &lt;version&gt;3.0.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt; &lt;artifactId&gt;tiles-core&lt;/artifactId&gt; &lt;version&gt;3.0.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tiles&lt;/groupId&gt; &lt;artifactId&gt;tiles-api&lt;/artifactId&gt; &lt;version&gt;3.0.7&lt;/version&gt;&lt;/dependency&gt;配置：1234567891011121314&lt;!-- 指定tiles.xml --&gt;&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt; &lt;property name="definitions"&gt; &lt;list&gt; &lt;value&gt;/WEB-INF/views/tiles.xml&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 代替InternalResourceViewResolver --&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.tiles3.TilesViewResolver"/&gt;&lt;!-- 配置静态资源路径 --&gt;&lt;mvc:resources location="/images/" mapping="/images/**"/&gt;tiles.xml见下文。tiles.xml1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE tiles-definitions PUBLIC "-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN" "http://tiles.apache.org/dtds/tiles-config_3_0.dtd"&gt;&lt;tiles-definitions&gt; &lt;!-- 设置基本tile，定义了header,body,footer --&gt; &lt;definition name="base" template="/WEB-INF/views/page.jsp"&gt; &lt;put-attribute name="header" value="/WEB-INF/views/header.jsp" /&gt; &lt;put-attribute name="footer" value="/WEB-INF/views/footer.jsp" /&gt; &lt;/definition&gt; &lt;!-- 拓展tile，name对应controller中的视图名，body指定页面主体内容 --&gt; &lt;definition name="index" extends="base"&gt; &lt;put-attribute name="body" value="/WEB-INF/views/index.jsp" /&gt; &lt;/definition&gt; &lt;definition name="register" extends="base"&gt; &lt;put-attribute name="body" value="/WEB-INF/views/register.jsp" /&gt; &lt;/definition&gt; &lt;/tiles-definitions&gt;每个元素都定义了一个Tile，它最终引用的是一个JSP模板。名为base的Tile中，模板为page.jsp，还定义了页首和页脚的模板JSP：header.jsp：1234567&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;&lt;a href="&lt;s:url value="/index/" /&gt;"&gt; &lt;img src='&lt;c:url value="/images/leanote.png"/&gt;' border="0"/&gt;&lt;/a&gt;footer.jsp：123&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;Copyright © Leanotepage.jsp：12345678910111213141516171819202122232425&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;&lt;%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="t" %&gt;&lt;%@ page session="false" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;leanote 蚂蚁笔记&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;div id="header"&gt; &lt;t:insertAttribute name="header" /&gt; &lt;/div&gt; &lt;!-- 主体内容，对应tiles.xml中继承base的Tile --&gt; &lt;div id="content"&gt; &lt;t:insertAttribute name="body" /&gt; &lt;/div&gt; &lt;!-- 尾部 --&gt; &lt;div id="footer"&gt; &lt;t:insertAttribute name="footer" /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;名为index和register的Tile各自都继承了base Tile，还定义了body，分别引用index.jsp和register.jsp：index.jsp：12345&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;p&gt;蚂蚁笔记，有极客范的云笔记！&lt;/p&gt;&lt;p&gt;前所未有的文档体验，近乎完美的平台覆盖，支持团队协同，企业级私有云&lt;/p&gt;&lt;p&gt;蚂蚁笔记 = 笔记 + 博客 + 协作 + 私有云&lt;/p&gt;register.jsp：1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %&gt; &lt;h3&gt;注册leanote&lt;/h3&gt;&lt;sf:form method="post" commandName="form" action="$&#123;pageContext.request.contextPath&#125;/register"&gt; &lt;sf:label path="name" cssErrorClass="error"&gt;用户名：&lt;/sf:label&gt; &lt;sf:input path="name" cssErrorClass="error"/&gt; &lt;sf:errors path="name" cssClass="error"/&gt;&lt;br/&gt; 邮箱：&lt;sf:input path="email"/&gt;&lt;sf:errors path="email" cssClass="error"/&gt;&lt;br/&gt; 密码：&lt;sf:password path="password" /&gt;&lt;sf:errors path="password" cssClass="error"/&gt;&lt;br/&gt; &lt;input type="submit" value="注册" /&gt;&lt;/sf:form&gt;测试访问http://localhost:8080/spring/index/：访问http://localhost:8080/spring/registerindex/可以看到，头部和尾部是固定的，变的只是body部分。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Apache Tiles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring表单校验]]></title>
    <url>%2FSpring%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C.html</url>
    <content type="text"><![CDATA[从Spring 3.0开始，Spring对Java校验API（Java Validation API，又称JSR-303）提供了支持。在Spring MVC中要使用Java校验API的话，并不需要什么额外的配置。只要保证在类路径下包含这个Java API的实现即可，比如Hibernate Validator。引入hibernate-validator：123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.4.Final&lt;/version&gt;&lt;/dependency&gt;校验注解所有的注解都位于javax.validation.constraints和org.hibernate.validator.constraints包中。下表列出了这些校验注解。注解描述@Null限制只能为null@NotNull限制必须不为null@AssertFalse限制必须为false@AssertTrue限制必须为true@DecimalMax(value)限制必须为一个不大于指定值的数字@DecimalMin(value)限制必须为一个不小于指定值的数字@Digits(integer,fraction)限制必须为一个小数，且整数部分的位数不能超过integer， 小数部分的位数不能超过fraction@Future限制必须是一个将来的日期@Past限制必须是一个过去的日期@Max(value)限制必须为一个不大于指定值的数字@Min(value)限制必须为一个不小于指定值的数字@Past限制必须是一个过去的日期@Pattern(value)限制必须符合指定的正则表达式@Size(max,min)限制字符长度必须在min到max之间@SafeHtml字符串是安全的html@URL字符串是合法的URL@NotBlank字符串必须有字符@NotEmpty字符串不为NULL，集合有字符@AssertFalse必须是false@AssertTrue必须是true使用校验注解配置实体类新建一个表单实体类，并加上注解：1234567891011121314151617181920212223242526272829303132333435363738394041import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;import org.hibernate.validator.constraints.Email; public class Form &#123; @NotNull @Size(min = 5, max = 16, message = "&#123;name.msg&#125;") private String name; @NotNull() @Email(message = "&#123;email.msg&#125;") private String email; @NotNull @Size(min = 5, max = 16, message = "&#123;password.msg&#125;") private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125;message属性用于添加国际化支持，接下来需要做的就是创建一个名为ValidationMessages.properties的文件（默认叫这个，不区分大小写，放在src/main/resources路径下）：123name.msg=\u7528\u6237\u540D\u957F\u5EA6\u4E3A&#123;min&#125;\u5230&#123;max&#125;\u4E2A\u5B57\u7B26password.msg=\u5BC6\u7801\u957F\u5EA6\u4E3A&#123;min&#125;\u5230&#123;max&#125;\u4E2A\u5B57\u7B26email.msg=\u90AE\u7BB1\u683C\u5F0F\u4E0D\u5408\u6CD5ValidationMessages.properties文件中每条信息的key值对应于注解中message属性占位符的 值。同时，最小和最大长度在ValidationMessages.properties文件中有自己的占位符——{min}和{max}——它们会引用@Size注解上所设置的min和max属性。自定义校验规则上面的注解都是较为简单的注解，实际编程中校验的规则可能五花八门。当自带的这些注解无法满足我们的需求时，我们也可以自定义校验注解。下面是一个自定义校验注解的基本格式：1234567891011121314151617import javax.validation.Constraint;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target@Target(&#123;ElementType.FIELD, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = MyConstraintValidator.class)public @interface MyConstraint &#123; String message(); Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;其中@Constraint注解表明这个注解是用于规则校验的，validatedBy属性表明用什么去校验，这里我们指定的类为MyConstraintValidator。注解还包含了三个书属性，属性message指定当校验不通过的时候提示什么信息。接下来编写MyConstraintValidator，代码如下所示：12345678910111213141516import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;public class MyConstraintValidator implements ConstraintValidator&lt;MyConstraint, Object&gt; &#123; @Override public void initialize(MyConstraint myConstraint) &#123; System.out.println("my validator init"); &#125; @Override public boolean isValid(Object o, ConstraintValidatorContext constraintValidatorContext) &#123; System.out.println(o); return false; &#125;&#125;MyConstraintValidator实现了ConstraintValidator接口，该接口必须指定两个泛型，第一个泛型指的是上面定义的注解类型，第二个泛型表示校验对象的类型。MyConstraintValidator实现了ConstraintValidator接口的initialize方法和isValid方法。initialize方法用于该校验初始化的时候进行一些操作；isValid方法用于编写校验逻辑，第一个参数为需要校验的值，第二个参数为校验上下文。Spring JSP库为了使用Spring JSP库，需要在JSP页首加入：12&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %&gt;引入依赖：123456&lt;!-- https://mvnrepository.com/artifact/jstl/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;相关标签如下表所示：JSP标签描述&lt;sf:checkbox&gt;渲染成一个HTML &lt;input&gt;标签，其中type属性设置为checkbox&lt;sf:checkboxes&gt;渲染成多个HTML &lt;input&gt;标签，其中type属性设置为checkbox&lt;sf:errors&gt;在一个HTML &lt;span&gt;中渲染输入域的错误&lt;sf:form&gt;渲染成一个HTML &lt;form&gt;标签，并为其内部标签暴露绑定路径，用于数据绑定&lt;sf:hidden&gt;渲染成一个HTML &lt;input&gt;标签，其中type属性设置为hidden&lt;sf:input&gt;渲染成一个HTML &lt;input&gt;标签，其中type属性设置为text&lt;sf:label&gt;渲染成一个HTML &lt;label&gt;标签&lt;sf:option&gt;渲染成一个HTML &lt;option&gt;标签，其selected属性根据所绑定的值进行设置&lt;sf:options&gt;按照绑定的集合、数组或Map，渲染成一个HTML &lt;option&gt;标签的列表&lt;sf:password&gt;渲染成一个HTML &lt;input&gt;标签，其中type属性设置为password&lt;sf:radiobutton&gt;渲染成一个HTML &lt;input&gt;标签，其中type属性设置为radio&lt;sf:radiobuttons&gt;渲染成多个HTML &lt;input&gt;标签，其中type属性设置为radio&lt;sf:select&gt;渲染为一个HTML &lt;select&gt;标签&lt;sf:textarea&gt;渲染为一个HTML &lt;textarea&gt;标签用Spring JSP标签创建一个register.jsp：123456789101112131415161718192021222324252627&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;chartset=utf-8"&gt; &lt;title&gt;leanote 蚂蚁笔记&lt;/title&gt;&lt;/head&gt;&lt;style&gt; input&#123;margin-top:5px;&#125; label.error&#123;color:red;&#125; span.error&#123;color:red;&#125; input.error&#123;border:1px solid red;&#125;&lt;/style&gt;&lt;body&gt; &lt;sf:form method="post" commanName="form" action="$&#123;pageContext.request.contextPath&#125;/register"&gt; &lt;sf:label path="name" cssErrorClass="error"&gt;用户名：&lt;/sf:label&gt; &lt;sf:input path="name" cssErrorClass="error"/&gt; &lt;sf:errors path="name" cssClass="error"/&gt;&lt;br/&gt; 邮箱：&lt;sf:input path="email"/&gt;&lt;sf:errors path="email" cssClass="error"/&gt;&lt;br/&gt; 密码：&lt;sf:password path="password"/&gt;&lt;sf:errors path="password" cssClass="error"/&gt;&lt;br/&gt; &lt;input type="submit" value="注册"/&gt; &lt;/sf:form&gt;&lt;/body&gt;&lt;/html&gt;&lt;sf:form&gt;会渲染为一个HTML&lt;form&gt;标签，也可以通过commandName属性构建针对某个模型对象的上下文信息。这里设为form（待会在controller中传递到此页面）。cssClass属性可以给标签加上样式Class，用于在CSS中对其选中并修改样式。path属性指向实体类form对应的属性名称。如果将&lt;sf:errors/&gt;标签的path属性设置为*的话，其将显示所有不满足校验的提示信息。cssErrorClass属性指定校验不通过时候除了&lt;sf:errors/&gt;标签外的标签样式。编写controllerRegester控制器如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142import javax.validation.Valid;import mrbird.mvc.entity.Form;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod; @Controllerpublic class LeanoteController &#123; @RequestMapping(value = "/registerindex", method = RequestMethod.GET) public String register(Model model) &#123; //对应&lt;sf:form/&gt;标签的commandName属性值 model.addAttribute(new Form()); return "register"; &#125; @RequestMapping(value = "/register", method = RequestMethod.POST) //form参数添加了@Valid注解，这会告知Spring，需要确保这个对象满足校验限制。 //Errors参数要紧跟在带有@Valid注解的参数后面 public String submit(@Valid Form form, BindingResult result) &#123; if (result.hasErrors()) &#123; // 输出校验失败信息 result.getAllErrors().stream().forEach(e -&gt; &#123; FieldError fieldError = (FieldError) e; System.out.println(((FieldError) e).getField() + " " + e.getDefaultMessage()); &#125; ); //出错时回到注册页面，这里不能够用重定向，不然看不到错误提示信息 return "register"; &#125; //校验通过，重定向到/success/&#123;name&#125; return "redirect:/success/" + form.getName(); &#125; @RequestMapping(value = "/success/&#123;name&#125;", method = RequestMethod.GET) public String success(@PathVariable String name, Model model) &#123; model.addAttribute(name); return "success"; &#125;&#125;部署项目，访问：http://localhost:8080/spring/registerindex：]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring传递参数]]></title>
    <url>%2FSpring%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.html</url>
    <content type="text"><![CDATA[总结下平时使用Spring时，服务端接收客户端传递的参数的几种方式。同名变量在客户端，使用GET请求发送一个变量到服务端，比如传递一个testParam变量：12345var testParam = 'mrbird';$.ajax(&#123; url:"$&#123;pageContext.request.contextPath&#125;/test?testParam="+testParam, method:"get"&#125;);服务端：12345678@Controller@RequestMapping(value="/test")public class TestContoller &#123; @RequestMapping(method=RequestMethod.GET) public void test(String testParam)&#123; &#125;&#125;用testParam同名参数接收，通过断点，得到的值为mrbird。@requestParam和第一种方法类似，只不过使用@requestParam注解后，变量可以使用别的名字命名：12345678@Controller@RequestMapping(value="/test")public class TestContoller &#123; @RequestMapping(method=RequestMethod.GET) public void test(@RequestParam("testParam") String param)&#123; &#125;&#125;HttpServletRequest通过HttpServletRequest对象获取：12345678@Controller@RequestMapping(value="/test")public class TestContoller &#123; @RequestMapping(method=RequestMethod.GET) public void test(HttpServletRequest request)&#123; String param = request.getParameter("testParam"); &#125;&#125;POJO使用POJO接收参数适用于参数量较多的时候，比方说表单提交的时候，但这里我们还是用testParam栗子演示。创建一个用于接收参数的POJO，并定义和传递参数同名的属性：12345678910public class Params &#123; private String testParam; public String getTestParam() &#123; return testParam; &#125; public void setTestParam(String testParam) &#123; this.testParam = testParam; &#125;&#125;服务端：12345678@Controller@RequestMapping(value="/test")public class TestContoller &#123; @RequestMapping(method=RequestMethod.GET) public void test(Params param)&#123; String testParam = param.getTestParam(); &#125;&#125;占位符我们将GET请求的URL改为：1url:"$&#123;pageContext.request.contextPath&#125;/test/"+testParam,将参数通过URL路径进行标识，而不是通过查询参数。为了实现这种路径变量，Spring MVC允许我们在@RequestMapping路径中添加占位符。占位符的名称要用大括号（“{”和“}”）括起来。路径中的其他部分要与所处理的请求完全匹配， 但是占位符部分可以是任意的值。修改controller：12345678@Controller@RequestMapping(value="/test")public class TestContoller &#123; @RequestMapping(value="&#123;testParam&#125;",method=RequestMethod.GET) public void test(@PathVariable String testParam)&#123; &#125;&#125;test方法参数名称必须和占位符名称相同。]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SpringMVC]]></title>
    <url>%2F%E6%90%AD%E5%BB%BASpringMVC.html</url>
    <content type="text"><![CDATA[guide下图展示了请求在Spring MVC中的过程：环境准备使用Maven构建Spring web MVC project。新建Maven Project（选中skip archetype selection）:点击next，然后填写Group Id和Artifact Id，打包方式为war：finish后，右击项目，选择properties，选中Deployment Assembly，移除选中的路径：apply后选择Project Facets，勾选Dynamic Web Module，点击下方的Further configuration avaiable：如下填写后确定即可：准备好后，在pom中引入依赖以及配置tomcat插件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 布置到tomcat --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;!--在这里定义端口号 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;XML配置搭建web.xml中配置DispatcherServlet：1234567891011121314&lt;!-- 配置dispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;mvc-xml&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-xml&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;配置applicationContext.xml：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd"&gt; &lt;!-- 开启组件扫描 --&gt; &lt;context:component-scan base-package="mrbird"/&gt; &lt;!-- 启用Spring mvc --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置viewResolver --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/views/" p:suffix=".jsp"&gt; &lt;/bean&gt;&lt;/beans&gt;编写一个最简单的cotroller：1234567891011import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod; @Controllerpublic class IndexController &#123; @RequestMapping(value="/index",method=RequestMethod.GET) public String index()&#123; return "index"; &#125;&#125;编写一个最简单的页面：12345678910111213&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;leanote 蚂蚁笔记&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;蚂蚁笔记，有极客范的云笔记！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;一切准备就绪，启动项目，访问http://localhost:8080/mvc-xml/index：JavaConfig配置搭建配置DispatcherServlet：123456789101112131415161718import org.springframework.web.servlet.support .AbstractAnnotationConfigDispatcherServletInitializer; public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer&#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[]&#123;RootConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[]&#123;WebConfig.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;"/"&#125;; &#125;&#125;WebConfig：123456789101112131415161718192021@Configuration//开启spring mvc@EnableWebMvc//开启扫描@ComponentScan("mrbird")public class WebConfig extends WebMvcConfigurerAdapter&#123; //配置viewResolver @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; @Override public void configureDefaultServletHandling( DefaultServletHandlerConfigurer configurer)&#123; configurer.enable(); &#125;&#125;新的WebConfig类还扩展了WebMvcConfigurerAdapter并重写了其configureDefaultServletHandling()方法。通过调用DefaultServletHandlerConfigurer的enable()方法，我们要求DispatcherServlet将对静态资源的请求转发到Servlet容器中默认的Servlet上，而不是使用DispatcherServlet本身来处理此类请求。RootConfig：123456@Configuration@ComponentScan(basePackages=&#123;"mrbird"&#125;, excludeFilters=&#123;@Filter(type=FilterType.ANNOTATION,value=EnableWebMvc.class)&#125;)public class RootConfig &#123; &#125;Controller和JSP页面同上。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注入外部值]]></title>
    <url>%2FSpring%E6%B3%A8%E5%85%A5%E5%A4%96%E9%83%A8%E5%80%BC.html</url>
    <content type="text"><![CDATA[Spring注入外部文件的值有几种方式：Spring Environment在Spring中，处理外部值的最简单方式就是声明属性源并通过Spring的Environment来检索属性。声明一个Phone接口：123public interface Phone &#123; public void phoneMsg();&#125;实现类GooglePixel：123456789101112131415public class GooglePixel implements Phone&#123; private String name; private String cpu; private String battery; public GooglePixel(String name, String cpu, String battery) &#123; this.name = name; this.cpu = cpu; this.battery = battery; &#125; public void phoneMsg() &#123; System.out.println(name+"，cpu型号："+cpu+"，电池容量："+battery); &#125;&#125;创建一个外部配置类：googlePixel.properties：123phone.name=Google Pixelphone.battery=2770mAhphone.cpu=Qualcomm Xiaolong 821在JavaConfig中加载外部配置，并用Spring的Environment对象获取：123456789101112131415161718192021import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.core.env.Environment; @Configuration//加载外部配置文件@PropertySource("classpath:/mrbird/leanote/properties/googlePixel.properties")public class PhoneConfig &#123; //注入Spring环境对象 @Autowired private Environment env; @Bean(name="googlePixel") public Phone phone()&#123; return new GooglePixel( env.getProperty("phone.name"), env.getProperty("phone.cpu"), env.getProperty("phone.battery")); &#125;&#125;测试是否注入成功：1234567public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new AnnotationConfigApplicationContext(PhoneConfig.class); Phone googlePixel = (Phone) ac.getBean("googlePixel"); googlePixel.phoneMsg(); &#125;&#125;控制台输出：1Google Pixel，cpu型号：Qualcomm Xiaolong 821，电池容量：2770mAhgetProperty()方法并不是获取属性值的唯一方法，getProperty()方法有四个重载的变种形式：1234String getProperty(String key)String getProperty(String key,String defaultValue)T getProperty(String key,Class&lt;T&gt; type)T getProperty(Stirng key,Class&lt;T&gt; type,T defaultValue)前两种形式的getProperty()方法都会返回String类型的值。上面的栗子使用第一种getProperty()方法。稍微对@Bean方法进行一下修改，这样在指定属性不存在的时候，会使用一个默认值：1234567@Bean(name="googlePixel") public Phone phone()&#123; return new GooglePixel( env.getProperty("phone.name","谷歌Pixel"), env.getProperty("phone.cpu","高通枭龙821"), env.getProperty("phone.battery","2770毫安时")); &#125;剩下的两种getProperty()方法与前面的两种非常类似，但是它们可以传入类型。Environment还提供了几个与属性相关的方法，如果你在使用getProperty()方法的时候 没有指定默认值，并且这个属性没有定义的话，获取到的值是null。如果你希望这个属性必须要定义，那么可以使用getRequiredProperty()方法，如下所示：1234567@Bean(name="googlePixel") public Phone phone()&#123; return new GooglePixel( env.getRequiredProperty("phone.name"), env.getRequiredProperty("phone.cpu"), env.getRequiredProperty("phone.battery")); &#125;在这里，如果phone.name或phone.cpu或phone.battery属性没有定义的话，将会抛出 IllegalStateException异常。如果想检查一下某个属性是否存在的话，那么可以调用Environment的 containsProperty()方法：1boolean nameExists = env.containsProperty("phone.name");属性占位符创建一个phone-config.xml文件，使用Spring context命名空间中的context:propertyplaceholder元素生成PropertySourcesPlaceholderConfigurer bean：1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;context:property-placeholder location="classpath:/mrbird/leanote/properties/googlePixel.properties"/&gt; &lt;bean id="googlePixel" class="mrbird.leanote.javaconfig.GooglePixel" c:name="$&#123;phone.name&#125;" c:cpu="$&#123;phone.cpu&#125;" c:battery="$&#123;phone.battery&#125;"/&gt;&lt;/beans&gt;测试：123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:phone-config.xml")public class Test &#123; @Autowired @Qualifier("googlePixel") private Phone phone; @Test public void drive()&#123; assertNotNull(phone); phone.phoneMsg(); &#125;&#125;输出结果同上。或者不用XML显示配置Bean，开启自动扫描，使用注解注入属性值：12&lt;!-- 开启扫描 --&gt;&lt;context:component-scan base-package="mrbird.leanote.javaconfig"/&gt;GooglePixel类属性注入：12345678910111213141516171819@Componentpublic class GooglePixel implements Phone&#123; @Value("$&#123;phone.name&#125;") private String name; @Value("$&#123;phone.cpu&#125;") private String cpu; @Value("$&#123;phone.battery&#125;") private String battery; public GooglePixel(String name, String cpu, String battery) &#123; this.name = name; this.cpu = cpu; this.battery = battery; &#125; public void phoneMsg() &#123; System.out.println(name+"，cpu型号："+cpu+"，电池容量："+battery); &#125;&#125;或者构造器注入：12345678910...public GooglePixel( @Value("$&#123;phone.name&#125;")String name, @Value("$&#123;phone.cpu&#125;")String cpu, @Value("$&#123;phone.battery&#125;")String battery) &#123; this.name = name; this.cpu = cpu; this.battery = battery;&#125;...util:properties在phone-config.xml文件中：12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd"&gt; &lt;util:properties id="p" location="classpath:/mrbird/leanote/properties/googlePixel.properties"/&gt; &lt;bean id="googlePixel" class="mrbird.leanote.javaconfig.GooglePixel" c:name="#&#123;p['phone.name']&#125;" c:cpu="#&#123;p['phone.cpu']&#125;" c:battery="#&#123;p['phone.battery']&#125;"/&gt;&lt;/beans&gt;和占位符区别是，这里需要用spEL表达式获取属性的值，并且不能写为：”#{p.phone.name}”，这样Spring读取不到属性值，将会抛出异常。使用注解配置和占位符类似，比如set注入：12345678...@Value("#&#123;p['phone.name']&#125;")private String name;@Value("#&#123;p['phone.cpu']&#125;")private String cpu;@Value("#&#123;p['phone.battery']&#125;")private String battery;...或者使用systemProperties来代替p：12345678...@Value("#&#123;systemProperties['phone.name']&#125;")private String name;@Value("#&#123;systemProperties['phone.cpu']&#125;")private String cpu;@Value("#&#123;systemProperties['phone.battery']&#125;")private String battery;...some：XML123&lt;context:property-placeholder location="classpath:....properties"/&gt; &lt;context:component-scan base-package=""/&gt; &lt;import resource="classpath:....xml"/&gt;注解：123@PropertySource(value = "classpath:....properties")@ComponentScan(basePackages = "")@ImportResource(value = &#123;"classpath:....xml"&#125;)]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring条件化装配Bean]]></title>
    <url>%2FSpring%E6%9D%A1%E4%BB%B6%E5%8C%96%E8%A3%85%E9%85%8DBean.html</url>
    <content type="text"><![CDATA[Spring4引入了@Conditional注解，可配合@Bean或者@Component注解一起使用。用CET4考试来演示@Conditional注解。新建考试结果Result接口：123public interface Result &#123; public void getResult();&#125;实现类CET4：12345public class CET4 implements Result&#123; public void getResult() &#123; System.out.println("恭喜你通过CET4"); &#125;&#125;定义学生接口：123public interface Student &#123; public void exam();&#125;实现类XiaoMing：12345678910public class XiaoMing implements Student&#123; //注入result @Autowired(required=false) private Result result; public void exam() &#123; if(result == null) System.out.println("抱歉，CET4未通过"); else result.getResult(); &#125;&#125;配置JavaConfig：12345678910111213141516import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration; @Configurationpublic class ConditionConfig &#123; @Bean @Conditional(ResultCondition.class) public Result result()&#123; return new CET4(); &#125; @Bean(name="xiaoming") public Student student()&#123; return new XiaoMing(); &#125;&#125;可以看到，@Conditional中给定了一个Class，它指明了条件——在本例中，也就是ResultCondition：123456789101112131415import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata; public class ResultCondition implements Condition&#123; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment env = context.getEnvironment(); //获取环境变量中的result属性 String result = env.getProperty("result"); if("success".equals(result)) return true; else return false; &#125;&#125;设置给@Conditional的类可以是任意实现了Condition接口的类型。可以看出来，这个接口实现起来很简单直接，只需提供matches()方法的实现即可。如果matches()方法返回 true，那么就会创建带有@Conditional注解的bean。如果matches()方法返回false，将不会创建这些bean。ConditionContext是一个接口，大致如下所示：1234567public interface conditioncontext&#123; BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); ResourceLoader getResourceLoader(); Environment getEnvironment(); ClassLoder getClassLoader();&#125;通过ConditionContext，我们可以做到如下几点：1.借助getRegistry()返回的BeanDefinitionRegistry检查bean定义；2.借助getBeanFactory()返回的ConfigurableListableBeanFactory检查bean是否存在，甚至探查bean的属性；3.借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么；4.读取并探查getResourceLoader()返回的ResourceLoader所加载的资源；5.借助getClassLoader()返回的ClassLoader加载并检查类是否存在。AnnotatedTypeMetadata则能够让我们检查带有@Bean注解的方法上还有什么其他的注解。像ConditionContext一样，AnnotatedTypeMetadata也是一个接口。它如下所示：12345678910public interface AnnotatedTypeMetadata&#123; boolean isAnnotated(String annotationType); Map&lt;String,Object&gt; getAnnotationAttributes(String annotationType); Map&lt;String,Object&gt; getAnnotationAttributes( String annotationType,boolean classValuesAsString); MutilValueMap&lt;String,Object&gt; getAllAnnotationAttributes( String annotationType); MutilValueMap&lt;String,Object&gt; getAllAnnotationAttributes( String annotationType,boolean classValuesAsString);&#125;借助isAnnotated()方法，我们能够判断带有@Bean注解的方法是不是还有其他特定的注解。借助其他的那些方法，我们能够检查@Bean注解的方法上其他注解的属性。现在测试@Conditional注解的作用：12345678public class TestConditional &#123; public static void main(String[] args) &#123; System.setProperty("result", "fail"); ApplicationContext ac = new AnnotationConfigApplicationContext(ConditionConfig.class); Student xiaoming = (Student) ac.getBean("xiaoming"); xiaoming.exam(); &#125;&#125;这里设置result为fail，ResultCondition的matches()方法返回false，所以CET4 Bean并不会被创建，结果应该输出“抱歉，CET4未通过”，测试结果：1抱歉，CET4未通过]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring混合装配Bean]]></title>
    <url>%2FSpring%E6%B7%B7%E5%90%88%E8%A3%85%E9%85%8DBean.html</url>
    <content type="text"><![CDATA[Spring可以通过Java代码以及XML配置来装配Bean，不仅如此，Spring还可以混合这两种装配方法。JavaConfig中引入XML配置去除@ComponentScan注解，让所有的Bean显示配置。创建一个DriverConfig配置类，里面只装配一个“laosiji”Bean：1234567@Configurationpublic class DriverConfig &#123; @Bean(name="laosiji") public Driver driver()&#123; return new LaoSiJi(); &#125;&#125;创建一个car-config.xml配置，在里面使用xml方式配置Car Bean：12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="wulinghongguang" class="mrbird.leanote.javaconfig.WuLing" c:_-ref="laosiji"/&gt;&lt;/beans&gt;最后创建一个MainConfig配置类，引入CarConfig以及car-config.xml配置：123456789101112import org.springframework.context.annotation.Import;import org.springframework.context.annotation.ImportResource;import org.springframework.test.context.ContextConfiguration; @ContextConfiguration//导入DriverConfig配置类@Import(DriverConfig.class)//JavaConfig中引入XML配置@ImportResource("classpath:car-config.xml")public class MainConfig &#123; &#125;测试是否注入成功：1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)//导入MainConfig配置类@ContextConfiguration(classes=MainConfig.class)public class CarTest &#123; @Autowired @Qualifier("wulinghongguang") private Car car; @Autowired private Driver driver; @Test public void drive()&#123; assertNotNull(car); car.drive(); assertNotNull(driver); driver.drive(); &#125;&#125;测试通过，页面输出：12快上车，来不及解释了快上车，来不及解释了XML配置中引入JavaConfig创建一个main-config.xml，里面分别引入DriverConfig以及car-config.xml：123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean class="mrbird.leanote.javaconfig.DriverConfig"/&gt; &lt;import resource="car-config.xml"/&gt;&lt;/beans&gt;测试：12345678910111213141516@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:main-config.xml")public class CarTest &#123; @Autowired @Qualifier("wulinghongguang") private Car car; @Autowired private Driver driver; @Test public void drive()&#123; assertNotNull(car); car.drive(); assertNotNull(driver); driver.drive(); &#125;&#125;测试通过，输出如上。]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码装配Bean]]></title>
    <url>%2FJava%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean.html</url>
    <content type="text"><![CDATA[除了可以使用XML配置Bean外，还可以使用Java代码来装配Bean。准备工作创建Maven项目，加入如下依赖：12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.stefanbirkner&lt;/groupId&gt; &lt;artifactId&gt;system-rules&lt;/artifactId&gt; &lt;version&gt;1.16.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;创建Bean创建Driver接口：123public interface Driver &#123; public void drive();&#125;其实现类LaoSiJi：12345public class LaoSiJi implements Driver&#123; public void drive() &#123; System.out.println("快上车，来不及解释了"); &#125;&#125;给老司机分配一辆车，定义Car接口：123public interface Car &#123; public void drive();&#125;其实现类五菱宏光：1234567891011public class WuLing implements Car&#123; private Driver driver; // 通过构造器注入老司机 @Autowired public WuLing(Driver driver) &#123; this.driver = driver; &#125; public void drive() &#123; driver.drive(); &#125;&#125;创建配置类配置类中可以显示的配置Bean，也可以采用自动扫描的方法来简化配置。显示配置：1234567891011121314151617import mrbird.leanote.javaconfig.Car;import mrbird.leanote.javaconfig.CarConfig;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration; @Configurationpublic class CarConfig &#123; //显示配置driver和car @Bean public Driver driver()&#123; return new LaoSiJi(); &#125; @Bean public Car car(Driver driver)&#123; return new WuLing(driver); &#125;&#125;自动扫描：自动扫描的话稍微修改配置类：1234567import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration; @Configuration@ComponentScanpublic class CarConfig &#123;&#125;然后在上面创建的Bean类上添加@Component注解，让Spring发现并注入到配置类中。测试测试是否注入成功：12345678910111213141516171819202122232425import mrbird.leanote.javaconfig.Car;import mrbird.leanote.javaconfig.CarConfig;import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; @RunWith(SpringJUnit4ClassRunner.class)//加载配置类@ContextConfiguration(classes=CarConfig.class)public class CarTest &#123; @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired private Car car; @Test public void drive()&#123; assertNotNull(car); car.drive(); &#125;&#125;输出：1快上车，来不及解释了]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个精彩的JavaScript代码段]]></title>
    <url>%2F%E5%87%A0%E4%B8%AA%E7%B2%BE%E5%BD%A9%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%E6%AE%B5.html</url>
    <content type="text"><![CDATA[1.根据给定的条件在原有的数组上，得到所需要的新数组1234567891011var a = [-1, -1, 1, 2, -2, -2, -3, -3, 3, -3];function f(s, e) &#123; var ret = []; for (var i in s) &#123; // 根据原有的数组长度进行循环 ret.push(e(s[i])); &#125; return ret;&#125;f(a, function(n) &#123; return n &gt; 0 ? n : 0&#125;); // 传输一个匿名函数作为逻辑判断​2.比原生type或typeof更详细的类型监测方法1234function type(p) &#123; /function.(\w*)\(\)/.test(p.constructor); //通过其构造函数来获取对应的类型。 return RegExp.$1;&#125;3.通过移位运算来替代”parseInt”123~~3.14 = &gt; 3;// ~~ 取整。~取当前数值的反,~~表示再次取反，也就是得到当前自身// （说明，JS中的“位”运算会将数值自动转换为整）4.将数值转换为16进制的字符串（常用于表示色彩）1234(~~ (Math.random() * (1 &lt;&lt; 24))).toString(16)// ~~ 通过位运算来取整。// &lt;&lt; 左移位。将1的二进制数左移24位。而1&lt;&lt;24 == 2^24(RGB模式下最多可表示的色彩数量)// toString(16) 将数值转换为16进制的字符串输出。5.正则匹配清除两侧空格1234var trim = function(v)&#123; var patrn = /^\s*(.*?)\s+$/; return (patrn.test(v))? RegExp.$1 : 'null ';&#125;转自：微信公众号：JavaScriptcn]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis Dynamic SQL]]></title>
    <url>%2FMyBatis-Dynamic-SQL.html</url>
    <content type="text"><![CDATA[MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。if动态 SQL 通常要做的事情是有条件地包含 where 子句的一部分。比如：12345678910&lt;select id="findRoles" resultType="roleList"&gt; SELECT * FROM t_role WHERE 1 = 1 &lt;if test="roleNo != null and roleNo != ''"&gt; AND role_no like concat('%',#&#123;roleNo&#125;,'%') &lt;/if&gt; &lt;if test="roleName != null and roleName != ''"&gt; AND role_name like concat('%',#&#123;roleName&#125;,'%') &lt;/if&gt;&lt;/select&gt;choose, when, otherwise有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。如：123456789101112131415&lt;select id="findRoles" resultType="roleList"&gt; SELECT * FROM t_role WHERE 1 = 1 &lt;choose&gt; &lt;when test="roleNo != null and roleNo != ''"&gt; AND role_no = #&#123;roleNo&#125; &lt;/when&gt; &lt;when test="roleName != null and roleName != ''"&gt; AND role_name like concat('%',#&#123;roleName&#125;,'%') &lt;/when&gt; &lt;otherwise&gt; AND note is not null &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt;trim, where, set在第一个栗子中，假如不加上1=1的话，比如当第一个条件不成立的时候，SQL就变成了这样：1SELECT * FROM t_role WHERE AND roleName like concat('%',#&#123;roleName&#125;,'%')为了防止这种情况，我们可以使用where元素：1234567891011&lt;select id="findRoles" resultType="roleList"&gt; SELECT * FROM t_role &lt;where&gt; &lt;if test="roleNo != null and roleNo != ''"&gt; AND role_no like concat('%',#&#123;roleNo&#125;,'%') &lt;/if&gt; &lt;if test="roleName != null and roleName != ''"&gt; AND role_name like concat('%',#&#123;roleName&#125;,'%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。和 where 元素等价的自定义 trim 元素为：123&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt;perfix表示语句前缀，prefixOverrides表示要去除的前缀（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的。比如：123456789101112&lt;update id="updateRole" parameterType="role"&gt; update t_role &lt;set&gt; &lt;if test="roleName != null and roleName != ''"&gt; role_name = #&#123;roleName&#125;, &lt;/if&gt; &lt;if test="note != null and note != ''"&gt; note = #&#123;note&#125; &lt;/if&gt; where role_no = #&#123;roleNo&#125; &lt;/set&gt;&lt;/update&gt;这里，set 元素会动态前置 SET 关键字，同时也会消除无关的逗号。对应的trim元素的写法为：123&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt;suffixOverrides去除后缀。forEach动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：1234567&lt;select id="findUserBySex" resultType="user"&gt; select * from t_user where sex in &lt;forEach item="sex" index="index" collection="sexList" open="(" separator="," close=")"&gt; #&#123;sex&#125; &lt;/forEach&gt;&lt;/select&gt;说明： 1.collection配置的sexList是传递进来的参数名称，可以为数组，List，Set或集合。2.item配置的是循环中当前的元素。3.index配置的是当前元素的下标。4.open和close配置的是以什么符号将这些集合元素包裹起来。5.separator配置的是间隔符。bindbind元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如：1234&lt;select id="findRole" resultMap="roleList"&gt; &lt;bind name="pattern" value="'%' + _parameter + '%'"/&gt; select * from t_role where role_name like #&#123;pattern&#125;&lt;/select&gt;其中_paramrter代表的是传进来的参数，和通配符连接后赋给了pattern。Multi-db vendor support一个配置了“_databaseId”变量的 databaseIdProvider 对于动态代码来说是可用的，这样就可以根据不同的数据库厂商构建特定的语句。比如下面的例子：1234567891011&lt;insert id="insert"&gt; &lt;selectKey keyProperty="id" resultType="int" order="BEFORE"&gt; &lt;if test="_databaseId == 'oracle'"&gt; select seq_users.nextval from dual &lt;/if&gt; &lt;if test="_databaseId == 'db2'"&gt; select nextval for seq_users from sysibm.sysdummy1" &lt;/if&gt; &lt;/selectKey&gt; insert into users values (#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt;《深入浅出MyBatis技术原理与实战》读书笔记]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis Cache]]></title>
    <url>%2FMyBatis-Cache.html</url>
    <content type="text"><![CDATA[MyBatis对缓存提供了支持，默认情况下只开启了一级缓存，要开启二级缓存需要进行配置。为了验证这个过程，我们创建log4j.properties：1234log4j.rootLogger=DEBUG , stdout log4j.logger.mrbird.leanote=DEBUG log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout在mybatis-config.xml文件中配置它：1234&lt;settings&gt; ... &lt;setting name="logImpl" value="LOG4J"/&gt;&lt;/settings&gt;一级缓存一级缓存是针对于一个SqlSession而言的，在参数和SQL完全一样的情况下，同一个SqlSession对象调用同一个Mapper方法，只会执行一次SQL，而不同的SqlSession都是相互隔离的，所以即使使用相同的Mapper，相同的方法，也会再次发送SQL进行查询。举个栗子：1234567891011121314151617181920212223242526272829SqlSession sqlSession1 = null;SqlSession sqlSession2 = null;final Logger logger = Logger.getLogger(MyBatisMain.class);try &#123; sqlSession1 = SqlSessionFactoryUtil.openSqlSession(); RoleMapper roleMapper1 = sqlSession1.getMapper(RoleMapper.class); Role role1 = roleMapper1.getRoleById(1L); logger.debug("使用同一个sqlSession再次执行"); Role role2 = roleMapper1.getRoleById(1L); //使用二级缓存的时候，SqlSession调用了commit方法后才会生效 sqlSession1.commit(); logger.debug("使用不同sqlSession再次执行"); sqlSession2 = SqlSessionFactoryUtil.openSqlSession(); RoleMapper roleMapper2 = sqlSession2.getMapper(RoleMapper.class); Role role3 = roleMapper2.getRoleById(1L); //使用二级缓存的时候，SqlSession调用了commit方法后才会生效 sqlSession2.commit();&#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession1.rollback();sqlSession2.rollback();&#125;finally&#123; if(sqlSession1 != null)&#123; sqlSession1.close(); &#125; if(sqlSession2 != null)&#123; sqlSession2.close(); &#125;&#125;查看控制台输出日志：1234567891011121314151617181920212223242526Logging initialized using 'class org.apache.ibatis.logging.slf4j.Slf4jImpl' adapter.Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.Opening JDBC ConnectionCreated connection 1995619265.Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@76f2bbc1]==&gt; Preparing: select * from t_role where id = ? ==&gt; Parameters: 1(Long)&lt;== Total: 1使用同一个sqlSession再次执行使用不同sqlSession再次执行Opening JDBC ConnectionCreated connection 2044366277.Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@79da8dc5]==&gt; Preparing: select * from t_role where id = ? ==&gt; Parameters: 1(Long)&lt;== Total: 1Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@76f2bbc1]Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@76f2bbc1]Returned connection 1995619265 to pool.Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@79da8dc5]Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@79da8dc5]Returned connection 2044366277 to pool.可见一级缓存是针对于SqlSession层面的。二级缓存二级缓存是针对于SqlSessionFactory层面的，也就是说只要是同一个SqlSessionFactory创建的SqlSession，它们间都将共享缓存。开启二级缓存需要POJO都实现Serializable接口，并在你的 SQL 映射文件中添加一行:1&lt;cache/&gt;字面上看就是这样。这个简单语句的效果如下: 1.映射语句文件中的所有 select 语句将会被缓存。2.映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。3.缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。4.根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。5.缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。6.缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。开启二级缓存后，再次执行上面的方法，查看控制台输出日志：1234567891011121314151617181920Logging initialized using 'class org.apache.ibatis.logging.slf4j.Slf4jImpl' adapter.Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.PooledDataSource forcefully closed/removed all connections.Cache Hit Ratio [mrbird.leanote.mapper.RoleMapper]: 0.0Opening JDBC ConnectionCreated connection 330382173.Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@13b13b5d]==&gt; Preparing: select * from t_role where id = ? ==&gt; Parameters: 1(Long)&lt;== Total: 1使用同一个sqlSession再次执行Cache Hit Ratio [mrbird.leanote.mapper.RoleMapper]: 0.0使用不同sqlSession再次执行Cache Hit Ratio [mrbird.leanote.mapper.RoleMapper]: 0.3333333333333333Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@13b13b5d]Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@13b13b5d]Returned connection 330382173 to pool.可见，从头到尾只发送了一次SQL进行查询。属性都可以通过缓存元素的属性来修改。比如：1&lt;cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true"/&gt;这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。可用的收回策略有: 1.LRU – 最近最少使用的:移除最长时间不被使用的对象。2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。3.SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。4.WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。默认的是 LRU。flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。《深入浅出MyBatis技术原理与实战》读书笔记]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis级联]]></title>
    <url>%2FMyBatis%E7%BA%A7%E8%81%94.html</url>
    <content type="text"><![CDATA[MyBatis中的级联分为3种：association，collection和discriminator：1.association：代表一对一关系，比如学生和学生证是一对一关系。2.collection：代表一对多关系，比如学生和课程是一对多关系，一个学生可以有多个课程。3.discriminator：鉴别器，它可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集。为了学习这些东东，设计一个模型关系：根据模型新建库表：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061CREATE TABLE t_lecture( id int(20) not null auto_increment comment '编号', lecture_name VARCHAR(60) not null comment '课程名称', PRIMARY KEY (id)); CREATE table t_student( id int(20) not null auto_increment comment '编号', cnname VARCHAR(60) not null comment '学生姓名', sex TINYINT(4) not null COMMENT '性别', selfcard_no int(20) not NULL COMMENT '学生证号', note VARCHAR(1024) COMMENT '备注', PRIMARY KEY (id)); CREATE table t_student_health_female( id int(20) not null auto_increment comment '编号', student_id VARCHAR(60) not null comment '学生编号', check_date VARCHAR(60) not NULL COMMENT '检查日期', heart VARCHAR(60) not NULL COMMENT '心', liver VARCHAR(60) not NULL COMMENT '肝', spleen VARCHAR(60) not NULL COMMENT '脾', lung VARCHAR(60) not NULL COMMENT '肺', kidney VARCHAR(60) not NULL COMMENT '肾', uterus VARCHAR(60) not NULL COMMENT '子宫', note VARCHAR(1024) not NULL comment '备注', PRIMARY KEY (id)); CREATE table t_student_health_male( id int(20) not null auto_increment comment '编号', student_id VARCHAR(60) not null comment '学生编号', check_date VARCHAR(60) not NULL COMMENT '检查日期', heart VARCHAR(60) not NULL COMMENT '心', liver VARCHAR(60) not NULL COMMENT '肝', spleen VARCHAR(60) not NULL COMMENT '脾', lung VARCHAR(60) not NULL COMMENT '肺', kidney VARCHAR(60) not NULL COMMENT '肾', prostate VARCHAR(60) not NULL COMMENT '前列腺', note VARCHAR(1024) not NULL comment '备注', PRIMARY KEY (id)); create table t_student_lecture( id int(20) not null auto_increment COMMENT '编号', student_id int(20) not null comment '学生编号', lecture_id int(20) not null comment '课程编号', grade DECIMAL(16,2) not null comment '评分', note VARCHAR(1024) comment '备注', PRIMARY KEY (id)); create table t_student_selfcard( id int(20) not null auto_increment COMMENT '编号', student_id int(20) not null comment '学生编号', native VARCHAR(60) not NULL COMMENT '籍贯', issue_date date NOT NULL comment '发证日期', end_date date not NULL COMMENT '结束日期', note VARCHAR(1024) comment '备注', PRIMARY KEY (id));association用t_student和t_student_selfcard演示一对一级联。新增Student POJO：12345678910public class Student &#123; private Long id; private String cnName; private Sex sex; private Long selfCardNo; private String note; //一对一关系 private StudentSelfcard selfCard; // getter，setter略&#125;StudentSelfcard POJO：123456789public class StudentSelfcard &#123; private Long id; private Long studentId; private String natives; private Date issueDate; private Date endDate; private String note; // getter，setter略&#125;定义接口StudentSelfcardMapper：1234public interface StudentSelfcardMapper &#123; public StudentSelfcard findStudentSelfcardByStudentId(Long id); public int insertStudentSelfcard(StudentSelfcard selfCard);&#125;创建对应的映射文件StudentSelfcardMapper.xml：123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentSelfcardMapper"&gt; &lt;sql id="studentSelfcard_column"&gt; id,student_id as studentId,native as natives,issue_date as issueDate, end_date as endDate,note &lt;/sql&gt; &lt;select id="findStudentSelfcardByStudentId" parameterType="long" resultType="studentSelfcard"&gt; select &lt;include refid="studentSelfcard_column"/&gt; from t_student_selfcard where student_id = #&#123;studentId&#125; &lt;/select&gt; &lt;insert id="insertStudentSelfcard" parameterType="studentSelfcard"&gt; insert into t_student_selfcard (student_id,native,issue_date,end_date, note) values (#&#123;studentId&#125;,#&#123;natives&#125;,#&#123;issueDate&#125;,#&#123;endDate&#125;,#&#123;note&#125;) &lt;/insert&gt;&lt;/mapper&gt;接着定义接口StudentMapper：1234public interface StudentMapper &#123; public Student findStudentById(Long id); public int createStudent(Student s);&#125;其相对于的映射文件StudentMapper.xml：1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentMapper"&gt; &lt;resultMap type="student" id="studentList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="cnname" property="cnName"/&gt; &lt;result column="sex" property="sex" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/&gt; &lt;result column="selfcard_no" property="selfCardNo"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 一对一关联，column指定用哪列的值作为select查询的条件，如果有多个值用 逗号隔开，select指定查询方法--&gt; &lt;association property="selfCard" column="id" select="mrbird.leanote.mapper.StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt; &lt;/resultMap&gt; &lt;sql id="student_column"&gt; id,cnname as cnName,sex,selfcard_no as selfCardNo,note &lt;/sql&gt; &lt;select id="findStudentById" parameterType="long" resultMap="studentList"&gt; select &lt;include refid="student_column"/&gt; from t_student where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 设置主键回填，供t_student_selfcard的student_id字段使用 --&gt; &lt;insert id="createStudent" parameterType="student" useGeneratedKeys="true" keyProperty="id"&gt; insert into t_student(cnname,sex,selfcard_no,note) values (#&#123;cnName&#125;, #&#123;sex,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;, #&#123;selfCardNo&#125;,#&#123;note&#125;) &lt;/insert&gt;&lt;/mapper&gt;设置别名，指定mapper略。先往库表插入值：123456789101112131415161718192021...sqlSession = SqlSessionFactoryUtil.openSqlSession();StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);StudentSelfcardMapper selfcardMapper = sqlSession.getMapper(StudentSelfcardMapper.class);Student student = new Student();student.setCnName("辛久奈");student.setNote("旋涡辛久奈");student.setSelfCardNo(10000L);student.setSex(Sex.FEMALE);int n = studentMapper.createStudent(student);if( n == 1)&#123; StudentSelfcard selfCard = new StudentSelfcard(); selfCard.setStudentId(student.getId()); selfCard.setNatives("福州"); selfCard.setIssueDate(new Date()); selfCard.setEndDate(new Date()); selfCard.setNote("旋涡辛久奈的学生证"); selfcardMapper.insertStudentSelfcard(selfCard);&#125;sqlSession.commit();...查询库表：123456789101112131415mysql&gt; select * from t_student;+----+--------+--------+-------------+------------+| id | cnname | sex | selfcard_no | note |+----+--------+--------+-------------+------------+| 10 | 辛久奈 | FEMALE | 10000 | 旋涡辛久奈 |+----+--------+--------+-------------+------------+1 row in set (0.00 sec) mysql&gt; select * from t_student_selfcard;+----+------------+--------+------------+------------+--------------------+| id | student_id | native | issue_date | end_date | note |+----+------------+--------+------------+------------+--------------------+| 2 | 10 | 福州 | 2017-01-06 | 2017-01-06 | 旋涡辛久奈的学生证 |+----+------------+--------+------------+------------+--------------------+1 row in set (0.00 sec)插入成功，现测试级联获取：1234567...sqlSession = SqlSessionFactoryUtil.openSqlSession();StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);Student student = studentMapper.findStudentById(10L);System.out.println(student.getSelfCard().getNote());sqlSession.commit();...控制台输出：1旋涡辛久奈的学生证success.collection学生和学生成绩是一对多的关系，所以用t_student和t_student_lecture表练习一对多级联。修改Student POJO：12345678910public class Student &#123; private Long id; private String cnName; private Sex sex; private Long selfCardNo; private String note; //一对多关联 private List&lt;StudentLecture&gt; lectures; // getter，setter略&#125;新增StudentLecture POJO：12345678public class StudentLecture &#123; private Long id; private Long studentId; private Long lectureId; private Double grade; private String note; // getter，setter略&#125;新建StudentLectureMapper接口：1234public interface StudentLectureMapper &#123; public List&lt;StudentLecture&gt; getLecturesByStudentId(Long studentId); public int insertStudentLecture(StudentLecture lecture);&#125;其对应的映射文件StudentLectureMapper.xml：1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentLectureMapper"&gt; &lt;resultMap type="studentLecture" id="lectures"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="student_id" property="studentId"/&gt; &lt;result column="lecture_id" property="lectureId"/&gt; &lt;result column="grade" property="grade"/&gt; &lt;result column="note" property="note"/&gt; &lt;/resultMap&gt; &lt;sql id="student_lecture_column"&gt; id,student_id as studentId,lecture_id as lectureId,grade,note &lt;/sql&gt; &lt;select id="getLecturesByStudentId" parameterType="long" resultMap="lectures"&gt; select &lt;include refid="student_lecture_column"/&gt; from t_student_lecture where student_id = #&#123;studentId&#125; &lt;/select&gt; &lt;insert id="insertStudentLecture" parameterType="student"&gt; &lt;![CDATA[ insert into t_student_lecture(student_id,lecture_id,grade,note) values (#&#123;studentId&#125;,#&#123;lectureId&#125;,#&#123;grade&#125;,#&#123;note&#125;) ]]&gt; &lt;/insert&gt;&lt;/mapper&gt;修改StudentMapper.xml：12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentMapper"&gt; &lt;resultMap type="student" id="studentList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="cnname" property="cnName"/&gt; &lt;result column="sex" property="sex" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/&gt; &lt;result column="selfcard_no" property="selfCardNo"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 一对多关联，column指定用哪列的值作为select查询的条件，如果由多个值用 逗号隔开，select指定查询方法--&gt; &lt;collection property="lectures" column="id" select="mrbird.leanote.mapper.StudentLectureMapper.getLecturesByStudentId"/&gt; &lt;/resultMap&gt; &lt;sql id="student_column"&gt; id,cnname as cnName,sex,selfcard_no as selfCardNo,note &lt;/sql&gt; &lt;select id="findStudentById" parameterType="long" resultMap="studentList"&gt; select &lt;include refid="student_column"/&gt; from t_student where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 设置主键回填，供t_student_selfcard的student_id字段使用 --&gt; &lt;insert id="createStudent" parameterType="student" useGeneratedKeys="true" keyProperty="id"&gt; insert into t_student(cnname,sex,selfcard_no,note) values (#&#123;cnName&#125;, #&#123;sex,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;, #&#123;selfCardNo&#125;,#&#123;note&#125;) &lt;/insert&gt;&lt;/mapper&gt;先插入一些测试数据：12345678910111213141516171819202122232425...sqlSession = SqlSessionFactoryUtil.openSqlSession();StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);StudentLectureMapper lectureMapper = sqlSession.getMapper(StudentLectureMapper.class);Student student = new Student();student.setCnName("水门");student.setSelfCardNo(11111L);student.setNote("波风水门");student.setSex(Sex.MALE);int n = studentMapper.createStudent(student);if(n == 1)&#123; Long studentId = student.getId(); String[] noteArr = new String[]&#123;"语文成绩","数学成绩","英语成绩"&#125;; Double[] gradeArr = new Double[]&#123;99.0,100.0,98.0&#125;; for(int i=0;i&lt;noteArr.length;i++)&#123; StudentLecture lecture = new StudentLecture(); lecture.setStudentId(studentId); lecture.setLectureId(Long.valueOf(i)); lecture.setGrade(gradeArr[i]); lecture.setNote(noteArr[i]); lectureMapper.insertStudentLecture(lecture); &#125;&#125;sqlSession.commit();...查询数据库：123456789101112131415161718mysql&gt; select * from t_student;+----+--------+--------+-------------+------------+| id | cnname | sex | selfcard_no | note |+----+--------+--------+-------------+------------+| 10 | 辛久奈 | FEMALE | 10000 | 旋涡辛久奈 || 12 | 水门 | MALE | 11111 | 波风水门 |+----+--------+--------+-------------+------------+2 rows in set (0.01 sec) mysql&gt; select * from t_student_lecture;+----+------------+------------+--------+----------+| id | student_id | lecture_id | grade | note |+----+------------+------------+--------+----------+| 1 | 12 | 0 | 99.00 | 语文成绩 || 2 | 12 | 1 | 100.00 | 数学成绩 || 3 | 12 | 2 | 98.00 | 英语成绩 |+----+------------+------------+--------+----------+3 rows in set (0.00 sec)插入成功，现测试级联获取lectures：123456789...sqlSession = SqlSessionFactoryUtil.openSqlSession();StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);Student student = studentMapper.findStudentById(12L);List&lt;StudentLecture&gt; lectures = student.getLectures();for(StudentLecture l : lectures)&#123; System.out.println(l.getNote()+"："+l.getGrade());&#125; ...控制台输出：123语文成绩：99.0数学成绩：100.0英语成绩：98.0success.discriminator鉴别器其实同其他级联一样，只不过是多了个鉴别的过程罢了。为了学习鉴别器，我们向t_student_health_female和t_student_health_male中插入一组数据：12345678910111213141516171819202122232425INSERT INTO `t_student_health_female`VALUES( 1, '10', '2017-1-6', '心正常', '肝正常', '脾正常', '肺正常', '肾正常', '子宫正常', '健康'); INSERT INTO `t_student_health_male`VALUES( 1, '12', '2017-1-6', '心脏良好', '肝良好', '脾良好', '肺良好', '肾良好', '前列腺良好', '健康');其对应的实体类StudentHealthFemale和StudentHealthMale略。新增两个POJO：MaleStudent和FemaleStudent均继承自Student：1234public class MaleStudent extends Student&#123; private List&lt;StudentHealthMale&gt; studentHealthMaleList; // getter，setter略&#125;1234public class FemaleStudent extends Student&#123; private List&lt;StudentHealthFemale&gt; studentHealthFemaleList; // getter，setter略&#125;接着编写两个接口StudentHealthMaleMapper和StudentHealthFemaleMapper，包含一个根据studentId获取health的抽象方法：12345import mrbird.leanote.pojo.StudentHealthMale; public interface StudentHealthMaleMapper &#123; public StudentHealthMale findStudentHealthMaleByStudentId(Long studentId);&#125;12345import mrbird.leanote.pojo.StudentHealthFemale; public interface StudentHealthFemaleMapper &#123; public StudentHealthFemale findStudentHealthFemaleByStudentId(Long studentId);&#125;各自对应的映射器：StudentHealthMaleMapper.xml：123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentHealthMaleMapper"&gt; &lt;select id="findStudentHealthMaleByStudentId" parameterType="long" resultType="studentHealthMale"&gt; select * from t_student_health_male where student_id = #&#123;studentId&#125; &lt;/select&gt; &lt;/mapper&gt;因为在MyBatis配置文件中配置了&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;，并且数据库命名规范，所以这里可以用select * from…studentHealthFemaleMapper.xml：12345678&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentHealthFemaleMapper"&gt; &lt;select id="findStudentHealthFemaleByStudentId" parameterType="long" resultType="studentHealthFemale"&gt; select * from t_student_health_female where student_id = #&#123;studentId&#125; &lt;/select&gt; &lt;/mapper&gt;接下来就是重点了，我们修改StudentMapper.xml：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentMapper"&gt; &lt;!-- 定义maleStudentList，类型为“maleStudent”。这是一个一对多关联，一个学生可以体检多次。 调用的方法为findStudentHealthMaleByStudentId。 正如其POJO继承Student那样，resultMap也同样继承自studentList--&gt; &lt;resultMap type="maleStudent" id="maleStudentList" extends="studentList"&gt; &lt;collection property="studentHealthMaleList" column="id" select="mrbird.leanote.mapper.StudentHealthMaleMapper .findStudentHealthMaleByStudentId"/&gt; &lt;/resultMap&gt; &lt;resultMap type="femaleStudent" id="femaleStudentList" extends="studentList"&gt; &lt;collection property="studentHealthFemaleList" column="id" select="mrbird.leanote.mapper.StudentHealthFemaleMapper .findStudentHealthFemaleByStudentId"/&gt; &lt;/resultMap&gt; &lt;resultMap type="student" id="studentList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="cnname" property="cnName"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="selfcard_no" property="selfCardNo"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 配置鉴别器，类似于switch，用于鉴别的列为“sex”， 值为MALE时结果集为maleStudentList 值为FEMALE时结果集为femaleStudentList --&gt; &lt;discriminator javaType="string" column="sex"&gt; &lt;case value="MALE" resultMap="maleStudentList"&gt;&lt;/case&gt; &lt;case value="FEMALE" resultMap="femaleStudentList"&gt;&lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;sql id="student_column"&gt; id,cnname as cnName,sex,selfcard_no as selfCardNo,note &lt;/sql&gt; &lt;select id="findStudentById" parameterType="long" resultMap="studentList"&gt; select &lt;include refid="student_column"/&gt; from t_student where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;测试一下：1234567...sqlSession = SqlSessionFactoryUtil.openSqlSession();StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);MaleStudent student = (MaleStudent) studentMapper.findStudentById(12L);System.out.println(student.getCnName()+"的"+ student.getStudentHealthMaleList().get(0).getProstate());...页面输出：1水门的前例腺良好(≖ ‿ ≖)✧延迟加载假如一次性将所有与Student有关的信息都加载出来，这必定会造成性能的问题，如：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentMapper"&gt; &lt;resultMap type="student" id="studentList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="cnname" property="cnName"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="selfcard_no" property="selfCardNo"/&gt; &lt;result column="note" property="note"/&gt; &lt;association property="selfCard" column="id" select="mrbird.leanote.mapper.StudentSelfcardMapper .findStudentSelfcardByStudentId"/&gt; &lt;collection property="lectures" column="id" select="mrbird.leanote.mapper.StudentLectureMapper .getLecturesByStudentId"/&gt; &lt;discriminator javaType="string" column="sex"&gt; &lt;case value="MALE" resultMap="maleStudentList"&gt;&lt;/case&gt; &lt;case value="FEMALE" resultMap="femaleStudentList"&gt;&lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; ... &lt;/mapper&gt;MyBatis的延迟加载策略可以很好的应对这种情况。只需在mybatis-config.xml中配置：1234567&lt;settings&gt; ... &lt;!-- 开启延迟加载 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 关闭按层级加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt;然后我们在级联标签上可以自由的配置fetchType=”lazy”或者fetchType=”eager”来改变加载策略。eager 英[ˈi:gə(r)] 美[ˈiɡɚ] adj. 急切; 渴望的; 热心的; 热切的，热情洋溢的;另外一种级联所谓的另外一种级联就是用一条sql查出所有学生的信息，没有性能问题。在StudentMapper中定义一个查找所有学生信息的抽象方法：1public List&lt;Student&gt; finAllStudentMsg();其映射文件如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentMapper"&gt; &lt;select id="finAllStudentMsg" resultMap="allStudentList"&gt; select s.id,s.cnname,s.sex,s.selfcard_no,s.note as snote, IF (s.sex = 'MALE',shm.id,shf.id) as hid, IF (s.sex = 'MALE',shm.check_date,shf.check_date) as checkDate, IF (s.sex = 'MALE',shm.heart,shf.heart) as heart, IF (s.sex = 'MALE',shm.liver,shf.liver) as liver, IF (s.sex = 'MALE',shm.spleen,shf.spleen) as spleen, IF (s.sex = 'MALE',shm.lung,shf.lung) as lung, IF (s.sex = 'MALE',shm.kidney,shf.kidney) as kidney, IF (s.sex = 'MALE',shm.note,shf.note) as hnote, shm.prostate,shf.uterus, ss.id as ssid,ss.native as natives, ss.issue_date as issueDate,ss.end_date as endDate, ss.note as ssNote, sl.id as slid,sl.lecture_id as lectureId,sl.grade, sl.note as slNote FROM t_student s LEFT JOIN t_student_health_male shm on s.id = shm.student_id LEFT JOIN t_student_health_female shf on s.id = shf.student_id LEFT JOIN t_student_selfcard ss on s.id = ss.student_id LEFT JOIN t_student_lecture sl on s.id = sl.student_id &lt;/select&gt; &lt;resultMap type="student" id="allStudentList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="cnname" property="cnName"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="selfcard_no" property="selfCardNo"/&gt; &lt;result column="snote" property="note"/&gt; &lt;!-- javaType属性告诉MyBtis用哪个类去映射这些字段 --&gt; &lt;association property="selfCard" column="id" javaType="studentSelfcard"&gt; &lt;result property="id" column="ssid"/&gt; &lt;result property="studentId" column="id"/&gt; &lt;result property="natives" column="natives"/&gt; &lt;result property="issueDate" column="issueDate"/&gt; &lt;result property="endDate" column="endDate"/&gt; &lt;result property="note" column="ssNote"/&gt; &lt;/association&gt; &lt;collection property="lectures" ofType="studentLecture"&gt; &lt;result property="id" column="slid"/&gt; &lt;result property="studentId" column="id"/&gt; &lt;result property="lectureId" column="lectureId"/&gt; &lt;result property="grade" column="grade"/&gt; &lt;result property="note" column="slNote"/&gt; &lt;/collection&gt; &lt;discriminator javaType="string" column="sex"&gt; &lt;case value="MALE" resultMap="maleStudentList"&gt;&lt;/case&gt; &lt;case value="FEMALE" resultMap="femaleStudentList"&gt;&lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;resultMap type="maleStudent" id="maleStudentList" extends="allStudentList"&gt; &lt;!-- ofType属性指定了其泛型 --&gt; &lt;collection property="studentHealthMaleList" ofType="studentHealthMale"&gt; &lt;id property="id" column="hid"/&gt; &lt;result property="studentId" column="id"/&gt; &lt;result property="checkDate" column="checkDate"/&gt; &lt;result property="heart" column="heart"/&gt; &lt;result property="liver" column="liver"/&gt; &lt;result property="spleen" column="spleen"/&gt; &lt;result property="lung" column="lung"/&gt; &lt;result property="kidney" column="kidney"/&gt; &lt;result property="prostate" column="prostate"/&gt; &lt;result property="note" column="hnote"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;resultMap type="femaleStudent" id="femaleStudentList" extends="allStudentList"&gt; &lt;collection property="studentHealthFemaleList" ofType="studentHealthFemale"&gt; &lt;id property="id" column="hid"/&gt; &lt;result property="studentId" column="id"/&gt; &lt;result property="checkDate" column="checkDate"/&gt; &lt;result property="heart" column="heart"/&gt; &lt;result property="liver" column="liver"/&gt; &lt;result property="spleen" column="spleen"/&gt; &lt;result property="lung" column="lung"/&gt; &lt;result property="kidney" column="kidney"/&gt; &lt;result property="uterus" column="uterus"/&gt; &lt;result property="note" column="hnote"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt;测试finAllStudentMsg方法：12345678910111213141516171819202122232425262728293031323334...sqlSession = SqlSessionFactoryUtil.openSqlSession();StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);List&lt;Student&gt; students = studentMapper.finAllStudentMsg();for(Student student : students)&#123; if("MALE".equalsIgnoreCase(student.getSex().toString()))&#123; MaleStudent male = (MaleStudent) student; System.out.println(male.getCnName()+"的卡号："+male.getSelfCardNo()); StudentSelfcard selfcard = male.getSelfCard(); System.out.println("来自："+selfcard.getNatives()+","+selfcard.getNote()); List&lt;StudentLecture&gt; lectures = male.getLectures(); for(StudentLecture le : lectures)&#123; System.out.println(le.getNote()+"："+le.getGrade()); &#125; List&lt;StudentHealthMale&gt; healthMales = male.getStudentHealthMaleList(); for(StudentHealthMale healthMale : healthMales)&#123; System.out.println(healthMale.getCheckDate()+"，"+healthMale.getProstate()); &#125; &#125;else&#123; FemaleStudent female = (FemaleStudent) student; System.out.println(female.getCnName()+"的卡号："+female.getSelfCardNo()); StudentSelfcard selfcard = female.getSelfCard(); System.out.println("来自："+selfcard.getNatives()+","+selfcard.getNote()); List&lt;StudentLecture&gt; lectures = female.getLectures(); for(StudentLecture le : lectures)&#123; System.out.println(le.getNote()+"："+le.getGrade()); &#125; List&lt;StudentHealthFemale&gt; healthFemales = female.getStudentHealthFemaleList(); for(StudentHealthFemale healthfemale : healthFemales)&#123; System.out.println(healthfemale.getCheckDate()+"，"+healthfemale.getUterus()); &#125; &#125;&#125;...控制台输出：123456789101112辛久奈的卡号：10000来自：福州,旋涡辛久奈的学生证语文成绩：99.0数学成绩：99.0英语成绩：99.02017-1-6，子宫正常水门的卡号：11111来自：厦门,波风水门的学生证语文成绩：99.0数学成绩：100.0英语成绩：98.02017-1-6，前例腺良好这种方式比较直观明了，但是SQL编写起来较为繁琐。《深入浅出MyBatis技术原理与实战》读书笔记]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis映射器]]></title>
    <url>%2FMyBatis%E6%98%A0%E5%B0%84%E5%99%A8.html</url>
    <content type="text"><![CDATA[映射器的配置：元素名称描述select查询语句insert插入语句update更新语句delete删除语句sql允许定义一部分SQL，然后各个地方引用resultMap用于定义结果集cache给定命名控件的缓存配置cache-ref其它命名控件缓存配置的引用selectmapUnderscoreToCamelCase数据库字段名一般采用下划线命名规则，而java中的字段名用的是驼峰命名规则：JavaBean数据库ididroleNamerole_namenotenoteisGirl&nbsp; &nbsp;is_girl如果数据库字段命名规范，我们可以在settins中配置mapUnderscoreToCamelCase为true：123&lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;&lt;/settings&gt;MyBatis就会自动将数据库字段名转换为JavaBean的字段名，比如：123&lt;select id="getRole" parameterType="long" resultType="role"&gt; &lt;![CDATA[select * from t_role where id = #&#123;id&#125;]]&gt;&lt;/select&gt;如果不将mapUnderscoreToCamelCase设置为true，则select元素必须指明字段别名：1234&lt;select id="getRole" parameterType="long" resultType="role"&gt; &lt;![CDATA[select id,role_name as roleName, note,is_girl as isGirl from t_role where id = #&#123;id&#125;]]&gt;&lt;/select&gt;否则没有对应上的字段值为null。传递多个参数1.使用Map传参定义一个抽象方法：1public List&lt;Role&gt; getRole(Map&lt;String,String&gt; params);映射文件中配置select：12345678910111213&lt;resultMap type="role" id="roleList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="role_name" property="roleName"/&gt; &lt;result column="note" property="note"/&gt; &lt;result column="is_girl" property="isGirl" javaType="Boolean" jdbcType="VARCHAR"/&gt;&lt;/resultMap&gt;&lt;select id="getRole" resultMap="roleList"&gt; &lt;![CDATA[select * from t_role where role_name like concat('%',#&#123;roleName&#125;,'%') and note like concat('%',#&#123;note&#125;,'%') ]]&gt;&lt;/select&gt;测试：1234567891011...sqlSession = SqlSessionFactoryUtil.openSqlSession();RoleMapper mapper = sqlSession.getMapper(RoleMapper.class);Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;();params.put("roleName", "雏田");params.put("note", "日向");List&lt;Role&gt; roleList = mapper.getRole(params);for(Role r : roleList)&#123; System.out.println(r.getRoleName()+" is a girl:"+r.getIsGirl());&#125;...输出：1雏田 is a girl:true2.使用注解传参修改抽象方法：12public List&lt;Role&gt; getRole(@Param("roleName")String roleName, @Param("note")String note);测试：12345678...sqlSession = SqlSessionFactoryUtil.openSqlSession();RoleMapper mapper = sqlSession.getMapper(RoleMapper.class);List&lt;Role&gt; roleList = mapper.getRole("雏田", "日向");for(Role r : roleList)&#123; System.out.println(r.getRoleName()+" is a girl:"+r.getIsGirl());&#125;...输出：1雏田 is a girl:true3.使用JavaBean传参定义一个传递参数JavaBean：12345678910111213141516public class RoleParams &#123; private String roleName; private String note; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125;&#125;修改抽象方法：1public List&lt;Role&gt; getRole(RoleParams params);测试：1234567891011...sqlSession = SqlSessionFactoryUtil.openSqlSession();RoleMapper mapper = sqlSession.getMapper(RoleMapper.class);RoleParams params = new RoleParams();params.setRoleName("鸣人");params.setNote("旋涡");List&lt;Role&gt; roleList = mapper.getRole(params);for(Role r : roleList)&#123; System.out.println(r.getRoleName()+" is a girl:"+r.getIsGirl());&#125;...输出：1鸣人 is a girl:falseinsert主键回填和自定义开发中有时候需要获取到插入行的主键值，MyBatis的主键回填可以完成这个功能。定义一个createRole抽象方法：1public int createRole(Role role);映射：1234567&lt;insert id="createRole" parameterType="role" useGeneratedKeys="true" keyProperty="id"&gt; &lt;![CDATA[ insert into t_role(role_name,note,is_girl) values (#&#123;roleName&#125;,#&#123;note&#125;, #&#123;isGirl,typeHandler=mrbird.leanote.typehandler.BooleanTypeHandler&#125;) ]]&gt;&lt;/insert&gt;useGeneratedKeys会使MyBatis使用JDBC的getGeneratedKeys方法来获取出由数据库内部生成的主键，keyProperty表示以哪个列为属性的主键。测试获取主键：1234567891011...sqlSession = SqlSessionFactoryUtil.openSqlSession();RoleMapper mapper = sqlSession.getMapper(RoleMapper.class);Role role = new Role();role.setRoleName("佐助");role.setNote("宇智波");role.setIsGirl(Boolean.FALSE);mapper.createRole(role);System.out.println(role.getId()); //7sqlSession.commit();...页面输出 7，查询数据库：123456789mysql&gt; select * from t_role;+----+-----------+----------+---------+| id | role_name | note | is_girl |+----+-----------+----------+---------+| 1 | 雏田 | 日向雏田 | Y || 2 | 鸣人 | 旋涡鸣人 | N || 7 | 佐助 | 宇智波 | N |+----+-----------+----------+---------+3 rows in set (0.00 sec)假如数据库主键没有设置自增，我们的要求是：如果表t_role没有记录，则id设置为1，否则我们取最大id加2。这时候我们可以对映射文件的insert标签稍作修改：1234567891011121314&lt;insert id="createRole" parameterType="role" useGeneratedKeys="true" keyProperty="id"&gt; &lt;!-- resultType必须和POJO里id的类型一致 --&gt; &lt;selectKey keyProperty="id" resultType="long" order="BEFORE"&gt; &lt;![CDATA[ select if(max(id) is null,1,max(id)+2) as id from t_role ]]&gt; &lt;/selectKey&gt; &lt;![CDATA[ insert into t_role(id,role_name,note,is_girl) values (#&#123;id&#125;,#&#123;roleName&#125;, #&#123;note&#125;, #&#123;isGirl,typeHandler=mrbird.leanote.typehandler.BooleanTypeHandler&#125;) ]]&gt;&lt;/insert&gt;测试：1234567891011...sqlSession = SqlSessionFactoryUtil.openSqlSession();RoleMapper mapper = sqlSession.getMapper(RoleMapper.class);Role role = new Role();role.setRoleName("小樱");role.setNote("春野樱");role.setIsGirl(Boolean.TRUE);mapper.createRole(role);System.out.println(role.getId()); //9sqlSession.commit();...输出9和我们预期的一致，查询数据库：12345678910mysql&gt; select * from t_role;+----+-----------+----------+---------+| id | role_name | note | is_girl |+----+-----------+----------+---------+| 1 | 雏田 | 日向雏田 | Y || 2 | 鸣人 | 旋涡鸣人 | N || 7 | 佐助 | 宇智波 | N || 9 | 小樱 | 春野樱 | Y |+----+-----------+----------+---------+4 rows in set (0.00 sec)update &amp; deleteupdate和delete较为简单，一个简单的更新和删除例子：1234567891011&lt;update id="updateRole" parameterType="role"&gt; &lt;![CDATA[ update t_role set role_name = #&#123;roleName&#125;, note = #&#123;note&#125; where id = #&#123;id&#125; ]]&gt;&lt;/update&gt;&lt;delete id="deleteRole" parameterType="long"&gt; &lt;![CDATA[ delete from t_role where id = #&#123;id&#125; ]]&gt;&lt;/delete&gt;参数参数配置参数除了可以指定javaType，jdbcType和typeHandler外，还可以对数值类型的参数设置精度：1#&#123;price,javaType=double,jdbcType=NUMERIC,numericScale=2&#125;$与井#{}的值被作为sql的参数，而${}则会被当作sql的一部分。sql元素sql元素的作用是可以定义sql语句的一部分，然后导出引用：123456789&lt;sql id="t_role_column"&gt; &lt;![CDATA[id,role_name as roleName,note,is_girl as isGirl]]&gt;&lt;/sql&gt;&lt;select id="getRole" resultMap="roleList"&gt; select &lt;include refid="t_role_column"/&gt; from t_role where role_name like concat('%',#&#123;roleName&#125;,'%') and note like concat('%',#&#123;note&#125;,'%')&lt;/select&gt;上述代码定义了一个id为t_role_column的sql，然后在select元素中使用include元素引用了它，从而达到了重用的功能。还可以在sql元素中指定标签：12345678910111213&lt;sql id="t_role_column"&gt; &lt;![CDATA[$&#123;prefix&#125;.id,$&#123;prefix&#125;.role_name as roleName, $&#123;prefix&#125;.note,$&#123;prefix&#125;.is_girl as isGirl]]&gt;&lt;/sql&gt;&lt;select id="getRole" resultMap="roleList"&gt; select &lt;include refid="t_role_column"&gt; &lt;property name="prefix" value="t"/&gt; &lt;/include&gt; from t_role t where t.role_name like concat('%',#&#123;roleName&#125;,'%') and t.note like concat('%',#&#123;note&#125;,'%')&lt;/select&gt;这个功能在使用关联查询的时候较为方便。级联🎉MyBatis级联cache🎉MyBatis缓存机制《深入浅出MyBatis技术原理与实战》读书笔记]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis配置文件]]></title>
    <url>%2FMyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[MyBatis配置文件mybatis-config.xml包含：■ properties：用于配置属性信息。■ settings：用于配置MyBatis的运行时方式。■ typeAliases：配置类型别名，可以在xml中用别名取代全限定名。■ typeHandlers：配置类型处理器。■ plugins：配置拦截器，用于拦截sql语句的执行。■ environments：配置数据源信息、连接池、事务属性等。■ mappers：配置SQL映射文件。注意：这些配置必须按照上述的顺序进行配置！]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis typeHandler]]></title>
    <url>%2FMyBatis-typeHandler.html</url>
    <content type="text"><![CDATA[MyBatis在设置参数或者从结果集中获取参数的时候，都会用到注册了的typeHandler进行处理。typeHandler的作用为将参数从javaType转为jdbcType，或者从数据库取出结果时把jdbcType转为javaType。带的typeHandler类型处理器Java类型JDBC类型BooleanTypeHandlerjava.lang.Boolean,boolean数据库兼容的BOOLEANByteTypeHandlerjava.lang.Byte,byte数据库兼容的NUMERIC或BYTEShortTypeHandler&nbsp;&nbsp;&nbsp;&nbsp;java.lang.Short,short数据库兼容的NUMERIC或SHORT INTEGERIntegerTypeHandler&nbsp;java.lang.Integer,int数据库兼容的NUMERIC或INTEGERLongTypeHandler&nbsp;java.lang.Long,long数据库兼容的NUMERIC或LONG INTEGERFloatTypeHandler&nbsp;java.lang.Float,float数据库兼容的NUMERIC或FLOATDoubleTypeHandler&nbsp;java.lang.Double,double数据库兼容的NUMERIC或DOUBLEBigDecimalTypeHandlerjava.math.BigDecimal数据库兼容的NUMERIC或DECIMALStringTypeHandler&nbsp;java.lang.StirngCHAR,VARCHARClobypeHandler&nbsp;java.lang.StringCLOB,LONGVARCHARNStringTypeHanlerjava.lang.StringNVARCHAR,NCHARNClobTypeHandler&nbsp;java.lang.StringNNCLOBByteArrayTypeHandler&nbsp;byte[]数据库兼容的字节流类型BlobTypeHandler&nbsp;byte[]BLOB,LONGVARBINARYDateTypeHandler&nbsp;java.util.DateTIMESTAMPDateOnlyTypeHandler&nbsp;java.util.DateDATETimeOnlyTypeHandler&nbsp;java.util.DateTIMESqlTimestampTypeHandler&nbsp;java.sql.TimestampTIMESTAMPSqlDateTypeHandler&nbsp;java.sql.DateDATESqlTimeTypeHandler&nbsp;java.sql.TimeTIMEObjectTypeHandler&nbsp;AnyOTHER或未指定类型EnumTypeHandler&nbsp;Enumeration TypeVARCHAR或任意兼容的字符串类型，存 储枚举的名称EnumOrdinalTypeHandler&nbsp;Enumeration Type任何兼容的NUMERIC或DOUBLE类型， 存储枚举的索引为了演示自带的typeHandler，新建一张表：1234567CREATE TABLE `t_role` ( `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '编号', `role_name` varchar(60) NOT NULL COMMENT '角色名称', `note` varchar(1024) DEFAULT NULL COMMENT '备注', `is_girl` varchar(20) DEFAULT NULL COMMENT '是否为女孩', PRIMARY KEY (`id`))库表对应的实体类Role略。接口RoleMapper中定义一个createRole()抽象方法：1public int createRole(Role role);映射文件：123456&lt;insert id="createRole" parameterType="role"&gt; &lt;![CDATA[ insert into t_role(role_name,note,is_girl) values (#&#123;roleName&#125;,#&#123;note&#125;, #&#123;isGirl&#125;) ]]&gt;&lt;/insert&gt;测试插入方法：12345678910......sqlSession = SqlSessionFactoryUtil.openSqlSession();RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);Role role = new Role();role.setRoleName("雏田");role.setNote("日向雏田");role.setIsGirl(Boolean.TRUE);roleMapper.createRole(role);sqlSession.commit();......查询数据库：1234567mysql&gt; select * from t_role;+----+-----------+----------+---------+| id | role_name | note | is_girl |+----+-----------+----------+---------+| 1 | 雏田 | 日向雏田 | 1 |+----+-----------+----------+---------+1 row in set (0.00 sec)从结果中可以看出，默认的BooleantypeHandler将true转换为了1。如果想把true转换为Y,false转换为N,我们可以自定义BooleantypeHandler。自定义typeHandler自定义typeHandler可以通过继承BasetypeHandler或者实现typeHandler接口来实现，现自定义一个BooleanTypeHandler：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mrbird.leanote.typehandler; import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.TypeHandler; public class BooleanTypeHandler implements TypeHandler&lt;Boolean&gt;&#123; @Override public Boolean getResult(ResultSet arg0, String arg1) throws SQLException &#123; String str = arg0.getString(arg1); Boolean flag = Boolean.FALSE; if(str.equalsIgnoreCase("Y"))&#123; flag = Boolean.TRUE; &#125; return flag; &#125; @Override public Boolean getResult(ResultSet arg0, int arg1) throws SQLException &#123; String str = arg0.getString(arg1); Boolean flag = Boolean.FALSE; if(str.equalsIgnoreCase("Y"))&#123; flag = Boolean.TRUE; &#125; return flag; &#125; @Override public Boolean getResult(CallableStatement arg0, int arg1) throws SQLException &#123; String str = arg0.getString(arg1); Boolean flag = Boolean.FALSE; if(str.equalsIgnoreCase("Y"))&#123; flag = Boolean.TRUE; &#125; return flag; &#125; @Override public void setParameter(PreparedStatement arg0, int arg1, Boolean arg2, JdbcType arg3) throws SQLException &#123; Boolean flag = (Boolean) arg2; String value = flag == true ? "Y" : "N"; arg0.setString(arg1, value); &#125;&#125;在mybatis-config.xml文件中配置该typeHandler：1234&lt;typeHandlers&gt; &lt;typeHandler javaType="Boolean" jdbcType="VARCHAR" handler="mrbird.leanote.typehandler.BooleanTypeHandler" /&gt;&lt;/typeHandlers&gt;然后在映射文件中对需要转换的字段标注javaType和jdbcType，或者无需在mybatis-config.xml中注册直接在映射文件中指明typeHandler的路径即可。指明javaType和jdbcType，与注册中的一致即可找到相对应的typeHandler：123456&lt;insert id="createRole" parameterType="role"&gt; &lt;![CDATA[ insert into t_role(role_name,note,is_girl) values (#&#123;roleName&#125;,#&#123;note&#125;, #&#123;isGirl,javaType=Boolean,jdbcType=VARCHAR&#125;) ]]&gt;&lt;/insert&gt;或指明typeHandler路径：123456&lt;insert id="createRole" parameterType="role"&gt; &lt;![CDATA[ insert into t_role(role_name,note,is_girl) values (#&#123;roleName&#125;,#&#123;note&#125;, #&#123;isGirl,typeHandler=mrbird.leanote.typehandler.BooleanTypeHandler&#125;) ]]&gt;&lt;/insert&gt;测试：12345678910......sqlSession = SqlSessionFactoryUtil.openSqlSession();RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);Role role = new Role();role.setRoleName("鸣人");role.setNote("旋涡鸣人");role.setIsGirl(Boolean.FALSE);roleMapper.createRole(role);sqlSession.commit();......查询数据库：12345678mysql&gt; select * from t_role;+----+-----------+----------+---------+| id | role_name | note | is_girl |+----+-----------+----------+---------+| 1 | 雏田 | 日向雏田 | 1 || 2 | 鸣人 | 旋涡鸣人 | N |+----+-----------+----------+---------+2 rows in set (0.00 sec)可发现，false已经转换为N了。枚举类型typeHandlerMyBatis自带两种枚举类型处理器：1.org.apache.ibatis.type.EnumOrdinalTypeHandler2.org.apache.ibatis.type.EnumTypeHandlerEnumOrdinalTypeHandler使用整数下标传递，EnumTypeHandler使用枚举字符串传递。创建一个枚举类型Sex：1234567891011121314151617181920212223package mrbird.leanote.enums; public enum Sex &#123; MALE(1,"男"),FEMALE(2,"女"); private int id; private String name; private Sex(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;EnumOrdinalTypeHandler创建一张表来演示EnumOrdinalTypeHandler：12345678CREATE TABLE `t_student` ( `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '编号', `cnname` varchar(60) NOT NULL COMMENT '学生姓名', `sex` tinyint(4) NOT NULL COMMENT '性别', `selfcard_no` int(20) NOT NULL COMMENT '学生证号', `note` varchar(1024) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`))这里sex字段类型为tinyint类型。Student实体类略。定义一个interface：123456789package mrbird.leanote.mapper; import java.util.List;import mrbird.leanote.pojo.Student; public interface StudentMapper &#123; public List&lt;Student&gt; getAllStudent(); public int createStudent(Student stu);&#125;对应的映射文件StudentMapper.xml：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentMapper"&gt; &lt;resultMap type="student" id="studentList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="cnname" property="cnName"/&gt; &lt;result column="sex" property="sex" typeHandler="org.apache.ibatis.type.EnumOrdinalTypeHandler"/&gt; &lt;result column="selfcard_no" property="selfCardNo"/&gt; &lt;result column="note" property="note"/&gt; &lt;/resultMap&gt; &lt;select id="getAllStudent" resultMap="studentList"&gt; &lt;![CDATA[select * from t_student]]&gt; &lt;/select&gt; &lt;insert id="createStudent" parameterType="student"&gt; &lt;![CDATA[ insert into t_student(cnname,sex,selfcard_no,note) values ( #&#123;cnName&#125;, #&#123;sex,typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;, #&#123;selfCardNo&#125;,#&#123;note&#125;) ]]&gt; &lt;/insert&gt;&lt;/mapper&gt;测试createStudent方法：12345678910...StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);Student stu = new Student();stu.setCnName("鸣人");stu.setSex(Sex.MALE);stu.setSelfCardNo(1L);stu.setNote("漩涡鸣人");studentMapper.createStudent(stu);sqlSession.commit();...查询数据库：1234567mysql&gt; select * from t_student;+----+--------+-----+-------------+----------+| id | cnname | sex | selfcard_no | note |+----+--------+-----+-------------+----------+| 1 | 鸣人 | 0 | 1 | 漩涡鸣人 |+----+--------+-----+-------------+----------+1 row in set (0.00 sec)可见EnumOrdinalTypeHandler已经将MALE转换为了MALE的下标了。测试getAllStudent方法：1234567...StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);List&lt;Student&gt; students = studentMapper.getAllStudent();for(Student stu : students)&#123; System.out.println(stu.getCnName()+"性别："+stu.getSex());&#125;...控制台输出：1鸣人性别：MALEEnumTypeHandler为了演示EnumTypeHandler，我们需要把sex字段类型改为VARCHAR：1alter table t_student modify column sex VARCHAR(20);修改映射文件中的typeHandler：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mrbird.leanote.mapper.StudentMapper"&gt; &lt;resultMap type="student" id="studentList"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="cnname" property="cnName"/&gt; &lt;result column="sex" property="sex" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/&gt; &lt;result column="selfcard_no" property="selfCardNo"/&gt; &lt;result column="note" property="note"/&gt; &lt;/resultMap&gt; &lt;select id="getAllStudent" resultMap="studentList"&gt; &lt;![CDATA[select * from t_student]]&gt; &lt;/select&gt; &lt;insert id="createStudent" parameterType="student"&gt; &lt;![CDATA[ insert into t_student(cnname,sex,selfcard_no,note) values ( #&#123;cnName&#125;, #&#123;sex,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;, #&#123;selfCardNo&#125;,#&#123;note&#125;) ]]&gt; &lt;/insert&gt;&lt;/mapper&gt;测试createStudent方法：12345678910...StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);Student stu = new Student();stu.setCnName("雏田");stu.setSex(Sex.FEMALE);stu.setSelfCardNo(2L);stu.setNote("日向雏田");studentMapper.createStudent(stu);sqlSession.commit();...查询数据库：1234567mysql&gt; select * from t_student where selfcard_no = '2';+----+--------+--------+-------------+----------+| id | cnname | sex | selfcard_no | note |+----+--------+--------+-------------+----------+| 2 | 雏田 | FEMALE | 2 | 日向雏田 |+----+--------+--------+-------------+----------+1 row in set (0.00 sec)可见EnumTypeHandler保存的是枚举字符串。《深入浅出MyBatis技术原理与实战》读书笔记]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis配置数据库]]></title>
    <url>%2FMyBatis%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
    <content type="text"><![CDATA[xml文件配置直接在mybatis-config.xml文件中配置：123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="6742530" /&gt; &lt;/dataSource&gt;properties配置文件为了方便日后维护修改，我们用properties配置文件来配置数据库属性：db.properties：1234driver:com.mysql.jdbc.Driverurl:jdbc:mysql://localhost:3306/mybatisusername:rootpassword:123456在mybatis-config.xml文件中引入：1234567&lt;properties resource="db.properties"/&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;/dataSource&gt;参数传递假如要对db.properties文件中的用户名和密码进行加密，那我们则需要在生成SqlSessionFactory的时候对用户名和密码解密（假设解密方法为decode()）：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SqlSessionFactoryUtil &#123; InputStream cfgStream = null; Reader cfgReader = null; InputStream proStream = null; Reader proReader = null; Properties properties = null; private static SqlSessionFactory sqlSessionFactory = null; //类线程锁 private static final Class CLASS_LOCK = SqlSessionFactoryUtil.class; //私有化构造函数 private SqlSessionFactoryUtil()&#123;&#125; //构建SqlSessionFactory public static SqlSessionFactory initSqlSessionFactory()&#123; try&#123; //读入配置文件流 cfgStream = Resources.getResourceAsStream("mybatis-config.xml"); cfgReader = new InputStreamReader(cfgStream); //读入属性文件 proStream = Resources.getResourceAsStream(db.properties); proReader = new InputStreamReader(proStream); properties = new Properties(); properties.load(proReader); properties.setProperty("username", decode(properties.getProperty("username"))); properties.setProperty("password", decode(properties.getProperty("password"))); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; synchronized (CLASS_LOCK) &#123; if(sqlSessionFactory == null)&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(cfgStream); &#125; &#125; return sqlSessionFactory; &#125; //创建SqlSession public static SqlSession openSqlSession()&#123; if(sqlSessionFactory == null)&#123; initSqlSessionFactory(); &#125; return sqlSessionFactory.openSession(); &#125;&#125;environments配置环境1234567891011121314&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 采用JDBC事务管理 --&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="autoCommit" value="false"/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="6742530" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;default属性表明默认选用哪个数据库。id属性为一个数据库配置的标识，可以同时配置多个数据库。dataSource的type属性可选非连接池UNPOOLED，连接池POOLED和JNDI《深入浅出MyBatis技术原理与实战》读书笔记]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis Guide]]></title>
    <url>%2FMyBatis-Guide.html</url>
    <content type="text"><![CDATA[准备工作创建表t_role：123456create table T_ROLE( id INT(20) not null auto_increment COMMENT '编号', role_name VARCHAR(60) not null comment '角色名称', note varchar(1024) comment '备注', PRIMARY KEY (id));添加MyBatis jar包和mySql连接驱动：MyBatis-jareclipse文件路径：各文件说明：文件作用MyBatisMain.java运行MyBatis程序的入口，包含main方法RoleMapper.java映射器RoleMapper.xml映射器配置文件Role.javaPOJOSqlSessionFactoryUtil.java构建SqlSessionFactory，并创建SqlSessionmybatis-config.xmlMyBatis配置配置mybatis-config.xml1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;!--给实体类起一个别名 role --&gt; &lt;typeAlias type="mrbird.leanote.pojo.Role" alias="role" /&gt; &lt;/typeAliases&gt; &lt;!--数据源配置 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 采用JDBC事务管理 --&gt; &lt;transactionManager type="JDBC"&gt; &lt;property name="autoCommit" value="false"/&gt; &lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="6742530" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--RoleMapper.xml装载进来 同等于把'dao'的实现装载进来 --&gt; &lt;mapper resource="mrbird/leanote/mapper/RoleMapper.xml" /&gt; &lt;/mappers&gt; &lt;/configuration&gt;构建SqlSessionFactory利用mybatis-config.xml完成SqlSessionFactory的构建，并创建SqlSession。采用单例的形式构建SqlSessionFactory。123456789101112131415161718192021222324252627282930313233343536373839package mrbird.leanote.util; import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder; public class SqlSessionFactoryUtil &#123; private static SqlSessionFactory sqlSessionFactory = null; //类线程锁 private static final Class CLASS_LOCK = SqlSessionFactoryUtil.class; //私有化构造函数 private SqlSessionFactoryUtil()&#123;&#125; //构建SqlSessionFactory public static SqlSessionFactory initSqlSessionFactory()&#123; String resource = "mybatis-config.xml"; InputStream in = null; try &#123; in = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; synchronized (CLASS_LOCK) &#123; if(sqlSessionFactory == null)&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); &#125; &#125; return sqlSessionFactory; &#125; //创建SqlSession public static SqlSession openSqlSession()&#123; if(sqlSessionFactory == null)&#123; initSqlSessionFactory(); &#125; return sqlSessionFactory.openSession(); &#125;&#125;POJO创建一个与库表对应的POJO：12345678910111213141516171819202122232425package mrbird.leanote.pojo; public class Role &#123; private Long id; private String roleName; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; &#125;接口与映射文件新建一个RoleMapper接口，包含简单的CRUD抽象方法：123456789package mrbird.leanote.mapper; import mrbird.leanote.pojo.Role; public interface RoleMapper &#123; public Role getRole(Long id); public int deleteRole(Long id); public int createRole(Role role);&#125;编写RoleMapper.xml映射文件，让其自动映射RoleMapper interface：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!--和接口路径和名称保持一致，MyBatis会自动帮我们找到这个 Mapper--&gt; &lt;mapper namespace="mrbird.leanote.mapper.RoleMapper"&gt; &lt;!-- id与接口方法名一致，参数类型与接口方法参数类型一致，返回值类型与接口方法一致 'role'为mybatis-config.xml中定义的别名 --&gt; &lt;select id="getRole" parameterType="long" resultType="role"&gt; &lt;![CDATA[ select id,role_name as roleName,note from t_role where id = #&#123;id&#125; ]]&gt; &lt;/select&gt; &lt;insert id="createRole" parameterType="role"&gt; &lt;![CDATA[ insert into t_role(role_name,note) values (#&#123;roleName&#125;,#&#123;note&#125;) ]]&gt; &lt;/insert&gt; &lt;delete id="deleteRole" parameterType="long"&gt; &lt;![CDATA[ delete from t_role where id = #&#123;id&#125; ]]&gt; &lt;/delete&gt;&lt;/mapper&gt;测试测试插入数据：12345678910111213141516171819202122232425262728package mrbird.leanote.mian; import mrbird.leanote.mapper.RoleMapper;import mrbird.leanote.pojo.Role;import mrbird.leanote.util.SqlSessionFactoryUtil;import org.apache.ibatis.session.SqlSession; public class MyBatisMain &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; sqlSession = SqlSessionFactoryUtil.openSqlSession(); RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); Role role = new Role(); role.setRoleName("mrbird"); role.setNote("the fun of code"); roleMapper.createRole(role); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally&#123; if(sqlSession != null)&#123; sqlSession.close(); &#125; &#125; &#125;&#125;运行后查询数据库：1234567mysql&gt; select * from t_role;+----+-----------+-----------------+| id | role_name | note |+----+-----------+-----------------+| 1 | mrbird | the fun of code |+----+-----------+-----------------+1 row in set (0.00 sec)创建成功。测试删除：123456789101112131415161718public class MyBatisMain &#123; public static void main(String[] args) &#123; SqlSession sqlSession = null; try &#123; sqlSession = SqlSessionFactoryUtil.openSqlSession(); RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); roleMapper.deleteRole(1L); sqlSession.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); &#125;finally&#123; if(sqlSession != null)&#123; sqlSession.close(); &#125; &#125; &#125;&#125;运行后查询数据库：12mysql&gt; select * from t_role;Empty set (0.00 sec)删除成功。《深入浅出MyBatis技术原理与实战》读书笔记]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的LHS和RHS]]></title>
    <url>%2FJS-%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS.html</url>
    <content type="text"><![CDATA[LHS和RHS的含义是”赋值操作符的左侧或右侧”，并不一定意味着就是“=赋值操作符的左侧或右侧“。赋值操作还有其他几种形式，因此在概念上最好将其理解为”赋值操作的目标是谁（LHS）“以及”谁是赋值操作的源头（RHS）“。比如下面这个例子：1234function foo(a)&#123; console.log(a);&#125;foo(2);最后一行foo(..)函数的调用需要对foo进行RHS引用，意味着去找到”foo的值，并把它给我“。代码中，隐式的 a = 2 操作进行了一次LHS查询，找到赋值操作的目标a——foo函数的形式参数。接下来对a进行RHS引用，并将得到的值传给console.log(..)。console.log(..)本身也需要对console进行一次RHS引用，查找是否有一个叫作log的方法。当LHS查询失败时，引擎会在全局作用域中创建该变量：12345function foo(a)&#123; b = a;&#125;foo(2);console.log(window.b); //2当RHS查询失败时，引擎会抛出ReferenceError异常：1234function foo()&#123; var b = a;&#125;foo();引擎抛出：Uncaught ReferenceError: a is not defined。《你不知道的JavaScript上卷》读书笔记]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2FAjax.html</url>
    <content type="text"><![CDATA[JavaScript AjaxXMLHttpRequest对象1234567891011function getXHR() &#123; //根据对象判断浏览器 if(window.XMLHttpRequest) &#123; //不是IE return new XMLHttpRequest(); &#125;else&#123; //IE return new ActiveXObject("Microsoft.XMLHttp"); &#125;&#125;var xhr = getXHR();get请求打开请求：1xhr.open("get", "example.php?name1=value1&amp;name2=value2", true);true表示发送异步请求。下面这个函数可以辅助向现有URL 的末尾添加查询字符串参数：12345function addURLParam(url, name, value) &#123; url += (url.indexOf("?") == -1 ? "?" : "&amp;"); url += encodeURIComponent(name) + "=" + encodeURIComponent(value); return url;&#125;addURLParam()函数接受三个参数：要添加参数的URL、参数的名称和参数的值。下面是使用这个函数来构建请求URL 的示例。12345678var url = "example.php";//添加参数url = addURLParam(url, "name", "Nicholas");url = addURLParam(url, "book", "Professional JavaScript");//初始化请求xhr.open("get", url, false);发送请求：1xhr.send(null);这里的send()方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器来说是必需的。调用send()之后，请求就会被分派到服务器。回调函数：XHR 对象的readyState 属性可取的值：0：未初始化。尚未调用open()方法。1：启动。已经调用open()方法，但尚未调用send()方法。2：发送。已经调用send()方法，但尚未接收到响应。3：接收。已经接收到部分响应数据。4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。只要readyState 属性的值由一个值变成另一个值，都会触发一次readystatechange 事件。可以利用这个事件来检测每次状态变化后readyState 的值。123456789xhr.onreadystatechange = function()&#123;callback(xhr);&#125;;//回调函数function callback(xhr) &#123; //当请求结束且没报错时 if(xhr.readyState==4 &amp;&amp; xhr.status==200) &#123; var txt = xhr.responseText; console.log(txt); &#125;&#125; ​在收到响应后，响应的数据会自动填充XHR 对象的属性，相关的属性简介如下。responseText：作为响应主体被返回的文本。responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM 文档。status：响应的HTTP 状态。statusText：HTTP 状态的说明。post请求12345678910xhr.open("post", "postexample.php", true);xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");//发送form表单数据var form = document.getElementById("form");xhr.send(serialize(form));//发送普通数据xhr.send("name = Nicholas");xhr.send("book = Professional JavaScript");jQuery Ajaxload()load() 方法通过 AJAX 请求从服务器加载数据，并把返回的数据放置到指定的元素中。语法：1load(url,data,function(response,status,xhr));参数描述url规定要将请求发送到哪个 URL。data可选。规定连同请求发送到服务器的数据。function(response,status,xhr)可选。规定当请求完成时运行的函数。额外的参数：response&amp;nbsp - 包含来自请求的结果数据status&amp;nbsp - 包含请求的状态（”success”, “notmodified”, “error”, “timeout” 或 “parsererror”）xhr&amp;nbsp - 包含 XMLHttpRequest 对象如在id为result的div中加载test.html页面：1$("#result").load("test.html");\$.get()和\$.post()$.get()方法使用 HTTP GET 请求从服务器加载数据。语法：1$.get(URL,data,function(data,status,xhr),dataType);参数：参数描述URL必需。规定您需要请求的 URL。data可选。规定连同请求发送到服务器的数据。function(data,status,xhr)可选。规定当请求成功时运行的函数。额外的参数：data&amp;nbsp - 包含来自请求的结果数据status&amp;nbsp - 包含请求的状态（”success”、”notmodified”、”error”、”timeout”、”parsererror”）xhr&amp;nbsp - 包含 XMLHttpRequest 对象dataType可选。规定预期的服务器响应的数据类型。默认地，jQuery 会智能判断。可能的类型：xml - 一个 XML 文档html - HTML 作为纯文本text - 纯文本字符串script - 以 JavaScript 运行响应，并以纯文本返回json - 以 JSON 运行响应，并以 JavaScript 对象返回jsonp - 使用 JSONP 加载一个 JSON 块，将添加一个 “?callback=?” 到 URL 来规定回调如：123456$.get("get.php",&#123; userName : $("#userName").val().trim(), content : $("#content").val().trim() &#125;,function(data)&#123; // do something&#125;,"json");$.post()和$.get()类似，区别在于$.post()可发送的数据量更大。\$.ajax()语法：1$.ajax(&#123;name:value, name:value, ... &#125;)下面的表格中列出了可能的名称/值：名称值/描述async布尔值，表示请求是否异步处理。默认是 true。beforeSend( xhr )发送请求前运行的函数。cache布尔值，表示浏览器是否缓存被请求页面。默认是 true。complete( xhr,status )请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。contentType发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。context为所有 AJAX 相关的回调函数规定 “this” 值。data规定要发送到服务器的数据。dataFilter( data , type )用于处理 XMLHttpRequest 原始响应数据的函数。dataType预期的服务器响应的数据类型。error( xhr,status,error )如果请求失败要运行的函数。global布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。ifModified布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。jsonp在一个 jsonp 中重写回调函数的字符串。jsonpCallback在一个 jsonp 中规定回调函数的名称。password规定在 HTTP 访问认证请求中使用的密码。processData布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。scriptCharset规定请求的字符集。success( result,status,xhr )当请求成功时运行的函数。timeout设置本地的请求超时时间（以毫秒计）。traditional布尔值，规定是否使用参数序列化的传统样式。type规定请求的类型（GET 或 POST）。url规定发送请求的 URL。默认是当前页面。username规定在 HTTP 访问认证请求中使用的用户名。xhr用于创建 XMLHttpRequest 对象的函数。]]></content>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM location]]></title>
    <url>%2FBOM-location.html</url>
    <content type="text"><![CDATA[使用location 对象可以通过很多方式来改变浏览器的位置。如：1location.assign("http://www.wrox.com");或：12window.location = "http://www.wrox.com";location.href = "http://www.wrox.com";另外，修改location 对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将hash、search、hostname、pathname 和port 属性设置为新值来改变URL。12345678910111213141516//假设初始URL 为http://www.wrox.com/WileyCDA/ //将URL 修改为"http://www.wrox.com/WileyCDA/#section1"location.hash = "#section1"; //将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"location.search = "?q=javascript"; //将URL 修改为"http://www.yahoo.com/WileyCDA/"location.hostname = "www.yahoo.com"; //将URL 修改为"http://www.yahoo.com/mydir/"location.pathname = "mydir"; //将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"location.port = 8080;使用location.replace(url)会导致浏览器位置改变，但不会在历史记录中生成新记录。”后退”按钮将不可点击。reload()：12location.reload(); //重新加载（有可能从缓存中加载）location.reload(true); //重新加载（从服务器重新加载）]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Function类型]]></title>
    <url>%2FJavaScript-Function%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[函数声明与函数表达式函数声明长这样：123function sum(num1, num2)&#123; return num1 + num2;&#125;函数表达式长这样：123var sum = function(num1, num2)&#123; return num1 + num2;&#125;;区别：解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。如下面语句不报错：1234alert(sum(10,10));function sum(num1, num2)&#123; return num1 + num2;&#125;而下面语句报错：1234alert(sum(10,10));var sum = function(num1, num2)&#123; return num1 + num2;&#125;;除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。作为值的函数因为ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。如：12345678function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument);&#125;function add10(num)&#123; return num + 10;&#125;var result1 = callSomeFunction(add10, 10);alert(result1); //20函数内部属性arguments在函数体内可以通过arguments 对象来访问参数数组，从而获取传递给函数的每一个参数，比如定义一个计算任意个参数的和的函数：1234567function sum() &#123; var s = 0; for(var i=0;i&lt;arguments.length;i++) &#123; s += arguments[i]; &#125; return s;&#125;虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。请看下面这个非常经典的阶乘函数。1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125;这个函数的执行与函数名factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee。1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125;thisthis引用的是函数据以执行的环境对象——或者也可以说是this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是window）。如：12345678window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //"red"o.sayColor = sayColor;o.sayColor(); //"blue"callerECMAScript 5 也规范化了另一个函数对象的属性：caller。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。例如：1234567function outer()&#123; inner();&#125;function inner()&#123; alert(inner.caller);&#125;outer();以上代码会导致警告框中显示outer()函数的源代码。因为outer()调用了inner()，所以inner.caller 就指向outer()。属性和方法ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length 和prototype。lengthlength属性表示函数希望接收的命名参数的个数，如下面的例子所示。123456789101112function sayName(name)&#123; alert(name);&#125;function sum(num1, num2)&#123; return num1 + num2;&#125;function sayHi()&#123; alert("hi");&#125;alert(sayName.length); //1alert(sum.length); //2alert(sayHi.length); //0prototype对于ECMAScript 中的引用类型而言，prototype是保存它们所有实例方法的真正所在。如：12345678910111213function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicholas"var person2 = new Person();person2.sayName(); //"Nicholas"alert(person1.sayName == person2.sayName); //true可以通过isPrototypeOf()方法来确定一个对象是否是另一个对象的原型：12alert(Person.prototype.isPrototypeOf(person1)); //truealert(Person.prototype.isPrototypeOf(person2)); //true使用Object.getPrototypeOf()可以方便地取得一个对象的原型：12alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //"Nicholas"每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。12345678910111213function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg";alert(person1.name); //"Greg"——来自实例alert(person2.name); //"Nicholas"——来自原型使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。123456789101112131415function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg";alert(person1.name); //"Greg"——来自实例alert(person2.name); //"Nicholas"——来自原型delete person1.name;alert(person1.name); //"Nicholas"——来自原型使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从Object 继承来的）只在给定属性存在于对象实例中时，才会返回true。123456789101112131415161718192021function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();alert(person1.hasOwnProperty("name")); //false person1.name = "Greg";alert(person1.name); //"Greg"——来自实例alert(person1.hasOwnProperty("name")); //truealert(person2.name); //"Nicholas"——来自原型alert(person2.hasOwnProperty("name")); //false delete person1.name;alert(person1.name); //"Nicholas"——来自原型alert(person1.hasOwnProperty("name")); //false在单独使用in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。看一看下面的例子。12345678910111213141516171819202122232425262728function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;; var person1 = new Person();var person2 = new Person(); alert(person1.hasOwnProperty("name")); //falsealert("name" in person1); //true person1.name = "Greg";alert(person1.name); //"Greg" ——来自实例alert(person1.hasOwnProperty("name")); //truealert("name" in person1); //true alert(person2.name); //"Nicholas" ——来自原型alert(person2.hasOwnProperty("name")); //falsealert("name" in person2); //true delete person1.name;alert(person1.name); //"Nicholas" ——来自原型alert(person1.hasOwnProperty("name")); //falsealert("name" in person1); //true要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5 的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。1234567891011121314151617function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;; var keys = Object.keys(Person.prototype);alert(keys); //"name,age,job,sayName" var p1 = new Person();p1.name = "Rob";p1.age = 31;var p1keys = Object.keys(p1);alert(p1keys); //"name,age"如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。12345678var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys); //"constructor,name,age,job,sayName" var p1 = new Person();p1.name = "Rob";p1.age = 31;var p1keys = Object.getOwnPropertyNames(p1);alert(p1keys); //"name,age"每个函数都包含两个非继承而来的方法：apply()和call()。apply()和call()这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this 对象的值。apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments对象。例如：1234567891011function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum1(num1, num2)&#123; return sum.apply(this, arguments); // 传入arguments 对象&#125;function callSum2(num1, num2)&#123; return sum.apply(this, [num1, num2]); // 传入数组&#125;alert(callSum1(10,10)); //20alert(callSum2(10,10)); //20在这里，this就相当于window。对于call()方法而言，第一个参数是this 值没有变化，变化的是其余参数都直接传递给函数。1234567function sum(num1, num2)&#123; return num1 + num2;&#125;function callSum(num1, num2)&#123; return sum.call(this, num1, num2);&#125;alert(callSum(10,10)); //20事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。12345678910window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125; sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blueECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值。例如：1234567window.color = "red";var o = &#123; color: "blue" &#125;;function sayColor()&#123; alert(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //blue ​《JavaScript高级程序设计》读书笔记]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript CreateObject]]></title>
    <url>%2FJavaScript-CreateObject.html</url>
    <content type="text"><![CDATA[创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数。如：123456789101112131415161718function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ["Shelby", "Court"];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; return this.name; &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor");alert(person1.friends); //"Shelby,Count"alert(person2.friends); //"Shelby,Count"alert(person1.friends === person2.friends); //falsealert(person1.sayName === person2.sayName); //true在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor 和方法sayName()则是在原型中定义的。而修改了person1.friends（向其中添加一个新字符串），并不会影响到person2.friends，因为它们分别引用了不同的数组。 这种构造函数与原型混成的模式，是目前在ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。《JavaScript高级程序设计》读书笔记]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Array类型]]></title>
    <url>%2FJavaScript-Array%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[检测数组ECMAScript 5 新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组。123if (Array.isArray(value))&#123; //对数组执行某些操作&#125;转换方法所有对象都具有toLocaleString()、toString()和valueOf()方法。其中，调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而 调用valueOf()返回的还是数组。1234var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组alert(colors.toString()); // red,blue,greenalert(colors.valueOf()); // red,blue,greenalert(colors); // red,blue,green最后一行代码直接将数组传递给了alert()。由于alert()要接收字符串参数，所以它会在后台调用toString()方法，由此会得到与直接调toString()方法相同的结果。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。123var colors = ["red", "green", "blue"];alert(colors.join(",")); //red,green,bluealert(colors.join("||")); //red||green||blue栈方法栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——栈的顶部。ECMAScript 为数组专门提供了push()和pop()方法，以便实现类似栈的行为。push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。12345678var colors = new Array(); // 创建一个数组var count = colors.push("red", "green"); // 推入两项alert(count); //2count = colors.push("black"); // 推入另一项alert(count); //3var item = colors.pop(); // 取得最后一项alert(item); //"black"alert(colors.length); //2队列方法队列数据结构的访问规则是FIFO（First-In-First-Out， 先进先出）。队列在列表的末端添加项，从列表的前端移除项。shift()方法移除数组中的第一个项并返回该项，同时将数组长度减1。12345678var colors = new Array(); //创建一个数组var count = colors.push("red", "green"); //推入两项alert(count); //2count = colors.push("black"); //推入另一项alert(count); //3var item = colors.shift(); //取得第一项alert(item); //"red"alert(colors.length); //2ECMAScript 还为数组提供了一个unshift()方法。顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。12345var colors = new Array(); //创建一个数组var count = colors.unshift("red", "green"); //推入两项alert(count); //2count = colors.unshift("black"); //推入另一项alert(count); //3重排序方法数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。reverse()方法会反转数组项的顺序。123var values = [1, 2, 3, 4, 5];values.reverse();alert(values); //5,4,3,2,1sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。123var values = [0, 1, 5, 10, 15];values.sort();alert(values); //0,1,10,15,5sort()方法还可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。123456function compare(value1, value2)&#123; return value2 - value1;&#125;var values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 15,10,5,1,0操作方法concat()方法可以基于当前数组中的所有项创建一个新数组。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。1234var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]);alert(colors); //red,green,bluealert(colors2); //red,green,blue,yellow,black,brownslice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。12345var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellowsplice()方法：12345678910var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); // 删除第一项alert(colors); // green,bluealert(removed); // red，返回的数组中只包含一项removed = colors.splice(1, 0, "yellow", "orange"); // 从位置1 开始插入两项alert(colors); // green,yellow,orange,bluealert(removed); // 返回的是一个空数组removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项alert(colors); // green,red,purple,orange,bluealert(removed); // yellow，返回的数组中只包含一项位置方法ECMAScript 5 为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。没有找到返回-1。12345var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)); //3alert(numbers.lastIndexOf(4)); //5alert(numbers.indexOf(4, 4)); //5alert(numbers.lastIndexOf(4, 4)); //3迭代方法every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。以上方法都不会修改数组中的包含的值。123456789var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(someResult); //true以上代码调用了every()和some()，传入的函数只要给定项大于2 就会返回true。对于every()，它返回的是false，因为只有部分数组项符合条件。对于some()，结果就是true，因为至少有一项是大于2 的。filter()函数：12345var numbers = [1,2,3,4,5,4,3,2,1];var filterResult = numbers.filter(function(item, index, array)&#123; return (item &gt; 2);&#125;);alert(filterResult); //[3,4,5,4,3]map()也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。例如，可以给数组中的每一项乘以2，然后返回这些乘积组成的数组：12345var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(mapResult); //[2,4,6,8,10,8,6,4,2]forEach()用于迭代数组：1234var numbers = [1,2,3,4,5,4,3,2,1];numbers.forEach(function(item, index, array)&#123; //执行某些操作&#125;);归并方法使用reduce()方法可以执行求数组中所有值之和的操作，比如：12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15第一次执行回调函数，prev 是1，cur 是2。第二次，prev 是3（1 加2 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。 reduceRight()的作用类似，只不过方向相反而已：12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;);alert(sum); //15在这个例子中，第一次执行回调函数，prev 是5，cur 是4。当然，最终结果相同，因为执行的都是简单相加的操作。使用reduce()还是reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。极值12var values = [1, 2, 3, 4, 5, 6, 7, 8];var max = Math.max.apply(Math, values); //8《JavaScript高级程序设计》读书笔记]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP 标签文件]]></title>
    <url>%2FJSP-%E6%A0%87%E7%AD%BE%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[定制JSP标签可以实现一些JSTL和EL没有提供的功能，基本步骤就是编写标签处理器然后注册标签。从JSP2.0以后，可以直接编写标签文件（.tag）来代替定制JSP标签。相比定制JSP标签，标签文件无需编写Java代码，无需注册标签，只需要在tag文件中写代码逻辑即可。一个简单的例子：在WEB-INF下创建tags文件夹，然后在里面新建一个firstTag.tag文件：123456&lt;%@tag import="java.util.Date"%&gt;&lt;%@tag import="java.text.SimpleDateFormat"%&gt;&lt;% SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); out.print(sdf.format(new Date()));%&gt;然后在firstTagTest.jsp页面中使用它：12&lt;%@ taglib prefix="mt" tagdir="/WEB-INF/tags"%&gt;Today is:&lt;mt:firstTag/&gt;部署到Tomcat中，启动服务，访问该jsp，页面显示：That’ all.标签文件中的隐式对象：对象类型requestjavax.servlet.http.HttpServletRequestresponsejavax.servlet.http.HttpServletResponseoutjavax.servlet.jsp.JspWritersessionjavax.servlet.http.HttpSessionapplicationjavax.servlet.ServletContextconfigjavax.servlet.ServletConfigjspContextjavax.servlet.jsp.JspContext和Jsp的隐式对象类似。标签文件指令tag指令tag指令常用属性：属性描述display-name通过XML工具显示的简称，默认为标签名body-content标签主体内容的信息，可以为empty，tagdependent或scriptless（默认）import导入Java类型pageEncoding指定编码isELIgnoreds是否使用EL表达式include指令该指令可以引入静态文件（HTML文件）或动态文件（另一个标签文件）。如有静态HTML文件included.html：123456789101112131415161718192021222324252627282930313233343536&lt;table border=1&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style="text-align: center;"&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/td&gt; &lt;td style="text-align: center;"&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;request&lt;/td&gt; &lt;td&gt;javax.servlet.http.HttpServletRequest&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;response&lt;/td&gt; &lt;td&gt;javax.servlet.http.HttpServletResponse&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;out&lt;/td&gt; &lt;td&gt;javax.servlet.jsp.JspWriter&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;session&lt;/td&gt; &lt;td&gt;javax.servlet.http.HttpSession&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;application&lt;/td&gt; &lt;td&gt;javax.servlet.ServletContext&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;config&lt;/td&gt; &lt;td&gt;javax.servlet.ServletConfig&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;jspContext&lt;/td&gt; &lt;td&gt;javax.servlet.jsp.JspContext&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;included.tag文件：1234&lt;%@tag pageEncoding="utf-8" %&gt;&lt;% out.print("和Jsp的隐式对象类似。");%&gt;在include.tag标签中引用included.html和included.tag：1234&lt;%@tag pageEncoding="utf-8"%&gt;标签文件中的隐式对象：&lt;/br&gt;&lt;/br&gt;&lt;%@include file="/WEB-INF/tags/included.html"%&gt;&lt;/br&gt;&lt;%@include file="/WEB-INF/tags/included.tag"%&gt;在jsp页面中测试：123&lt;%@taglib prefix="mt" tagdir="/WEB-INF/tags" %&gt;&lt;%@page pageEncoding="utf-8" %&gt;&lt;mt:include/&gt;启动访问，页面显示：taglib指令该指令的作用就是在一个标签文件中使用另外一个标签，如现有taglibDemo.tag：12&lt;%@ taglib prefix="mt" tagdir="/WEB-INF/tags" %&gt;Today's date : &lt;mt:firstTag/&gt;该标签调用了第一个例子中创建的firstTag标签。attribute指令该指令在标签中使用属性，attribute常用的属性有：属性描述name属性名required是否式必须的，默认为falsetype&nbsp;&nbsp;&nbsp;&nbsp;类型，默认为String编写一个时间格式化标签formatDate.tag：1234567&lt;%@tag import="java.util.Date"%&gt;&lt;%@tag import="java.text.SimpleDateFormat"%&gt;&lt;%@ attribute name="fmt" required="true"%&gt;&lt;% SimpleDateFormat sdf = new SimpleDateFormat(fmt); out.print(sdf.format(new Date()));%&gt;jsp中测试：123&lt;%@ taglib prefix="mt" tagdir="/WEB-INF/tags" %&gt;&lt;mt:dateFormat fmt="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/br&gt;&lt;mt:dateFormat fmt="yyyyMMdd"/&gt;页面显示：variable指令用于定义标签文件的变量，常用的属性有：属性描述name-given变量名scope范围description描述如下标签，它有两个变量：longDate和shortDate：123456789101112&lt;%@tag import="java.text.SimpleDateFormat"%&gt;&lt;%@tag import="java.util.Date"%&gt;&lt;%@ variable name-given="longDate" %&gt;&lt;%@ variable name-given="shortDate" %&gt;&lt;% Date date = new Date(); SimpleDateFormat longFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); SimpleDateFormat shortFormat = new SimpleDateFormat("yyyy-MM-dd"); jspContext.setAttribute("longDate", longFormat.format(date)); jspContext.setAttribute("shortDate", shortFormat.format(date));%&gt;&lt;jsp:doBody/&gt;jsp页面引用：12345678&lt;%@ taglib prefix="tags" tagdir="/WEB-INF/tags" %&gt;Today's date:&lt;br/&gt;&lt;tags:varDemo&gt;In long format: $&#123;longDate&#125;&lt;br/&gt;In short format: $&#123;shortDate&#125;&lt;/tags:varDemo&gt;测试，页面显示：]]></content>
      <tags>
        <tag>servlet&amp;jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO Stream]]></title>
    <url>%2FIO-Stream.html</url>
    <content type="text"><![CDATA[我们编写的程序除了自身会定义一些数据信息外，经常还会引用外界的数据，或是将自身的数据发送到外界。比如，我们编写的程序想读取一个文本文件，又或者我们想将程序中的某些数据写入到一个文件中。这时我们就要使用输入与输出。什么是输入(read):输入是一个从外界进入到程序的方向，通常我们需要“读取”外界的数据时，使用输入。所以输入是用来读取数据的。什么是输出(write):输出是一个从程序发送到外界的方向，通常我们需要”写出”数据到外界时，使用输出。所以输出是用来写出数据的。InputStream是所有字节输入流的父类，其定义了基础的读取方法，常用的方法如下:1.int read():读取一个字节，以int形式返回，该int值的”低八位”有效，若返回值为-1则表示EOF。2.int read(byte[] d):尝试最多读取给定数组的length个字节并存入该数组，返回值为实际读取到的字节量。OutputStream是所有字节输出流的父类，其定义了基础的写出方法，常用的方法如下:1.void write(int d):写出一个字节,写的是给定的int的”低八位”。2.void write(byte[] d):将给定的字节数组中的所有字节全部写出。文件流FileOutputStreamjava.io.FileOutputStream：文件字节输出流，用于将数据写入到文件中的流，该流是一个低级流。低级流特点:数据的来源和去向是明确的，真实负责“搬运”数据的流。123456789101112131415161718192021222324public class FOSDemo &#123; public static void main(String[] args) throws IOException &#123; /* * 向文件中写出数据 * 一个参数的构造方法: * FileOutputStream(String path) * FileOutputStream(File file) * 创建出来的文件输出流是覆盖写操作，若操作的 * 文件中有数据，会先将数据清除，重写本次写出的数据。 * * 若希望追加写操作，则需要传入第二个参数 * 是一个boolean值，为true即可。 * FileOutputStream(File file,boolean append) * FileOutputStream(String path,boolean append) */ // File file=new File("fos.txt"); // FileOutputStream fos = new FileOutputStream(file,true); FileOutputStream fos = new FileOutputStream("fos.txt",true); String str = "一步两步,一步一步像爪牙,像魔鬼的步伐!"; fos.write(str.getBytes("UTF-8")); fos.close(); &#125;&#125;FileInputStreamjava.io.FileInputStream：低级流，可以从文件中读取字节（操作过程和RandomAccessFile相似）。1234567891011public class FISDemo &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("fos.txt"); byte[] data = new byte[1024]; int len = fis.read(data); String str = new String(data,0,len,"UTF-8"); System.out.println(str);//一步两步,一步一步像爪牙,像魔鬼的步伐! fis.close(); &#125;&#125;复制使用文件流的形式复制文件。1234567891011121314151617 public class CopyDemo1 &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("fos.txt"); FileOutputStream fos = new FileOutputStream("fos_copy.txt"); byte[] data = new byte[1024*10]; int len = -1; while((len = fis.read(data))!=-1)&#123; fos.write(data,0,len); &#125; System.out.println("复制完毕"); fis.close(); fos.close(); &#125;&#125;缓冲流在读取数据时若以字节为单位读取数据，会导致读取次数过于频繁从而大大的降低读取效率。为此我们可以通过提高一次读取的字节数量减少读写次数来提高读取的效率。1.BIS:是一个处理流，该流为我们提供了缓冲功能。2.BOS:与缓冲输入流相似，在向硬件设备做写出操作时，增大写出次数无疑也会降低写出效率，为此我们可以使用缓冲输出流来一次性批量写出若干数据减少写出次数来提高写 出效率。3.BufferedInputStream是缓冲字节输入流。其内部维护着一个缓冲区(字节数组)，使用该流在读取一个字节时，该流会尽可能多的一次性读取若干字节并存入缓冲区，然后逐一的将字节返回，直到缓冲区中的数据被全部读取完毕，会再次读取若干字节从而反复。这样就减少了读取的次数，从而提高了读取效率。4.BufferedOutputStream缓冲输出流内部也维护着一个缓冲区，每当我们向该流写数据时，都会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。BIS和BOSBufferedInputStream与BufferedOutputStream(BIS和BOS):缓冲字节输入流，缓冲字节输出流.这是一对高级流，作用是可以提高读写效率.（作用类似于字节数组）。12345678910111213141516171819202122public class CopyDemo2 &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("1.mp4"); BufferedInputStream bis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream("1_copy2.mp4"); BufferedOutputStream bos = new BufferedOutputStream(fos); int d = -1; while((d=bis.read())!=-1)&#123; bos.write(d); &#125; System.out.println("复制完毕!"); /* * 关闭流的时候，只需要关闭最外层的高级流 * 即可。因为高级流在关闭自身前会先将其处理 * 的流关闭。 */ bis.close(); bos.close(); &#125;&#125;flushvoid flush()，缓冲流都提供了flush的实现。作用是强制将现有缓冲数组中的数据一次性写出。避免了因缓冲数组中数据不够而导致文件内容为空的问题。频繁调用该方法会提高写出次数从而降低写出效率，但是当我们需要有写出数据即时性的时候就要使用。12345678910111213public class BosDemo &#123; public static void main(String[] args) throws IOException &#123; FileOutputStream fos = new FileOutputStream("bos.txt"); BufferedOutputStream bos = new BufferedOutputStream(fos); String str = "我爱北京天安门"; byte[] data = str.getBytes(); bos.write(data); // bos.flush(); bos.close();//close内部也有flush()方法. &#125;&#125;对象流对象是存在于内存中的。有时候我们需要将对象保存到硬盘上，又有时我们需要将对象传输到另一台计算机上等等这样的操作。这时我们需要将对象转换为一个字节序列，而这个过程就称为对象序列化。相反，我们有这样一个字节序列需要将其转换为对应的对象，这个过程就称为对象的反序列化。1.java.io.ObjectOutputStream：高级流，功能是将给定的一个对象转换为一组字节，然后通过其处理的流将字节写出。2.java.io.ObjectInputStream：高级流，可以进行对象的反序列化。将 一组字节还原回对象，前提是这一组字节必须是由ObjectOutputStream将一个对象序列化后的字节读写对象一般用于:保存现有对象到硬盘上；在网络中传输对象。以下Person类用于测试对象流读写对象：123456789101112131415161718192021public class Person implements Serializable&#123; private String name; private int age; private String gender; private List&lt;String&gt; otherInfo; public Person()&#123; &#125; public Person(String name, int age, String gender, List&lt;String&gt; otherInfo) &#123; super(); this.name = name; this.age = age; this.gender = gender; this.otherInfo = otherInfo; &#125; // get,set略 public String toString()&#123; return name+","+age+","+gender+","+otherInfo; &#125;&#125;对象→字节1234567891011121314151617181920212223242526public class OOSDemo &#123; public static void main(String[] args) throws IOException &#123; FileOutputStream fos = new FileOutputStream("person.obj"); ObjectOutputStream oos = new ObjectOutputStream(fos); Person p = new Person(); p.setName("路飞"); p.setAge(18); p.setGender("男"); List&lt;String&gt; otherInfo = new ArrayList&lt;String&gt;(); otherInfo.add("蒙奇·D·路飞"); otherInfo.add("要成为海贼王的男人"); otherInfo.add("积极乐观"); p.setOtherInfo(otherInfo); /* * void writeObject(Object obj) * 该方法会将给定的对象转换为一组字节，然后写出 * * 序列化:将一个数据结构转换为一组字节的过程 * 持久化:将内存中的数据写入硬盘长久保存的过程 */ oos.writeObject(p); oos.close(); &#125;&#125;字节→对象123456789101112131415public class OISDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; FileInputStream fis = new FileInputStream("person.obj"); ObjectInputStream ois = new ObjectInputStream(fis); /* * Object readObject() * 该方法会读取若干字节，然后将其反序列化回对象。 * 并以Object形式返回，需要自己强制类型转换 */ Person p = (Person)ois.readObject(); System.out.println(p); //路飞,18,男,[蒙奇·D·路飞, 要成为海贼王的男人, 积极乐观] ois.close(); &#125;&#125;字符流Reader是所有字符输入流的父类，而Writer是所有字符输出流的父类。字符流是以字符(char)为单位读写数据的。一次处理一个unicode。字符流都是高级流，其底层都是依靠字节流进行读写数据的，所以底层仍然是基于字节读写数据的。Reader的常用方法:1.int read()：读取一个字符，返回的int”值低16”位有效。2.int read(char[] chs)：从该流中读取一个字符数组length个字符并存入该数组，返回值为实际读取到的字符量。Writer的常用方法:1.void write(int c)：写出一个字符,写出给定int值”低16”位表示的字符。2.void write(char[] chs)：将给定字符数组中所有字符写出。3.void write(String str)：给定的字符串写出。4.void write(char[] chs,int offset,int len)：将给定的字符数组中从offset处开始连续的len个字符写出。WriterWriter字符输出流，特点:以字符为单位写出数据。OutputStreamWriter:字符流的一个常用实现类。特点是可以按照指定的字符集将给定的字符串转换为对应的字节后写出。1234567891011121314151617public class OSWDemo &#123; public static void main(String[] args) throws IOException &#123; FileOutputStream fos = new FileOutputStream("osw.txt"); /* * 常用构造方法: * OutputStreamWriter(OutputStream out) * 按照系统默认字符集将字符串转换为字节后写出 * * OutputStreamWriter(OutputStream out,String charsetName) * 按照给定的字符集将字符串转换为字节后写出 */ OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8"); osw.write("我爱北京天安门"); osw.write("天安门上太阳升"); osw.close(); &#125;&#125;ReaderReader字符输入流 特点:以字符为单位读取数据InputStreamReader是其常用实现类，作用是可以按照指定的字符集读取字符。123456789101112public class ISRDemo &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("osw.txt"); InputStreamReader isr = new InputStreamReader(fis,"UTF-8"); int d = -1; while((d=isr.read())!=-1)&#123; System.out.print((char)d); &#125; isr.close(); &#125;&#125;转码转码：比如将UTF-8编码的文本文件转换为GBK编码的文本文件原理:使用UTF-8编码将每一个字符读取出来，再以GBK编码将字符写入另一个文件即可。123456789101112131415161718public class ChangeCharsetDemo &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("osw.txt"); InputStreamReader isr = new InputStreamReader(fis,"UTF-8"); FileOutputStream fos= new FileOutputStream("osw_gbk.txt"); OutputStreamWriter osw = new OutputStreamWriter(fos,"GBK"); char[] data = new char[1024*5]; int len = -1; while((len = isr.read(data))!=-1)&#123; osw.write(data,0,len); &#125; System.out.println("转码完毕!"); osw.close(); isr.close(); &#125;&#125;PrintWriter缓冲字符输出流，特点是可以以行为单位写出字符串并且该流还具备自动行刷新功能。传统的缓冲字符输出流是BufferedWriter.由于PrintWriter在创建的时候内部使用了该流，并且PrintWriter还具有自动行刷新，所以比较常用。PrintWriter提供了若干构造方法，可以方便快速创建。123456789101112131415public class PWDemo &#123; public static void main(String[] args) throws IOException &#123; /* * PrintWriter可以直接创建基于文件的写操作: * PrintWriter(File file) * PrintWriter(String path) */ // File file=new File("pw.txt"); // PrintWriter pw = new PrintWriter(file,"UTF-8"); PrintWriter pw = new PrintWriter("pw.txt","UTF-8"); pw.println("我爱北京天安门"); pw.println("天安门上太阳升"); pw.close(); &#125;&#125;PrintWriter处理其他流的形式：1234567891011121314151617public class PWDemo2 &#123; public static void main(String[] args) throws IOException &#123; /* * PrintWriter提供了用于处理其他流的构造方法， * 既可以处理字符流，也可以处理字节流。 */ FileOutputStream fos = new FileOutputStream("pw2.txt"); /* * 若要按照指定字符集写出，需要中间再创建一个 * OSW来负责转字符集的操作。 */ OutputStreamWriter osw = new OutputStreamWriter(fos,"UTF-8"); PrintWriter pw = new PrintWriter(osw); pw.println("随便啦"); pw.close(); &#125;&#125;BufferedReaderjava.io.BufferedReader：缓冲字符输入流 特点:以行为单位读取字符串。1234567891011121314151617181920212223public class BRDemo &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis= new FileInputStream( "src" + File.separator + "IO" + File.separator + "BRDemo.java"); InputStreamReader isr = new InputStreamReader(fis); BufferedReader br = new BufferedReader(isr); /* * String readLine() * BufferedReader提供的该方法会读取若干字符，直到读取到 * 换行符为止，然后将换行符之前读取的这若干字符组成一个 * 字符串返回。需要注意，返回的字符串中是不包含换行符的！ * 若返回值为null,说明读取到文件末尾了。 */ String line = null; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java文件操作]]></title>
    <url>%2FJava%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[java.io.File：File的每一个实例用来表示硬盘上的一个文件或目录，我们通过File可以:1.访问一个文件或目录的属性信息，文件名，大小，修改日期，访问权限等。2.可以创建文件，删除文件，创建目录，删除目录。3.可以访问目录中的所有子项但是不能访问文件数据。基本操作在项目根目录新建test.txt文件，内容为hello world。以下为基本操作。123456789101112131415161718192021222324252627282930313233343536public class FileDemo1 &#123; public static void main(String[] args) &#123; /* * 在eclipse中，"."当前目录，指的是项目的根目录 * separator相当于”/” */ File file = new File("."+File.separator+"test.txt"); //获取文件名 String name = file.getName(); /* * 获取文件大小。返回值为一个long值，表示占用的字节量 * 中文以及中文状态下的标点符号都占用两个字节 * 英文及英文状态下的标点符号占用一个字节 */ long length = file.length(); // 获取文件最后修改时间 long time = file.lastModified(); // 查看文件是否具有可运行，可读，可写的权限 file.canExecute(); file.canRead(); file.canWrite(); // 判断当前File对象表示的是否为一个文件 boolean isFile = file.isFile(); // 判断当前File对象表示的是否为一个目录 boolean isDir = file.isDirectory(); //是否为一个隐藏文件 boolean isHidden = file.isHidden()); &#125;&#125;创建文件1234567891011public class FileDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 在当前目录下创建一个文件demo.txt File file = new File("."+File.separator+"demo.txt"); if(!file.exists())&#123; file.createNewFile(); System.out.println("创建完毕!"); &#125; &#125;&#125;删除文件12345678910public class FileDemo3 &#123; public static void main(String[] args) &#123; File file = new File("."+File.separator+"demo.txt"); if(file.exists())&#123; file.delete(); System.out.println("删除完毕!"); &#125; &#125;&#125; ​创建目录123456789101112public class FileDemo4 &#123; public static void main(String[] args) &#123; // 当前目录下创建一个目录demo File dir = new File("demo"); if(!dir.exists())&#123; // 创建目录 dir.mkdir(); System.out.println("创建完毕!"); &#125; &#125;&#125;创建多级目录12345678910111213141516171819public class FileDemo5 &#123; public static void main(String[] args) &#123; // 在当前目录下创建目录a/b/c/d/e/f File dir = new File( "a"+File.separator + "b"+File.separator + "c"+File.separator + "d"+File.separator + "e"+File.separator + "f" ); if(!dir.exists())&#123; // mkdirs方法在创建当前目录的同时会将所有不存在的父目录 // 自动创建出来。 dir.mkdirs(); System.out.println("创建完毕！"); &#125; &#125;&#125;结果：删除目录只能删除空目录。12345678910public class FileDemo6 &#123; public static void main(String[] args) &#123; File dir = new File("demo"); if(dir.exists())&#123; // 删除目录，只能删除空目录，即: 目录中不能含有任何子项。 dir.delete(); System.out.println("删除完毕!"); &#125; &#125;&#125;listFiles获取一个目录下的所有子项。123456789public class FileDemo7 &#123; public static void main(String[] args) &#123; File dir = new File("."); File[] subs = dir.listFiles(); for(File sub : subs)&#123; System.out.println((sub.isFile()?"文件:":"目录:")+sub.getName()); &#125; &#125;&#125;Filefilter文件过滤器Filefilter：获取一个目录下符合条件的子项，需要使用文件过滤器来定义过滤条件。通常使用匿名内部类来实现。1234567891011121314151617181920212223242526public class FileDemo8 &#123; public static void main(String[] args) &#123; /* * 获取当前目录下所有名字是以"."开头的子项 * 使用匿名内部类 */ FileFilter filter = new FileFilter()&#123; public boolean accept(File file) &#123; String name = file.getName(); System.out.println("正在过滤:"+name); return name.startsWith("."); &#125; &#125;; File dir = new File("."); /* * 该重载的listFiles方法会将当前目录中的每 * 一个子项都交给过滤器，然后只保留满足过滤器 * 要求(为true)的子项 */ File[] subs = dir.listFiles(filter); for(File sub : subs)&#123; System.out.println(sub.getName()); &#125; &#125;&#125;输出：1234567891011正在过滤:.classpath正在过滤:.project正在过滤:.settings正在过滤:a正在过滤:build正在过滤:src正在过滤:test.txt正在过滤:WebContent.classpath.project.settings删除含有子项目录使用“递归”的方式删除含有子项的目录（删除上面创建的a目录）。123456789101112131415161718192021public class FileDemo9 &#123; public static void main(String[] args) &#123; File dir = new File("a"); deleteFile(dir); &#125; /** * 将给定的File表示的文件或目录删除 * @param file */ public static void deleteFile(File file)&#123; if(file.isDirectory())&#123; //先将其所有子项删除 File[] subs = file.listFiles(); for(File sub:subs)&#123; //递归 deleteFile(sub); &#125; &#125; file.delete(); &#125;&#125;读写文件数据写入：123456789101112131415161718public class RandomAccessFileDemo1 &#123; public static void main(String[] args) throws IOException &#123; /* * RandomAccessFile创建支持很多模式 * 常用的有: * "r":只读 * "rw":读写 */ RandomAccessFile raf= new RandomAccessFile("demo.dat","rw"); /* * void write(int d) * 向文件中写入一个字节，写的是该int值对应的2进制内容中的"低八位", * 范围255 */ raf.write(27); raf.close(); &#125;&#125;读取：12345678910111213public class RandomAccessFileDemo2 &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile("demo.dat","r"); /* * int read() * 读取一个字节，并以int(低八位)形式返回 * 若读取到文件末尾则返回值为-1 */ int d = raf.read(); System.out.println(d); // 27 raf.close(); &#125;&#125;批量读写void write(byte[] data)：批量写出字节。一次性将给定的字节数组中的所有字节写出。12345678910111213141516171819202122public class RandomAccessFileDemo3 &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile("demo.dat","rw"); String str = "摩擦摩擦，是魔鬼的步伐"; /* * byte[] getBytes() * String提供的该方法可以将当前字符串 * 按照系统默认的字符集转换为对应的一组字节 * * byte[] getBytes(String charset) * 按照给定的字符集将字符串转换为一组字节 * 字符集名称: * GBK:国标编码 中文2字节 * UTF-8:变长编码集，1-4个字节，中文3字节 * ISO8859-1:欧洲编码，不支持中文 */ byte[] data = str.getBytes("GBK"); raf.write(data); System.out.println("写出完毕"); raf.close(); &#125;&#125;int read(byte[] data)：一次性尝试读取给定字节数组长度的字节量，并存入该数组中，返回值为实际读取到的字节量，若返回值为-1,则表示这次没有读到任何数据(文件末尾了)。12345678910111213141516public class RandomAccessFileDemo4 &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile raf = new RandomAccessFile("demo.dat","r"); byte[] data = new byte[100]; int len = raf.read(data);//每次read的长度，不写默认为1 System.out.println("读到了"+len+"个字节");//读到了22个字节 /* * 该构造方法允许我们将给定的字节数组 * 中指定范围内的字节转换为对应的字符串 */ String str = new String(data,0,len,"GBK"); System.out.println(str);//摩擦摩擦，是魔鬼的步伐 raf.close(); &#125;&#125;复制文件实际上就是一读一写。12345678910111213141516171819public class CopyDemo &#123; public static void main(String[] args) throws IOException &#123; RandomAccessFile src = new RandomAccessFile("1.mp4","r"); RandomAccessFile desc = new RandomAccessFile("1_copy.mp4","rw" ); byte[] buf = new byte[1024*10]; int len = -1; while((len=src.read(buf))!=-1)&#123; /* * void write(byte[] data,int offset,int len) * 将当前数组中从offset指定位置开始，连续len * 个字节写出 */ desc.write(buf,0,len); &#125; src.close(); desc.close(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制JSP标签]]></title>
    <url>%2F%E5%AE%9A%E5%88%B6JSP%E6%A0%87%E7%AD%BE.html</url>
    <content type="text"><![CDATA[当JSTL自带标签无法满足我们的开发需求的时候，我们可以自定义标签。定制标签可以通过实现SimpleTag接口或者继承SimpleTagSupport类（SimpleTagSupport提供了SimpleTag接口默认实现）。标签的具体实现功能逻辑写在doTag()方法中，定制JSP标签的大致步骤分为两步：1.编写标签处理器2.注册标签SimpleTag标签处理器编写一个Java类，实现SimpleTag接口：12345678910111213141516171819202122232425262728public class MyFirstTag implements SimpleTag&#123; JspContext jspContext; @Override public void doTag() throws JspException, IOException &#123; System.out.println("doTag"); jspContext.getOut().print("This is my first tag."); &#125; @Override public JspTag getParent() &#123; return null; &#125; @Override public void setJspBody(JspFragment body) &#123; System.out.println(body); &#125; @Override public void setJspContext(JspContext jspContext) &#123; this.jspContext=jspContext; &#125; @Override public void setParent(JspTag parent) &#123; &#125;&#125;doTag方法中编写了定制标签要实现的功能。getParent，setParent方法只有标签嵌套在另一个标签的时候才被调用。setJspContext方法传递了一个JspContext对象，JspContext对象的getOut方法返回一个JspWriter。注册标签在WEB-INF文件夹下新建一个tlds文件夹，然后在该文件夹下新建一个mytags.tld文件：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;description&gt;Simple tag examples&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;My First Taglib Example&lt;/short-name&gt; &lt;tag&gt; &lt;name&gt;firstTag&lt;/name&gt; &lt;tag-class&gt;MyTags.MyFirstTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt;最主要的为tag标签，name标签名，tag-class为标签java类路径。在jsp页面中使用该标签：123456789&lt;%@ taglib uri="/WEB-INF/tlds/mytags.tld" prefix="mt"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Testing my first tag&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;mt:firstTag/&gt;&lt;/body&gt;&lt;/html&gt;启动tomcat访问该jsp，页面显示This is my first tag. 控制台输出doTag。SimpleTagSupport另一种方法为继承SimpleTagSupport类，重写doTag方法，这里模拟一个时间格式化标签：12345678910111213public class DateFormatTag extends SimpleTagSupport&#123; private String fmt; public void setFmt(String fmt) &#123; this.fmt = fmt; &#125; public void doTag() throws IOException, JspException &#123; JspContext jspContext = getJspContext(); JspWriter out = jspContext.getOut(); SimpleDateFormat sdf = new SimpleDateFormat(fmt); out.print(sdf.format(new Date())); &#125;&#125;fmt为标签的属性，这里为时间格式化的格式。通过静态方法getJspContext可以获取JspContext对象。编写好便签处理器后，注册它：123456789&lt;tag&gt; &lt;name&gt;DateFormat&lt;/name&gt; &lt;tag-class&gt;MyTags.DateFormatTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;fmt&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;/attribute&gt;&lt;/tag&gt;​attribute标签定义了标签的属性。在jsp页面中进行测试：1234567891011121314&lt;%@ taglib uri="/WEB-INF/tlds/mytags.tld" prefix="mt"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test dateformat&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;mt:DateFormat fmt="yyyy-MM-dd HH:mm:ss"/&gt;&lt;br/&gt; &lt;mt:DateFormat&gt; &lt;jsp:attribute name="fmt"&gt; yyyy-MM-dd &lt;/jsp:attribute&gt; &lt;/mt:DateFormat&gt;&lt;/body&gt;&lt;/html&gt;两种方式给fmt属性赋值，启动tomcat访问该jsp页面，页面显示：JspFragmentJspFragment就是一段不包含scriplet的jsp代码段，JspFragment类有两个方法：getJspContext和invoke。getJspContext方法返回与这个JspFragment相关的JspContext，invoke方法用来执行片段，如果片段不含标签无需执行的话，则传递null。现定制一个select标签，任务是根据传入的以逗号分隔的字符串转为对应的下拉选框。select标签里的JspFragment内容为：1&lt;option value="$&#123;value&#125;"&gt;$&#123;text&#125;&lt;/option&gt;编写标签处理器：12345678910111213141516171819public class SelectTag extends SimpleTagSupport&#123; private String values; public void setValues(String values) &#123; this.values = values; &#125; public void doTag() throws IOException, JspException &#123; JspContext jspContext = getJspContext(); JspWriter out = jspContext.getOut(); String[] arr= values.split(","); out.print("&lt;select&gt;\n"); for(int i=0;i&lt;arr.length;i++)&#123; jspContext.setAttribute("value", i+1); jspContext.setAttribute("text", arr[i]); getJspBody().invoke(null); &#125; out.print("&lt;/select&gt;\n"); &#125;&#125;注册该标签：123456789&lt;tag&gt; &lt;name&gt;select&lt;/name&gt; &lt;tag-class&gt;MyTags.SelectTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;values&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;/attribute&gt;&lt;/tag&gt;因为标签包含JspFragment，所以body-content标签配置为scriptless。在jsp页面中测试该标签：1234567891011&lt;%@ taglib uri="/WEB-INF/tlds/mytags.tld" prefix="mt"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test selecttag&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;mt:select values="fuzhou,xiamen,longyan"&gt; &lt;option value="$&#123;value&#125;"&gt;$&#123;text&#125;&lt;/option&gt; &lt;/mt:select&gt;&lt;/body&gt;&lt;/html&gt;启动tomcat，访问该jsp页面，页面显示：查看源码：12345&lt;select&gt; &lt;option value="1"&gt;fuzhou&lt;/option&gt; &lt;option value="2"&gt;xiamen&lt;/option&gt; &lt;option value="3"&gt;longyan&lt;/option&gt;&lt;/select&gt;函数假如JSTL中的函数标签不能满足我们的实际需求，我们也可以自己编写。新建Function包，在包下创建StringFunction类：12345public class StringFunction &#123; public static String reverseString(String value)&#123; return new StringBuffer(value).reverse().toString(); &#125;&#125;注册该标签：在WEB-INF下的tlds下新建function.tld：123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_1.xsd" version="2.1"&gt; &lt;description&gt;Function tag examples&lt;/description&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;function&gt; &lt;description&gt;Reverses a String&lt;/description&gt; &lt;name&gt;reverseString&lt;/name&gt; &lt;function-class&gt;Functions.StringFunction&lt;/function-class&gt; &lt;function-signature&gt; java.lang.String reverseString(java.lang.String) &lt;/function-signature&gt; &lt;/function&gt; &lt;/taglib&gt;name表示函数名。function-class为实现该函数的Java类的全类名。function-signature表示该函数的静态Java方法签名。在jsp中测试该EL函数：123456789&lt;%@ taglib uri="/WEB-INF/tlds/function.tld" prefix="fn"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Testing reverseString function&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;fn:reverseString("Hello World")&#125;&lt;/body&gt;&lt;/html&gt;启动tomcat，访问该jsp，页面显示：《Servlet和JSP学习指南》学习笔记]]></content>
      <tags>
        <tag>servlet&amp;jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP Standard Tag Library]]></title>
    <url>%2FJSP-Standard-Tag-Library.html</url>
    <content type="text"><![CDATA[JSTL（JSP Standard Tag Library）下载地址：https://jstl.java.net/。JSTL包含：1.JSTL API2.JSTL ImplementationJSP页面中使用JSTL，使用taglib指令引入：1&lt;%@ taglib rui="uri" prefix="prefix"%&gt;通用动作指令引入：1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;out标签标记&lt;c:out&gt;具有以下属性：属性描述value*+ &nbsp;要运算的表达式default默认值escapeXmlTrue，如果标签转义特殊XML字符*表示属性是必需的，+号表示可以为表达式。默认情况下，excapeXml属性为true，意味着会将&lt;，&gt;，’，”和&amp;转换为&lt;，&gt;，&#039;和&amp;。set标签&lt;c:set&gt;标记具有以下属性：属性描述value+要创建的字符串，或要引用的限域对象，或新的属性值target+其属性应该被修改的限域对象目标property+要修改的属性名称var限域变量scope范围，默认为page如，创建一个page范围的foo变量，并赋值：1&lt;c:set var="foo" value="The wisest fool"/&gt;创建一个限域变量job，值为request范围的对象position，限域变量的范围为page：1&lt;c:set var="job" value="$&#123;requestScope.position&#125;" socpe="page"/&gt;设置address对象的city属性为fuzhou：1&lt;c:set target="$&#123;address&#125;" property="city" value="fuzhzou"/&gt;也可以这样写：123&lt;c:set target="$&#123;address&#125;" property="city"&gt; fuzhou&lt;/c:set&gt;remove标签&lt;c:remove&gt;标签具有以下属性：属性描述默认值var要删除的变量名Nonescope删除变量的作用域所有作用域如删除作用域为page的job限域变量：1&lt;c:remove var="job" scope="page"/&gt;条件式动作指令引入：1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;if标签&lt;c:if&gt;标签具有以下属性：属性描述默认test*+条件计算Nonevar变量名称来存储条件的结果，Boolean类型Nonescopevar变量的作用域page如：1234&lt;c:set var="salary" scope="session" value="$&#123;2000*2&#125;"/&gt;&lt;c:if test="$&#123;salary &gt; 2000&#125;"&gt; My salary is: &lt;c:out value="$&#123;salary&#125;"/&gt;&lt;/c:if&gt;模拟if…else：123456&lt;c:if test="$&#123;param.user=='mrbird' &amp;&amp; password=='mrbird'&#125;"&gt; mrbird logged in successfully.&lt;/c:if&gt;&lt;c:if test="$&#123;!(param.user=='mrbird' &amp;&amp; password=='mrbird')&#125;"&gt; userName or password is wrong&lt;/c:if&gt;choose,when和otherwise该标签类似于Java中的switch和case关键字类似，使用方法如下：1234567891011&lt;c:choose&gt; &lt;c:when test="$&#123;param.user=="mrbird"&#125;"&gt; hi,mrbird. &lt;/c:when&gt; &lt;c:when test="$&#123;param.user=="jint"&#125;"&gt; hi,jint. &lt;/c:when&gt; &lt;c:otherwise&gt; hi,someone else. &lt;/c:otherwise&gt;&lt;/c:choose&gt;iterator动作指令forEach标签&lt;c:forEach&gt;标记具有以下属性：属性描述默认items+要迭代的对象集合Nonebegin+开始索引0end+结束索引Last elementstep+迭代步长1var当前迭代内容的限域变量名NonevarStatus保存迭代状态的限域变量名None其中，varStatus包含一些属性：1.current当前这次迭代的（集合中的）项2.index当前这次迭代从 0 开始的迭代索引3.count当前这次迭代从 1 开始的迭代计数4.first用来表明当前这轮迭代是否为第一次迭代的标志5.last用来表明当前这轮迭代是否为最后一次迭代的标志如循环输出books集合，并控制单双行表格样式：1234567891011121314151617&lt;table&gt; &lt;tr style="background:#ababff"&gt; &lt;td&gt;ISBN&lt;/td&gt; &lt;td&gt;Title&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach item="$&#123;requestScope.books&#125;" var="book" vatStatus="status"&gt; &lt;c:if test="$&#123;status.count%2 == 0&#125;"&gt; &lt;tr style="background:#eeeeff"&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;status.count%2 != 0&#125;"&gt; &lt;tr style="background:#dedeff"&gt; &lt;/c:if&gt; &lt;td&gt;$&#123;book.isbn&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.title&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;简单的forEach标签示例：123&lt;c:forEach var="x" begin="1" end="5"&gt; &lt;c:out value="$&#123;x&#125;"/&gt;,&lt;/c:forEach&gt;页面输出1，2，3，4，5。forTokens标签forTokens标签使用的比较少，常用的例子：123&lt;c:forTokens items="Zara,nuha,roshy" delims="," var="name"&gt; &lt;c:out value="$&#123;name&#125;"/&gt;&lt;/c:forTokens&gt;这将产生以下输出结果：123Zaranuharoshy格式化动作指令引入：1&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;formatNumber标签&lt;fmt:formatNumber&gt;标签用于格式化数字，百分比和货币。&lt;fmt:formatNumber&gt;标签有如下属性：属性描述默认值value*+要显示的数字无type+NUMBER，CURRENCY，或 PERCENT类型Numberpattern+指定一个自定义的格式化模式用于输出无currencyCode+货币码（当type=”currency”时）取决于默认区域currencySymbol+货币符号 (当 type=”currency”时)取决于默认区域groupingUsed+是否对数字分组 (TRUE 或 FALSE)truemaxIntegerDigits+整型数最大的位数无minIntegerDigits+整型数最小的位数无maxFractionDigits+小数点后最大的位数无minFractionDigits+小数点后最小的位数无var存储格式化数字的变量Print to pagescopevar属性的作用域pagepattern属性包含的字符：符号描述0代表一位数字E使用指数格式#代表一位数字，若没有则显示0.小数点,数字分组分隔符;分隔格式-使用默认负数前缀%百分数?千分数¤货币符号，使用实际的货币符号代替X指定可以作为前缀或后缀的字符‘在前缀或后缀中引用特殊字符例子：1234567891011121314151617181920&lt;c:set var="balance" value="120000.2309" /&gt;格式化数字 (1): &lt;fmt:formatNumber value="$&#123;balance&#125;" type="currency"/&gt;格式化数字 (2): &lt;fmt:formatNumber type="number" maxIntegerDigits="3" value="$&#123;balance&#125;" /&gt;格式化数字 (3): &lt;fmt:formatNumber type="number" maxFractionDigits="3" value="$&#123;balance&#125;" /&gt;格式化数字 (4): &lt;fmt:formatNumber type="number" groupingUsed="false" value="$&#123;balance&#125;" /&gt;格式化数字 (5): &lt;fmt:formatNumber type="percent" maxIntegerDigits="3" value="$&#123;balance&#125;" /&gt;格式化数字 (6): &lt;fmt:formatNumber type="percent" minFractionDigits="10" value="$&#123;balance&#125;" /&gt;格式化数字 (7): &lt;fmt:formatNumber type="percent" maxIntegerDigits="3" value="$&#123;balance&#125;" /&gt;格式化数字 (8): &lt;fmt:formatNumber type="number" pattern="###.###E0" value="$&#123;balance&#125;" /&gt;美元 : &lt;fmt:setLocale value="en_US"/&gt; &lt;fmt:formatNumber value="$&#123;balance&#125;" type="currency"/&gt;结果：12345678910数字格式化:格式化数字 (1): ￥120,000.23格式化数字 (2): 000.231格式化数字 (3): 120,000.231格式化数字 (4): 120000.231格式化数字 (5): 023%格式化数字 (6): 12,000,023.0900000000%格式化数字 (7): 023%格式化数字 (8): 120E3美元 : $120,000.23formatDate标签&lt;fmt:formatDate&gt;标签用于使用不同的方式格式化日期。&lt;fmt:formatDate&gt;标签有如下属性：属性描述是否必要默认值value要显示的日期是无typeDATE, TIME, 或 BOTH否datedateStyleFULL, LONG, MEDIUM, SHORT, 或 DEFAULT否defaulttimeStyleFULL, LONG, MEDIUM, SHORT, 或 DEFAULT否defaultpattern自定义格式模式否无timeZone显示日期的时区否默认时区var存储格式化日期的变量名否显示在页面scope存储格式化日志变量的范围否页面&lt;fmt:formatDate&gt; 标签格式模式：代码描述实例G时代标志ADy不包含纪元的年份。如果不包含纪元的年份小于 10， 则显示不具有前导零的年份。2002M月份数字。一位数的月份没有前导零。April &amp; 04d月中的某一天。一位数的日期没有前导零。20h12 小时制的小时。一位数的小时数没有前导零。12H24 小时制的小时。一位数的小时数没有前导零。0m分钟。一位数的分钟数没有前导零。45s秒。一位数的秒数没有前导零。52S毫秒970E周几TuesdayD一年中的第几天180F一个月中的第几个周几2 (一个月中的第二个星期三)w一年中的第几周r27W一个月中的第几周2aa.m./p.m. 指示符PMk小时(12 小时制的小时)24K小时(24 小时制的小时)0z时区中部标准时间‘&nbsp;转义文本‘’&nbsp;单引号例子：1234567891011&lt;c:set var="now" value="&lt;%=new java.util.Date()%&gt;" /&gt;&lt;p&gt;日期格式化 (1): &lt;fmt:formatDate type="time" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (2): &lt;fmt:formatDate type="date" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (3): &lt;fmt:formatDate type="both" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (4): &lt;fmt:formatDate type="both" dateStyle="short" timeStyle="short" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (5): &lt;fmt:formatDate type="both" dateStyle="medium" timeStyle="medium" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (6): &lt;fmt:formatDate type="both" dateStyle="long" timeStyle="long" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (7): &lt;fmt:formatDate pattern="yyyy-MM-dd" value="$&#123;now&#125;" /&gt;&lt;/p&gt;结果：12345678日期格式化:日期格式化 (1): 11:19:43日期格式化 (2): 2016-6-26日期格式化 (3): 2016-6-26 11:19:43日期格式化 (4): 16-6-26 上午11:19日期格式化 (5): 2016-6-26 11:19:43日期格式化 (6): 2016年6月26日 上午11时19分43秒日期格式化 (7): 2016-06-26剩下的fmt标签较少使用，懒得记录。函数引入：1&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %&gt;contains函数fn:contains()函数的语法如下：123&lt;c:if test="$&#123;fn:contains(&lt;原始字符串&gt;, &lt;要查找的子字符串&gt;)&#125;"&gt; ...&lt;/c:if&gt; ​如，下面的EL表达式都返回true：123&lt;c:set var="myString" value="Hello World"/&gt;$&#123;fn:contains(myString,"Hello")&#125;$&#123;fn:contains("Stella Cadente","Cadente")&#125;containsIgnoreCase函数和contains类似，不区分大小写。endsWith函数判断以什么为结尾。startsWith函数escapeXml函数如：1$&#123;fn:escapeXml("Use &lt;br&gt; to change lines")&#125;显示为：1Use &lt;br&gt; to change linesindexOf函数fn:indexOf()函数返回一个字符串中指定子串的位置。fn:indexOf()函数的语法如下：1$&#123;fn:indexOf(&lt;原始字符串&gt;,&lt;子字符串&gt;)&#125;例子：12&lt;c:set var="string1" value="This is first String."/&gt;&lt;p&gt;Index: $&#123;fn:indexOf(string1, "first")&#125;&lt;/p&gt;结果：1Index: 8join函数fn:join()函数将一个数组中的所有元素使用指定的分隔符来连接成一个字符串。split函数fn:split()函数将一个字符串用指定的分隔符分裂为一个子串数组。join和split例子：1234&lt;c:set var="string1" value="www runoob com"/&gt;&lt;c:set var="string2" value="$&#123;fn:split(string1, ' ')&#125;" /&gt;&lt;c:set var="string3" value="$&#123;fn:join(string2, '-')&#125;" /&gt;&lt;p&gt;string3 字符串 : $&#123;string3&#125;&lt;/p&gt;结果为：1字符串为 : www-runoob-comlength函数replace函数fn:replace()函数将字符串中所有指定的子串用另外的字符串替换。fn:replace()函数的语法如下：1$&#123;fn:replace(&lt;原始字符串&gt;, &lt;被替换的字符串&gt;, &lt;要替换的字符串&gt;)&#125;例子：123&lt;c:set var="string1" value="I am from USA"/&gt;&lt;c:set var="string2" value="$&#123;fn:replace(string1, 'USA', 'China')&#125;" /&gt;&lt;p&gt;替换后的字符串 : $&#123;string2&#125;&lt;/p&gt;结果：1替换后的字符串 : I am from Chinasubstring函数fn:substring()函数返回字符串中指定开始和结束索引的子串。fn:substring()函数的语法如下：1$&#123;fn:substring(&lt;string&gt;, &lt;beginIndex&gt;, &lt;endIndex&gt;)&#125;例子：123&lt;c:set var="string1" value="This is first String."/&gt;&lt;c:set var="string2" value="$&#123;fn:substring(string1, 5, 15)&#125;" /&gt;&lt;p&gt;生成的子字符串为 : $&#123;string2&#125;&lt;/p&gt;结果：1生成的子字符串为 : is first SsubstringBefore函数fn:substringBefore()函数返回一个字符串中指定子串前面的部分。如：123&lt;c:set var="string1" value="This is first String."/&gt;&lt;c:set var="string2" value="$&#123;fn:substringBefore(string1, 'first')&#125;" /&gt;&lt;p&gt;生成的子字符串 : $&#123;string2&#125;&lt;/p&gt;结果：1生成的子字符串 : This issubstringAfter函数toLowerCase函数toUpperCase函数trim函数sql标签略。《Servlet和JSP学习指南》学习笔记]]></content>
      <tags>
        <tag>servlet&amp;jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Server Pages]]></title>
    <url>%2FJava-Server-Pages.html</url>
    <content type="text"><![CDATA[scripletJSP页面可以直接书写Java 代码，Java代码要用&lt;% %&gt;包裹起来，&lt;% %&gt;代码块也被成为scriplet。可以使用page指令的import导入Java类型，否则scriplet里的Java类必须使用全类名。如：123456789101112&lt;%@ page import="java.util.Date"%&gt;&lt;%@ page import="java.text.DataFormat"%&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Today's date&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;% DateFormat df = DateFormat.getDateInstance(DateFormat.LONG); String s = df.format(new Date()); out.println("Today is " + s); %&gt; &lt;/body&gt;&lt;/html&gt;隐式对象对象描述requestHttpServletRequest类的实例responseHttpServletResponse类的实例outPrintWriter类的实例，用于把结果输出至网页上sessionHttpSession类的实例applicationServletContext类的实例，与应用上下文有关configServletConfig类的实例pageContextPageContext类的实例，提供对JSP页面所有对象以及命名空间的访问page类似于Java类中的this关键字ExceptionException类的对象，代表发生错误的JSP页面中对应的异常对象获取HttpServletRequest对象的userName参数：123&lt;% String userName = request.getParameter("userName");%&gt;PageContext实用方法为存取属性：setAttribute()和getAttribute()。setAttribute方法签名：1public abstract void setAttribute(String name, Object value, int scope);scope值可以取：PAGE_SCOPE, REQUEST_SCOPE, SESSION_SCOPE, APPLICATION_SCOPE。如，下面scriplet在ServletRequset中保存了一个属性：1234&lt;% //product is a Java object pageContext.setAttribute("product",product,pageContext.REQUEST.SCOPE);%&gt;等价于：123&lt;% request.setAttribute("product",product);%&gt;out对象类似于在HttpServletResponse中调用getWritter()之后得到的java.io.PrintWriter，如在页面输出Welcome：123&lt;% out.println("Welcome");%&gt;指令page指令常用指令表：属性定义language=”ScriptLanguage”指定JSP Container用什么语言来编译，目前只支持JAVA语言。默认为JAVAextends=”className”定义此JSP网页产生的Servlet是继承哪个import=”importList”定义此JSP网页要使用哪些Java APIsession=”true|false”决定此页面是否使用session对象。默认为truebuffer=”none|size in kb”决定输出流(Input stream)是否又缓冲区。默认为8kbautoFlush=”true|false”决定输出流的缓冲区慢了后是否需要自动清除，缓冲区慢了后会产生异常错误(Exception).默认为trueisThreadSafe=”true|false”是否支持线程。默认为trueerrorPage=”url”如果此页发生异常，网页会重新指向一个urlisErrorPage=”true|false”表示此页面是否为错误处理页面。默认为falsecontentType=”text/html;charset=gb2312”表示MIME类型和JSP的编码方式。笔者使用例左pageEncoding=”ISO-8859-1”编码方式。isELLgnored=”true|false”表示是否在此JSP页面中EL表达式。true则忽略，反之false则支持。默认为false &nbsp; &nbsp;设置jsp中用到的语言,用到的是java，也是目前唯一有效的设定：1&lt;%@ page language="java"%&gt;jsp页面所用到的类：1&lt;%@ page import="java.sql.*"% &gt;设置该jsp页面出现异常时所要转到的页面,如果没设定，容器将使用当前的页面显示错误信息：1&lt;%@ page errorPage="error.jsp"%&gt;设置该jsp页面是否作为错误显示页面,默认是false,如果设置为true,容器则会在当前页面生成一个exception对象：1&lt;%@ page isErrorPage="true"%&gt;设置页面文件格式和编码方式：1&lt;%@ page contentType="text/html;charset=utf-8"%&gt;设置容器以多线程还是单线程运行该jsp页面，默认是true,是多线程。设置为false,则以单线程的方式运行该jsp页面：1&lt;%@ page isThreadSafe="true"% &gt;设置该jsp页面是否可以用到session对象(jsp内置对象，为web容器创建),默认是true,能用到session.设置为false,则用不到：1&lt;%@ page session="true"% &gt;include指令语法：1&lt;%@ include file="url"%&gt;被引用的文件扩展名为jspf(JSP fragment)。脚本元素scriplet前面介绍了，这里不在赘述。表达式以&lt;%=开头，%&gt;结束：1Today is &lt;%=java.util.Calendar.getInstance().getTime()%&gt;等价于：1234Today is&lt;% out.println(java.util.Calendar.getInstance().getTime());%&gt;声明可以声明能够在JSP页面中实用的变量和方法，声明用&lt;%!%&gt;包裹起来，比如在JSP页面中声明一个getTodaysDate的方法：1234567891011&lt;%! public String getTodaysDate() &#123; return new java.util.Date(); &#125; %&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Declarations&lt;/title&gt;&lt;/head&gt; &lt;body&gt; Today is &lt;%=getTodayDate()%&gt; &lt;/body&gt;&lt;/html&gt;我们可以利用声明覆盖实现类中的init和destory方法：12345678&lt;%! public void jspInit() &#123; System.out.println("jspInit ..."); &#125; public void jspDestory() &#123; System.out.println("jspDestory ..."); &#125;%&gt;关闭脚本为了页面的整洁性，现在一般用EL，JSTL取代脚本元素，我们可以设置关闭脚本元素：123456&lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;动作动作会被编译为执行某个操作的Java代码，例如访问某个Java对象，或者调用某个方法。useBean如：123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;useBean&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;jsp:useBean id="today" class="java.util.Date"/&gt; &lt;%=today%&gt; &lt;/body&gt;&lt;/html&gt;运行页面后，会在浏览器输出当前日期和时间。存取属性有Employee JavaBean，现在页面中存取属性值：12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;getProperty and setProperty&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;jsp:useBean id="employee" class="com.mrbird.entity.Employee"/&gt; &lt;jsp:setProperty name="employee" property="firstName" value="Mrbird"/&gt; First Name:&lt;jsp:getProperty name="employee" property="firstName"/&gt; &lt;/body&gt;&lt;/html&gt;includeinclude动作用于动态地包含另一个资源，它可以包含另一个JSP页面，一个Servlet，一个静态HTML页面。12345678910 &lt;html&gt; &lt;head&gt; &lt;title&gt;Include Action&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;jsp:include page="jspf/menu.jsp"/&gt; &lt;jsp:param name="text" value="How are you?"/&gt; &lt;/jsp:include&gt; &lt;/body&gt;&lt;/html&gt;include动作和include指令区别：① 使用include指令所引用的东东是发生在页面转换的时候，include动作包含是发生在请求的时候。② 使用include指令时，被包含的文件扩展名是什么并不重要，而使用include动作时，文件扩展名必须为jsp，以便它能够作为一个JSP页面进行处理。forwardforward动作是将当前页面跳转到另外一个页面，比如：123&lt;jsp:forward page="jspf/login.jsp"&gt; &lt;jsp:param name="text" value="Please login"/&gt;&lt;/jsp:forward&gt;错误处理在可能发生异常的jsp页面设置异常页面路径：1&lt;%@ page errorPage="errorHandler.jsp"%&gt;errorHandler.jsp：1234567891011&lt;%@ page isErrorPage="true"%&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Error&lt;/title&gt;&lt;/head&gt; &lt;body&gt; An error occurred.&lt;br/&gt; Error message: &lt;% out.println(exception.toString); %&gt; &lt;/body&gt;&lt;/html&gt;《Servlet和JSP学习指南》学习笔记]]></content>
      <tags>
        <tag>servlet&amp;jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nexus搭建私服]]></title>
    <url>%2FNexus%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D.html</url>
    <content type="text"><![CDATA[安装Nexus下载Nexus：http://pan.baidu.com/s/1miTmJB6 ，密码：2jh7解压后找到bin/jsw目录下选择对于的操作系统文件夹：如windows-x86-64，双击start-nexus.bat即可启动nexus，启动后浏览器访问loaclhost:8081/nexus/：点击右上角Log In登录，管理员账号密码 admin，admin123。Nexus仓库和仓库组Nexus内置仓库点击左侧的Repositories可看到：类型分为：group（仓库组），proxy（代理），hosted（宿主），virtual（虚拟）：Central：代理Maven中央仓库，策略为Release，因此只会下载和缓存中央仓库中的发行版本构件Releases：策略为Release的宿主类型仓库，用来部署组织内部的发行版本构件Snapshots：策略为Snapshots的宿主类型仓库，用来部署组织内部的快照版本构件Apache Snapshots：策略为Snapshots的代理仓库，用来代理Apache Maven仓库的快照版本构件3rd party：策略为Release的宿主类型仓库，用来部署无法从公共仓库获得的第三方发行版构件Public Repositories：该仓库组为上述所有策略为Release的仓库聚合并通过一致的地址提供服务Public Snapshot Repositories：该仓库组为上述所有策略为Snapshots的仓库聚合并通过一致的地址提供服务上述的几种仓库类型关系如下图所示：maven可以直接从宿主仓库和代理仓库下载构件，代理仓库会间接地从远程仓库下载并缓存构件。为了方便，maven可以从仓库组下载构件，仓库组没有实际的内容，它会转向其包含的宿主仓库或者代理仓库获得实际的构件。创建Nexus宿主仓库点击Repositories界面的Add按钮，选择Hosted Repository：Repository ID：仓库id，该值会被作为仓库路径的最后一项内容Repository Name：仓库名称Provider：仓库的格式，一般选默认的Maven2Repository Policy：配置仓库构件为快照类型还是发行类型Default Local Storage Location：仓库默认地址，自动根据id生成Override Local Storage Location：自定义仓库地址Deployment Policy：部署策略，有Disable Redeploy（同一构件只能部署一次），Allow Redeploy（允许重新部署），Readonly（禁止部署）Allow File Browsing：为true时以树形结构浏览仓库存储文件内容Include in Search：是否对该仓库进行索引并提供搜索Publish URL：是否通过URL提供服务，为false的时候，访问该仓库地址会得到HTTP 404 Not Found错误Not Found Cache TTL：如果某文件不存在，在这1440分钟内再次访问这个文件，直接返回不存在信息未完待续，懒得写]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven聚合与继承]]></title>
    <url>%2Fmaven%E8%81%9A%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF.html</url>
    <content type="text"><![CDATA[maven中聚合和继承是两个概念，两者的目的是不一样的。聚合是为了方便的快速构建项目，而继承是为了消除一些重复的配置。对于聚合模块来说，它知道有哪些模块被聚合了，但是那些被聚合的模块并不知道这个聚合模块的存在。对于继承关系的父pom来说，它不知道哪些被聚合的模块，但那些被聚合的模块必须知道自己的父pom是什么。聚合开发中，一个项目一般被分为多个模块，通过maven的聚合特性，我们可以创建一个父maven项目来管理所有的子模块。现有account-email和account-persist两个maven项目，我们创建一个account-parent项目将其聚合在一起。聚合有两种结构方式：1.父子结构：2.平行结构下面例子以平行结构为例。account-parent配置如下：12345678910&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;&lt;artifactId&gt;account-parent&lt;/artifactId&gt;&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;name&gt;Account Parent&lt;/name&gt; &lt;modules&gt; &lt;module&gt;../account-email&lt;/module&gt; &lt;module&gt;../account-persist&lt;/module&gt;&lt;/modules&gt;modules元素用于聚合子模块，packaging元素声明其打包方式为pom。对于一个聚合子模块的父模块，其打包方式必须为pom。对于平行结构来说，父模块的内容仅为一个pom文件。对父模块执行 mvn clean install命令：12345678910111213[INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO] [INFO] Account Parent .................................... SUCCESS [0.447s][INFO] Account Email ..................................... SUCCESS [3.334s][INFO] Account Persist ................................... SUCCESS [1.582s][INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 5.489s[INFO] Finished at: Wed Oct 26 16:59:05 CST 2016[INFO] Final Memory: 17M/160M[INFO] ------------------------------------------------------------------------继承如果需要继承父模块pom中的一些配置，我们只需要在子模块pom中添加如下配置123456&lt;parent&gt; &lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-parent&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../account-parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;通过parent元素指定其父模块，relativePath指向父模块的pom路径，其默认值为../pom.xml。父模块pom中声明的一些元素可以被子模块继承，常用的有：■ groupId：项目id，项目坐标的核心元素■ version：项目版本，项目坐标的核心元素■ description：项目的描述信息■ organization：项目的组织信息■ distributionManagement：项目的部署信息■ properties：自定义的maven属性■ dependencies：依赖■ dependencyManagement：依赖管理配置■ repositories：项目的仓库配置■ build：项目的源码目录配置，输出目录配置，插件配置，插件管理配置等依赖继承对于子模块共用的依赖，可以统一在父模块中声明，比如在父模块account-parent中配置dependencyManagement：12345678910111213141516171819202122232425262728293031323334&lt;properties&gt; &lt;springframework.version&gt;2.5.6&lt;/springframework.version&gt; &lt;junit.version&gt;4.7&lt;/junit.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;子模块使用这些依赖的时候，只需要简单的配置，如account-email的pom配置：1234567891011121314151617181920212223242526272829303132333435363738&lt;properties&gt; &lt;javax.mail.version&gt;1.4.1&lt;/javax.mail.version&gt; &lt;greenmail.version&gt;1.3.1b&lt;/greenmail.version&gt;&lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;$&#123;javax.mail.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.icegreen&lt;/groupId&gt; &lt;artifactId&gt;greenmail&lt;/artifactId&gt; &lt;version&gt;$&#123;greenmail.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;可发现，account-email的dependencies配置省去了version，对于junit还省去了scope。省去这些信息是因为account-email继承了父模块的dependencyManagement配置，完整的依赖声明已经包含在父pom中，子模块只需要声明简单的groupId和artifactId就可以找到对应的依赖。注意：虽然完整的依赖已经包含在父模块pom中了，但并不是说子模块完全不需要声明依赖了。比如子模块不声明spring-context-support依赖，那么该依赖不会被引入。插件继承在父模块account-parent的pom中配置pluginManagement元素：123456789101112131415161718192021&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.5&lt;/source&gt; &lt;target&gt;1.5&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt;子模块需要用到这些插件的时候，只需要简单的配置：123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;只需要在子模块中指定插件的groupId和artifactId就可以在父模块pom中找到对应的插件配置。《Maven实战》读书笔记]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON小记]]></title>
    <url>%2FJSON%E5%B0%8F%E8%AE%B0.html</url>
    <content type="text"><![CDATA[JSON全称JavaScript Object Notation，是一种轻量级的数据交换格式，取名自JavaScript对象，但两者之间并没有什么直接的联系。JSON语法和JavaScript对象语法上区别如下表所示：对比内容JSONJS对象键名必须是加双引号可允许不加、加单引号、加双引号属性值只能是数值（10进制）、 字符串（双引号）、 布尔值和null， 也可以是数组或者符合JSON要求的对象， 不能是函数、NaN, Infinity, &nbsp;-Infinity和undefined什么都可以逗号问题最后一个属性后面不能有逗号可以数值前导0不能用，小数点后必须有数字没限制可以看到，相对于JS对象，JSON的格式更严格，所以大部分写的JS对象是不符合JSON的格式的。如：123456789101112131415161718192021var obj1 = &#123;&#125;; // 这只是 JS 对象 // 可把这个称做：JSON 格式的 JavaScript 对象 var obj2 = &#123;"width":100,"height":200,"name":"rose"&#125;; // 可把这个称做：JSON 格式的字符串var str1 = '&#123;"width":100,"height":200,"name":"rose"&#125;'; // 这个可叫 JSON 格式的数组，是 JSON 的稍复杂一点的形式var arr = [ &#123;"width":100,"height":200,"name":"rose"&#125;, &#123;"width":100,"height":200,"name":"rose"&#125;, &#123;"width":100,"height":200,"name":"rose"&#125;,]; // 这个可叫稍复杂一点的 JSON 格式的字符串 var str2='['+ '&#123;"width":100,"height":200,"name":"rose"&#125;,'+ '&#123;"width":100,"height":200,"name":"rose"&#125;,'+ '&#123;"width":100,"height":200,"name":"rose"&#125;,'+']';以下是JSON的一些转换方法。JavaScriptjs对象→json字符串转换函数JSON.stringify，函数签名如下所示：1JSON.stringify(value[, replacer [, space]])下面将分别展开带1~3个参数的用法：基本使用——仅需一个参数12345//创建js对象var obj = &#123;"name":"mrbird","age":24&#125;;//将此对象转成json字符串var str = JSON.stringify(obj);// "&#123;"name":"mrbird","age":24&#125;"第二个参数可以是函数，也可以是一个数组如果第二个参数是一个函数，那么序列化过程中的每个属性都会被这个函数转化和处理.如果第二个参数是一个数组，那么只有包含在这个数组中的属性才会被序列化到最终的JSON字符串中。如果第二个参数是null，那作用上和空着没啥区别，但是不想设置第二个参数，只是想设置第三个参数的时候，就可以设置第二个参数为null。这第二个参数若是函数：123456789101112131415161718var friend=&#123; "firstName": "Good", "lastName": "Man", "phone":"1234567", "age":18&#125;; var friendAfter=JSON.stringify(friend,function(key,value)&#123; if(key==="phone") return "(000)"+value; else if(typeof value === "number") return value + 10; else return value; //如果你把这个else分句删除，那么结果会是undefined&#125;); console.log(friendAfter); //输出：&#123;"firstName":"Good","lastName":"Man","phone":"(000)1234567","age":28&#125;第二个参数若是数组：12345678910111213var friend=&#123; "firstName": "Good", "lastName": "Man", "phone":"1234567", "age":18&#125;; //注意下面的数组有一个值并不是上面对象的任何一个属性名var friendAfter=JSON.stringify(friend,["firstName","address","phone"]); console.log(friendAfter); //&#123;"firstName":"Good","phone":"1234567"&#125;//指定的“address”由于没有在原来的对象中找到而被忽略如果第二个参数是一个数组，那么只有在数组中出现的属性才会被序列化进结果字符串，只要在这个提供的数组中找不到的属性就不会被包含进去，而这个数组中存在但是源JS对象中不存在的属性会被忽略，不会报错。第三个参数用于美化输出指定缩进用的空白字符，可以取以下几个值：· 是1-10的某个数字，代表用几个空白字符· 是字符串的话，就用该字符串代替空格，最多取这个字符串的前10个字符· 没有提供该参数等于设置成null，也等于设置一个小于1的数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var friend=&#123; "firstName": "Good", "lastName": "Man", "phone":&#123;"home":"1234567","work":"7654321"&#125;&#125;; //直接转化是这样的：//&#123;"firstName":"Good","lastName":"Man","phone":&#123;"home":"1234567","work":"7654321"&#125;&#125; var friendAfter=JSON.stringify(friend,null,4); console.log(friendAfter); /*&#123; "firstName": "Good", "lastName": "Man", "phone": &#123; "home": "1234567", "work": "7654321" &#125;&#125;*/ var friendAfter=JSON.stringify(friend,null,"HAHAHAHA"); console.log(friendAfter); /*&#123;HAHAHAHA"firstName": "Good", HAHAHAHA"lastName": "Man", HAHAHAHA"phone": &#123; HAHAHAHAHAHAHAHA"home": "1234567", HAHAHAHAHAHAHAHA"work": "7654321" HAHAHAHA&#125; &#125;*/ var friendAfter=JSON.stringify(friend,null,"WhatAreYouDoingNow"); console.log(friendAfter); /* 最多只取10个字符&#123;WhatAreYou"firstName": "Good", WhatAreYou"lastName": "Man", WhatAreYou"phone": &#123; WhatAreYouWhatAreYou"home": "1234567", WhatAreYouWhatAreYou"work": "7654321" WhatAreYou&#125; &#125;*/JSON.stringify函数有几个需要注意的地方：1.键名不是双引号的（包括没有引号或者是单引号），会自动变成双引号；字符串是单引号的，会自动变成双引号。2.最后一个属性后面有逗号的，会被自动去掉。3.非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中 这个好理解，也就是对非数组对象在最终字符串中不保证属性顺序和原来一致。4.布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 也就是你的什么new String(“bala”)会变成”bala”，new Number(2017)会变成2017。5.undefined、任意的函数（其实有个函数会发生神奇的事，后面会说）以及 symbol值。出现在非数组对象的属性值中：在序列化过程中会被忽略。出现在数组中时：被转换成 null。1234JSON.stringify(&#123;x: undefined, y: function()&#123;return 1;&#125;, z: Symbol("")&#125;); //出现在非数组对象的属性值中被忽略："&#123;&#125;"JSON.stringify([undefined, Object, Symbol("")]); //出现在数组对象的属性值中，变成null："[null,null,null]"将JSON字符串解析为JS数据结构函数JSON.parse的签名如下：1JSON.parse(text[, reviver])如果第一个参数，即JSON字符串不是合法的字符串的话，那么这个函数会抛出错误。值得注意的是这里有一个可选的第二个参数，这个参数必须是一个函数，这个函数作用在属性已经被解析但是还没返回前，将属性处理后再返回。123456789101112131415161718192021222324252627282930313233343536373839404142var friend=&#123; "firstName": "Good", "lastName": "Man", "phone":&#123;"home":"1234567","work":["7654321","999000"]&#125;&#125;; //我们先将其序列化var friendAfter=JSON.stringify(friend); //'&#123;"firstName":"Good","lastName":"Man","phone":&#123;"home":"1234567","work":["7654321","999000"]&#125;&#125;' //再将其解析出来，在第二个参数的函数中打印出key和valueJSON.parse(friendAfter,function(k,v)&#123; console.log(k); console.log(v); console.log("----");&#125;);/*firstName Good ----lastName Man ----home 1234567 ----0 7654321 ----1 999000 ----work []----phone Object ---- Object ----*/仔细看一下这些输出，可以发现这个遍历是由内而外的，可能由内而外这个词大家会误解，最里层是内部数组里的两个值啊，但是输出是从第一个属性开始的，怎么就是由内而外的呢？这个由内而外指的是对于复合属性来说的，通俗地讲，遍历的时候，从头到尾进行遍历，如果是简单属性值（数值、字符串、布尔值和null），那么直接遍历完成，如果是遇到属性值是对象或者数组形式的，那么暂停，先遍历这个子JSON，而遍历的原则也是一样的，等这个复合属性遍历完成，那么再完成对这个属性的遍历返回。本质上，这就是一个深度优先的遍历。影响 JSON.stringify 的神奇函数——object.toJSON如果你在一个JS对象上实现了toJSON方法，那么调用JSON.stringify去序列化这个JS对象时，JSON.stringify会把这个对象的toJSON方法返回的值作为参数去进行序列化。1234567891011var info=&#123; "msg":"I Love You", "toJSON":function()&#123; var replaceMsg=new Object(); replaceMsg["msg"]="Go Die"; return replaceMsg; &#125;&#125;; JSON.stringify(info); //出si了，返回的是：'"&#123;"msg":"Go Die"&#125;"',说好的忽略函数呢这个函数就是这样子的。其实Date类型可以直接传给JSON.stringify做参数，其中的道理就是，Date类型内置了toJSON方法。Java下面是JSON和Java对象等的转换方法。准备工作，创建Emp实体类：1234567891011121314public class Emp implements Serializable &#123; private String name; private Integer age; public Emp() &#123; &#125; public Emp(String name, Integer age) &#123; super(); this.name = name; this.age = age; &#125; //get,set略&#125;java对象→json字符串123456789@Testpublic void test1() &#123; //1.获取Java对象 Emp e = new Emp("mrbird",24); //2.先将其转换成json对象(Map) JSONObject obj = JSONObject.fromObject(e); //3.在将json对象转成字符串 System.out.println(obj.toString());&#125;输出：1&#123;"age":24,"name":"mrbird"&#125;集合/数组→json字符串1234567891011@Testpublic void test2() &#123; //1.获取集合/数组 List&lt;Emp&gt; list = new ArrayList&lt;Emp&gt;(); list.add(new Emp("mrbird",24)); list.add(new Emp("leanote",33)); //2.先把集合转成json数组(List) JSONArray ary = JSONArray.fromObject(list); //3.把整个数组转成字符串 System.out.println(ary.toString());&#125;输出：1[&#123;"age":24,"name":"mrbird"&#125;,&#123;"age":33,"name":"leanote"&#125;]json字符串→java对象12345678910@Testpublic void test3() &#123; //1.获取json字符串 String str = "&#123;\"name\":\"mrbird\",\"age\":24&#125;"; //2.将此字符串转成json对象(Map) JSONObject obj = JSONObject.fromObject(str); //3.将json对象转换成Java对象(bean) Emp e = (Emp)JSONObject.toBean(obj, Emp.class); System.out.println(e.getName());&#125;输出：1mrbirdjson字符串转→List1234567891011121314151617@Testpublic void test4() &#123; //1.获取json字符串 String str = "[&#123;\"name\":\"mrbird\",\"age\":24&#125;," + "&#123;\"name\":\"leanote\",\"age\":33&#125;]"; //2.先将此字符串转成json数组(List) //当前List中存的是Map。 JSONArray ary = JSONArray.fromObject(str); //3.将List&lt;Map&gt;转成List&lt;Emp&gt; //JSONArray会自动实例化一个集合，然后将ary中的每一个Map转成Emp， //增加到这个新建的集合中 List&lt;Emp&gt; list = (List&lt;Emp&gt;)JSONArray.toCollection(ary, Emp.class); for(Emp e : list) &#123; System.out.println(e.getName()); &#125;&#125;参考文章 – JSON：如果你愿意一层一层剥开我的心，你会发现…这里水很深——深入理解JSON]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven生命周期和插件]]></title>
    <url>%2Fmaven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[maven生命周期（lifecycle）对构建的过程进行了抽象和统一，实际的工作是由对应的插件（plugins）来完成的。maven生命周期maven生命周期可以分为三个部分：clean生命周期该周期的任务是清理项目，包含三个阶段：pre-clean执行清理前需要完成的工作clean清理上一次构建生成的文件post-clean执行清理后需要完成的工作default生命周期default生命周期定义了真正构建时需要的所有步骤。validate验证项目是正确的，所有必要的信息是可用的initialize初始化构建状态，例如：设置属性或创建目录generate-sources生成编译期的源代码。process-sources处理项目主资源文件。一般来说是对src/main/resources目录内容进行变量替换等工作后，复制到项目输出的主目录classpath目录中generate-resources生成包含在打包过程中的资源process-resources复制和处理资源到目标目录，准备打包compile编译项目的源代码process-classes处理编译后生成的class文件generate-test-sources生成编译期内的测试源代码process-test-sources处理测试源代码，如过滤一些值generate-test-resources创建测试资源process-test-resources复制测试资源到目标目录并处理test-compile编译测试源代码到测试目标目录process-test-classes处理编译测试代码后生成的class文件test使用合适的单元测试框架运行测试。 这些测试代码不会被打包和 部署prepare-package执行打包前需要的任何工作package接收编译好的代码，打包成可发布的格式，如jar，war等pre-integration-test执行集成测试之前所需的操作integration-test如果需要，可以将软件包处理和部署到可以运行集成测试的环境中post-integration-test执行集成测试之后所需的操作verify运行任何检查以验证程序包是否有效并符合质量标准install将程序包安装到maven本地仓库，供本地其他maven项目使用deploy将最终包复制到远程仓库，供其它开发人员和maven项目使用site生命周期site生命周期的作用是建立和发布项目站点。pre-site执行一些在生成项目站点之前所需要完成的工作site生成项目站点文档post-site执行一些在生成项目站点之后需要完成的工作site-deploy将生成的项目站点发布到服务器上maven生命周期是相互依赖的关系，如执行 mvn clean命令时，会执行pre-clean，clean阶段；执行mvn deploy会执行default生命周期前面的所有阶段。插件目标maven生命周期的各个阶段是和插件绑定在一起的，一个插件可以包含多个功能，每个功能对应生命周期的一个阶段，并称其为插件目标。如：maven-dependency-plugin包含插件目标：dependency：tree，dependency：list，dependency：analyze等。内置绑定插件maven在核心为一些主要的生命周期绑定了许多插件目标：clean生命周期阶段与插件绑定情况：生命周期阶段插件目标pre-cleanmaven-clean-plugin:cleancleanpost-cleandefault生命周期阶段与插件绑定情况及具体任务：生命周期阶段插件目标执行任务process-resourcesmaven-resources-plugin:resources复制主资源文件到输出 目录compilemaven-compiler-plugin:compile编译主代码到输出目录process-test-resourcesmaven-resources-plugin:testResources复制测试资源文件到输 出目录test-compilemaven-compiler-plugin:testCompile编译测试代码到输出目 录testmaven-surefire-plugin:test执行测试用例packagemaven-jar-plugin:jar创建项目jar包installmaven-install-plugin:install将项目输出构件安装到 本地仓库deploymaven-deploy-plugin:deploy将项目输出构件部署到 远程仓库site生命周期阶段与插件绑定情况：生命周期阶段插件目标pre-sitemaven-site-plugin:sitesitepost-sitesite-deploymaven-site-plugin:deploy如，对项目执行 mvn clean install 命令：1234567891011121314151617181920212223242526272829--- maven-clean-plugin:2.5:clean (default-clean) @ viswcm-project ---[INFO] Deleting D:\workspace\viswcm-project\target[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ viswcm-project ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ viswcm-project ---[INFO] Compiling 20 source files to D:\workspace\viswcm-project\target\classes[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ viswcm-project ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory D:\workspace\viswcm-project\src\test\resources[INFO] [INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ viswcm-project ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ viswcm-project ---[INFO] No tests to run.[INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ viswcm-project ---[INFO] Building jar: D:\workspace\viswcm-project\target\viswcm-project-0.0.1-SNAPSHOT.jar[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ viswcm-project ---[INFO] Installing D:\workspace\viswcm-project\target\viswcm-project-0.0.1-SNAPSHOT.jar to D:\64\m2\repository\com\visgreat\viswcm-project\0.0.1-SNAPSHOT\viswcm-project-0.0.1-SNAPSHOT.jar[INFO] Installing D:\workspace\viswcm-project\pom.xml to D:\64\m2\repository\com\visgreat\viswcm-project\0.0.1-SNAPSHOT\viswcm-project-0.0.1-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------其输出结果和上面的表格描述一致。自定义插件绑定除了maven内置绑定，我们还可以自行绑定某个插件到某个生命周期的某个阶段。比如要生成项目源码jar包，我们可以将maven-source-plugin插件配置到default生命周期的verify阶段：123456789101112131415161718&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;verify&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;上述配置描述了maven-source-plugin插件坐标外，还有插件执行配置executions元素下的每个execution子元素可以用来配置执行一个任务。这里配置了一个id为attach-sources的任务，通过phase元素，将其绑定到verify阶段上，再通过goals配置指定执行的插件目标。运行mvn verify：12[INFO] --- maven-source-plugin:2.1.1:jar-no-fork (attach-sources) @ viswcm-project --- [INFO] Building jar: D:\workspace\viswcm-project\target\viswcm-project-0.0.1-SNAPSHOT-sources.jar获取插件信息maven官方插件：http://maven.apache.org/plugins/index.htmlmaven官方插件下载地址：http://repo1.maven.org/maven2/org/apache/maven/plugins/配置插件仓库1234567891011121314&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven.Plugin.Repository&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;《Maven实战》读书笔记]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven repository]]></title>
    <url>%2Fmaven-repository.html</url>
    <content type="text"><![CDATA[保存构件的地方即为repository（仓库）。仓库的分类maven仓库分为两类：本地仓库和远程仓库。当maven根据pom中定义的坐标寻找构件时，首先在本地仓库中寻找，当找不到时再从远程仓库寻找，都找不到时抛出异常。maven远程仓库还可进一步分类：本地仓库默认maven会在c盘创建一个.m2的本地仓库，如果要修改本地仓库地址，可以修改setting.xml文件：123&lt;settings&gt; &lt;localRepository&gt;D:\64\m2\repository&lt;/localRepository&gt;&lt;/settings&gt;远程仓库中央仓库使用解压软件打开%M2_HOME%/lib/maven-model-builder-3.1.1.jar，然后访问路径org/apache/maven/model/pom-4.0.0.xml，可看到：1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;包含这段配置的文件是所有maven项目都会继承的超级pom。上述配置中，snapshots子元素enabled的值为false，表示不从中央仓库下载快照版本的构件。私服私服是一种特殊的远程仓库，架设于局域网内。当maven需要下载构件时，先从私服寻找，私服中没有再从外部仓库下载。私服有许多显著的优点：■ 节省外网带宽■ 加速maven构件■ 部署第三方构件■ 提高稳定性，增强控制■ 降低中央仓库的负荷远程仓库配置如果默认的远程中央仓库无法满足需求，我们可以在pom中添加远程仓库的配置：1234567891011121314151617&lt;project&gt; ... &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jboss&lt;/id&gt; &lt;name&gt;JBoss Repository&lt;/name&gt; &lt;url&gt;http://repository.jboss.com/maven2/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt;在repositories元素下，使用repository元素声明一个或多个远程仓库。上面的xml声明了一个id为jboss，名称为JBoss Repository的仓库。任何一个仓库的id是唯一的，maven自带的中央仓库使用的id为central，如果其他仓库的id也为central，那么它将覆盖自带的中央仓库。url指向仓库地址，一般该地址都是基于http协议。releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。release和snapshots元素还可以配置另外两个子元素：12345&lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;ignore&lt;/checksumPolicy&gt;&lt;/snapshots&gt;updatePolicy元素配置maven从远程仓库检查更新的频率，默认值为daily。其他可用值有：never —— 从不检查更新，always —— 每次构建都检查更新，interval：X —— 每隔X分钟检查一次更新。用户也可以使用命令 mvn clean install -U强制更新。checksumPolicy元素用来配置当下载构件时，maven检验和验证失败时候的动作，默认为warn，即输出警告信息，ignore则为忽略错误。远程仓库认证如果远程仓库出于安全的考虑设置了用户名和密码，这时候我们必须在settings.xml中配置：12345678910&lt;settings&gt; ... &lt;servers&gt; &lt;server&gt; &lt;id&gt;my-proj&lt;/id&gt; &lt;username&gt;repo-user&lt;/username&gt; &lt;password&gt;repo_pwd&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt;&lt;/settings&gt;上述xml指定了id为my-proj的远程仓库的用户名和密码。部署至远程仓库如前所述，私服一大作用是可以部署第三方构件。无论是开发中生成的构件还是正式发布的构件，都需要部署到私服中供小组中的其他开发人员使用，在maven项目pom中配置：123456789101112131415161718&lt;project&gt; ... &lt;distributionManagement&gt; &lt;snapshotRepository&gt; &lt;id&gt;user-snapshot&lt;/id&gt; &lt;name&gt;User Porject Snapshot&lt;/name&gt; &lt;url&gt;http://192.168.10.217:8081/nexus/ content/repositories/snapshots/&lt;/url&gt; &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt; &lt;/snapshotRepository&gt; &lt;repository&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;name&gt;User Porject Release&lt;/name&gt; &lt;url&gt;http://192.168.10.217:8081/nexus/ content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt;&lt;/project&gt;上述xml明确指定了快照版本和发行版本的私服id和地址，如前所述，如果私服设置了账号密码，则应该在settings.xml中设置对应id的私服账号和密码，就本例来说，我们应该在settings.xml中设置：1234567891011121314&lt;settings&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;user-snapshot&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt;&lt;/settings&gt;配置正确后，可以运行命令mvn clean deploy将项目构建输出的构件部署到对应的远程仓库。快照版本版本元素version中添加SNAPSHOT标识，表明该构件为快照版本。SNAPSHOT版本的构件发布到私服的过程中，maven会自动加上时间戳。另一位开发者从该私服获取这个构件的时候，maven会自动获取时间戳最新的构件。快照版本只应该在组织内部依赖使用，项目不应该依赖于任何组织外部的快照版本依赖。因为快照版本的不稳定性会对项目造成潜在的危险。镜像如果仓库B可以提供仓库A存储的所有内容，那么就可以认为B是A的一个镜像。maven默认的远程中央仓库由于服务器不在中国，所以访问速度可能会慢些，这时候可以再settings.xml中配置一个镜像：1234567891011&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;one of the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt;&lt;mirrorOf&gt;的值为central，表示该配置为中央仓库的镜像。任何对于中央仓库的请求都会本转至该镜像。镜像常用于私服。由于私服可以代理任何外部的公共仓库，所以可以说私服就是所有仓库的镜像。如：12345678910&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://192.168.10.217:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt;&lt;mirrorOf&gt;的值为*号，表示http://192.168.10.217:8081/nexus/content/groups/public/是所有外部仓库的镜像。任何对远程仓库的请求都会被转到这个地址。&lt;mirrorOf&gt;的配置：■ &lt;mirrorOf&gt;*&lt;mirrorOf&gt;：匹配所有的远程仓库■ &lt;mirrorOf&gt;external:*&lt;mirrorOf&gt;：匹配所有不在本机上的远程仓库■ &lt;mirrorOf&gt;repo1,repo2&lt;mirrorOf&gt;：匹配仓库repo1和repo2■ &lt;mirrorOf&gt;*,!repo1&lt;mirrorOf&gt;：匹配除了repo1之外的所有远程仓库镜像仓库完全屏蔽了被镜像仓库，当镜像仓库停止服务的时候，maven仍无法访问被镜像仓库，因而将无法下载构建。仓库搜索服务下面列出几个目前能用的maven坐标服务：1.The Centrl Repository：http://search.maven.org/2.Maven Repository：http://www.mvnrepository.com/3.Nexus Repository Manager：https://repository.sonatype.org/#welcome《Maven实战》读书笔记]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn总结]]></title>
    <url>%2Fsvn%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。服务端安装visualsvn下载地址：https://www.visualsvn.com/downloads/，选择：下载后开始安装，一路next，直到：选择仓库地址和端口号，然后继续next即可。客户端安装tortoisesvn下载地址：https://tortoisesvn.net/downloads.html，安装过程一路next即可。tortoisesvn语言包，tortoisesvn下载地址下面可选择安装对应的语言包：服务端配置新增repository仓库打开VisualSvn server,如下图所示新建一个repository：填写仓库名称：新建完后左边目录如下图所示：创建项目文件夹右键新建好的MyRepository，选择新建 → Floder…：填写Floder名称：点击ok即可。创建完后：创建用户这里我们创建两个开发者账号：developer1和developer2，两个测试人员：tester1和tester2。点击Users → Create User：创建好developer1后再执行同样操作创建剩余的账号，创建完后如图所示：创建用户群这里我们建立两个群：开发者群和测试人员群：点击Groups → Create Group…：点击Add按钮向群中添加用户：点击ok后就创建好了developer群并添加了相关人员，创建测试群操作一样，创建好后如下图所示：设置权限右击项目文件夹Project1，选择properties：弹出框点击Add添加用户群：点击ok后如下图所示设置用户群权限：因为测试人员不参与开发，所以将其权限设置为Read Only即可。使用tortoisesvn导入项目右击需要导入的项目，选择导入：弹出框：其中URL来源于之前在服务端新建的项目文件夹的URL地址，获取方法为：点击确定后即可向服务器导入项目：使用tortoisesvn导出项目在需要导出项目的路径下右键选择SVN检出，然后弹出：点击确定后弹出账号密码填写框，这里我们分别使用develop1和developer2检出：检出后：SVN提交在developer1文件夹下新建一个readme.txt文件，然后选中该文件右击选择加入：完成后会发现readme.txt上新增了一个加号的图标：此文件可以提交到SVN库里了。选中文件右键选择SVN提交：可以在信息框里填写修改信息，点击确定后readme.txt即可被提交到SVN库：SVN更新developer1提交了新文件，现在在developer2文件夹下更新此文件：右键developer2文件夹，选择SVN更新，弹出填写账号密码框，填写developer2账号密码即可。更新后developer2文件夹同步了readme.txt文件：解决冲突冲突来源：比如developer1修改了readme.txt文件的内容，并且提交了。这时候developer2并没有去更新developer1提交的内容，修改的文件也为readme.txt，developer2修改完提交时就会发现版本冲突了，如下图所示：冲突的文件被标记问感叹号，并且多出了3个文件。解决冲突有两种办法：1.选择冲突文件，右键选择SVN还原，这样项目就会被还原到你修改前的状态。这种做法缺点显而易见，那就是你修改部分的代码变没了，所以选择这种方法前，请注意备份好自己修改部分的源代码。2.选择冲突文件，右键选择编辑冲突：红色部分即为冲突部分，可以和提交此文件的开发者商量，将商量好后的代码放置于已合并部分即可：点击保存后，多出来的3个文件本删除了，这时候将readme.txt提交即可。验证权限使用tester1的账号导出项目后，在项目里添加一个modify.txt文件，然后加入，提交：操作限制。]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven坐标与依赖]]></title>
    <url>%2Fmaven%E5%9D%90%E6%A0%87%E4%B8%8E%E4%BE%9D%E8%B5%96.html</url>
    <content type="text"><![CDATA[坐标在maven中，任何构件都有明确定义的坐标。这些坐标是通过一些元素定义的，下面是nexus-indexer的坐标定义：1234&lt;groupId&gt;org.sonatype.nexus&lt;/groupId&gt;&lt;artifactId&gt;nexus-indexer&lt;/artifactId&gt;&lt;version&gt;2.0.0&lt;/version&gt;&lt;packing&gt;jar&lt;/packing&gt;groupId：定义当前maven项目隶属的实际项目，一般由公司前缀+隶属项目名称组成artifactId：定义当前maven项目模块，一般由隶属项目名称+当前maven模块名称组成version：版本号packing：打包方式。有jar，war等，默认为jar classifier：定义构件输出的一些附属构件。本例主构件输出nexus-indexer-2.0.0.jar，附属构件比如有：nexus-indexer-2.0.0-javadoc.jar，nexus-indexer-2.0.0-source.jar等依赖配置除了上面的基本坐标定义，依赖还可以包含：123456789101112131415161718192021&lt;project&gt; ... &lt;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;... &lt;/groupId&gt; &lt;artifactId&gt;... &lt;/artifactId&gt; &lt;version&gt;... &lt;/version&gt; &lt;type&gt;... &lt;/type&gt; &lt;scope&gt;... &lt;/scope&gt; &lt;optional&gt;... &lt;/optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; ... &lt;/exclusion&gt; ... &lt;/exclusions&gt; &lt;/dependency&gt; ... &lt;/dependency&gt; ...&lt;/project&gt;type：依赖的类型，对应坐标中的packing，默认为jar，一般不用声明scope：依赖的范围optional：标记依赖是否可选，若为true则为可选依赖。可选依赖不能传递exclusions：用来排除传递性依赖依赖范围在一个maven项目中主要有三个classpath：编译classpath，测试classpath，运行时classpath。下表列出了依赖范围和classpath的关系：依赖范围（Scope）对于编译classpath有效对于测试classpath有效对于运行时classpath有效例子compile√√√spring-coretest×√×JUnitprovided√√×servlet-apiruntime×√√JDBC驱动实现system√√×本地的，Maven仓库外的 类库文件compile：编译依赖范围test：测试依赖范围provided：已提供依赖范围runtime：运行时依赖范围system：系统依赖范围import：导入依赖范围传递性依赖现有pom如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.juven.mvnbook.account&lt;/groupId&gt; &lt;artifactId&gt;account-email&lt;/artifactId&gt; &lt;name&gt;Account Email&lt;/name&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.icegreen&lt;/groupId&gt; &lt;artifactId&gt;greenmail&lt;/artifactId&gt; &lt;version&gt;1.5.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;上面的xml中有一个org.springframework：spring-core.4.3.3.RELEASE.jar依赖。在中央仓库查看其xml，会发现其还包含了：123456&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;该依赖的范围为compile，而spring-core依赖没有直接声明依赖范围，默认为compile。现在account-email有一个compile范围的spring-core依赖，spring-core有一个compile范围的comms-logging依赖，所以comms-logging会成为account-email的compile范围的传递性依赖。现假设A依赖于B，B依赖于C，那么A相对于B是第一直接依赖，B相对于C是第二直接依赖，A相对于C是传递性依赖，其依赖范围按下表定义：compiletestprovidedruntimecompilecompile——compiletesttest——testprovidedprovided—providedprovidedruntimeruntime——runtime表中，第一列是第一直接依赖范围，第一行是第二直接依赖范围，交叉部分是最终传递性依赖范围。依赖调解依赖调解有两个原则：1.路径最近的优先现在有如下两个依赖：A → B → C → X（1.0.0）A → B → X（1.2.1）A有两个版本的传递性依赖X，因为X（1.2.1）路径较短，所以最终X（1.2.1）会被解析使用。2.第一声明者优先现在有如下两个依赖：A → B → X（1.0.0）A → B → X（1.2.1）两个版本X的依赖路径一样长，这时候谁被解析取决于谁先定义！排除依赖使用compile:tree查看依赖树：123456789101112131415[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ account-email ---[INFO] com.juven.mvnbook.account:account-email:jar:1.0.0-SNAPSHOT[INFO] +- org.springframework:spring-core:jar:4.3.3.RELEASE:compile[INFO] | \- commons-logging:commons-logging:jar:1.2:compile[INFO] +- org.springframework:spring-beans:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context:jar:4.3.3.RELEASE:compile[INFO] | +- org.springframework:spring-aop:jar:4.3.3.RELEASE:compile[INFO] | \- org.springframework:spring-expression:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context-support:jar:4.3.3.RELEASE:compile[INFO] +- javax.mail:mail:jar:1.4.7:compile[INFO] | \- javax.activation:activation:jar:1.1:compile[INFO] +- junit:junit:jar:4.7:test[INFO] \- com.icegreen:greenmail:jar:1.5.2:test[INFO] +- com.sun.mail:javax.mail:jar:1.5.6:test[INFO] \- org.slf4j:slf4j-api:jar:1.7.21:test如上所述的，spring-core隐式依赖于commons-logging，如果不想传递此依赖，可以为spring-core添加exclusions元素：1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.3.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;再次执行dependency:tree命令：1234567891011121314[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ account-email ---[INFO] com.juven.mvnbook.account:account-email:jar:1.0.0-SNAPSHOT[INFO] +- org.springframework:spring-core:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-beans:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context:jar:4.3.3.RELEASE:compile[INFO] | +- org.springframework:spring-aop:jar:4.3.3.RELEASE:compile[INFO] | \- org.springframework:spring-expression:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context-support:jar:4.3.3.RELEASE:compile[INFO] +- javax.mail:mail:jar:1.4.7:compile[INFO] | \- javax.activation:activation:jar:1.1:compile[INFO] +- junit:junit:jar:4.7:test[INFO] \- com.icegreen:greenmail:jar:1.5.2:test[INFO] +- com.sun.mail:javax.mail:jar:1.5.6:test[INFO] \- org.slf4j:slf4j-api:jar:1.7.21:test可发现spring-core已经不依赖于commons-logging了，当然这里只是单纯演示排除依赖，commons-logging对于Spring框架是必须的。归类依赖在上述的pom中，spring的版本都为4.3.3.RELEASE版本，而且对于一个框架来说，其各个模块的版本一般都是一样的，这里我们可以统一声明其版本，然后引用即可：123456789101112131415161718192021222324&lt;properties&gt; &lt;springframework.version&gt;4.3.3.RELEASE&lt;/springframework.version&gt;&lt;/properties&gt;...&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;这样在以后更新spring版本的时候，只需要修改properties即可。优化依赖除了使用dependency:tree命令外，还可使是dependency:list查看所有依赖：dependency:list12345678910111213141516[INFO] --- maven-dependency-plugin:2.8:list (default-cli) @ account-email ---[INFO] [INFO] The following files have been resolved:[INFO] org.springframework:spring-beans:jar:4.3.3.RELEASE:compile[INFO] org.springframework:spring-context-support:jar:4.3.3.RELEASE:compile[INFO] org.slf4j:slf4j-api:jar:1.7.21:test[INFO] junit:junit:jar:4.7:test[INFO] com.sun.mail:javax.mail:jar:1.5.6:test[INFO] com.icegreen:greenmail:jar:1.5.2:test[INFO] commons-logging:commons-logging:jar:1.2:compile[INFO] org.springframework:spring-aop:jar:4.3.3.RELEASE:compile[INFO] javax.activation:activation:jar:1.1:compile[INFO] javax.mail:mail:jar:1.4.7:compile[INFO] org.springframework:spring-core:jar:4.3.3.RELEASE:compile[INFO] org.springframework:spring-context:jar:4.3.3.RELEASE:compile[INFO] org.springframework:spring-expression:jar:4.3.3.RELEASE:compile使用dependency:analyze分析依赖：1234567[INFO] &lt;&lt;&lt; maven-dependency-plugin:2.8:analyze (default-cli) @ account-email &lt;&lt;&lt;[INFO] [INFO] --- maven-dependency-plugin:2.8:analyze (default-cli) @ account-email ---[WARNING] Unused declared dependencies found:[WARNING] org.springframework:spring-core:jar:4.3.3.RELEASE:compile[WARNING] org.springframework:spring-beans:jar:4.3.3.RELEASE:compile[INFO] ------------------------------------------------------------------------《Maven实战》读书笔记]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用m2eclipse创建maven项目]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8m2eclipse%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE.html</url>
    <content type="text"><![CDATA[新建maven项目新建一个maven project，填写Group Id，Artifact Id：点击finish后项目目录下自动生成了pom.xml文件（Project Object Model，项目对象模型）：1234567891011121314151617181920212223242526&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;mrbird.leanote.com&lt;/groupId&gt; &lt;artifactId&gt;hello_maven&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello_maven&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;&lt;groupId&gt;定义了项目属于哪个组，一般为公司域名加组名。&lt;artifactId&gt;定义了当前maven项目在组中的唯一id。&lt;version&gt;定义了当前项目的版本。&lt;name&gt;定义了更为友好的项目名称。&lt;dependencies&gt;包含一个或多个&lt;dependency&gt;，上面代码添加了一个依赖——groupId为junit，artifactId为junit，version为4.7。通过这段声明，maven能够自动下载junit-4.7.jar。编写主代码在src/main/java目录下的mrbird.leanote.com.hello_maven包下新建HelloMaven.java：12345678910public class HelloMaven &#123; public String sayHello()&#123; return "Hello Maven"; &#125; public static void main(String[] args)&#123; System.out.print( new HelloMaven().sayHello() ); &#125;&#125;进行maven进行编译，右击项目→Run As→Maven build…：然后点击run：12345678910111213141516171819202122[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building hello_maven 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello_maven ---[INFO] Deleting F:\workspaces\Spring\hello_maven\target[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory F:\workspaces\Spring\hello_maven\src\main\resources[INFO] [INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ hello_maven ---[INFO] Compiling 1 source file to F:\workspaces\Spring\hello_maven\target\classes[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 2.443s[INFO] Finished at: Mon Oct 17 13:12:43 CST 2016[INFO] Final Memory: 11M/115M[INFO] ------------------------------------------------------------------------clean告诉maven清理输出目录target/，compile告诉maven编译项目主代码。从上面的输出可以看出，maven首先执行了celan任务，删除target/目录。接着执行resource任务，将项目主代码编译至F:\workspaces\Spring\hello_maven\target\classes目录。编写测试代码在src/test/java目录下的mrbird.leanote.com.hello_maven包下新建HelloMavenTest.java：123456789public class HelloMavenTest&#123; @Test public void testSayHello() &#123; HelloMaven helloMaven = new HelloMaven(); String result = helloMaven.sayHello(); assertEquals( "Hello Maven", result ); &#125;&#125;调用maven执行测试，右击项目→Run As→Maven build…输入clean test→run：12345678910111213141516171819202122232425262728293031323334353637383940414243[INFO] Scanning for projects...[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building hello_maven 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello_maven ---[INFO] Deleting F:\workspaces\Spring\hello_maven\target[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory F:\workspaces\Spring\hello_maven\src\main\resources[INFO] [INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ hello_maven ---[INFO] Compiling 1 source file to F:\workspaces\Spring\hello_maven\target\classes[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello_maven ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] skip non existing resourceDirectory F:\workspaces\Spring\hello_maven\src\test\resources[INFO] [INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ hello_maven ---[INFO] Compiling 1 source file to F:\workspaces\Spring\hello_maven\target\test-classes[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello_maven ---[INFO] Surefire report directory: F:\workspaces\Spring\hello_maven\target\surefire-reports ------------------------------------------------------- T E S T S-------------------------------------------------------Running mrbird.leanote.com.hello_maven.HelloMavenTestTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.056 sec Results : Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 2.794s[INFO] Finished at: Mon Oct 17 13:32:08 CST 2016[INFO] Final Memory: 13M/151M[INFO] ------------------------------------------------------------------------测试通过。打包运行compile和test之后，执行package。右击项目→Run As→Maven build…输入clean package→run：123456789101112131415161718192021...------------------------------------------------------- T E S T S-------------------------------------------------------Running mrbird.leanote.com.hello_maven.HelloMavenTestTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.078 sec Results : Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ hello_maven ---[INFO] Building jar: F:\workspaces\Spring\hello_maven\target\hello_maven-0.0.1-SNAPSHOT.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 4.254s[INFO] Finished at: Mon Oct 17 13:53:15 CST 2016[INFO] Final Memory: 13M/139M[INFO] ------------------------------------------------------------------------打包成功，已经生成了jar包。如果要让别的maven项目能够引用HelloMaven，则还需执行 clean install：12345678910111213141516171819202122232425...------------------------------------------------------- T E S T S-------------------------------------------------------Running mrbird.leanote.com.hello_maven.HelloMavenTestTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.064 sec Results : Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ hello_maven ---[INFO] Building jar: F:\workspaces\Spring\hello_maven\target\hello_maven-0.0.1-SNAPSHOT.jar[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ hello_maven ---[INFO] Installing F:\workspaces\Spring\hello_maven\target\hello_maven-0.0.1-SNAPSHOT.jar to C:\Users\Administrator\.m2\repository\mrbird\leanote\com\hello_maven\0.0.1-SNAPSHOT\hello_maven-0.0.1-SNAPSHOT.jar[INFO] Installing F:\workspaces\Spring\hello_maven\pom.xml to C:\Users\Administrator\.m2\repository\mrbird\leanote\com\hello_maven\0.0.1-SNAPSHOT\hello_maven-0.0.1-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 4.486s[INFO] Finished at: Mon Oct 17 14:01:13 CST 2016[INFO] Final Memory: 14M/138M[INFO] ------------------------------------------------------------------------该操作会将该项目打包后的jar和pom文件拷贝到本地maven仓库。因为主方法中有main方法，默认打包生成的jar包是不能运行的，如：12F:\workspaces\Spring\hello_maven&gt;java -jar target/hello_maven-0.0.1-SNAPSHOT.jartarget/hello_maven-0.0.1-SNAPSHOT.jar中没有主清单属性为了生成可执行的jar，需要借助maven-shade-plugin，在pom中配置：1234567891011121314151617181920212223242526&lt;build&gt;&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation="org.apache.maven.plugins.shade. resource.ManifestResourceTransformer"&gt; &lt;mainClass&gt;mrbird.leanote.com.hello_maven.HelloMaven&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt;配置mainClass为mrbird.leanote.com.hello_maven.HelloMaven。再次执行clean install操作，然后执行jar：12F:\workspaces\Spring\hello_maven&gt;java -jar target/hello_maven-0.0.1-SNAPSHOT.jarHello Maven《Maven实战》读书笔记]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境变量设置]]></title>
    <url>%2F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[JDK1.JAVA_HOME：1C:\Program Files\Java\jdk1.8.0_602.Path：1%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin3.CLASSPATH :1.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar检测：1234567C:\Users\Administrator&gt;echo %java_home%C:\Program Files\Java\jdk1.8.0_60 C:\Users\Administrator&gt;java -versionjava version "1.8.0_60"Java(TM) SE Runtime Environment (build 1.8.0_60-b27)Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)MAVEN1.M2_HOME：1D:\Program Files\apache-maven-3.1.12.Path：1%M2_HOME%\bin测试：12345678910C:\Users\Administrator&gt;echo %m2_home%D:\Program Files\apache-maven-3.1.1 C:\Users\Administrator&gt;mvn -vApache Maven 3.1.1 (0728685237757ffbf44136acec0402957f723d9a)Maven home: D:\Program Files\apache-maven-3.1.1Java version: 1.8.0_60, vendor: Oracle CorporationJava home: C:\Program Files\Java\jdk1.8.0_60\jreDefault locale: zh_CN, platform encoding: GBKOS name: "windows 10", version: "10.0", arch: "amd64", family: "dos"]]></content>
      <tags>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事务管理]]></title>
    <url>%2FSpring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[在SimpleJdbcTemplate的UserDaoImpl中的addUser()方法中手动制造一个NullPointerException异常：123456789public void addUser(User user) &#123; Map&lt;String, Object&gt; params=new HashMap&lt;String, Object&gt;(); params.put("name", user.getName()); params.put("age", user.getAge()); params.put("pwd", user.getPassword()); jdbcTemplate.update(SQL_INSERT_USER, params); String a = null; a.toString();&#125;测试addUser()方法：123456789101112public class TestJdbc &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao=ac.getBean("userDao",UserDao.class); User u=new User(); u.setName("testUser"); u.setAge("24"); u.setPassword("123456"); dao.addUser(u); &#125;&#125;执行时，控制台抛出NullPointerException异常，但是数据插入成功了么？查询数据库：123456SQL&gt; select * from lzp.userinfo; USERI NAME AGE PWD----- ---------- --- ----------8 testUser 24 1234564 SCOTT 25 123456发现虽然addUser()方法抛出了异常，但是数据还是被成功的插入，这违背了事务的ACID原则。Spring提供了对事务管理的支持。这里仅介绍声明式事务。选择事务管理器JDBC事务管理器如果应用程序中直接使用JDBC来进行持久化，那么应该选择DataSourceTransactionManager作为事务管理器：1234&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;Hibernate事务管理器如果应用程序的持久化是通过Hibernate来实现的，那么应该选择HibernateTransactionManager作为事务管理器：1234&lt;bean id="transactionManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt;事务五大属性传播行为传播行为（propagation behavior）定义了客户端与被调用方法之间的事务边界。即何时要创建一个事务，或者何时使用已有的事务：传播行为含义PROPAGATION_MANDATORY表示该方法必须在事务中进行，如果当前事务不存在，则会 抛出一个异常PROPAGATION_NESTED如果当前已存在一个事务，那么该方法在嵌套事务中运行。 嵌套事务可以独立于当前事务进行单独地提交或回滚。如 果当前事务不存在，那么行为和 PROPAGATION_REQUIRED一样PROPAGATION_NEVER表示当前方法不运行在事务上下文中。如果当前正有一个 事务在运行，则会抛出异常PROPAGATION_NOT_SUPPORTED表示该方法不应该运行在事务上下文中，如果存在当前事 务，在该方法运行期间，当前事务会被挂起PROPAGATION_REQUIRED表示当前方法必须运行在事务中，如果事务不存在，则启 动一个新的事务PROPAGATION_REQUIRED_NEW表示当前方法必须运行在它自己的事务中。一个新的事务 将启动。如果存在当前事务，当前事务会被挂起PROPAGATION_SUPPORTS表示当前方法不需要事务上下文，但是如果存在当前事务 的话，那么该方法会在这个事务中运行&nbsp;&nbsp;隔离级别隔离级别（isolation level）定义了一个事务可能受其他并发事务的影响程度。并发操作相同的数据可能产生一些问题：1.脏读（Dirty reads）—— 发生在一个事务读取了另一个事务改写后但未提交的数据，如果改写被回滚了，那么第一个事务获取的数据就是“脏”的。2.不可重复读（Nonrepeatable read）—— 一个事务执行两次以上相同查询得到不同的数据。这通常是另外一个事务在此期间更新了数据。3.幻读（Phantom read）—— 一个事务读取了几行数据，另一个事务插入了几条数据，当第一个事务再次读取时发现多了几条原本没有的数据。隔离级别如下表所示：隔离级别含义ISOLATION_DEFAULT使用后端数据库默认的隔离级别ISOLATION_READ_UNCOMMITTED允许读取尚未提交的数据表更。可能导致脏读，不可重复 读，幻读ISOLATION_READ_COMMITTED允许读取并发事务已经提交的数据，可以阻止脏读，但不 可重复读，幻读仍可能发生ISOLATION_REPEATABLE_READ对同一字段的多次读取结果一致，除非数据是本事务自己 修改的。可以阻止脏读，不可重复读，但仍可能发生幻读REPEATABLE_SERIALIZABLE完全服从事务的ACID原则，避免脏读，不可重复读，幻读可以看出，ISOLATION_READ_UNCOMMITTED隔离级别是最低的，可能导致脏读，不可重复读，幻读。REPEATABLE_SERIALIZABLE隔离级别最高，但是这会降低数据读取速率，它通常是通过完全锁定事务相关的数据库表来实现的。只读只读（read-only） 如果事务只读数据库进行读操作，那么设置该属性为true可以给数据库执行优化措施。因为只读是在事务启动，由数据库实施的，所以对那些具备启动一个新的事务的传播行为（PROPAGATION_REQUIRED，PROPAGATION_REQUIRED_NEW和PROPAGATION_NESTED）才有意义。设置只读还会使Hibernate的flush模式被设置为FLUSH_NEVER。事务超时超时（timeout）假如事务运行时间过长，则会影响效率，所以可以设置超时属性，超时后执行自动回滚。因为超时时钟会在事务开启时启动，所以只有对那些具备启动一个新的事务的传播行为（PROPAGATION_REQUIRED，PROPAGATION_REQUIRED_NEW和PROPAGATION_NESTED）才有意义。回滚原则默认情况遇到运行期异常就回滚。回滚原则可以定义遇到哪些异常不回滚。XML中定义事务使用tx命名空间配置：123456&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="add*" propagation="REQUIRED"/&gt; &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;transaction-manager为上述的事务管理器。&lt;tx:method&gt;元素为某个（某些）name属性指定的方法定义事务参数。&lt;tx:method&gt;有多个属性来帮助定义方法的事务策略，这些属性对于上述的事务五大属性：属性含义isolation指定隔离级别propagation指定传播原则read-only指定事务为只读回滚原则：rollback-forno-rollback-forrollback-for指定事务为哪些检查型异常回滚no-rollback-for指定事务对哪些异常继续运行而不回滚timeout设定事务超时时间我们还需设定哪些Bean应该被通知，使用aop定义一个通知器（advisor）：12345&lt;aop:config&gt; &lt;aop:advisor pointcut="execution(* *..UserDaoImpl.*(..))" advice-ref="txAdvice"/&gt;&lt;/aop:config&gt;advice-ref属性引用了名为txAdvice的通知。现在测试添加事务后的addUser()方法：123456789101112public class TestTransaction &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao=ac.getBean("userDao",UserDao.class); User u=new User(); u.setName("testTx"); u.setAge("30"); u.setPassword("123456"); dao.addUser(u); &#125;&#125;控制台抛出异常：12Exception in thread "main" java.lang.NullPointerException at com.spring.dao.UserDaoImpl.addUser(UserDaoImpl.java:51)查询数据：123456SQL&gt; select * from lzp.userinfo; USERI NAME AGE PWD----- ---------- --- ----------8 testUser 24 1234564 SCOTT 25 123456可以发现testTx并没有被插入。注解事务除了使用XML定义事务，我们还可以注解事务，通过声明：1&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;tx:annotation-driven&gt;告诉Spring检查上下文中所有使用@Transaction注解的Bean，不管这个注解是在类级别上还是方法级别上。使用注解修改UserDaoImpl：12345678910111213141516@Repository("userDao")@Transactional(propagation=Propagation.SUPPORTS,readOnly=true)public class UserDaoImpl implements UserDao &#123; //... @Transactional(propagation=Propagation.REQUIRED,readOnly=false) public void addUser(User user) &#123; Map&lt;String, Object&gt; params=new HashMap&lt;String, Object&gt;(); params.put("name", user.getName()); params.put("age", user.getAge()); params.put("pwd", user.getPassword()); jdbcTemplate.update(SQL_INSERT_USER, params); String a=null; a.toString(); &#125; //...&#125;再次运行testTransaction()方法，抛出异常后查询数据库：123456SQL&gt; select * from lzp.userinfo; USERI NAME AGE PWD----- ---------- --- ----------8 testUser 24 1234564 SCOTT 25 123456可发现和XML配置事务效果是一样的。《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各进制数的转换]]></title>
    <url>%2F%E5%90%84%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[总结备忘。十进制转二进制方法为：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。12345678217/2 = 108 ---- 1108/2 = 54 ---- 054/2 = 27 ---- 027/2 = 13 ---- 113/2 = 6 ---- 16/2 = 3 ---- 03/2 = 1 ---- 11/2 = 0 ---- 1所以十进制217转二进制数为 11011001。js转换：12&gt; parseInt("217").toString(2);&gt; "11011001"二进制转十进制方法为：把二进制数按权展开、相加即得十进制数。$$ 11011001=1\times2^0+1\times2^3+1\times2^4+1\times2^6+1\times2^7=1+8+16+64+128=217 $$js转换：12&gt; parseInt("11011001",2);&gt; 217二进制转八进制方法为：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。$$ 11011001=(011)(011)(001)=(1\times2^0+1\times2^1)(t\times2^0+1\times2^1)(t\times2^0)=331 $$js转换：12&gt; parseInt("11011001",2).toString(8);&gt; "331"八进制转二进制方法为：八进制数每个位上的数分别转换为三位二进制，顺序从右往左。$$ 331=(3)(3)(1)=(011)(011)(001)=11011001 $$js转换：12&gt; parseInt('331',8).toString(2);&gt; "11011001"二进制转十六进制方法为：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。$$ 11011001=(1101)(1001)=(1\times2^0+1\times2^2+1\times2^3)(1\times2^0+1\times2^3)=(13)(9)=d9 $$js转换：12&gt; parseInt('11011001',2).toString(16);&gt; "d9"十六进制转二进制方法为：十六进制数每个位上的数分别转换为四位二进制，顺序从右往左。$$ d9=(d)(9)=(13)(9)=(1101)(1001)=11011001 $$js转换：12&gt; parseInt('d9',16).toString(2);&gt; "11011001"十进制转八进制方法和十进制转二进制类似：123150/8 = 18 ---- 618/8 = 2 ---- 22/8 = 0 ---- 2js转换：12&gt; parseInt(150).toString(8);&gt; "226"八进制转十进制方法：把八进制数按权展开、相加即得十进制数。$$ 226=2\times8^2+2\times8^1+6\times8^0=128=16=6=150 $$js转换：12&gt; parseInt('226',8);&gt; 150十进制转十六进制方法和十进制转二进制类似：12150/16 = 9 ---- 69/16 = 0 ---- 9js转换：12&gt; parseInt(150).toString(16);&gt; "96"十六进制转十进制方法：把八进制数按权展开、相加即得十进制数。$$ 96=9\times16^1+6\times16^0=144+16=150 $$js转换：12&gt; parseInt('96',16);&gt; 150]]></content>
      <tags>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring SimpleJdbcTemplate]]></title>
    <url>%2FSpring-SimpleJdbcTemplate.html</url>
    <content type="text"><![CDATA[Spring提供了JDBC模板，代替了JDBC繁琐操作。使用Spring JDBC模板我们不再需要手动去关闭连接，抛出的异常也更为明确。准备工作数据库创建表：123456create table userinfo ( userid varchar2(5) not null, name varchar2(10), age varchar2(3), pwd varchar2(10))创建序列：1create sequence user_seq start with 1 increment by 1;配置数据源连接池新建一个数据库配置文件db.properties：123username=oraclepassword=123456url=jdbc:oracle:thin:/localhost:1521/orcl在Spring配置文件读取db.properties1&lt;util:properties id="db" location="classpath:db.properties" /&gt;配置连接池：1234567891011&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="oracle.jdbc.OracleDriver"/&gt; &lt;!-- SpEL读取 --&gt; &lt;property name="url" value="#&#123;db.url&#125;"/&gt; &lt;property name="username" value="#&#123;db.username&#125;"/&gt; &lt;property name="password" value="#&#123;db.password&#125;"/&gt; &lt;property name="initialSize" value="5"/&gt; &lt;property name="maxActive" value="10"/&gt;&lt;/bean&gt;除了上述配置属性，下表列出了BasicDataSource的一些常用属性：池配置属性所指定的内容initialSize池启动时创建的连接数量maxActive同一时间可以从池中分配的最多连接数，如果设置为0，表示无限制maxIdle池里不会被释放的最多空闲连接数。如果设置为0，表示无限制maxOpenPreparedStatements在同一时间能够从语句池中分配的预处理语句的最大数量。如果设置 为0，表示无限制maxWait在抛出异常之前，池等待连接回收的最大时间 (当没有可用连接时)。 如果设置为-1，表示无限等待minEvictableIdleTimeMillis连接在池中保持空闲而不被回收的最大时间minIdle在不创建新连接的情况下，池中保持空闲的最小连接数poolPreparedStatements是否对预处理语句进行池管理（布尔类型）使用JdbcTemplate在Spring配置文件中配置JdbcTemplate：1234&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.simple.SimpleJdbcTemplate"&gt; &lt;constructor-arg ref="dataSource"/&gt;&lt;/bean&gt;新建一个User类，用于存储查询结果：1234567public class User &#123; private Integer userId; private String name; private String age; private String password; // get,set略&#125;新建UserDao interface，定义基本的增删改查方法：1234567public interface UserDao &#123; void addUser(User user); void deleteUser(Integer userId); void updateUser(User user); User selectUser(Integer userId); List&lt;User&gt; selectAll();&#125;新建UserDao实现类UserDaoImpl：12345678// DAO注解@Repository("userDao")public class UserDaoImpl implements UserDao &#123; // 注入JdbcTemplate @Resource private SimpleJdbcTemplate jdbcTemplate; // ......&#125;增加用户实现addUser()方法：12345678910private static final String SQL_INSERT_USER = "insert into userinfo (userid,name,age,pwd) " + "values (user_seq.nextval,?,?,?)";public void addUser(User user) &#123; Object[] params = &#123; user.getName(), user.getAge(), user.getPassword() &#125;; jdbcTemplate.update(SQL_INSERT_USER, params);&#125;上述SQL使用了索引参数，这使得我们不得不严格按照参数的顺序来定义参数。SimpleJdbcTemplate支持使用命名参数的SQL。修改addUser()方法：12345678910private static final String SQL_INSERT_USER = "insert into userinfo (userid,name,age,pwd) " + "values (user_seq.nextval,:name,:age,:pwd)";public void addUser(User user) &#123; Map&lt;String, Object&gt; params=new HashMap&lt;String, Object&gt;(); params.put("name", user.getName()); params.put("age", user.getAge()); params.put("pwd", user.getPassword()); jdbcTemplate.update(SQL_INSERT_USER, params);&#125;现在，参数的顺序已经不重要了，只要参数名称对应上就行。测试：123456789101112public class TestJdbc &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao=ac.getBean("userDao",UserDao.class); User user=new User(); user.setName("SCOTT"); user.setAge("25"); user.setPassword("123456"); dao.addUser(user); &#125;&#125;查询数据库：12345SQL&gt; select * from lzp.userinfo where name='SCOTT'; USERI NAME AGE PWD----- ---------- --- ----------5 SCOTT 25 123456删除用户实现deleteUser()方法：12345private static final String SQL_DELETE_USER = "delete from userinfo where userid=?";public void deleteUser(Integer userId) &#123; jdbcTemplate.update(SQL_DELETE_USER, userId);&#125;测试：12345678public class TestJdbc &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao=ac.getBean("userDao",UserDao.class); dao.deleteUser(5); &#125;&#125;查询数据库，SCOTT已被删除：123456SQL&gt; select * from lzp.userinfo; USERI NAME AGE PWD----- ---------- --- ----------6 JANE 24 1234567 MIKE 28 123456查询单个用户实现selectUser()方法：1234567891011121314151617private static final String SQL_SELECT_USER = "select * from userinfo where userid = ?";public User selectUser(Integer userId) &#123; return jdbcTemplate.queryForObject( SQL_SELECT_USER, new ParameterizedRowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setUserId(rs.getInt("userId")); user.setName(rs.getString("name")); user.setAge(rs.getString("age")); user.setPassword(rs.getString("pwd")); return user; &#125; &#125;, userId);&#125;测试：1234567891011public class TestJdbc &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao=ac.getBean("userDao",UserDao.class); User user=new User(); user=dao.selectUser(6); System.out.println(user.getName()); // JANE &#125;&#125;查询所有用户实现selectAll()方法：12345678910111213141516private static final String SQL_SELECT_All_USER = "select * from userinfo"; public List&lt;User&gt; selectAll() &#123; return jdbcTemplate.query( SQL_SELECT_All_USER, new ParameterizedRowMapper&lt;User&gt;() &#123; public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setUserId(rs.getInt("userId")); user.setName(rs.getString("name")); user.setAge(rs.getString("age")); user.setPassword(rs.getString("pwd")); return user; &#125; &#125;);&#125;测试：1234567891011public class TestJdbc &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao=ac.getBean("userDao",UserDao.class); List&lt;User&gt; list=dao.selectAll(); for(User u:list)&#123; System.out.println(u.getName()); &#125; &#125;&#125;输出：12JANEMIKE修改用户实现updateUser()方法：12345678private static final String SQL_UPDATE_USER = "update userinfo set age=:age where userid=:userid";public void updateUser(User user) &#123; Map&lt;String, Object&gt; params=new HashMap&lt;String, Object&gt;(); params.put("userid", user.getUserId()); params.put("age", user.getAge()); jdbcTemplate.update(SQL_UPDATE_USER, params);&#125;测试：1234567891011public class TestJdbc &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao=ac.getBean("userDao",UserDao.class); User user=new User(); user.setUserId(6); user.setAge("100"); dao.updateUser(user); &#125;&#125;查询数据库，可发现值已被修改：123456SQL&gt; select * from lzp.userinfo; USERI NAME AGE PWD----- ---------- --- ----------6 JANE 100 1234567 MIKE 28 123456Spring JDBC DAO支持类除了向DAO中注入simpleJdbcTemplate外，我们还可以通过继承Spring提供的SimpleJdbcDaoSupport类：123public class UserDaoImpl extends SimpleJdbcDaoSupport implements UserDao &#123; //... &#125;获取simpleJdbcTemplate对象可通过静态方法：getSimpleJdbcTemplate()。《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 事件函数]]></title>
    <url>%2FjQuery-%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[页面载入ready()当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这个方法纯粹是对向window.load事件注册事件的替代方法。有一个参数对jQuery函数的引用会传递到这个ready事件处理函数中。可以给这个参数任意起一个名字，并因此可以不再担心命名冲突而放心地使用$别名。可以在同一个页面中无限次地使用$(document).ready()事件。其中注册的函数会按照（代码中的）先后顺序依次执行。示例：在DOM加载完成时运行的代码，可以这样写：123$(document).ready(function()&#123; // 在这里写你的代码...&#125;);使用 $(document).ready() 的简写，同时内部的 jQuery 代码依然使用 $ 作为别名，而不管全局的 $ 是什么。123$(function($) &#123; // 你可以在这里继续使用$作为别名...&#125;); ​事件处理on(eve,[sel],[data],fn)on()方法在被选元素及子元素上添加一个或多个事件处理程序。自 jQuery 版本 1.7 起，on() 方法是 bind()、live() 和 delegate() 方法的新的替代品。该方法给 API 带来很多便利，我们推荐使用该方法，它简化了 jQuery 代码库。语法：1$(selector).on(event,childSelector,data,function,map)参数描述event必需。规定要从被选元素移除的一个或多个事件或命名空间。由空格分隔多个事件值。必须是有效的事件。childSelector可选。规定只能添加到指定的子元素上的事件处理程序（且不是选择器本身，比如已废弃的 delegate() 方法）。data可选。规定传递到函数的额外数据。function可选。规定当事件发生时运行的函数。map规定事件映射 ( {event:function, event:function, …}) ，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。示例：单击文本时，显示文本的内容：123$("p").on("click", function()&#123; alert( $(this).text() );&#125;);取消表单提交操作，并通过返回false防止事件冒泡：1$("form").on("submit", false)通过使用.preventDefault()取消默认操作：123$("form").on("submit", function(event) &#123; event.preventDefault();&#125;);使用.stopPropagation()停止事件冒泡，而不会阻止表单提交：123$("form").on("submit", function(event) &#123; event.stopPropagation();&#125;);off(eve,[sel],[fn])off() 方法通常用于移除通过 on() 方法添加的事件处理程序。自 jQuery 版本 1.7 起，off() 方法是 unbind()、die() 和 undelegate() 方法的新的替代品。该方法给 API 带来很多便利，我们推荐使用该方法，它简化了 jQuery 代码库。语法：1$(selector).off(event,selector,function(eventObj),map)参数描述event必需。规定要从被选元素移除的一个或多个事件或命名空间。由空格分隔多个事件值。必须是有效的事件。selector可选。规定添加事件处理程序时最初传递给 on() 方法的选择器。function(eventObj)可选。规定当事件发生时运行的函数。map规定事件映射 ( {event:function, event:function, …}) ，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。示例：从所有段落中删除所有事件处理函数：1$("p").off()从所有段落中删除所有单击函数：1$("p").off( "click", "**" )通过传递第三个参数，只删除一个先前绑定的处理函数：12345678910var foo = function () &#123; // code to handle some kind of event&#125;; // ... now foo will be called when paragraphs are clicked ...$("body").on("click", "p", foo); // ... foo will no longer be called.$("body").off("click", "p", foo);通过其命名空间解除所有委派的事件处理函数：123456789101112var validate = function () &#123; // code to validate form entries&#125;; // delegate events under the ".validator" namespace$("form").on("click.validator", "button", validate); $("form").on("keypress.validator", "input[type='text']", validate); // remove event handlers in the ".validator" namespace $("form").off(".validator");bind(type,[data],fn)为每个匹配元素的特定事件绑定事件处理函数。与其相反的函数为unbind()。语法：1$(selector).bind(event,data,function,map)参数描述event必需。规定添加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。data可选。规定传递到函数的额外数据。function必需。规定当事件发生时运行的函数。map规定事件映射 ( {event:function, event:function, …}) ，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。示例：当每个段落被点击的时候，弹出其文本：123$("p").bind("click", function()&#123; alert( $(this).text() );&#125;);同时绑定多个事件类型：123$('#foo').bind('mouseenter mouseleave', function() &#123; $(this).toggleClass('entered');&#125;);同时绑定多个事件类型/处理程序：12345$("button").bind(&#123; click:function()&#123;$("p").slideToggle();&#125;, mouseover:function()&#123;$("body").css("background-color","red");&#125;, mouseout:function()&#123;$("body").css("background-color","#FFFFFF");&#125; &#125;);你可以在事件处理之前传递一些附加的数据：1234function handler(event) &#123; alert(event.data.foo);&#125;$("p").bind("click", &#123;foo: "bar"&#125;, handler);通过返回false来取消默认的行为并阻止事件起泡：1$("form").bind("submit", function() &#123; return false; &#125;)通过使用 preventDefault() 方法只取消默认的行为：123$("form").bind("submit", function(event)&#123; event.preventDefault();&#125;);通过使用 stopPropagation() 方法只阻止一个事件起泡：123$("form").bind("submit", function(event)&#123; event.stopPropagation();&#125;); ​one(type,[data],fn)one() 方法为被选元素添加一个或多个事件处理程序，并规定当事件发生时运行的函数。当使用 one() 方法时，每个元素只能运行一次事件处理程序函数。语法：1$(selector).one(event,data,function)参数描述event必需。规定添加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。data可选。规定传递到函数的额外数据。function必需。规定当事件发生时运行的函数。示例：当所有段落被第一次点击的时候，显示所有其文本。123$("p").one("click", function()&#123; alert( $(this).text() );&#125;); ​trigger(type,[data])trigger() 方法触发被选元素上指定的事件以及事件的默认行为（比如表单提交）。这个函数也会导致浏览器同名的默认行为的执行。比如，如果用trigger()触发一个’submit’，则同样会导致浏览器提交表单。如果要阻止这种默认行为，应返回false。示例：页面一加载就执行button的click函数：12345$(document).ready(function()&#123; $("button").click(function()&#123; alert("123"); &#125;).trigger("click");&#125;);提交第一个表单，但不用submit()1$("form:first").trigger("submit")给一个事件传递参数1234$("p").click( function (event, a, b) &#123; // 一个普通的点击事件时，a和b是undefined类型 // 如果用下面的语句触发，那么a指向"foo",而b指向"bar"&#125; ).trigger("click", ["foo", "bar"]);下面的代码可以显示一个”Hello World”123$("p").bind("myEvent", function (event, message1, message2) &#123; alert(message1 + ' ' + message2);&#125;).trigger("myEvent", ["Hello","World!"]); ​triggerHandler(type, [data])这个方法与trigger()类似，但不会执行浏览器默认动作，也不会产生事件冒泡。事件委派live(type, [data], fn)jQuery 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的也有效。这个方法是基本是的 .bind() 方法的一个变体。使用 .bind() 时，选择器匹配的元素会附加一个事件处理函数，而以后再添加的元素则不会有。为此需要再使用一次 .bind() 才行。比如说：123&lt;body&gt; &lt;div class="clickme"&gt;Click here&lt;/div&gt;&lt;/body&gt;可以给这个元素绑定一个简单的click事件：123$('.clickme').bind('click', function() &#123; alert("Bound handler called.");&#125;);当点击了元素，就会弹出一个警告框。然后，想象一下这之后有另一个元素添加进来了。1$('body').append('&lt;div class="clickme"&gt;Another target&lt;/div&gt;');尽管这个新的元素也能够匹配选择器 “.clickme” ，但是由于这个元素是在调用 .bind() 之后添加的，所以点击这个元素不会有任何效果。.live() 就提供了对应这种情况的方法。如果我们是这样绑定click事件的：123$('.clickme').live('click', function() &#123; alert("Live handler called."); &#125;);然后再添加一个新元素：1$('body').append('&lt;div class="clickme"&gt;Another target&lt;/div&gt;');然后再点击新增的元素，他依然能够触发事件处理函数。从 jQuery 1.7 开始，不再建议使用 .live() 方法。请使用 .on() 来添加事件处理。与其作用相反的函数为die()。delegate(sel,[t],[d],fn)delegate() 方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。使用 delegate() 方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）。语法：1$(selector).delegate(childSelector,event,data,function)参数描述childSelector必需。规定要添加事件处理程序的一个或多个子元素。event必需。规定添加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。data可选。规定传递到函数的额外数据。function必需。规定当事件发生时运行的函数。示例：当点击鼠标时，隐藏或显示 p 元素：HTML 代码:1234&lt;div&gt; 这是一个段落。 &lt;button&gt;请点击这里&lt;/button&gt;&lt;/div&gt;jQuery 代码:123$("div").delegate("button","click",function()&#123; $("p").slideToggle();&#125;); ​delegate这个方法可作为live()方法的替代，使得每次事件绑定到特定的DOM元素。以下两段代码是等同的:12345678$("table").delegate("td", "hover", function()&#123; $(this).toggleClass("hover");&#125;);$("table").each(function()&#123; $("td", this).live("hover", function()&#123; $(this).toggleClass("hover"); &#125;); &#125;); ​与其相反的函数是undelegate()。事件切换hover([over,]out)当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。示例：鼠标悬停的表格加上特定的类：12345678$("td").hover( function () &#123; $(this).addClass("hover"); &#125;, function () &#123; $(this).removeClass("hover"); &#125;); ​下面连段代码效果相同：12$("td").bind("mouseenter mouseleave",handlerInOut);$("td").hover(handlerInOut);toggle([s],[easing],[fn])toggle() 方法在被选元素上进行 hide() 和 show() 之间的切换。如：在所有 元素上进行隐藏和显示之间的切换：123$("button").click(function()&#123; $("p").toggle();&#125;);该方法检查被选元素的可见状态。如果一个元素是隐藏的，则运行 show()，如果一个元素是可见的，则运行 hide() - 这会造成一种切换的效果。带参数语法：1$(selector).toggle(speed,easing,callback)参数描述speed可选。规定隐藏/显示效果的速度。 可能的值：毫秒“slow”“fast”easing可选。规定在动画的不同点上元素的速度。默认值为 “swing”。 可能的值：“swing” - 在开头/结尾移动慢，在中间移动快“linear” - 匀速移动callback可选。toggle() 方法执行完之后，要执行的函数。1秒之内动态隐藏和显示p元素：123$("button").click(function()&#123; $("p").toggle(1000);&#125;);1秒之内动态隐藏和显示p元素，并执行回调函数：12345$("button").click(function()&#123; $("p").toggle(1000,function()&#123; alert("toggle() 方法已完成!"); &#125;); ​&#125;);toggle(fn1,fn2...fnN)函数也可以用于几个函数间的切换，现有如下代码：123456789$("panel h5.head").bind("click",function()&#123; var $content=$(this).next("div.content"); if($content.is(":visible"))&#123; $content.hide(); &#125;else&#123; $content.show(); &#125; &#125;);使用toggle改写：1234567$("panel h5.head").toggle( function()&#123; $(this).next("div.content").show(); &#125;,function()&#123; $(this).next("div.content").hide(); &#125;);事件blur([[data],fn])当元素失去焦点时触发 blur 事件。示例：触发所有段落的blur事件：1$("p").blur();任何段落失去焦点时弹出一个 “Hello World!”在每一个匹配元素的blur事件中绑定的处理函数：1$("p").blur( function () &#123; alert("Hello World!"); &#125; ); ​change([[data],fn])当元素的值改变时发生 change 事件（仅适用于表单字段）。示例：当&lt;input&gt;文本值发生改变，且失去焦点或者按Enter键的时候触发：123$("input").change(function()&#123; alert("文本已被修改");&#125;);注意，在输入过程中，虽然值不断改变，但不会触发change()，除非&lt;input&gt;失去焦点或者按Enter键的时候触发。click([[data],fn])略。dblclick([[data],fn])略。error([[data],fn])当元素遇到错误（没有正确载入）时，发生 error 事件。如：图片加载错误时，替换为文本提示：123$("img").error(function()&#123; $("img").replaceWith("&lt;p&gt;图片加载错误!&lt;/p&gt;");&#125;);focus([[data],fn])当元素获得焦点时，触发 focus 事件。可以通过鼠标点击或者键盘上的TAB导航触发。这将触发所有绑定的focus函数。示例：当页面加载后将 id 为 ‘login’ 的元素设置焦点：123$(document).ready(function()&#123; $("#login").focus();&#125;);使人无法使用文本框：123$("input[type=text]").focus(function()&#123; this.blur();&#125;); ​focusin([data],fn)当元素（或在其内的任意元素）获得焦点时发生 focusin 事件。当在元素或在其内的任意元素上发生 focus 事件时，focusin() 方法添加要运行的函数。与 focus() 方法不同的是，focusin()方法在任意子元素获得焦点时也会触发。例如，现有div：1234&lt;div style="border: 1px solid black;padding:10px;"&gt; First name: &lt;input type="text"&gt;&lt;br&gt; Last name: &lt;input type="text"&gt;&lt;/div&gt;div子元素&lt;input&gt;获得焦点时，改变div的颜色：123$("div").focusin(function()&#123; $(this).css("background-color","#FFFFCC");&#125;);focusout([data],fn)与foucusin相反。keydown([[data],fn])当键盘或按钮被按下时，发生 keydown 事件。例如：在页面内对键盘按键做出回应，可以使用如下代码：12345678$(window).keydown(function(event)&#123; switch(event.which) &#123; // ... // 不同的按键可以做不同的事情 // 不同的浏览器的keycode不同 // ... &#125;&#125;);keypress([[data],fn])keydown：用户在键盘上按下某按键是发生。一直按着某按键则会不断触发（opera浏览器除外）。keypress：用户按下一个按键，并产生一个字符时发生（也就是不管类似shift、alt、ctrl之类的键，就是说用户按了一个能在屏幕上输出字符的按键keypress事件才会触发）。一直按着某按键则会不断触发。keyup([[data],fn])当按钮被松开时，发生 keyup 事件。mousedown([[d,fn])当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。mousedown 与 click 事件不同，mousedown 事件仅需要按键被按下，而不需要松开即可发生。鼠标按键可以为左键右键和滚轮。mouseup([[data],fn])与mousedown()相反。例子：当鼠标指向&lt;div&gt;并按下鼠标按键时，以及松开时触发事件：HTML：1&lt;div&gt;在这个 div 元素中按下和释放鼠标按钮。&lt;/div&gt;jQuery：123456$("div").mouseup(function()&#123; $(this).after("释放鼠标按钮。");&#125;);$("div").mousedown(function()&#123; $(this).after("按下鼠标按钮。");&#125;);mouseenter([[data],fn])当鼠标指针穿过元素时，会发生 mouseenter 事件。该事件大多数时候会与 mouseleave 事件一起使用。mouseleave([[data],fn])当鼠标指针离开元素时，会发生 mouseleave 事件。该事件大多数时候会与 mouseenter 事件一起使用。例子：当鼠标指针进入 &lt;p&gt; 元素时，设置背景色为黄色，离开时设置为灰色：HTML：1&lt;p&gt;鼠标移动到该段落。&lt;/p&gt;jQuery：123456$("p").mouseenter(function()&#123; $("p").css("background-color","yellow");&#125;);$("p").mouseleave(function()&#123; $("p").css("background-color","lightgray");&#125;);mouseover([[d],fn])当鼠标指针位于元素上方时，会发生 mouseover 事件。该事件大多数时候会与 mouseout 事件一起使用。注释：与 mouseenter 事件不同，不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。mouseout([[data],fn])当鼠标指针从元素上移开时，发生 mouseout 事件。mousemove([[data],fn])当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件。例子：获得鼠标指针在页面中的位置：123$(document).mousemove(function(event)&#123; $("span").text(event.pageX + ", " + event.pageY);&#125;);resize([[data],fn])当调整浏览器窗口的大小时，发生 resize 事件。例子：HTML：1&lt;p&gt;窗口重置了 &lt;span&gt;0&lt;/span&gt; 次大小。&lt;/p&gt;jQuery：123$(window).resize(function()&#123; $("span").text(x+=1);&#125;);scroll([[data],fn])当用户滚动指定的元素时，会发生 scroll 事件。对元素滚动的次数进行计数：123$("div").scroll(function()&#123; $("span").text(x+=1);&#125;);select([[data],fn])当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。123$("input").select(function()&#123; alert("文本已选中!");&#125;);submit([[data],fn])当提交表单时，会发生 submit 事件。该事件只适用于表单元素。如果你要阻止表单提交:123$("form").submit( function () &#123; return false;&#125;); ​unload([[data],fn])当用户离开页面时，会发生 unload 事件。当发生以下情况下，会触发 unload 事件：1.点击某个离开页面的链接2.在地址栏中键入了新的 URL3.使用前进或后退按钮4.关闭浏览器窗口5.重新加载页面unload() 方法只应用于 window 对象。123$(window).unload(function()&#123; alert("Goodbye!");&#125;);]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 文档处理]]></title>
    <url>%2FjQuery-%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[内部插入append(content|fn)向每个匹配的元素内部追加内容。示例：向所有段落中追加一些HTML标记：HTML 代码：1&lt;p&gt;I would like to say: &lt;/p&gt;jQuery 代码：1$("p").append("&lt;b&gt;Hello&lt;/b&gt;")结果：1&lt;p&gt;I would like to say: &lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;​appendTo(content)把所有匹配的元素追加到另一个指定的元素元素集合中。 实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。示例1：把所有段落追加到div元素中。HTML 代码：12&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; ​jQuery 代码：1$("p").appendTo("div")结果：12&lt;div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt; ​示例2：新建段落追加div中并加上一个classHTML 代码：1&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; ​jQuery 代码：12345$("&lt;p/&gt;") .appendTo("div") .addClass("test") .end() .addClass("test2"); ​结果：12&lt;div&gt;&lt;p class="test test2"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p class="test"&gt;&lt;/p&gt;&lt;/div&gt;prepend(content)向每个匹配的元素内部前置内容。示例1：向所有段落中前置一些HTML标记代码。HTML 代码：1&lt;p&gt;I would like to say: &lt;/p&gt;jQuery 代码：1$("p").prepend("&lt;b&gt;Hello&lt;/b&gt;");结果：1&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;示例2：将一个DOM元素前置入所有段落。HTML 代码：1234&lt;p&gt;I would like to say: &lt;/p&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b class="foo"&gt;Hello&lt;/b&gt;&lt;b class="foo"&gt;Good Bye&lt;/b&gt;jQuery 代码：1$("p").prepend( $(".foo")[0] );结果：123&lt;p&gt;&lt;b class="foo"&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;&lt;p&gt;&lt;b class="foo"&gt;Hello&lt;/b&gt;I would like to say: &lt;/p&gt;&lt;b class="foo"&gt;Good Bye&lt;/b&gt; ​prependTo(content)把所有匹配的元素前置到另一个、指定的元素元素集合中。实际上，使用这个方法是颠倒了常规的$(A).prepend(B)的操作，即不是把B前置到A中，而是把A前置到B中。示例1：HTML 代码：1&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;&lt;/div&gt;jQuery 代码：1$("p").prependTo("#foo");结果：1&lt;div id="foo"&gt;&lt;p&gt;I would like to say: &lt;/p&gt;&lt;/div&gt; ​外部插入after(content|fn)在每个匹配的元素之后插入内容。示例1：在所有段落之后插入一些HTML标记代码。HTML 代码：1&lt;p&gt;I would like to say: &lt;/p&gt;jQuery 代码：1$("p").after("&lt;b&gt;Hello&lt;/b&gt;");结果：1&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt; ​示例2：在所有段落之后插入一个DOM元素。HTML 代码：1&lt;b id="foo"&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;jQuery 代码：1$("p").after( $("#foo")[0] );结果：1&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b id="foo"&gt;Hello&lt;/b&gt; ​示例3：在所有段落中后插入一个jQuery对象(类似于一个DOM元素数组)。HTML 代码：1&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;jQuery 代码：1$("p").after( $("b") );结果：1&lt;p&gt;I would like to say: &lt;/p&gt;&lt;b&gt;Hello&lt;/b&gt; ​insertAfter(content)把所有匹配的元素插入到另一个、指定的元素元素集合的后面。实际上，使用这个方法是颠倒了常规的$(A).after(B)的操作，即不是把B插入到A后面，而是把A插入到B后面。示例：把所有段落插入到一个元素之后。与 $(&quot;#foo&quot;).after(&quot;p&quot;)相同HTML 代码：1&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;Hello&lt;/div&gt;jQuery 代码：1$("p").insertAfter("#foo");结果：1&lt;div id="foo"&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt; ​before(content|fn)在每个匹配的元素之前插入内容。示例：在所有段落之前插入一些HTML标记代码。HTML 代码：1&lt;p&gt;I would like to say: &lt;/p&gt;jQuery 代码：1$("p").before("&lt;b&gt;Hello&lt;/b&gt;");结果：1&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;I would like to say: &lt;/p&gt;insertBefore(content)把所有匹配的元素插入到另一个、指定的元素元素集合的前面。实际上，使用这个方法是颠倒了常规的$(A).before(B)的操作，即不是把B插入到A前面，而是把A插入到B前面。示例：把所有段落插入到一个元素之前。与 $(&quot;#foo&quot;).before(&quot;p&quot;)相同。HTML 代码：1&lt;div id="foo"&gt;Hello&lt;/div&gt;&lt;p&gt;I would like to say: &lt;/p&gt;jQuery 代码：1$("p").insertBefore("#foo");结果：1&lt;p&gt;I would like to say: &lt;/p&gt;&lt;div id="foo"&gt;Hello&lt;/div&gt; ​包裹wrap(html|element|fn)把所有匹配的元素用其他元素的结构化标记包裹起来。示例：html参数描述：把所有的段落用一个新创建的div包裹起来jQuery 代码：1$("p").wrap("&lt;div class='wrap'&gt;&lt;/div&gt;");elem参数描述：用ID是”content”的div将每一个段落包裹起来jQuery 代码：1$("p").wrap(document.getElementById('content'));回调函数描述：用原先div的内容作为新div的class，并将每一个元素包裹起来HTML 代码：1234&lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt;&lt;/div&gt;jQuery 代码：123$('.inner').wrap(function() &#123; return '&lt;div class="' + $(this).text() + '" /&gt;';&#125;);结果：12345678&lt;div class="container"&gt; &lt;div class="Hello"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;div class="Goodbye"&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; ​unwrap()这个方法将移出元素的父元素。这能快速取消 .wrap()方法的效果。匹配的元素（以及他们的同辈元素）会在DOM结构上替换他们的父元素。示例：HTML 代码：12345&lt;div&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;p&gt;cruel&lt;/p&gt; &lt;p&gt;World&lt;/p&gt;&lt;/div&gt;jQuery 代码：1$("p").unwrap()结果：123&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt; ​wrapAll(html|ele)将所有匹配的元素用单个元素包裹起来。示例：html描述：用一个生成的div将所有段落包裹起来。HTML代码：123&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt; ​jQuery 代码：1$("p").wrapAll("&lt;div&gt;&lt;/div&gt;");结果：12345&lt;div&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;p&gt;cruel&lt;/p&gt; &lt;p&gt;World&lt;/p&gt;&lt;/div&gt; ​elem描述：用一个生成的div将所有段落包裹起来jQuery 代码：1$("p").wrapAll(document.createElement("div")); ​wrapInner(htm|ele|fn)将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来。示例：参数html描述：把所有段落内的每个子内容加粗jQuery 代码：1$("p").wrapInner("&lt;b&gt;&lt;/b&gt;");参数elem描述：把所有段落内的每个子内容加粗jQuery 代码：1$("p").wrapInner(document.createElement("b"));回调函数描述：用原先div的内容作为新div的class，并将每一个元素包裹起来HTML 代码：1234&lt;div class="container"&gt; &lt;div class="inner"&gt;Hello&lt;/div&gt; &lt;div class="inner"&gt;Goodbye&lt;/div&gt;&lt;/div&gt;jQuery 代码：123$('.inner').wrapInner(function() &#123; return '&lt;div class="' + $(this).text() + '" /&gt;';&#125;);结果：12345678&lt;div class="container"&gt; &lt;div class="inner"&gt; &lt;div class="Hello"&gt;Hello&lt;/div&gt; &lt;/div&gt; &lt;div class="inner"&gt; &lt;div class="Goodbye"&gt;Goodbye&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;替换replaceWith(content|fn)将所有匹配的元素替换成指定的HTML或DOM元素。示例1：把所有的段落标记替换成加粗的标记。HTML 代码：1&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;jQuery 代码：1$("p").replaceWith("&lt;b&gt;Paragraph. &lt;/b&gt;");结果：1&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt; ​示例2：用第一段替换第三段，你可以发现他是移动到目标位置来替换，而不是复制一份来替换。HTML 代码：12345&lt;div class="container"&gt; &lt;div class="inner first"&gt;Hello&lt;/div&gt; &lt;div class="inner second"&gt;And&lt;/div&gt; &lt;div class="inner third"&gt;Goodbye&lt;/div&gt;&lt;/div&gt;jQuery 代码：1$('.third').replaceWith($('.first'));结果：1234&lt;div class="container"&gt; &lt;div class="inner second"&gt;And&lt;/div&gt; &lt;div class="inner first"&gt;Hello&lt;/div&gt;&lt;/div&gt; ​replaceAll(selector)用匹配的元素替换掉所有 selector匹配到的元素。和 replaceWith() 相反。示例：把所有的段落标记替换成加粗标记HTML 代码：1&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;jQuery 代码：1$("&lt;b&gt;Paragraph. &lt;/b&gt;").replaceAll("p");结果：1&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt;&lt;b&gt;Paragraph. &lt;/b&gt; ​删除empty()删除匹配的元素集合中所有的子节点。示例：把所有段落的子元素（包括文本节点）删除HTML 代码：1&lt;p&gt;Hello, &lt;span&gt;Person&lt;/span&gt; &lt;a href="#"&gt;and person&lt;/a&gt;&lt;/p&gt;jQuery 代码：1$("p").empty();结果：1&lt;p&gt;&lt;/p&gt; ​remove([expr])从DOM中删除所有匹配的元素。这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。但除了这个元素本身得以保留之外，其他的比如绑定的事件，附加的数据等都会被移除。示例1：从DOM中把所有段落删除HTML 代码：1&lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;jQuery 代码：1$("p").remove();结果：1how are示例2：从DOM中把带有hello类的段落删除。HTML 代码：1&lt;p class="hello"&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;jQuery 代码：1$("p").remove(".hello");结果：1how are &lt;p&gt;you?&lt;/p&gt; ​detach([expr])从DOM中删除所有匹配的元素。 这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。复制clone([Even[,deepEven]])克隆匹配的DOM元素并且选中这些克隆的副本。示例1：克隆所有b元素（并选中这些克隆的副本），然后将它们前置到所有段落中。HTML 代码:1&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;, how are you?&lt;/p&gt;jQuery 代码:1$("b").clone().prependTo("p");结果:1&lt;b&gt;Hello&lt;/b&gt;&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;, how are you?&lt;/p&gt;示例2：创建一个按钮，他可以复制自己，并且他的副本也有同样功能。HTML 代码:1&lt;button&gt;Clone Me!&lt;/button&gt;jQuery 代码:123$("button").click(function()&#123; $(this).clone(true).insertAfter(this);&#125;); ​]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用注解配置AOP切面]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEAOP%E5%88%87%E9%9D%A2.html</url>
    <content type="text"><![CDATA[注解切面除了使用XML配置AOP切面，我们还可以使用更简洁的注解配置。现使用注解修改Audience类：123456789101112131415161718192021222324252627282930313233343536import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectpublic class Audience &#123; // 声明切点 @Pointcut("execution(* com.spring.entity.Performer.perform(..))") public void performance()&#123; &#125; // 表演之前 @Before("performance()") public void takeSeats()&#123; System.out.println("观众入座"); &#125; // 表演之前 @Before("performance()") public void turnOffCellPhones()&#123; System.out.println("关闭手机"); &#125; // 表演之后 @AfterReturning("performance()") public void applaud()&#123; System.out.println("啪啪啪啪啪"); &#125; // 表演失败后 @AfterThrowing("performance()") public void failure()&#123; System.out.println("坑爹，退钱！"); &#125;&#125;@Aspect使得Audience成为了切面。为了让Spring识别改注解，我们还需在XML中添加&lt;aop:aspectj-autoproxy/&gt;。&lt;aop:aspectj-autoproxy/&gt;将在Spring应用上下文中创建一个AnnotationAwareAspectJAutoProxyCreator类，它会自动代理@Aspect标注的Bean：1&lt;aop:aspectj-autoproxy proxy-target-class="true" /&gt;实例化kenny，输出：123456观众入座关闭手机唱：May Rain吹萨克斯啪啪啪啪啪和XML配置AOP效果一样。在这途中遇到错误：1：error at ::0 can't find referenced pointcut XXX网络上的说法是JDK不匹配造成的，我原来用的JDK1.7匹配的是aspectjrt.1.6和aspectjweaver.1.6,因此会报错。 如果要使用AspectJ完成注解切面需要注意下面的JDK与AspectJ的匹配：JDK1.6 —— aspectJ1.6JDK1.7 —— aspectJ1.7.3+aspectJ1.7下载链接：密码：6wd7注解环绕通知使用@Around注解环绕通知：123456789101112131415161718192021222324@Component@Aspectpublic class Audience &#123; // 声明切点 @Pointcut("execution(* com.spring.entity.Performer.perform(..))") public void performance()&#123; &#125; @Around("performance()") public void watch(ProceedingJoinPoint joinpoint)&#123; try&#123; System.out.println("观众入座"); System.out.println("关闭手机"); long start=System.currentTimeMillis(); // 执行被通知的方法！ joinpoint.proceed(); long end=System.currentTimeMillis(); System.out.println("啪啪啪啪啪"); System.out.println("表演耗时："+(end-start)+" milliseconds"); &#125;catch(Throwable t)&#123; System.out.println("坑爹，退钱！"); &#125; &#125;&#125;实例化kenny，输出：123456观众入座关闭手机唱：May Rain吹萨克斯啪啪啪啪啪表演耗时：30 milliseconds注解传递参数修改Magician类：123456789101112131415161718192021222324import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectpublic class Magician implements MindReader&#123; private String thoughts; // 声明参数化切点 @Pointcut("execution(* com.spring.entity." + "Thinker.thinkOfSomething(String)) &amp;&amp; args(thoughts)") public void thinking(String thoughts) &#123; &#125; // 把参数传递给通知 @Before("thinking(thoughts)") public void interceptThoughts(String thoughts) &#123; System.out.println("侦听志愿者的心声"); this.thoughts=thoughts; &#125; public String getThoughts() &#123; return thoughts; &#125;&#125;&lt;aop:pointcut&gt;变为@Pointcut注解，&lt;aop:before&gt;变为@Before注解。测试：12345678910public class TestIntercept &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Volunteer volunteer = (Volunteer) ac.getBean("volunteer"); volunteer.thinkOfSomething("演出真精彩！"); Magician magician = (Magician) ac.getBean("magician"); System.out.println("志愿者心里想的是："+magician.getThoughts()); &#125;&#125;输出：12侦听志愿者的心声志愿者心里想的是：演出真精彩！通过注解引入新的方法之前通过在XML中配置AOP切面的方法为Bean引入新的方法，现在改用注解的方式来实现：新建一个ContestantIntroducer类：123456789101112import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;import org.springframework.stereotype.Component;@Component@Aspectpublic class ContestantIntroducer &#123; @DeclareParents( value = "com.spring.entity.Performer+", defaultImpl = OutstandingContestant.class) public static Contestant contestant;&#125;@DeclareParents注解代替了之前的&lt;aop:declare-parents&gt;标签。 @DeclareParents注解由三个部分组成：1.value属性等同于&lt;aop:declare-parents&gt;的types-matching属性。它标识应该被引入指定接口的Bean。2.defaultImpl属性等同于&lt;aop:declare-parents&gt;的default-impl属性。它标识该类所引入接口的实现。3.由@DeclareParents注解所标注的static属性制订了将被引入的接口。测试：12345678910public class Play &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Instrumentalist kenny = (Instrumentalist)ac.getBean("kenny"); kenny.perform(); Contestant kenny1=(Contestant) ac.getBean("kenny"); kenny1.receiveAward(); &#125;&#125;输出：1234567观众入座关闭手机唱：May Rain吹萨克斯啪啪啪啪啪表演耗时：27 milliseconds参加颁奖典礼《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring XML中声明切面]]></title>
    <url>%2F%E5%9C%A8Spring-XML%E4%B8%AD%E5%A3%B0%E6%98%8E%E5%88%87%E9%9D%A2.html</url>
    <content type="text"><![CDATA[在Spring AOP中，需要使用AspectJ的切点表达式语言来定义切点。下表列出了Spring AOP所支持的AspectJ切点指示器：AspectJ指示器描述arg()限制连接点匹配参数为指定类型的执行方法@args()限制连接点匹配参数由指定注解标注的执行方法execution()用于匹配是连接点的执行方法this()限制连接点匹配AOP代理的Bean引用的指定类型的类target()限制连接点匹配目标对象为执行类型的类@target()限制连接点匹配特定的执行对象，这些对象对应的类要具备指定类型的注解within()限制连接点匹配指定的类型@within()限制连接点匹配指定注解所标注的类型(当使用Spring AOP时，方法定义在由指定的注解所标注的类里)@annotation()限制匹配带有指定注解连接点编写切点如下所示的切点表达式表示当Instrument的play()方法执行时会触发通知。1execution(* com.spring.entity.Instrument.play(..))使用execution()指示器选择Instrument的play()方法。方法表达式以*开始，表示返回任意类型的返回值。然后指定了全限定类名和方法名。对于参数列表(..)标识切点选择任意的pay()方法，无论方法的入参是什么。使用Spring的Bean()指示器Spring2.5引入了新的bean()指示器。如：1execution(* com.spring.entity.Instrument.play()) and bean(eddie)表示，执行Instrument的play()方法时应用通知，并且Bean的ID为eddie。XML中配置AOP在Spring XML中配置AOP使用元素，下表概述了AOP配置元素。AOP配置元素描述&lt;aop:advisor&gt;定义AOP通知器&lt;aop:after&gt;定义AOP后置通知(不管被通知的方法是否执行成功)&lt;aop:after-returning&gt;定义AOP after-returning通知&lt;aop:after-throwing&gt;定义AOP after-throwing通知&lt;aop:around&gt;定义AOP环绕通知&lt;aop:aspect&gt;定义切面&lt;aop:aspectj-autoproxy&gt;启用@AspectJ注解驱动切面&lt;aop:before&gt;定义AOP前置通知&lt;aop:config&gt;顶层的AOP配置元素&lt;aop:declare-parents&gt;为被通知的对象引入额外的接口，并透明的实现&lt;aop:pointcut&gt;定义切点为了演示Spring AOP，现在定义一个观众类 Audience：123456789101112131415161718public class Audience &#123; // 表演之前 public void takeSeats()&#123; System.out.println("观众入座"); &#125; // 表演之前 public void turnOffCellPhones()&#123; System.out.println("关闭手机"); &#125; // 表演之后 public void applaud()&#123; System.out.println("啪啪啪啪啪"); &#125; // 表演失败后 public void failure()&#123; System.out.println("坑爹，退钱！"); &#125;&#125;在Spring XML中配置该Bean：1&lt;bean id="audience" class="com.spring.entity.Audience"/&gt;声明前置和后置通知将audience Bean变成一个切面：12345678910111213141516&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:before pointcut= "execution(* com.spring.entity.Performer.perform(..))" method="takeSeats"/&gt; &lt;aop:before pointcut= "execution(* com.spring.entity.Performer.perform(..))" method="turnOffCellPhones"/&gt; &lt;aop:after-returning pointcut= "execution(* com.spring.entity.Performer.perform(..))" method="applaud"/&gt; &lt;aop:after-throwing pointcut= "execution(* com.spring.entity.Performer.perform(..))" method="failure"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;四个切点的表达式完全一样，我们可以简化上述写法：1234567891011121314&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:pointcut id="performance" expression="execution(* com.spring.entity.Performer.perform(..))"/&gt; &lt;aop:before pointcut-ref="performance" method="takeSeats"/&gt; &lt;aop:before pointcut-ref="performance" method="turnOffCellPhones"/&gt; &lt;aop:after-returning pointcut-ref="performance" method="applaud"/&gt; &lt;aop:after-throwing pointcut-ref="performance" method="failure"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;再次实例化kenny：12345678public class Play &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Instrumentalist kenny=(Instrumentalist)ac.getBean("kenny"); kenny.perform(); &#125;&#125;结果发现报错：12Exception in thread "main" java.lang.ClassCastException: com.sun.proxy.$Proxy8 cannot be cast to...原因暂时还不晓得…😢解决办法，在&lt;aop:config&gt;元素添加proxy-target-class=&quot;true&quot;：123&lt;aop:config proxy-target-class="true"&gt; //...&lt;/aop:config&gt;输出：12345观众入座关闭手机唱：May Rain吹萨克斯啪啪啪啪啪现在在Instrumentalist的perform()方法里制造一个异常：12345public void perform() &#123; System.out.println("唱："+song+""); instrument = null; instrument.play();&#125;实例化kenny输出：12345观众入座关闭手机唱：May Rain坑爹，退钱！Exception in thread "main" java.lang.NullPointerException声明环绕通知如果不使用成员变量，那么在前置通知和后置通知之间共享信息是非常麻烦的。可以使用环绕通知代替前置通知和后置通知，现在在Audience类里添加一个新的方法：123456789101112131415 public void watch(ProceedingJoinPoint joinpoint)&#123; try&#123; System.out.println("观众入座"); System.out.println("关闭手机"); long start=System.currentTimeMillis(); // 执行被通知的方法！ joinpoint.proceed(); long end=System.currentTimeMillis(); System.out.println("啪啪啪啪啪"); System.out.println("表演耗时："+(end-start)+"milliseconds"); &#125;catch(Throwable t)&#123; System.out.println("坑爹，退钱！"); &#125;&#125;对于新的方法，我们使用了ProceedingJoinPoint作为参数，这个对象可以在通知里调用被通知的方法！！我们要把控制转给被通知的方法时，必须调用ProceedingJoinPoint的proceed()方法。修改&lt;aop:config&gt;元素：123456789&lt;aop:config proxy-target-class="true"&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:pointcut id="performance" expression="execution(* com.spring.entity.Performer.perform(..))"/&gt; &lt;aop:around pointcut-ref="performance" method="watch"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;实例化kenny输出：123456观众入座关闭手机唱：May Rain吹萨克斯啪啪啪啪啪表演耗时：20 milliseconds假如不调用ProceedingJoinPoint的proceed()方法发现输出为：1234观众入座关闭手机啪啪啪啪啪表演耗时：0 milliseconds这样我们使用AOP就没啥意义了。我们甚至可以重复调用ProceedingJoinPoint的proceed()方法，重复执行perform()方法，输出：12345678910观众入座关闭手机唱：May Rain吹萨克斯唱：May Rain吹萨克斯唱：May Rain吹萨克斯啪啪啪啪啪表演耗时：22 milliseconds为通知传递参数定义一个新的参赛者，他是一个读心者，由MindReader接口所定义：1234public interface MindReader &#123; void interceptThoughts(String thoughts); String getThoughts();&#125;魔术师Magician实现该接口：1234567891011public class Magician implements MindReader&#123; private String thoughts; public void interceptThoughts(String thoughts) &#123; System.out.println("侦听志愿者的心声"); this.thoughts=thoughts; &#125; public String getThoughts() &#123; return thoughts; &#125;&#125;再定义一个Magician所要侦听的志愿者，首先定义一个思考者接口：123public interface Thinker &#123; void thinkOfSomething(String thoughts);&#125;志愿者Volunteer实现该接口：123456789public class Volunteer implements Thinker&#123; private String thoughts; public void thinkOfSomething(String thoughts) &#123; this.thoughts=thoughts; &#125; public String getThoughts()&#123; return thoughts; &#125;&#125;接下来使用Spring AOP传递Volunteer的thoughts参数，以此实现Magician的侦听。。。:1234567891011&lt;bean id="magician" class="com.spring.entity.Magician"/&gt;&lt;aop:config proxy-target-class="true"&gt; &lt;aop:aspect ref="magician"&gt; &lt;aop:pointcut id="thinking" expression=" execution(* com.spring.entity.Volunteer.thinkOfSomething(String)) and args(thoughts)"/&gt; &lt;aop:before pointcut-ref="thinking" method="interceptThoughts" arg-names="thoughts"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;arg-names属性传递了参数给interceptThoughts()方法。测试：12345678910public class TestIntercept &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Volunteer volunteer = (Volunteer) ac.getBean("volunteer"); volunteer.thinkOfSomething("演出真精彩！"); Magician magician = (Magician) ac.getBean("magician"); System.out.println("志愿者心里想的是："+magician.getThoughts()); &#125;&#125;输出：12侦听志愿者的心声志愿者心里想的是：演出真精彩！通过切面引入新的方法现在假设要给Performer派生类添加一个新的方法，传统做法是找到所有派生类，让后逐个增加新的方法或者实现。这不但很累而且假设第三方实现没有源码的话，这个过程会变得很困难。幸好，通过Spring AOP可以不必入侵性地改变原有地实现。比如，现在要给所有演出者添加一个receiveAward()方法：新增一个接口Contestant：123public interface Contestant &#123; void receiveAward();&#125;由OutstandingContestant实现：12345public class OutstandingContestant implements Contestant&#123; public void receiveAward() &#123; System.out.println("参加颁奖典礼"); &#125;&#125;XML：12345678&lt;aop:config proxy-target-class="true"&gt; &lt;aop:aspect&gt; &lt;aop:declare-parents types-matching="com.spring.entity.Performer+" implement-interface="com.spring.entity.Constentant" default-impl="com.spring.entity.OutstandingContestant"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;或者：123456789&lt;bean id="contestantDelegate" class="com.spring.entity.OutstandingContestant"/&gt;&lt;aop:config proxy-target-class="true"&gt; &lt;aop:aspect&gt; &lt;aop:declare-parents types-matching="com.spring.entity.Performer+" implement-interface="com.spring.entity.Contestant" delegate-ref="contestantDelegate"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;types-matching指定所要添加新方法的派生类实现的接口，implement-interface指定要实现新的接口，default-impl指定这个接口的实现类。测试：12345678910public class Play &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Instrumentalist kenny=(Instrumentalist)ac.getBean("kenny"); kenny.perform(); Contestant kenny1=(Contestant) ac.getBean("kenny"); kenny1.receiveAward(); &#125;&#125;输出：123唱：May Rain吹萨克斯参加颁奖典礼《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP术语]]></title>
    <url>%2FAOP%E6%9C%AF%E8%AF%AD.html</url>
    <content type="text"><![CDATA[在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。—— 百度百科通知(Advice)在AOP中，切面的工作被称为通知。通知定义了切面是什么以及何时使用。Spring切面可以应用5中类型的通知：Before —— 在方法被调用之前调用通知。After —— 在方法完成之后调用通知，无论方法是否执行成功。After-returning —— 在方法成功执行之后调用通知。After-throwing —— 在方法抛出异常以后调用通知。Around —— 通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。连接点(Joinpoint)连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时，抛出异常时，甚至是修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。切点(Pointcut)切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称模式来指定这些切点。切面(Aspect)切面是通知和切点的结合。通知和切点共同定义了关于切面的全部内容 —— 它是什么，在何时和何处完成其功能。引入(Introduction)引入允许我们向现有的类添加新的方法和属性。织入(Weaving)织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：编译器 —— 切面在目标类编译时被织入。类加载期 —— 切面在目标类加载到JVM时被织入。运行期 —— 切面在应用运行的某个时候被织入。Spring AOP就是以这种方式织入切面的。]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 自动检测Bean]]></title>
    <url>%2FSpring-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BBean.html</url>
    <content type="text"><![CDATA[开启自动检测开启自动检测Bean有两种方式：XML配置&lt;context:annotation-config&gt;虽然消除了&lt;property&gt;和&lt;constructor-arg&gt;元素，但我们仍需使用&lt;bean&gt;元素显示定义Bean。&lt;context:component-scan&gt;除了完成与&lt;context:annotation-config&gt;一样的工作还可以自动检测Bean和定义Bean。在Spring XML中配置：12&lt;context:component-scan base-package="com.spring.entity"&gt;&lt;/context:component-scan&gt;base-package指定了扫描的路径。Java配置1234567import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration; @Configuration@ComponentScanpublic class InstrumentConfig&#123;&#125;@ComponentScan会扫描与该类相同包下的所有带有@Component注解的类。如果想明确指出扫描路径，可以配置value：1@ComponentScan(basePackages="com.spring")也可以配置多个扫描路径：1@ComponentScan(basePackages=&#123;"com.spring.entity","com.spring.dao"&#125;)除了指定扫描路径，我们也可以指定扫描的类型：1@ComponentScan(basePackageClasses=&#123;Piano.class,Guitar.class&#125;)为自动检测标注Bean注解类型：@Component —— 通用的构造型注解，标识该类为Spring组件。@Controller —— 标识将该类定义为Spring MVC Controller组件。@Repository —— 标识将该类定义为数据仓库。@Service —— 标识将该类定义为服务。通过标注这些注解，Spring才知道哪些类要被注册为Spring Bean。如，使用@Component标注Guitar类：123456@Componentpublic class Guitar implements Instrument&#123; public void play() &#123; System.out.println("弹奏吉他"); &#125; &#125;Spring扫描com.spring.entity包时，会发现使用@Component注解所标注的Guitar，并自动将其注册为Spring Bean。Bean的ID默认为无限定首字母小写类名，也就是guitar。我们也可以显式设定ID：1234567891011121314151617181920212223242526272829@Component("kenny")public class Instrumentalist implements Performer&#123; @Value("May Rain") private String song; @Autowired @Qualifier("guitar") private Instrument instrument; public Instrumentalist() &#123; &#125; public void perform() &#123; System.out.println("唱："+song+""); instrument.play(); &#125; //注入歌曲 public String getSong() &#123; return song; &#125; public void setSong(String song) &#123; this.song = song; &#125; public Instrument getInstrument() &#123; return instrument; &#125; //注入乐器 public void setInstrument(Instrument instrument) &#123; this.instrument = instrument; &#125;&#125;也可以使用@Named(&quot;kenny&quot;)代替@Component(&quot;kenny&quot;)，但一般我们还是使用@Component(&quot;kenny&quot;)比较直观。然后实例化kenny Bean：12345678public class Play &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Instrumentalist kenny=(Instrumentalist)ac.getBean("kenny"); kenny.perform(); &#125;&#125;输出：12唱：May Rain弹奏吉他现在在XML中没有任何&lt;bean&gt;元素，也实现了和先前一样的效果。在这个过程中，遇到了两个问题：12345678Exception in thread "main" org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [F:\workspaces\Spring\Spring2\build\classes\com\spring\entity\Guitar.class]; nested exception is org.springframework.core.NestedIOException: ASM ClassReader failed to parse class file - probably due to a new Java class file version that isn't supported yet: file [F:\workspaces\Spring\Spring2\build\classes\com\spring\entity\Guitar.class]; nested exception is java.lang.IllegalArgumentException通过查阅资料，发现有位老外给出了解释：Note that the Java 8 bytecode level (-target 1.8, as required by -source 1.8) is only fully supported as of Spring Framework 4.0. In particular, Spring 3.2 based applications need to be compiled with a maximum of Java 7 as the target, even if they happen to be deployed onto a Java 8 runtime. Please upgrade to Spring 4 for Java 8 based applications.于是将jdk改为1.7版本。修改后又遇到异常：12Exception in thread "main" java.lang.UnsupportedClassVersionError: ...原来是jdk版本和jvm版本不一致所致。右键项目–&gt;properties–&gt;java compiler –&gt; Enable project specific settings –&gt;将compiler compliance level设置为1.7，至此问题都解决了。过滤组件扫描&lt;context:component-scan&gt;默认扫描指定路径下通过@Component标注的Bean。假如现在我们只要把Instrument所派生的类注册为Spring Bean，我们不得不去查看所有java代码，一个一个的给Instrument派生类添加@Component注解，假如有第三方实现了Instrument，其源码我们还看不到，这时候添加@Component注解就变得非常困难甚至不可能。幸好，我们还可以给&lt;context:component-scan&gt;元素添加过滤行为：通过为其配置&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子元素。比如：123456&lt;context:component-scan base-package="com.spring.entity"&gt; &lt;context:include-filter type="assignable" expression="com.spring.entity.Instrument"/&gt; &lt;context:exclude-filter type="annotation" expression="com.spring.entity.SkipIt"/&gt;&lt;/context:component-scan&gt;其中，过滤器类型有5种：过滤器类型描述annotation过滤器扫描使用指定注解所标注的那些类，通过expression属性指定要扫描的注解assignable过滤器扫描派生于expression属性所指定类型的那些类aspectj过滤器扫描与expression属性所指定的AspectJ表达式所匹配的那些类custom使用自定义的org.springframework.core.type.TypeFilter实现类，该类由expression 属性指定regex过滤器扫描类的名称与expression属性所指定的正则表达式所匹配的类com.spring.entity.SkipIt自定义限定器：123456@Target(&#123;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface SkipIt &#123; &#125;com.spring.entity目录下有三个类派生于Instrument：Piano，Saxophone，Guitar。现在用@SkipIt标注Piano和Guitar类：123456@SkipItpublic class Piano implements Instrument&#123; public void play() &#123; System.out.println("钢琴声响起"); &#125;&#125;123456@SkipItpublic class Guitar implements Instrument&#123; public void play() &#123; System.out.println("弹奏吉他"); &#125; &#125;Saxophone不做任何标注：12345public class Saxophone implements Instrument&#123; public void play() &#123; System.out.println("吹萨克斯"); &#125;&#125;实例化kenny，输出：12唱：May Rain吹萨克斯非常方便！《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 自动装配Bean]]></title>
    <url>%2FSpring-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8DBean.html</url>
    <content type="text"><![CDATA[为了简化XML配置，Spring提供了自动装配（autowiring）。四种类型自动装配byName自动装配byName自动装配遵循约定：为属性自动装配ID与该属性的名字相同的Bean。例如，将先前的kenny例子：1234&lt;bean id="kenny" class="com.spring.entity.Instrumentalist"&gt; &lt;property name="instrument" ref="saxophone"&gt;&lt;/property&gt; &lt;property name="song" value="May Rain"/&gt;&lt;/bean&gt;改为：123&lt;bean id="kenny" class="com.spring.entity.Instrumentalist" autowire="byName"&gt; &lt;property name="song" value="May Rain"/&gt;&lt;/bean&gt;通过autowire属性，Spring就可以利用此信息自动装配kenny的剩下的instrument属性了。配置一个id为”instrument”的Bean：1&lt;bean id="instrument" class="com.spring.entity.Saxophone"/&gt;这样，saxophone就自动装配给kenny的instrument属性了。当找不到时，则该属性不进行装配。如果多个Instrumentalist Bean都被配置为byName自动装配，那他们将会演奏同一个乐器。byType自动装配byType自动装配通过寻找哪一个Bean的类型与属性的类型相匹配。如果找到多个与需要装配的属性类型相匹配的Bean，Spring会直接抛出异常。所以，应用只允许存在一个类型相匹配的Bean。但在实际中，XML中可能存在多个类型一样的Bean，为了解决这种情况，Spring提供了两种解决方法：① 为自动装配标识一个首选Bean使用&lt;bean&gt;元素的primary属性。如果只有一个自动装配的候选Bean的primary属性设置为true，那么其将被优先选择。比如设置saxophone为首选Bean：1&lt;bean id="saxophone" class="com.spring.entity.Saxophone" primary="true"/&gt;也可以使用@Primary注解。 ② 取消某个Bean自动装配的候选资格使用方法为设置Bean的autowire-candidate属性为false即可：1&lt;bean id="saxophone" class="com.spring.entity.Saxophone" autowire-candidate="false"/&gt;constructor自动装配如果通过构造器注入配置Bean，那么可以移除&lt;constructor-arg&gt;元素。如将先前的duke配置：1&lt;bean id="duke" class="com.spring.entity.Juggler" autowire="constructor"/&gt;通过autowire=&quot;constructor&quot;声明，Spring会去获取Juggler某个构造器的所有参数类型，然后再XML中寻找与其类型匹配的Bean。so，constructor自动装配与byType自动装配具有相同的局限性。autodetect自动装配detect 英[dɪˈtekt] 美[dɪˈtɛkt] vt. 查明，发现; 洞察; 侦察，侦查; [电子学] 检波1&lt;bean id="duke" class="com.spring.entity.Juggler" autowire="autodetect"/&gt;通过该声明，Spring首次尝试使用constructor自动装配，失败的话再次尝试使用byType自动装配。默认自动装配通过配置&lt;beans&gt;元素上增加一个default-autowire属性：123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd" default-autowire="byType"&gt; &lt;!--Bean declarations go here --&gt;&lt;/beans&gt;这样的话，Spring配置文件里的所有Bean都将使用byType自动装配，除非Bean自己配置了autowire属性。混合装配一个Bean可以同时使用自动装配和显示装配，如：12345&lt;bean id="kenny" class="com.spring.entity.Instrumentalist" autowire="byType"&gt; &lt;property name="song" value="May Rain"/&gt; &lt;property name="instrument" ref="saxophone"&gt;&lt;/property&gt;&lt;/bean&gt;混合使用可以避免当自动装配失败的时候，使用显示装配覆盖自动装配。使用constructor自动装配时，不能混合使用constructor自动装配策略和元素。使用注解装配1&lt;context:annotation-config/&gt;annotation 英[ˌænə’teɪʃn] 美[ˌænə’teɪʃn] n. 注释;&lt;context:annotation-config/&gt;可以消除Spring中的&lt;property&gt;和&lt;constructor-arg&gt;元素。注意，我们还是得使用&lt;bean&gt;元素显示定义Bean。@Autowired例如，在Instrumentalist的setInstrument()方法进行标注：12345//注入乐器@Autowiredpublic void setInstrument(Instrument instrument) &#123; this.instrument = instrument;&#125;这样，我们可以移除用来定义Instrumentalist的instrument属性所对应的&lt;property&gt;元素了。通过@Autowired注解，Spring会通过byType自动装配。假如@Autowired注解标注于属性，我们可以删除setter方法：12@Autowiredprivate Instrument instrument;@Autowired也可以标注于构造器，这样XML文件中可以省去&lt;constructor-arg&gt;元素配置Bean：1234@Autowiredpublic Instrumentalist(Instrument instrument) &#123; this.instrument=instrument;&#125;当多个构造器都通过@Autowired注解的时候，Spring就会从所有满足装配条件的构造器中选择出参数最多的那个。可选的自动装配：通过@Autowired标注的属性或者参数必须是可装配的。假如匹配失败，则抛出NoSuchBeanDefinitionException异常。假如属性不一定要装配，null值也可以接收的话，我们可以设置required=fasle来让自动装配变为可选：12@Autowired(required=false)private Instrument instrument;当使用构造器装配时，只有一个构造器可以将@Autowired的required属性设置为true，其余的只能设置为false。限定歧义性依赖：如果通过@Autowired注解匹配到好几个Bean，为了鉴别哪一个是我们需要的，我们可以在@Autowired注解下添加@Qualifier注解：qualifier 英[ˈkwɒlɪfaɪə(r)] 美[ˈkwɑ:lɪfaɪə(r)] n. 合格者，已取得资格的人; [语] 修饰语; 预选赛，资格赛123@Autowired@Qualifier("guitar")private Instrument instrument;如上所示，@Qualifier注解将尝试注入ID为”guitar”的Bean。除了通过Bean的ID来匹配，我们还可以修改guitar Bean配置：123&lt;bean class="com.spring.entity.Guitar"&gt; &lt;qualifier value="Stringed"/&gt;&lt;/bean&gt;&lt;qualifier&gt;元素限定了guitar Bean是一个弦乐器(stringed)。这时候可以将上面的注解修改为：123@Autowired@Qualifier("Stringed")private Instrument instrument;创建自定义的限定器：首先，通过如下代码创建自定义的限定器：123456789101112import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.beans.factory.annotation.Qualifier; @Target(&#123;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface StringedInstrument &#123; &#125;这样，我们在guitar类上添加此限定器：123456@StringedInstrumentpublic class Guitar implements Instrument&#123; public void play() &#123; System.out.println("弹奏吉他"); &#125; &#125;在自动装配的instrument属性进行限定：123@Autowired@StringedInstrumentprivate Instrument instrument;这样guitar就会被装配的instrument属性里！假如匹配到多个Bean，需要进一步的缩小范围，继续定义自定义限定器即可！@InjectMaven依赖：123456&lt;!-- https://mvnrepository.com/artifact/javax.inject/javax.inject --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.inject&lt;/groupId&gt; &lt;artifactId&gt;javax.inject&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt;&lt;/dependency&gt;为了规范各种依赖注入框架的编程模型，JCP(Java Community Process)发布了Java依赖注入规范，简称为JCR-330。Spring 3.0开始兼容该依赖注入模型。@Inject注解几乎可以完全替代@Autowired。如：12@Injectprivate Instrument instrument;@Inject也可以标注于属性，方法和构造器，不过@Inject没有required属性，所以@Inject注解所标注的依赖关系必须存在，否则抛出异常。限定@Inject所标注的属性类似于前面的@Qualifier，@Inject所对应的是@Named注解：123@Inject@Named("piano")private Instrument instrument;创建自定义的JSR-330 Qualifier通过下面的代码创建一个新的@NewStringedInstrument注解：123456789101112import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.inject.Qualifier; @Target(&#123;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface NewStringedInstrument &#123; &#125;和前面的自定义限定器唯一的区别就是@Qualifier注解的导入声明。在注解中使用SpEL表达式Spring3.0 引入了@Value，其可以注解装配String类型和基本类型的值。比如，我们通过@Value注解传入一个String类型的值：12@Value("May Rain")private String song;这样”May Rain”就被注入到song属性中了。我们还可以结合SpEL表达式：12@Value("#&#123;systemProperties.myFavoriteSong&#125;")private String song;@ResourceMaven依赖：123456&lt;!-- https://mvnrepository.com/artifact/javax.annotation/jsr250-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;@Resource注解是JSR-250发布的注解。与@Autowired和@Inject不同的是，@Resource注解不能用于构造器！@Resource注解默认使用byName自动装配！@Resource有两个中重要的属性：name和type ，而Spring将@Resource注解的name属性解析为bean的 名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用 byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。byName：12@Resource(name="piano")private Instrument instrument;byType：12@Resource(type=Instrument.class)private Instrument instrument;《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpEL表达式]]></title>
    <url>%2FSpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[Spring3引入了Spring表达式语言(Spring Expression Language，SpEL)。前面介绍的注入都是编写Spring配置文件的时候就确定了的。而SpEL它通过运行期间执行的表达式将值装配到Bean的属性或者构造器参数中。SpEL有许多特性：1.使用Bean的ID来引用Bean2.调用方法和访问对象的属性3.对值进行算数，关系和逻辑运算4.正则表达式匹配5.集合操作SpEL的基本使用字面值最简单的SpEL表达式仅包含一个字面值。假设现在某个类的count属性的值为5，我们用SpEL表达式表示：1&lt;property name="count" value="#&#123;5&#125;"/&gt;#{ }符号会提醒Spring，里面的内容是一个SpEL表达式。它们还可以与非SpEL表达式混用：1&lt;property name="message" value="the value is #&#123;5&#125;"/&gt;Java基本数据类型都可以出现在SpEL表达式中。表达式中的数字也可以使用科学记数法：1&lt;property name="salary" value="#&#123;1e4&#125;"/&gt;引用Bean , Properties和方法SpEL表达式能够通过其他Bean的ID进行引用。如：1&lt;constructor-arg value="#&#123;deceivedByLife&#125;"/&gt;其等价于：1&lt;constructor-arg ref="deceivedByLife"/&gt;carl参赛者是一位模仿高手，kenny唱什么歌，弹奏什么乐器，他就唱什么歌，弹奏什么乐器：1234567&lt;bean id="kenny" class="com.spring.entity.Instrumentalist" p:song="May Rain" p:instrument-ref="piano"/&gt;&lt;bean id="carl" class="com.spring.entity.Instrumentalist"&gt; &lt;property name="instrument" value="#&#123;kenny.instrument&#125;"/&gt; &lt;property name="song" value="#&#123;kenny.song&#125;"/&gt;&lt;/bean&gt;As you can see，属性的值由key和value组成。key指定kenny&lt;bean&gt; 的id，value指定kenny&lt;bean&gt;的song属性。其等价于执行下面的代码：12Instrumentalist carl = new Instrumentalist();carl.setSong(kenny.getSong());除了访问类的属性，SpEL表达式还可以访问类的方法。假设现在有个SongSelector类，该类有个selectSong()方法，这样的话carl就可以不用模仿别人，开始唱songSelector所选的歌了：1&lt;property name="song" value="#&#123;SongSelector.selectSong()&#125;"/&gt;carl有个癖好，歌曲名不是大写的他就浑身难受，我们现在要做的就是仅仅对返回的歌曲调用toUpperCase()方法：1&lt;property name="song" value="#&#123;SongSelector.selectSong().toUpperCase()&#125;"/&gt;注意：这里我们不能确保不抛出NullPointerException，为了避免这个讨厌的问题，我们可以使用SpEL的null-safe存取器1&lt;property name="song" value="#&#123;SongSelector.selectSong()?.toUpperCase()&#125;"/&gt;yes，就是这么简单。?.符号会确保左边的表达式不会为null，如果为null的话就不会调用toUpperCase()方法了。操作类在SpEL表达式中，使用T()运算符会调用类的作用域和方法。例如，我们要调用java.lang.Math的PI值：1&lt;property name="pi" value="#&#123;T(java.lang.Math).PI&#125;"/&gt;获取0~1随机数：1&lt;property name="random" value="#&#123;T(java.lang.Math).random()&#125;"/&gt;在SpEL值上执行操作SpEL提供了几种运算符：运算符类型运算符算数运算+, -, *, /, %, ^关系运算&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge逻辑运算and, or, not, !条件运算?:(ternary), ?:(Elvis)正则表达式matches算数运算加法运算：1&lt;property name="add" value="#&#123;counter.total+42&#125;"/&gt;加号还可以用于字符串拼接：1&lt;property name="blogName" value="#&#123;my blog name is+' '+mrBird &#125;"/&gt;^运算符执行幂运算，其余算数运算符和Java一毛一样，这里不再赘述。关系运算判断一个Bean的某个属性是否等于100：1&lt;property name="eq" value="#&#123;counter.total==100&#125;"/&gt;返回值是boolean类型。关系运算符唯一需要注意的是：在Spring XML配置文件中直接写&gt;=和&lt;=会报错。因为这”&lt;”和”&gt;”两个符号在XML中有特殊的含义。所以实际使用时，最号使用文本类型代替符号：运算符符号文本类型等于==eq小于&lt;lt小于等于&lt;=le大于&gt;gt大于等于&gt;=ge如：1&lt;property name="eq" value="#&#123;counter.total le 100&#125;"/&gt;逻辑运算SpEL表达式提供了多种逻辑运算符，其含义和Java也是一毛一样，只不过符号不一样罢了。使用and运算符：1&lt;property name="largeCircle" value="#&#123;shape.kind == 'circle' and shape.perimeter gt 10000&#125;"/&gt;两边为true时才返回true。其余操作一样，只不过非运算有not和!两种符号可供选择。非运算：1&lt;property name="outOfStack" value="#&#123;!product.available&#125;"/&gt;条件运算条件运算符类似于Java的三目运算符：12&lt;property name="instrument" value="#&#123;songSelector.selectSong() == 'May Rain' ? piano:saxphone&#125;"/&gt;当选择的歌曲为”May Rain”的时候，一个id为piano的Bean将装配到instrument属性中，否则一个id为saxophone的Bean将装配到instrument属性中。注意区别piano和字符串“piano”！一个常见的三目运算符的使用场合是判断是否为null值：1&lt;property name="song" value="#&#123;kenny.song !=null ? kenny.song:'Jingle Bells'&#125;"/&gt;这里，kenny.song引用重复了两次，SpEL提供了三目运算符的变体来简化表达式：1&lt;property name="song" value="#&#123;kenny.song !=null ?:'Jingle Bells'&#125;"/&gt;在以上示例中，如果kenny.song不为null，那么表达式的求值结果是kenny.song否则就是“Jingle Bells”。正则表达式验证邮箱：12&lt;property name="email" value="#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'&#125;"/&gt;虽然这个邮箱正则不够健壮，但对于演示matches来说足够啦。在SpEL中筛选集合为了展示SpEL操作集合的方法，我们创建一个City类：1234567891011121314151617181920212223public class City &#123; private String name; private String state; private int population; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public int getPopulation() &#123; return population; &#125; public void setPopulation(int population) &#123; this.population = population; &#125;&#125;同样，我们在Spring容器中使用&lt;util:list&gt;元素配置一个包含City对象的List集合：123456789101112131415161718&lt;util:list id="cities"&gt; &lt;bean class="com.spring.entity.City" p:name="Chicago" p:state="IL" p:population="2853114"/&gt; &lt;bean class="com.spring.entity.City" p:name="Atlanta" p:state="GA" p:population="537958"/&gt; &lt;bean class="com.spring.entity.City" p:name="Dallas" p:state="TX" p:population="1279910"/&gt; &lt;bean class="com.spring.entity.City" p:name="Houston" p:state="TX" p:population="2242193"/&gt; &lt;bean class="com.spring.entity.City" p:name="Odessa" p:state="TX" p:population="90943"/&gt; &lt;bean class="com.spring.entity.City" p:name="El Paso" p:state="TX" p:population="613190"/&gt; &lt;bean class="com.spring.entity.City" p:name="Jal" p:state="NM" p:population="1996"/&gt; &lt;bean class="com.spring.entity.City" p:name="Las Cruces" p:state="NM" p:population="91865"/&gt;&lt;/util:list&gt;访问集合成员定义一个ChoseCity类：123456789public class ChoseCity &#123; private City city; public void setCity(City city) &#123; this.city = city; &#125; public City getCity() &#123; return city; &#125;&#125;选取集合中的某一个成员，并赋值给city属性中：123&lt;bean id="choseCity" class="com.spring.entity.ChoseCity"&gt; &lt;property name="city" value="#&#123;cities[0]&#125;"/&gt;&lt;/bean&gt;实例化这个Bean：12345678public class ChoseaCity &#123; public static void main(String[] args) &#123; String conf="applicationContext.xml"; ApplicationContext ac=new ClassPathXmlApplicationContext(conf); ChoseCity c=(ChoseCity)ac.getBean("choseCity"); System.out.println(c.getCity().getName()); &#125;&#125;输出：1Chicago随机的选择一个city：123&lt;bean id="choseCity" class="com.spring.entity.ChoseCity"&gt; &lt;property name="city" value="#&#123;cities[T(java.lang.Math).random()*cities.size()]&#125;"/&gt;&lt;/bean&gt;中括号[]运算符始终通过索引访问集合中的成员。[]运算符同样可以用来获取java.util.Map集合中的成员。例如，假设City对象以其名字作为键放入Map集合中，在这种情况下，我们可以像下面那样获取键为Dallas的entry：1&lt;property name="chosenCity" value="#&#123;cities['Dallas']&#125;"/&gt;[]运算符的另一种用法是从java.util.Properties集合中取值。例如，假设我们需要通过&lt;util:properties&gt;元素在Spring中加载一个properties配置文件：1&lt;util:properties id="settings" loaction="classpath:settings.properties"/&gt;现在要在这个配置文件Bean中访问一个名为twitter.accessToken的属性：1&lt;property name="accessToken" value="#&#123;settings['twitter.accessToken']&#125;"/&gt;[]运算符同样可以通过索引来得到某个字符串的某个字符，例如下面的表达式将返回s：1'This is a test'[3]查询集合成员如果我们想从城市cities集合中查询出人口大于10000的城市，在SpEL中只需要用一个查询运算符 .?[]就可以简单做到。修改choseCity类：12345678910public class ChoseCity &#123; private List&lt;City&gt; city; public List&lt;City&gt; getCity() &#123; return city; &#125; public void setCity(List&lt;City&gt; city) &#123; this.city = city; &#125;&#125;修改Bean：123&lt;bean id="choseCity" class="com.spring.entity.ChoseCity"&gt; &lt;property name="city" value="#&#123;cities.?[population gt 100000]&#125;"/&gt;&lt;/bean&gt;实例化该Bean：12345678910public class ChoseCitys &#123; public static void main(String[] args) &#123; String conf="applicationContext.xml"; ApplicationContext ac=new ClassPathXmlApplicationContext(conf); ChoseCity c=(ChoseCity)ac.getBean("choseCity"); for(City city:c.getCity())&#123; System.out.println(city.getName()); &#125; &#125;&#125;输出：12345ChicagoAtlantaDallasHoustonEl PasoSpEL还提供了其他两种查询运算符：.^[]和.$[]，从集合查询中查出第一个匹配项和最后一个匹配项。例如查询第一个符合查询条件的城市：1&lt;property name="firstBigCity" value="#&#123;cities.^[population gt 100000]&#125;"/&gt;投影集合集合投影就是从集合的每一个成员中选择特定的属性放入到一个新的集合中。SpEL的投影运算符.![]完全可以做到这一点。例如，我们仅需要包含城市名称的一个String类型的集合：1&lt;property name="cityNames" value="#&#123;cities.![name]&#125;"/&gt;再比如，得到城市名字加州名的集合：1&lt;property name="cityNames" value="#&#123;cities.![name+','+state]&#125;"/&gt;把符合条件的城市的名字和州名作为一个新的集合：1&lt;property name="cityNames" value="#&#123;cities.?[population gt 100000].![name+','+state]&#125;"/&gt;总之SpEL非常强大，但SpEL最终也只是一个字符串，不易于测试，也没IDE语法检查的支持。所以：建议不要把过多的逻辑放入SpEL表达式中。《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Bean生命周期]]></title>
    <url>%2FSpring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[传统的Java应用，Bean的生命周期很简单。使用Java关键字new进行Bean的实例化，然后该Bean就可以使用了。一旦该Bean不再被使用，则有GC选择回收。相比之下，在Spring容器中，Bean的生命周期要细腻的多，大致过程如下图所示：1.Spring对Bean进行实例化；2.Spring将值和对Bean的引用注入进Bean对应的属性中；3.如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()接口方法；4.如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()接口方法，将BeanFactory容器实例传入；5.如果Bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()接口方法，将应用上下文的引用传入；6.如果Bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()接口方法；7.如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()接口方法。类似的，如果Bean使用init-method声明了初始化方法，该方法也会被调用。8.如果Bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法；9.此时此刻，Bean已经准备就绪，可以被使用了。它们将一直驻留在Spring容器中，直到容器被销毁；10.如果Bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果Bean使用destroy-method声明了销毁方法，该方法也会被调用；]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Setter方法注入]]></title>
    <url>%2FSpring-Setter%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5.html</url>
    <content type="text"><![CDATA[Spring除了构造器注入，还可以通过类的set()方法注入。为了演示这个过程，现在有请下一位参赛者kenny。kenny是一位天赋异禀的乐器演奏者，现定义一个乐器演奏师类：1234567891011121314151617181920212223242526272829public class Instrumentalist implements Performer&#123; private String song; private Instrument instrument; public Instrumentalist() &#123; &#125; public void perform() &#123; System.out.println("唱："+song+""); instrument.play(); &#125; public String screamSong()&#123; return song; &#125; public String getSong() &#123; return song; &#125; //注入歌曲 public void setSong(String song) &#123; this.song = song; &#125; public Instrument getInstrument() &#123; return instrument; &#125; //注入乐器 public void setInstrument(Instrument instrument) &#123; this.instrument = instrument; &#125;&#125;乐器Instrument接口：123public interface Instrument&#123; public void play();&#125;setter注入简单值可以通过InstrumentList类的默认构造器来实例化该Bean，但没有给song和instrument属性赋值的话显然没有什么意义。Spring可以用&lt;property&gt;元素给属性Song注入值：123&lt;bean id="kenny" class="com.spring.entity.Instrumentalist"&gt; &lt;property name="song" value="May Rain"/&gt;&lt;/bean&gt;name为属性名，value为属性值。引用其他的Bean有了歌曲，kenny现在还差乐器。定义一个piano类，实现Instrument接口：12345public class Piano implements Instrument&#123; public void play() &#123; System.out.println("钢琴声响起"); &#125;&#125;有了piano类，现在我们在Spring容器中定义这个钢琴类：1&lt;bean id="piano" class="com.spring.entity.Piano"/&gt;有了钢琴，现在我们把钢琴交给kenny，修改kenny的&lt;bean&gt;配置：1234&lt;bean id="kenny" class="com.spring.entity.Instrumentalist"&gt; &lt;property name="song" value="May Rain"/&gt; &lt;property name="piano" ref="piano"&gt;&lt;/property&gt;&lt;/bean&gt;ref属性指向之前定义的piano&lt;bean&gt;。现在我们让kenny正式上台表演：1234567public class Play &#123; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml"); Instrumentalist kenny=(Instrumentalist)ac.getBean("kenny"); kenny.perform(); &#125;&#125;输出：123开灯唱：May Rain钢琴声响起注入内部Beankenny是一个占有欲很强的人，他不希望自己的钢琴被别人使用。这时候我们不能像上面那样引用piano&lt;bean&gt;了，因为这样任何一个&lt;bean&gt;都可以引用它。现在修改kenny的&lt;bean&gt;：123456&lt;bean id="kenny" class="com.spring.entity.Instrumentalist"&gt; &lt;property name="song" value="May Rain"/&gt; &lt;property name="instrument" &gt; &lt;bean class="com.spring.entity.Piano"/&gt; &lt;/property&gt;&lt;/bean&gt;如你所见，内部Bean是直接声明一个&lt;bean&gt;元素作为&lt;property&gt;元素的子节点而定义的。同样，构造器注入也支持内部Bean的声明。 细心的你 会发现内部Bean没有定义id属性，实际上在这里定义id属性是完全合法的，只不过对于内部Bean，id属性显然不重要了。使用Spring P装配属性&lt;property&gt;元素的写法可以更简略，只需在&lt;beans&gt;加入如下代码：1xmlns:p="http://www.springframework.org/schema/p"通过这段代码，我们可以使用p:作为&lt;bean&gt;元素的所有属性的前缀来装配Bean的属性。现修改kenny的&lt;bean&gt;配置：123&lt;bean id="kenny" class="com.spring.entity.Instrumentalist" p:song="May Rain" p:instrument-ref="piano"/&gt;装配集合当配置集合类型的Bean属性时，Spring提供了相应的集合配置元素：集合元素用途&lt;list&gt;装配list类型的值，允许重复&lt;set&gt;装配set类型的值，不允许重复&lt;map&gt;装配map类型的值，名称和值可以是任意类型&lt;props&gt;装配properties类型的值，名称和值都必须是String类型为了展示Spring装配集合，现在有请下一位参赛者hank。hank是一位才华横溢的一人乐队，可以同时演奏多种乐器。现定义一个OneManBan类：1234567891011121314public class OneManBan implements Performer&#123; private Collection&lt;Instrument&gt; instruments; //注入instruments集合 public void setInstruments(Collection&lt;Instrument&gt; instruments) &#123; this.instruments = instruments; &#125; public void perform() &#123; for(Instrument ins:instruments)&#123; ins.play(); &#125; &#125;&#125;装配List,Set和Array现在再定义两个乐器类，并在Spring容器中定义它：12&lt;bean id="saxophone" class="com.spring.entity.Saxophone"/&gt;&lt;bean id="guitar" class="com.spring.entity.Guitar"/&gt;现在把所有乐器都装配给hank：123456789&lt;bean id="hank" class="com.spring.entity.OneManBan"&gt; &lt;property name="instruments"&gt; &lt;list&gt; &lt;ref bean="saxophone"/&gt; &lt;ref bean="piano"/&gt; &lt;ref bean="guitar"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;还可以使用其他的Spring设置元素设置&lt;list&gt;的成员。包括&lt;value&gt;，&lt;bean&gt;，&lt;/null&gt;甚至&lt;list&gt;。实际上，instruments属性只要是java.util.collection的实现类型都可以使用&lt;list&gt;，如：1java.util.List&lt;Instrument&gt; instruments;或者：1Instrument[] instruments;&lt;set&gt;元素的使用与&lt;list&gt;完全一致，唯一区别在于&lt;set&gt;元素的成员都是唯一的。现在实例化hank查看输出：1234开灯吹萨克斯钢琴声响起弹奏吉他装配Map集合如果instruments属性是一个Map集合的话，我们又该如何装配呢？现修改OneManBan类：1234567891011121314151617public class OneManBan implements Performer&#123; private Map&lt;String,Instrument&gt; instruments; public OneManBan() &#123; &#125; public void perform() &#123; for(String key:instruments.keySet())&#123; System.out.print(key+": "); Instrument ins=instruments.get(key); ins.play(); &#125; &#125; public void setInstruments(Map&lt;String, Instrument&gt; instruments) &#123; this.instruments = instruments; &#125;&#125;hank&lt;bean&gt;修改如下：123456789&lt;bean id="hank" class="com.spring.entity.OneManBan"&gt; &lt;property name="instruments"&gt; &lt;map&gt; &lt;entry key="saxophone" value-ref="saxophone"/&gt; &lt;entry key="piano" value-ref="piano"/&gt; &lt;entry key="guitar" value-ref="guitar"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;map&gt;的&lt;entry&gt;由key和value组成：属性用途key键为Stringkey-ref键为Spring容器中其他Bean的引用value值为Stringvalue-ref值为Spring容器中其他Bean的引用装配Properties集合当key和value都是String类型的时候，我们可以使用Properties来代替Map修改OneManBan：12345678910111213141516public class OneManBan implements Performer&#123; private Properties instruments; public OneManBan() &#123; &#125; public void perform() &#123; for(Object key:instruments.keySet())&#123; System.out.print(key+": "); String ins=instruments.getProperty(key.toString()); System.out.println(ins); &#125; &#125; public void setInstruments(Properties instruments) &#123; this.instruments = instruments; &#125;&#125;修改&lt;bean&gt;:123456789&lt;bean id="hank" class="com.spring.entity.OneManBan"&gt; &lt;property name="instruments"&gt; &lt;props&gt; &lt;prop key="saxophone" &gt;play the saxophone&lt;/prop&gt; &lt;prop key="piano"&gt;play the piano&lt;/prop&gt; &lt;prop key="guitar"&gt;play the guitar&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 构造器注入]]></title>
    <url>%2FSpring-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5.html</url>
    <content type="text"><![CDATA[从Spring3.0开始，Spring可以通过注解的方式来配置Bean。这里先介绍以传统的XML配置式来配置Bean。用一场选秀比赛来模拟Spring装备Bean过程。一场比赛中，需要一些参赛者来参加比赛，为此我们定义一个Performer接口：123public interface Performer &#123; public void perform();&#125;参赛选手都实现了这个Performer接口。以下为一个典型的Spring XML配置文件(Spring容器，Spring上下文)：1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd"&gt; &lt;!--Bean declarations go here --&gt;&lt;/beans&gt;在&lt;beans&gt;元素内，我们可以配置所有Spring配置信息以及&lt;bean&gt;元素的声明。除此之外，Spring还自带了包括&lt;beans&gt;在内的10大命名空间：命名空间用途aop为声明切面以及将@AspectJ注解的类代理为Spring切面提供了配置元素beans&nbsp;&nbsp;&nbsp;&nbsp;支持声明Bean和装配Bean，是Spring最核心也是最原始的命名空间context为配置Spring应用上下文提供了配置元素，包括自动检测和自动装配Bean，注入非Spring直接管理的对象jee&nbsp;&nbsp;&nbsp;&nbsp;提供了与Java EE API的集成，例如JNDI和EJBjms为声明消息驱动的POJO提供了配置元素lang支持配置由Groovy，JRuby或BeanShell等脚本实现的Beanmvc启动Spring MVC的能力，例如面向注解的控制器，视图控制器和拦截器oxm支持Spring的对象到XML映射配置tx提供声明事务配置util提供各种各样的工具类元素，包括把集合配置为Bean，支持属性占位符元素回归比赛，第一位参赛者是一个Juggler(杂技师)，声明一个Juggler Bean：12345678910111213public class Juggler implements Performer&#123; private int beanBags=3; public Juggler() &#123; &#125; public Juggler(int beanBags) &#123; this.beanBags = beanBags; &#125; public void perform() &#123; System.out.println("throws "+beanBags+" beanBags"); &#125;&#125;Juggler实现了Performer接口，默认可以同时抛出三个豆袋子。也可以通过有参构造器改变袋子数量。现在有请第一位叫duke的杂技师上场！在applicationContext.xml文件中配置Duke：1&lt;bean id="duke" class="com.spring.entity.Juggler"/&gt;id表明他叫duke，class表明他是一个juggler。现在让duke上台表演：12345678public class Show &#123; public static void main(String[] args) &#123; String conf="applicationContext.xml"; ApplicationContext ac=new ClassPathXmlApplicationContext(conf); Juggler duke=(Juggler)ac.getBean("duke"); duke.perform(); //扔了 3 个豆袋子 &#125;&#125;构造器注入评委觉得这并没有什么难度，于是duke决定一次性扔15个豆袋子！修改duke&lt;bean&gt;的配置：123&lt;bean id="duke" class="com.spring.entity.Juggler"&gt; &lt;constructor-arg value="15" /&gt;&lt;/bean&gt;也可以使用c-命名空间代替&lt;constructor-arg&gt;标签，要使用它的话，现在XML顶部声明其模式：1xmlns:c="http://www.springframework.org/schema/c"上面的配置可以改为：1&lt;bean id="duke" class="com.spring.entity.Juggler" c:beanBags="15"&gt;或者：1&lt;bean id="duke" class="com.spring.entity.Juggler" c:_0="15"&gt;像这种只有一个参数的话也可以写为：1&lt;bean id="duke" class="com.spring.entity.Juggler" c:_="15"&gt;Juggler类有两个构造器，无参和有参。当没有声明&lt;constructor-arg&gt;的时候，Spring将默认使用无参的构造方法。现在，我们将&lt;constructor-arg&gt;的value设置位15的时候，Spring使用有参构造方法来改变属性beanBags的值。再次表演，输出：12扔了 15 个豆袋子掌声雷动。稍等！duke说他还会边扔袋子变朗诵诗歌！为此我们定义一个PoeticJuggler（会朗诵的杂技师）：1234567891011121314151617181920public class PoeticJuggler extends Juggler&#123; //诗歌属性 private Poem poem; public PoeticJuggler(Poem poem) &#123; this.poem = poem; &#125; public PoeticJuggler(int beanBags,Poem poem) &#123; //继承豆袋子属性 super(beanBags); this.poem = poem; &#125; public void perform()&#123; //继承扔袋子技能 super.perform(); System.out.println("边朗诵..."); //朗诵诗歌 poem.recite(); &#125;&#125;诗歌接口：123public interface Poem &#123; public void recite();&#125;duke最喜欢的是普希金的《假如生活欺骗了你》，为此我们定义一个DeceivedByLife类，实现Poem接口：123456789101112131415161718192021public class DeceivedByLife implements Poem&#123; private static String[] LINES = &#123; "假如生活欺骗了你，", "不要悲伤，不要心急！", "忧郁的日子里须要镇静：", "相信吧，快乐的日子将会来临！", "心儿永远向往着未来；", "现在却常是忧郁。", "一切都是瞬息，一切都将会过去；", "而那过去了的，就会成为亲切的怀恋"&#125;; public DeceivedByLife()&#123; &#125; //朗诵诗歌 public void recite() &#123; for(int i=0;i&lt;LINES.length;i++)&#123; System.out.println(LINES[i]); &#125; &#125; &#125;在Spring容器里配置这首诗歌：1&lt;bean id="deceivedByLife" class="com.spring.entity.DeceivedByLife"/&gt;现在duke是一个poeticJuggler了，为此我们修改duke的&lt;bean&gt;配置：1234&lt;bean id="poeticDuke" class="com.spring.entity.PoeticJuggler"&gt; &lt;constructor-arg value="15"/&gt; &lt;constructor-arg ref="deceivedByLife"/&gt;&lt;/bean&gt;c-命名空间写法：123&lt;bean id="poeticDuke" class="com.spring.entity.PoeticJuggler" c:_beanBags="15" c:_poem-ref="deceivedByLife"/&gt;或者：123&lt;bean id="poeticDuke" class="com.spring.entity.PoeticJuggler" c:_0="15" c:_1-ref="deceivedByLife"/&gt;当Spring碰到deceivedByLife和poeticDuke的&lt;bean&gt;声明时，它所执行的逻辑本质和下面的Java代码是一样的：12Poem deceivedByLife = new DeceivedByLife();Performer duke = new PoeticJuggler(15,deceivedByLife);现在，duke再次进行了表演：12345678public class Show &#123; public static void main(String[] args) &#123; String conf="applicationContext.xml"; ApplicationContext ac=new ClassPathXmlApplicationContext(conf); Juggler duke=(PoeticJuggler)ac.getBean("poeticDuke"); duke.perform(); &#125;&#125;输出：12345678910扔了 15 个豆袋子边朗诵...假如生活欺骗了你，不要悲伤，不要心急！忧郁的日子里须要镇静：相信吧，快乐的日子将会来临！心儿永远向往着未来；现在却常是忧郁。一切都是瞬息，一切都将会过去；而那过去了的，就会成为亲切的怀恋掌声再次雷动。通过工厂方法创建Bean有时候，一个类没有公开的构造方法，这时候就不能使用构造器注入了。Spring支持&lt;bean&gt;元素的factory-method方法来装配Bean。创建一个舞台类：12345678910111213141516public class Stage &#123; private Stage()&#123; &#125; //延迟加载实例 public static class stageSingletonHolder&#123; static Stage instance=new Stage(); &#125; //返回实例 public static Stage getInstance()&#123; return stageSingletonHolder.instance; &#125; public void createStage()&#123; System.out.println("创造一个舞台"); &#125;&#125;Stage作为一个单例类，没有公开的构造方法，相反，静态方法getInstance()每次调用都返回一个相同的Stage实例。&lt;bean&gt;元素的factory-method属性允许我们调用一个静态方法，从而代替构造方法来创建一个类的实例。在Spring上下文中配置Stage&lt;bean&gt;：1&lt;bean id="stage" class="com.spring.entity.Stage" factory-method="getInstance"/&gt;现在从Spring容器中获取这个&lt;bean&gt;：12345678public class CreateStage &#123; public static void main(String[] args) &#123; String conf="applicationContext.xml"; ApplicationContext ac=new ClassPathXmlApplicationContext(conf); Stage stage=(Stage)ac.getBean("stage"); stage.createStage(); &#125;&#125;输出：1创造一个舞台Bean作用域所有Spring Bean默认都是单例的。如果现在要创建一个”门票”类，每个人的门票肯定是不一样的。为了让Spring每次请求都产生一个新的实例，我们可以定义如下ticket&lt;bean&gt;：1&lt;bean id="ticket" class="com.spring.entity.Ticket" scope="prototype"/&gt;除了prototype，Spring还提供了其他几个作用域选项：作用域定义singleton在每一个spring容器中，一个Bean定义只有一个对象实例（默认）prototype允许Bean的定义可以被实例化任意次（每次调用都创建一个新的实例）request在一次HTTP请求中，每个Bean定义对应一个实例。该作用域仅在基于Web的Spring上下文中才有效session在一个HTTP Session中，每个Bean定义对应一个实例。该作用域仅在基于Web的Spring上下文中才有效global-session在一个全局HTTP Session中，每个Bean定义对应一个实例。该作用域仅在Protlet上下文中才有效Spring的单例Bean只能保证在每个应用上下文中只有一个Bean实例。没有人能够阻止你使用传统的方式实例化同一个Bean，或者你甚至可以定义几个声明来实例化同一个Bean。初始化和销毁Bean为Bean定义初始化和销毁操作，只需要使用init-method和destroy-method参数来配置&lt;bean&gt;元素。init-method属性指定了在初始化Bean时要调用的方法。destroy-method属性指定了Bean从容器移除之前要调用的方法。现在定义一个灯光类Light：12345678public class Light &#123; void turnOnTheLight()&#123; System.out.println("开灯"); &#125; void turnOffTheLight()&#123; System.out.println("关灯"); &#125;&#125;在容器中配置该Bean：12&lt;bean id="light" class="com.spring.entity.Light" init-method="turnOnTheLight" destroy-method="turnOffTheLight"/&gt;加载容器，以此来实例化light：123456789public class LightControl &#123; public static void main(String[] args) &#123; String conf="applicationContext.xml"; //加载容器 ApplicationContext ac=new ClassPathXmlApplicationContext(conf); //关闭容器 ((ClassPathXmlApplicationContext)ac).close(); &#125;&#125;输出：123开灯...关灯我们还可以定义默认的init-method和destroy-method。如果上下文中Bean定义了名字相同的初始化和销毁方法，我们可以统一配置default-init-method和default-destroy-method：12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:util="http://www.springframework.org/schema/util" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd" default-init-method="turnOnTheLight" default-destroy-method="turnOffTheLight"&gt; &lt;!--Bean declarations go here --&gt;&lt;/beans&gt;为Bean定义初始化和销毁的方法是让Bean实现Spring的InitializingBean和DisposableBean接口。InitializingBean声明了一个afterPropertiesSet()方法作为初始化方法。DisposableBean声明了一个destroy()方法作为销毁方法。在Spring容器中无需任何配置。修改Light类：12345678public class Light implements InitializingBean,DisposableBean&#123; public void afterPropertiesSet() throws Exception &#123; System.out.println("开灯"); &#125; public void destroy() throws Exception &#123; System.out.println("关灯"); &#125;&#125; ​这种方法的缺点显而易见了：实现Spring的接口意味着Bean与Spring的API产生了耦合。所以这种方法并不推荐！《Spring In Action》读书笔记]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器总结]]></title>
    <url>%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[jQuery选择器和CSS选择器一样，并在其基础上做出了拓展。可在此页面上练习jQuery选择器：http://mrbird.leanote.com/single/jQuery-Selectors-Lab-Page基本选择器选择器描述返回示例#id根据给定的id匹配一个元素单个元素$(“#test”)选取id为test的元素.class根据给定的类名匹配元素集合元素$(“.test”)选取所有class为test的元素element根据给定的元素名匹配元素集合元素$(“p”)选取所有&lt;p&gt;元素*匹配所有元素集合元素$(“*”)选取所有元素selector1,selector2 ……，selectorN将每一个选择器匹配到的元素合并后一起返回集合元素$(“div,span,p.myClass”)选取所有&lt;div&gt;，&lt;span&gt;和 拥有class为myClass的&lt;p&gt;标签的一组元素层次选择器选择器描述返回示例$(“ancestor descendant”)选取ancestor元素里的所有descendant（后代）元素集合元素$(“div span”)选取&lt;div&gt;里的所有的&lt;span&gt;元素$(“parent&gt;child”)选取parent元素下的child元素与\$(“ancestor descendant”)有区别，\$(“ancestor descendant”)选择的是后代元素集合元素$(“div&gt;span”)选取&lt;div&gt;元素下元素名是&lt;span&gt;的子元素$(“prev+next”)选取紧接在prev元素后的next元素集合元素$(“.one+div”)选取class为one的下一个&lt;div&gt;同辈元素$(“prev~siblings”)选取prev元素之后的所有siblings元素集合元素$(“#two~div”)选取id为two的元素后的 所有&lt;div&gt;同辈元素过滤选择器jQuery过滤选择器规则同CSS中的伪类选择器，都以一个冒号(:)开头。按照不同的过滤规则，过滤选择器可以分为基本过滤器，内容过滤器，可见性过滤器，属性过滤器，子元素过滤器和表单对象属性过滤选择器。基本过滤选择器选择器&nbsp;描述返回示例:first选取第一个元素单个元素$(“div:first”)选取所有&lt;div&gt;元素中第一个&lt;div&gt;元素:last选取最后一个元素单个元素$(“div:last”)选取所有&lt;div&gt;元素中最后一个&lt;div&gt;元素:not(selector)去除所有与给定选择器匹配的 元素集合元素$(“input:not(.myClass)”)选取class不是myClass的&lt;input&gt; 元素:even选取索引是偶数的所有元素， 索引从0开始集合元素$(“input:even”)选取索引是偶数的&lt;input&gt;元素:odd选取索引是奇数的所有元素， 索引从0开始集合元素$(“input:odd”)选取索引是奇数的&lt;input&gt;元素:eq(index)选取索引等于index的元素， (index)从0开始集合元素$(“input:eq(1)”)选取索引等于1的&lt;input&gt;元素:gt(index)选取索引大于index的元素， (index)从0开始集合元素$(“input:gt(1)”)选取索引大于1的&lt;input&gt;元素（注：大于1，而不包括1）:lt(index)选取索引小于index的元素， (index)从0开始集合元素$(“input:lt(1)”)选取索引小于1的&lt;input&gt;元素（注：小于1，而不包括1）:header选取所有的标题元素，如h1， h2等集合元素$(“:header”)选取网页中所有header，如h1,h2…:animated选取当前正在执行动画的元素集合元素$(“div:animate”)选取正在执行动画的&lt;div&gt;元素:focus获取当前获取焦点的元素集合元素$(“input:focus”)获取当前获取焦点的&lt;input&gt;元素:root选择文档的根元素单个元素$(“:root”)获取当前文档的根元素:lang(language)只选择采用特定语言的元素集合元素$(“p:lang(en)”)选取带有以 “en” 开头的lang 属性值的所有 &lt;p&gt; 元素内容过滤选择器选择器描述返回示例:contains(text)选取含有文本内容为”text”的元素集合元素$(“div:contents(‘我’)”)选取含有文本我的&lt;div&gt;元素:empty选取不包含子元素和文本的空元素集合元素$(“div:empty”)选取不包含子元素(包括文本元素)的 &lt;div&gt;元素:has(selector)选取含有选择器所匹配的元素的元素集合元素$(“div:has(p)”)选取含有&lt;p&gt;元素的&lt;div&gt;元素:parent选取含有子元素或文本的元素集合元素$(“div:parent”)选取拥有子元素（包括文本元素）的 &lt;div&gt;元素可见性过滤选择器选择器描述返回示例:hidden选取所有不可见元素集合元素\$(“:hidden”)选取所有不可见元素。包括&lt;input type=”hidden/“&gt;，&lt;div sytle=”dispaly:none;”&gt;和&lt;div&gt;等元素。如果只想选取&lt;input&gt;元素，可以使用\$(“input:hidden”):visible选取所有可见元素集合元素$(“input:visible”)选取所有可见的&lt;div&gt;元素属性过滤选择器选择器描述返回示例[attribute]选取拥有此属性的元素集合元素$(“div[id]”)选取拥有属性id的元素[attribute=value]选取属性的值为value的元素集合元素$(“div[title=test]”)选取属性title为”test”的&lt;div&gt;元素[attribute!=value]选取属性的值不等于value的元素集合元素$(“div[title!=test]”)选取属性title不等于”test”的&lt;div&gt;元素（注意：没有属性title的&lt;div&gt;元素也会被选取）[attribute^=value]选取属性的值以value开始的元素集合元素$(“div[title^=test]”)选取属性title以”test”开始的&lt;div&gt;[attribute$=value]选取属性的值以value结束的元素集合元素\$(“div[title$=test]”)选取属性title以”test”结束的&lt;div&gt;[attribute*=value]选取属性的值含有value的元素集合元素$(“div[title*=test]”)选取属性title含有”test”的&lt;div&gt;[attribute|=value]选取属性等于给定字符串或以该字符串为前缀（该字符串后跟一个“_“）的元素集合元素$(“div[title|=’en’]”)选取属性tite等于en或以en为前缀（该字符串后跟一个连字符”_“）的元素[attribute~=value]选取属性用空格分隔的值中包含一个给定值的元素集合元素$(“div[title~=’uk’]”)选取属性title用空格分隔的值中包含字符uk的元素[attribute1][attribute2][attributeN]复合属性选择器满足多个条件，每选择一次，范围缩小一次集合元素\$(“div[id][title$=’test’]”)选取拥有属性id，并且属性title以”test”结束的&lt;div&gt;元素子元素过滤选择器选择器描述返回示例:nth-child(index/even/odd/equation)选取每个父元素下的第index个子元素或者奇偶元素（index从1开始）集合元素:eq(index)只匹配一个元素，而:nth-child将为每一个父元素匹配子元素，并且:nth-child(index)的index是从1开始的，而eq(index)是从0开始的:nth-last-child(index/even/odd/equation)选取父元素下的倒数第n个子元素或符合特定顺序规则的元素&nbsp;集合元素&nbsp;:nth-last-child(2)表示作为父元素的倒数第2个子元素；:nth-last-child(3n)表示匹配作为父元素倒数顺序的第3n个子元素的元素（n表示包括0在内的自然数）:first-child选取每个父元素的第一个子元素集合元素:first只返回一个元素，而:first-child选择符将为每个父元素匹配子元素。例如$(“ul li:fisrt-child”)选取每个&lt;ul&gt;中的第一个&lt;li&gt;元素:last-child选取每个父元素的最后一个子元素集合元素:last只返回一个元素，而:last-child选择符将为每个父元素匹配子元素。例如$(“ul li:last-child”)选取每个&lt;ul&gt;中的末尾&lt;li&gt;元素:only-child如果某个元素是它父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，那么不会被匹配集合元素$(“ul li:only-child”)在&lt;ul&gt;中选取是唯一子元素的&lt;li&gt;元素:only-of-type匹配作为父元素唯一一个该类型的子元素的元素，将其封装为jQuery对象并返回。集合元素$(“li:only-of-type”)选取li父元素下的唯一的一个li元素:first-fo-type匹配作为父元素的第一个该类型的子元素的元素，将其封装为jQuery对象并返回集合元素\$(“span:first-of-type”)选取span父元素下的第一个span元素，等价于\$(“span:nth-of-type(1)”):last-of-type匹配作为父元素的最后一个该类型的子元素的元素，将其封装为jQuery对象并返回&nbsp;集合元素\$(“span:last-of-type”)选取span父元素下的最后一个span元素，等价于\$(“span:nth-last-of-type(1)”):nth-of-type(index/even/odd/equation)匹配作为父元素的同类型子元素中的第n个(或符合特定顺序的)元素，将其封装为jQuery对象并返回&nbsp;集合元素&nbsp; $(“span:nth-of-type(2)”)选取span父元素下的第二个span元素:nth-last-of-type(index/even/odd/equation)匹配作为父元素的同类型子元素中的倒数第n个（或符合特定倒数顺序的）元素，将其封装为jQuery对象并返回&nbsp;集合元素$(“span:nth-last-of-type(2)”)选取span父元素下的倒数第二个span元素:nth-child()选择器是很常见的子元素过滤选择器，详细功能如下：(1) :nth-child(even)能选取每个父元素下的索引值是偶数的元素。(2) :nth-child(odd)能选取每个父元素下的索引值是奇数的元素。(3) :nth-child(2)能选取每个父元素下的索引值等于2的元素。(4) :nth-child(3n)能选取每个父元素下的索引值是3的倍数的元素。(n从1开始)另外，关于:only-child和:only-of-type的区别可以看下面这个例子：1234567891011&lt;ul&gt; &lt;span id="span"&gt;span&lt;/span&gt; &lt;li id="li1"&gt;li1&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li id="li2"&gt;li2&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; console.log($("li:only-child")); console.log($("li:only-of-type"));&lt;/script&gt;打印结果：表单对象属性过滤选择器此选择器主要是对所选择的表单元素进行过滤，例如选择被选中的下拉框，多选框等元素。选择器描述返回示例:enabled选取所有可用元素集合元素$(“#form1:enabled”)选取id为form1的表单内所有可用元素:disabled选取所有不可用元素集合元素$(“#form2:disabled”)选取id为form2的表单内所有不可用元素:checked选取所有被选中的元素（单选框，复选框）集合元素$(“input:checked”)选取所有被选中的&lt;input&gt;元素:selected选取所有被选中的选项元素（下拉列表）集合元素$(“select option:selected”)选取所有被选中的选项元素表单选择器选择器描述返回示例:input选取所有&lt;input&gt;，&lt;textarea&gt;,&lt;select&gt;和&lt;button&gt;元素集合元素$(“:input”)选取所有&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt;元素:text选取所有的单行文本框集合元素$(“:text”)选取所有的单行文本框:password选取所有的密码框集合元素$(“:password”)选取所有的密码框:radio选取所有的单选框集合元素$(“:radio”)选取所有的单选框:checkbox选取所有的多选框集合元素$(“:checkbox”)选取所有的多选框:submit选取所有的提交按钮集合元素$(“:submit”)选取所有的提交按钮:image选取所有的图像按钮集合元素$(“:image”)选取所有的图像按钮:reset选取所有的重置按钮集合元素$(“:reset”)选取所有的重置按钮:button选取所有的按钮集合元素$(“:button”)选取所有的按钮:file选取所有的上传域集合元素$(“:file”)选取所有的上传域:hidden选取所有的不可见元素集合元素同前所述]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解決jQuery和其他库的冲突]]></title>
    <url>%2F%E8%A7%A3%E6%B1%BAjQuery%E5%92%8C%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E5%86%B2%E7%AA%81.html</url>
    <content type="text"><![CDATA[jQuery库在其他库之后导入在其他库和jQuery库都被加载完毕后，可以任何时候调用jQuery.noConflict()函数来将变量\$的使用权移交给其他JavaScript库。示例如下：1234567891011121314151617181920// ...省略其他代码&lt;p id="pp"&gt;Test-prototype(将被隐藏)&lt;/p&gt;&lt;p &gt;Test-jQuery(将被绑定单击事件)&lt;/p&gt;&lt;!-- 引入 prototype --&gt;&lt;script src="lib/prototype.js" type="text/javascript"&gt;&lt;/script&gt;&lt;!-- 引入 jQuery --&gt;&lt;script src="../../scripts/jquery.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;jQuery.noConflict(); //将变量$的控制权让渡给prototype.jsjQuery(function()&#123; //使用jQuery jQuery("p").click(function()&#123; alert( jQuery(this).text() ); &#125;);&#125;); $("#pp").style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt; &lt;/body&gt;// ...省略其他代码然后，就可以在程序里使用jQuery()函数作为jQuery对象的制造工厂。此外，还有另外一种选择。如果想确保jQuery’不会与其他库冲突，但又想自定义一个快捷方式。可以进行如下操作：123456789101112// ...省略其他代码&lt;script type="text/javascript"&gt;var $j = jQuery.noConflict(); //自定义一个比较短快捷方式$j(function()&#123; //使用jQuery，利用自定义快捷方式——$j $j("p").click(function()&#123; alert( $j(this).text() ); &#125;);&#125;); $("#pp").style.display = 'none'; //使用prototype.js隐藏元素&lt;/script&gt;// ...省略其他代码可以自定义备用名称，例如jq，\$j等。如果不想自定义名称，还想继续使用\$符号，又不能与其他js库冲突的话，可以使用以下两种办法：其一：12345678910&lt;script type="text/javascript"&gt;jQuery.noConflict(); //将变量$的控制权让渡给prototype.jsjQuery(function($)&#123; //使用jQuery设定页面加载时执行的函数 $("p").click(function()&#123; //在函数内部继续使用 $() 方法 alert( $(this).text() ); &#125;);&#125;); $("#pp").style.display = 'none'; //使用prototype&lt;/script&gt;其二：123456789101112&lt;script type="text/javascript"&gt;jQuery.noConflict(); //将变量$的控制权让渡给prototype.js(function($)&#123; //定义匿名函数并设置形参为$ $(function()&#123; //匿名函数内部的$均为jQuery $("p").click(function()&#123; //继续使用 $() 方法 alert($(this).text()); &#125;); &#125;);&#125;)(jQuery); //执行匿名函数且传递实参jQuery $("#pp").style.display = 'none'; //使用prototype&lt;/script&gt;jQuery库在其他库之前导入如果jQuery库在其他库之前就导入了，那么可以直接使用“jQuery”来做一些jQuery的工作，同时，可以使用\$()方法作为其他库的快捷方式。无需调用jQuery.noConflict()函数。示例如下：12345678910111213141516171819&lt;!-- 引入 jQuery --&gt;&lt;script src="../../scripts/jquery.js" type="text/javascript"&gt;&lt;/script&gt;&lt;!-- 引入 prototype --&gt;&lt;script src="lib/prototype.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p id="pp"&gt;Test-prototype(将被隐藏)&lt;/p&gt;&lt;p &gt;Test-jQuery(将被绑定单击事件)&lt;/p&gt; &lt;script type="text/javascript"&gt;jQuery(function()&#123; //直接使用 jQuery ,没有必要调用"jQuery.noConflict()"函数。 jQuery("p").click(function()&#123; alert( jQuery(this).text() ); &#125;);&#125;); $("#pp").style.display = 'none'; //使用prototype&lt;/script&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射机制]]></title>
    <url>%2FJava-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。—-百度百科动态：运行期间动态绑定执行规则。静态：编译以后就已经确定的执行过程。动态加载类到方法区1234567891011public void test1()&#123; String str = new String("Hello"); Class cls = String.class; //动态获取 String类型的方法信息： Method[] all = cls.getDeclaredMethods(); //Method 代表方法的信息 // method.getName 可以获取方法的名称 for (Method method : all) &#123; System.out.println(method.getName()); &#125;&#125;创建对象过程1.Java 将类加载到方法区（自动完成）2.利用类创建对象。内存中有一个String对象，方法区中还有类的信息！通过Class对象可以获取类的相关信息。动态获取类的信息动态获取类的方法信息Foo类（package：demo）：12345678910//编译以后是 demo.Foo.class//类的全名是 demo.Fooclass Foo&#123; public int test()&#123; return 5; &#125; public double test1()&#123; return 5d; &#125;&#125;动态获取Foo类的方法：1234567891011121314151617181920@Testpublic void testClassForName()&#123; /* * 动态的加载类信息到方法区 * 并且返回对应的Class对象！ * Class 对象可以访问类的全部信息！ * * 将className对应的类文件，从磁盘中加载 * 内存方法区，返回这个类的信息 */ String className = "demo.Foo"; try &#123; Class cls = Class.forName(className); Method[] all = cls.getDeclaredMethods(); for (Method method : all) &#123; System.out.println(method.getName()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125;输出：12testtest1 ​动态获取类的属性信息Eoo类：1234567891011121314151617class Eoo&#123; int id; String name; double salary; String meno; public Eoo()&#123; &#125; public Eoo(int id, String name, double salary, String meno) &#123; super(); this.id = id; this.name = name; this.salary = salary; this.meno = meno; &#125; // get，set略&#125;动态获取Eoo类的属性：1234567891011121314151617@Testpublic void testField()throws Exception &#123; /* * 动态获取一个类的全部属性信息 * 1 动态加载一个类到方法区 * 2 动态获取类的属性信息 */ String className = "demo.Eoo"; //动态加载类 Class cls = Class.forName(className); //动态获取类声明的属性信息 Field[] all = cls.getDeclaredFields(); for (Field field : all) &#123; //getName 获取属性的名字 System.out.print(field.getName()+" "); &#125;&#125;输出：1id name salary meno动态获取类的构造器信息123456789101112131415161718@Testpublic void testCon() throws Exception&#123; /* * 1 动态加载类 */ String className = "demo.Eoo"; Class cls = Class.forName(className); Constructor[] all = cls.getDeclaredConstructors(); for (Constructor c : all) &#123; System.out.print(c.getName()); //获取构造器的参数类型列表 // Parameter 参数 Type类型 // Class[] 代表所有参数的类型列表 Class[] types = c.getParameterTypes(); System.out.println(Arrays.toString(types)); &#125;&#125;输出：12demo.Eoo[]demo.Eoo[int, class java.lang.String, double, class java.lang.String] ​动态创建对象调用无参构造器创建对象如果没有无参数构造器，将发生异常！Class 提供了方法 newInstance()。123456789101112131415161718@Testpublic void testNewInstance() throws Exception&#123; /* * 动态调用无参数构造器创建对象 * 1 动态加载类 * 2 利用class 的方法 newInstance 执行 * 无参数构造器常见对象 * 注意：类必须有无参数，否则出异常 */ String className = "java.util.Date"; Class cls = Class.forName(className); // cls.newInstance()调用无参数构造器创建对象 Object obj = cls.newInstance(); System.out.println(obj); //静态的创建对象！编译已经就固定了！ Date date = new Date();&#125;输出：1Fri Sep 16 20:04:55 CST 2016调用有参构造器创建对象如果没有对应有参数构造器！将发生异常！参数传递错误、将发生异常！123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 调用 className 类名对应的类的有参数构造器，paramTypes 代表对应构造器的参数列表 * className + paramTypes 共同决定调用哪个构造器！执行构造器还需要具体的参数params */public Object create(String className,Class[] paramTypes,Object[] params) throws Exception&#123; // 动态加载类 // 动态获取指定参数类型的构造器 // 执行这个构造器，传递 params 参数。 Class cls = Class.forName(className); //getDeclaredConstructor 在类信息中查找 //给定参数类型的构造器信息 Constructor c = cls.getDeclaredConstructor(paramTypes); //执行构造器 c.newInstance() 方法，创建对象 //返回值就是这个构造器创建的对象 Object obj = c.newInstance(params); return obj;&#125;@Testpublic void testCreate() throws Exception &#123; String className = "java.util.Date"; //类型列表==Class类型的数组 Class[] paramTypes = &#123;long.class&#125;; //实际参数列表 Object[] params=&#123;-1000L*60*60*24*365&#125;; Object obj = create(className, paramTypes, params); System.out.println(obj); //思考：如何动态调用 new String("Hello"); className = "java.lang.String"; /* * &#123;&#125; 只能拥有声明变量时候直接初始化 * 不能用于赋值语句！ * 赋值语句可以使用 new Object[]&#123;"Hello"&#125; */ paramTypes = new Class[]&#123;String.class&#125;; params = new Object[]&#123;"Hello"&#125;; obj = create(className, paramTypes, params); System.out.println(obj);//Hello //思考：如何动态调用 new String(byte[],"utf-8"); obj = create("java.lang.String", new Class[]&#123;byte[].class, String.class&#125;, new Object[]&#123;new byte[]&#123;65,66,67,68&#125;, "UTF-8"&#125;); System.out.println(obj);&#125;输出：123Wed Jan 01 08:00:00 CST 1969HelloABCD ​动态获取类的属性值实现过程（如何利用反射API实现动态属性访问）：1.找到对象的类型信息（方法区）2.在信息中找属性信息（Field）3.在对象上获取属性的值！类Goo：123456789101112public class Goo &#123; public int id; public String name; public Goo() &#123; &#125; public Goo(int id, String name) &#123; super(); this.id = id; this.name = name; &#125;&#125;动态获取属性的值：12345678910111213141516171819202122232425262728293031323334353637383940 /** * 获取obj对象的 fieldName 对应属性的值 * @param obj * @param fieldName * @return 属性值 */public Object get(Object obj, String fieldName)throws Exception&#123; //1 获取类信息 /* * Java 中对象的getClass()方法可以获取 对象的类型信息！ * Java 中 有3种方法可以获取Class信息 * 1. 类名.class 获取类信息(静态) * 2. Class.forName("类名") 获取类信息 动态 * 3. obj.getClass() 获取类信息。运行期间，通过当前对象获取类信息 */ Class cls = obj.getClass(); //找到属性: /* * getDeclaredField 按照属性名在cls中查找 * 类信息。 当属性没有找到时候，抛出异常！ */ Field field = cls.getDeclaredField(fieldName); //在对象上获取属性的值！ /* * get方法：在一个对象上获取属性的值，对象上没有对应的属性，抛出异常 */ Object value = field.get(obj); return value;&#125; @Testpublic void testGetField()throws Exception &#123; /* * 动态获取对象的属性 */ Goo goo = new Goo(5, "Tom"); Object v1 = get(goo, "id"); Object v2 = get(goo, "name"); System.out.println(v1+" "+v2);&#125;输出：15 Tom动态调用类的方法12345678910111213@Testpublic void testinvoke()throws Exception&#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add("tom"); list.add("jack"); // 动态获取类信息 Class cls = list.getClass(); // 通过方法名和参数类型找到对应的方法 Method method = cls.getDeclaredMethod("remove", new Class[]&#123;int.class&#125;); // 调用方法，传递对象和具体参数 Object value=method.invoke(list,new Object[]&#123;0&#125;); System.out.println(value); //tom&#125;反射的意义常见的框架的底层都是使用反射实现的！如：Spring MyBatis Struts2 Hibernate …现有application.xml文件：12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;bean id="date" class="java.util.Date"&gt;&lt;/bean&gt; &lt;bean id="list" class="java.util.ArrayList"&gt;&lt;/bean&gt;&lt;/beans&gt;模拟Spring框架的getBean()方法：123456789101112131415161718192021222324252627282930313233343536public class ApplicationContext &#123; private HashMap&lt;String, Object&gt; map= new HashMap&lt;String, Object&gt;(); public ApplicationContext(String xml) &#123; SAXReader reader = new SAXReader(); try&#123; //读取xml InputStream in = this.getClass().getClassLoader().getResourceAsStream(xml); Document doc = reader.read(in); //解析XML内容 获取全部的&lt;bean&gt; List&lt;Element&gt; beans = doc.getRootElement().elements(); for (Element e : beans) &#123; //e 是每个 &lt;bean&gt; 元素 String id = e.attributeValue("id"); String className = e.attributeValue("class"); //利用反射创建对象 Class cls = Class.forName(className); Object obj = cls.newInstance(); //对象缓存到 map中 map.put(id, obj); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125; public Object getBean(String id)&#123; return map.get(id); &#125; public static void main(String[] args) &#123; String conf = "application.xml"; ApplicationContext ac = new ApplicationContext(conf); Object o = ac.getBean("date"); System.out.println(o); //Fri Sep 16 21:30:07 CST 2016 &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle SQL常用函数]]></title>
    <url>%2FOracle-SQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[文中例子涉及到的表数据：1234567891011121314151617181920SQL&gt; select empno,ename,job, hiredate,sal,deptno,comm from lzp.emp; EMPNO ENAME JOB HIREDATE SAL DEPTNO COMM---------- ---------- --------- -------------- ------- ---------- ---------- 7369 SMITH CLERK 17-12月-80 800 20 null 7499 ALLEN SALESMAN 20-2月 -81 3100 30 300 7521 WARD SALESMAN 22-2月 -81 1250 30 500 7566 JONES MANAGER 02-4月 -81 2975 20 null 7654 MARTIN SALESMAN 28-9月 -81 8000 30 1400 7698 BLAKE MANAGER 01-5月 -81 2850 30 null 7782 CLARK MANAGER 09-6月 -81 2450 10 null 7788 SCOTT ANALYST 19-4月 -87 3000 20 null 7839 KING PRESIDENT 17-11月-81 5000 10 null 7844 TURNER SALESMAN 08-9月 -81 1500 30 0 7876 ADAMS CLERK 23-5月 -87 1100 20 null 7900 JAMES CLERK 03-12月-81 950 30 null 7902 FORD ANALYST 03-12月-81 3000 20 null 7934 MILLER CLERK 23-1月 -82 1300 10 null 已选择14行。字符函数字符串截取12345SQL&gt; select substr('mrbird',3,6) from dual; SUBS----bird查找子串位置12345SQL&gt; select instr('mrBird','Bird') from dual; INSTR('MRBIRD','BIRD')---------------------- 3字符串连接123456789101112/* 1. || */SQL&gt; select 'mr'||'Bird'as result from dual; RESULT------mrBird/* 2.concat */SQL&gt; select concat('mr','Bird') as result from dual; RESULT------mrBird去除空格1234567891011SQL &gt; SELECT LTRIM (' mrBird') l, RTRIM ('mrBird ') r, TRIM (' mrBird ') TFROM dual; L R T------ ------ ------mrBird mrBird mrBird去除前缀和后缀1234567891011SQL &gt; SELECT TRIM (LEADING 'M' FROM 'MMMMMmrBird') s1, TRIM (TRAILING 'D' FROM 'mrBirdDDDD') s2, TRIM ('M' FROM 'MMMmrBirdMMMM') s3FROM dual; S1 S2 S3------ ------ ------mrBird mrBird mrBird计算字符串长度12345SQL&gt; select length('mrbird') from dual; LENGTH('MRBIRD')---------------- 6initcap（首字母变大写） ,lower（变小写）,upper（变大写）12345SQL&gt; select initcap('mrbird') s1,lower('MRBIRD') s2,upper('mrbird') s3 from dual; S1 S2 S3------ ------ ------Mrbird mrbird MRBIRD替换12345SQL&gt; select replace('mrXiaoniao','Xiaoniao','Bird') from dual; REPLAC------mrBirddecode[实现if ..then 逻辑] 注:第一个是表达式,最后一个是不满足任何一个条件的值123456789101112131415161718192021222324SQL&gt; SELECT DECODE ( deptno, 10, '人力资源部', 20, '软件开发部', 30, '市场部', '其他神秘部门' ) deptName, deptno, enameFROM lzp.empWHERE empno &gt;= 7900; DEPTNAME DEPTNO ENAME------------ ---------- ----------市场部 30 JAMES软件开发部 20 FORD人力资源部 10 MILLERcase[实现switch ..case 逻辑]12345678910111213141516171819202122232425262728293031SQL&gt; SELECT CASEWHEN sal &lt; 2000 THEN '被剥削的人'WHEN sal &lt; 3000 THEN '被压榨的人'WHEN sal &lt; 5000 THEN '普通的人'ELSE '努力的人'END meno, sal, enameFROM lzp.empWHERE deptno = 30ORDER BY sal ASC; MENO SAL ENAME---------- ---------- ----------被剥削的人 950 JAMES被剥削的人 1250 WARD被剥削的人 1500 TURNER被压榨的人 2850 BLAKE普通的人 3100 ALLEN努力的人 8000 MARTIN 已选择6行。十进制和ASCII互相转换12345SQL&gt; select ascii('A'),chr(65) from dual; ASCII('A') C---------- - 65 A日期函数TO_DATE格式(以时间: 2007-11-02 13:45:25 为例)Yearyy &nbsp; &nbsp;two digits两位年显示值:07yyythree digits三位年显示值:007yyyyfour digits四位年显示值:2007Monthmm &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;number&nbsp;两位月&nbsp;显示值:11mon&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;abbreviated字符集表示显示值:11月,若是英文版,显示nov&nbsp;monthspelled out字符集表示显示值:11月,若是英文版,显示novemberDaydd &nbsp; &nbsp; &nbsp;&nbsp;number当月第几天显示值:02ddd&nbsp;&nbsp;number当年第几天显示值:306dy &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;abbreviated &nbsp; &nbsp;当周第几天简写&nbsp;显示值:星期五,若是英文版,显示fridayspelled out当周第几天全写显示值:星期五,若是英文版,显示fridayddspthspelled out当月第几天英文显示值:secondHourhh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;two digits12小时进制&nbsp;显示值:01hh24two digits24小时进制显示值:13Minute &nbsp;&nbsp;mi/mm &nbsp; &nbsp;&nbsp;two digits60进制显示值:45Secondss &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;two digits60进制显示值:25OthersQ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;digit季度显示值:4WWdigit当年第几周&nbsp;显示值:44Wdigit当月第几周显示值:124小时格式下时间范围为： 0:00:00 - 23:59:59….12小时格式下时间范围为： 1:00:00 - 12:59:59 ….日期字符串相互转换时间转字符串:Year：1234567891011SQL&gt; SELECT TO_CHAR (SYSDATE, 'yy') yy, TO_CHAR (SYSDATE, 'yyy') yyy, TO_CHAR (SYSDATE, 'yyyy') yyyyFROM dual; YY YYY YYYY-- --- ----16 016 2016Month：1234567891011SQL&gt;SELECT TO_CHAR (SYSDATE, 'mm') mm, TO_CHAR (SYSDATE, 'mon') mon, TO_CHAR (SYSDATE, 'month') monthFROM dual; MM MON MONTH-- -------- ------09 9月 9月Day：12345678910111213SQL&gt;SELECT TO_CHAR (SYSDATE, 'dd') dd, TO_CHAR (SYSDATE, 'ddd') ddd, TO_CHAR (SYSDATE, 'dy') dy, TO_CHAR (SYSDATE, 'day') DAY, TO_CHAR (SYSDATE, 'ddspth') ddspthFROM dual; DD DDD DY DAY DDSPTH-- --- ------------ --------- --------------06 250 tue tuesday sixthHour：12345678910SQL&gt;SELECT TO_CHAR (SYSDATE, 'hh') hh, TO_CHAR (SYSDATE, 'hh24') hh24FROM dual; HH HH24-- --05 17Minute,Second略季度，周：1234567891011SQL&gt;SELECT TO_CHAR (SYSDATE, 'Q') Q, TO_CHAR (SYSDATE, 'WW') WW, TO_CHAR (SYSDATE, 'W') WFROM dual; Q WW W- -- -3 36 1字符串转时间：12345SQL&gt; select to_date('2016-09-06','yyyy-MM-dd') time from dual; TIME--------------06-9月 -16next_day返回下个星期的日期,day为1-7或星期日-星期六,1表示星期日，也可以用英文表示星期。12345SQL&gt; select next_day(sysdate,'monday') time from dual; TIME--------------12-9月 -16两个日期相差天数12345SQL&gt; select floor(sysdate - to_date('20020405','yyyymmdd')) time from dual; TIME---------- 5268months_between123456789101112SQL&gt; SELECT MONTHS_BETWEEN ( TO_DATE ('2016-09-01', 'yyyy-MM-dd'), TO_DATE ('2016-01-01', 'yyyy-MM-dd') ) monthsFROM dual; MONTHS---------- 8round [舍入到最接近的日期]（day:舍入到最接近的星期日）12345678910111213SQL&gt; SELECT SYSDATE S1, ROUND (SYSDATE) S2, ROUND (SYSDATE, 'year') YEAR, ROUND (SYSDATE, 'month') MONTH, ROUND (SYSDATE, 'day') DAYFROM dual; S1 S2 YEAR MONTH DAY-------------- -------------- -------------- -------------- --------------07-9月 -16 07-9月 -16 01-1月 -17 01-9月 -16 04-9月 -16计算时间差注:oracle时间差是以天数为单位,所以换算成年月,日123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566SQL&gt;SELECT FLOOR ( TO_NUMBER ( SYSDATE - TO_DATE ( '2007-11-02 15:55:03', 'yyyy-mm-dd hh24:mi:ss' ) ) / 365 ) AS spanYearsFROM dual; SPANYEARS---------- 8SQL&gt;SELECT CEIL ( MONTHS_BETWEEN ( SYSDATE, TO_DATE ( '2007-11-02 15:55:03', 'yyyy-mm-dd hh24:mi:ss' ) ) ) AS spanMonthsFROM dual; SPANMONTHS---------- 107SQL&gt;SELECT FLOOR ( TO_NUMBER ( SYSDATE - TO_DATE ( '2007-11-02 15:55:03', 'yyyy-mm-dd hh24:mi:ss' ) ) ) AS spanDaysFROM dual; SPANDAYS---------- 3231SQL&gt;SELECT FLOOR ( TO_NUMBER ( SYSDATE - TO_DATE ( '2007-11-02 15:55:03', 'yyyy-mm-dd hh24:mi:ss' ) ) * 24 ) AS spanHoursFROM dual; SPANHOURS---------- 77562/* 分秒略，以此类推 */查找月的最后一天12345SQL&gt; select last_day(sysdate) from dual; LAST_DAY(SYSDA--------------30-9月 -16ADD_MONTHS(date，i)对给定的日期加上给定的月，查看每个员工入职20周年1234567891011121314151617181920SQL&gt; select ename,add_months(hiredate,12*20) from lzp.emp; ENAME ADD_MONTHS(HIR---------- --------------SMITH 17-12月-00ALLEN 20-2月 -01WARD 22-2月 -01JONES 02-4月 -01MARTIN 28-9月 -01BLAKE 01-5月 -01CLARK 09-6月 -01SCOTT 19-4月 -07KING 17-11月-01TURNER 08-9月 -01ADAMS 23-5月 -07JAMES 03-12月-01FORD 03-12月-01MILLER 23-1月 -02已选择14行。EXTRACT单独获取指定时间的年或月或日12345SQL&gt; select extract(year from sysdate) from dual; EXTRACT(YEARFROMSYSDATE)------------------------ 2016数字函数取整函数（ceil 向上取整,floor 向下取整）12345SQL&gt; select ceil(66.6) N1,floor(66.6) N2 from dual; N1 N2---------- ---------- 67 66取幂(power) 和 求平方根(sqrt)12345SQL&gt; select power(3,2) N1,sqrt(9) N2 from dual; N1 N2---------- ---------- 9 3求余12345SQL&gt; select mod(9,5) from dual; MOD(9,5)---------- 4返回固定小数位数 （round:四舍五入，trunc:直接截断）12345SQL&gt; select round(66.667,2) N1,trunc(66.667,2) N2 from dual; N1 N2---------- ---------- 66.67 66.66返回值的符号（正数返回为1,负数为-1）12345SQL&gt; select sign(-32),sign(293) from dual; SIGN(-32) SIGN(293)---------- ---------- -1 1LEAST、GREATEST两个函数都可以有多个参数值，但参数类型必须一致，返回结果是参数列表中最大或最小的值。 在比较之前，在参数列表中第二个以后的参数会被隐含的转换为第一个参数的数据类型，所以如果可以转换，则继续比较，如果不能转换将会报错。12345SQL&gt; select least(1,2,3),greatest(sysdate,'01-10月-16') from dual; LEAST(1,2,3) GREATEST(SYSDA------------ -------------- 1 01-10月-16其他函数vsize: 返回表达式所需的字节数12345SQL&gt; select vsize('mrBird123') from dual; VSIZE('MRBIRD123')------------------ 9nvl(ex1,ex2):ex1值为空则返回ex2,否则返回该值本身ex1（常用） 例：如果雇员没有佣金，将显示0，否则显示佣金1234567891011121314151617181920SQL&gt; select comm,nvl(comm,0) from lzp.emp; COMM NVL(COMM,0)---------- ----------- 0 300 300 500 500 0 1400 1400 0 0 0 0 0 0 0 0 0 0 已选择14行。nullif(ex1,ex2):1234567891011121314SQL&gt; select nullif(88,88) from dual; NULLIF(88,88)------------- SQL&gt; select nullif(88,123) from dual; NULLIF(88,123)-------------- 88SQL&gt; select nullif('mrBird','mrBird') from dual; NULLIF------nvl2(ex1,ex2,ex3) :如果ex1不为空，显示ex2,否则显示ex3注：部分内容来自脚本之家]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Encryption - Decryption]]></title>
    <url>%2FJava-Encryption-Decryption.html</url>
    <content type="text"><![CDATA[开发中，经常要对一些敏感内容进行加密，这时候可以用到javax.crypto.Cipher类提供加密和解密功能。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class EncryptionDecryption &#123; //设置默认密匙 private static String strDefaultKey = "defaultKey"; //加密 private Cipher encryptCipher = null; //解密 private Cipher decryptCipher = null; /** * 将byte数组转换为表示16进制值的字符串， 如：byte[]&#123;8,18&#125;转换为：0813和 * public static byte[]hexStr2ByteArr(String strIn) 互为可逆的转换过程 * @param arrB 需要转换的byte数组 * @return 转换后的字符串 * @throws Exception */ public static String byteArr2HexStr(byte[] arrB) throws Exception &#123; int iLen = arrB.length; // 每个byte用两个字符才能表示，所以字符串的长度是数组长度的两倍 StringBuffer sb = new StringBuffer(iLen * 2); for (int i = 0; i &lt; iLen; i++) &#123; int intTmp = arrB[i]; // 把负数转换为正数 while (intTmp &lt; 0) &#123; intTmp = intTmp + 256; &#125; // 小于0F的数需要在前面补0 if (intTmp &lt; 16) &#123; sb.append("0"); &#125; sb.append(Integer.toString(intTmp, 16)); &#125; return sb.toString(); &#125; /** * 将表示16进制值的字符串转换为byte数组和public static String * byteArr2HexStr(byte[] arrB)互为可逆的转换过程 * @param strIn 需要转换的字符串 * @return 转换后的byte数组 * @throws Exception */ public static byte[] hexStr2ByteArr(String strIn) throws Exception &#123; byte[] arrB = strIn.getBytes(); int iLen = arrB.length; // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2 byte[] arrOut = new byte[iLen / 2]; for (int i = 0; i &lt; iLen; i = i + 2) &#123; String strTmp = new String(arrB, i, 2); arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16); &#125; return arrOut; &#125; /** * 默认构造方法，使用默认密钥 * @throws Exception */ public EncryptionDecryption() throws Exception &#123; this(strDefaultKey); &#125; /** * 指定密钥构造方法 * @param strKey 指定的密钥 * @throws Exception */ public EncryptionDecryption(String strKey) throws Exception &#123; Security.addProvider(new com.sun.crypto.provider.SunJCE()); Key key = getKey(strKey.getBytes()); encryptCipher = Cipher.getInstance("DES"); encryptCipher.init(Cipher.ENCRYPT_MODE, key); decryptCipher = Cipher.getInstance("DES"); decryptCipher.init(Cipher.DECRYPT_MODE, key); &#125; /** * 加密字节数组 * @param arrB 需加密的字节数组 * @return 加密后的字节数组 * @throws Exception */ public byte[] encrypt(byte[] arrB) throws Exception &#123; return encryptCipher.doFinal(arrB); &#125; /** * 加密字符串 * * @param strIn 需加密的字符串 * @return 加密后的字符串 * @throws Exception */ public String encrypt(String strIn) throws Exception &#123; return byteArr2HexStr(encrypt(strIn.getBytes())); &#125; /** * 解密字节数组 * @param arrB 需解密的字节数组 * @return 解密后的字节数组 * @throws Exception */ public byte[] decrypt(byte[] arrB) throws Exception &#123; return decryptCipher.doFinal(arrB); &#125; /** * 解密字符串 * @param strIn 需解密的字符串 * @return 解密后的字符串 * @throws Exception */ public String decrypt(String strIn) throws Exception &#123; try &#123; return new String(decrypt(hexStr2ByteArr(strIn))); &#125; catch (Exception e) &#123; return ""; &#125; &#125; /** * 从指定字符串生成密钥，密钥所需的字节数组长度为8位 不足8位时后面补0，超出 * 8位只取前8位 * @param arrBTmp 构成该字符串的字节数组 * @return 生成的密钥 * @throws java.lang.Exception */ private Key getKey(byte[] arrBTmp) throws Exception &#123; // 创建一个空的8位字节数组（默认值为0） byte[] arrB = new byte[8]; // 将原始字节数组转换为8位 for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) &#123; arrB[i] = arrBTmp[i]; &#125; // 生成密钥 Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES"); return key; &#125;&#125;测试：1234567891011121314public static void main(String[] args) &#123; try &#123; //设置密匙 EncryptionDecryption ed=new EncryptionDecryption("mrbird"); //加密 System.out.println(ed.encrypt("testEncryption")); //a9eb83878c22e90a23dcc32a0333e5e8 //解密 System.out.println(ed.decrypt("a9eb83878c22e90a23dcc32a0333e5e8")); //testEncryption &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库与实例]]></title>
    <url>%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%AE%9E%E4%BE%8B.html</url>
    <content type="text"><![CDATA[通常，“Oracle数据库”既指存储在硬盘上的内部存有数据的数据文件，也指用来管理这些数据文件的内存结构。实际上，“数据库”归属于数据文件，“实例”则归属于内存结构。图1-1展示了oracle实例与数据库的关系。一个实例由系统全局内存区域（System Global Area，SGA）以及一系列后台进程组成。每个链接到数据库的用户都是通过一个客户端进程进行管理，客户端进程与服务器进程相联结，每个服务器进程都会被分配一块私有的内存区域，该区域称为程序共享内存区域或进程共享内存区域（Process Global Area，PGA）。图1-1 实例与数据库关系图 SGA共享池共享池是Oracle缓存数据的地方。执行过的每一条SQL语句在共享池都存有解析后的内容。而存放这些内容的区域称为库高速缓存。在每一条SQL语句执行之前，Oracle都会查看库高速缓存中是否已存在相同的SQL语句。存在的话直接从里面读取该信息，而非再解析一遍。共享池还存储所有Oracle数据库对象信息，存储该信息的区域称为数据字典缓存区域。共享池内存有限，已加载的语句不能长时间存放在其中。基本思想是保留那些使用最频繁以及最近使用的语句。库高速缓存每一条SQL语句执行之前都将被解析并存入到库高速缓存中。解析包括验证语法，检验提及对象，确认对象用户权限。检验过后，下一个步骤就是执行软解析或者硬解析。软解析：库高速缓存解析每一条sql，判断之前是否执行过该语句，如果是，Oracle将取回之前解析的信息并重用。硬解析：如果该语句之前没有执行过，Oracle将执行所有工作来为当前的sql语句生成执行计划，并将其保存在缓存中以备将来重用。由此可见，软解析效率远比硬解析效率高得多！完全相同的语句有三条SQL语句：12345678910111213141516171819202122232425262728SQL&gt; select employee_id,first_name,last_name from hr.employees where department_id = 60; EMPLOYEE_ID FIRST_NAME LAST_NAME----------- -------------------- ------------------------- 103 Alexander Hunold 104 Bruce Ernst 105 David Austin 106 Valli Pataballa 107 Diana LorentzSQL&gt; SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME FROM HR.EMPLOYEES WHERE DEPARTMENT_ID = 60; EMPLOYEE_ID FIRST_NAME LAST_NAME----------- -------------------- ------------------------- 103 Alexander Hunold 104 Bruce Ernst 105 David Austin 106 Valli Pataballa 107 Diana Lorentz SQL&gt; select /*a_comment*/ employee_id,first_name,last_name from hr.employees where department_id = 60; EMPLOYEE_ID FIRST_NAME LAST_NAME----------- -------------------- ------------------------- 103 Alexander Hunold 104 Bruce Ernst 105 David Austin 106 Valli Pataballa 107 Diana Lorentz三条SQL语句的执行结果完全一致。但他们是完全一样的SQL语句么？查看V$sql视图：1234567SQL&gt; select sql_id,hash_value,executions from v$sql where upper(sql_text) like '%EMPLOYEES%'; SQL_ID HASH_VALUE EXECUTIONS------------- ---------- ----------3g8h969j7cgdd 1651916205 13j0qbm7gx8jwz 3755231135 1ary9nccpyyqmb 737106539 1从结果来看，这三条SQL并不一样，因为它们并不是严格一致的。完全相同的SQL语句必须 大小写字母一致，空格位置一致，注释内容位置完全一致。可以通过绑定变量的方式来代替常量：123456789101112131415161718192021222324252627282930313233343536373839SQL&gt; variable v_dept numberSQL&gt; exec :v_dept :=10 SQL&gt; select employee_id,first_name,last_name from hr.employees where department_id = :v_dept; EMPLOYEE_ID FIRST_NAME LAST_NAME----------- -------------------- ------------------------- 200 Jennifer Whalen /*--------------------------------------------------------*/SQL&gt; exec :v_dept :=20 SQL&gt; select employee_id,first_name,last_name from hr.employees where department_id = :v_dept; EMPLOYEE_ID FIRST_NAME LAST_NAME----------- -------------------- ------------------------- 201 Michael Hartstein 202 Pat Fay /*--------------------------------------------------------*/SQL&gt; exec :v_dept :=30 SQL&gt; select employee_id,first_name,last_name from hr.employees where department_id = :v_dept; EMPLOYEE_ID FIRST_NAME LAST_NAME----------- -------------------- ------------------------- 114 Den Raphaely 115 Alexander Khoo 116 Shelli Baida 117 Sigal Tobias 118 Guy Himuro 119 Karen Colmenares /*--------------------------------------------------------*/SQL&gt; select sql_id,hash_value,executions from v$sql where upper(sql_text) like '%V_DEPT%'; SQL_ID HASH_VALUE EXECUTIONS------------- ---------- ----------6qsnhnb7dbdra 3470112490 3由此可见，库高速缓存只存储了一条语句，并执行了三次。锁存器Oracle只有获得了锁存器后才可以从库高速缓存或其他内存中读取信息。锁存器可以避免库高速缓存同时被两个会话修改，一个会话在读取库高速缓存信息之前，都会获得一个锁存器，另一个会话必须等到上一个会话释放锁存器。自旋如Oracle判断当前sql是否已经存在库高速缓存中时必须先获得锁存器，如果此时锁存器不是空闲的，Oracle会迭代轮询，查看锁存器是否可用。经过一段时间（_spin_count=2000）锁存器仍不可用的话，该请求会被暂时挂起，直到下一次获得cpu时间片。SGA缓冲区缓存存储数据块。块是Oracle进行操作的最小的单位，包含数据行，索引或用来排序的临时数据（也包含块自身信息）。Oracle必须读取块来获取sql需要的数据行。缓冲区块的管理也遵循LRU(Least Recently Used)原则，同时也有个叫接触计数器（touch-count）的东西，记录块被使用的次数，被访问越频繁的块存活时间越长。在验证块是否存在缓冲区缓存的过程中，也需要获得锁存器。如果一个sql查询所需数据不在缓冲区缓存的块中，就必须读取操作系统硬盘来获取这些信息，然后存放到缓冲区缓存的块中。逻辑读取：Oracle从缓冲区缓存块中读取数据；物理读取：缓冲区缓存块中没有数据，Oracle从硬盘中读取数据的过程。Eg:1.清除共享池和缓冲区缓存（硬解析和物理读取）：123456789101112131415161718192021SQL&gt; alter system set events 'immediate trace name flush_cache';系统已更改。SQL&gt; alter system flush shared_pool;系统已更改。SQL&gt; set autotrace traceonly statisticsSQL&gt;SQL&gt; select * from hr.employees where department_id=60; 统计信息---------------------------------------------------------- 976 recursive calls 0 db block gets 237 consistent gets 23 physical reads 0 redo size 1320 bytes sent via SQL*Net to client 359 bytes received via SQL*Net from client 2 SQL*Net roundtrips to/from client 9 sorts (memory) 0 sorts (disk) 5 rows processed2.仅清除缓冲区缓存（软解析和物理读取）：12345678910111213141516171819202122SQL&gt; set autotrace offSQL&gt;SQL&gt; alter system set events 'immediate trace name flush_cache'; 系统已更改。SQL&gt; set autotrace traceonly statisticsSQL&gt;SQL&gt; select * from hr.employees where department_id=60; 统计信息---------------------------------------------------------- 0 recursive calls 0 db block gets 4 consistent gets 2 physical reads 0 redo size 1320 bytes sent via SQL*Net to client 359 bytes received via SQL*Net from client 2 SQL*Net roundtrips to/from client 0 sorts (memory) 0 sorts (disk) 5 rows processed ​3.都不清除（软解析和逻辑读取）：123456789101112131415SQL&gt; select * from hr.employees where department_id=60; 统计信息---------------------------------------------------------- 0 recursive calls 0 db block gets 4 consistent gets 0 physical reads 0 redo size 1320 bytes sent via SQL*Net to client 359 bytes received via SQL*Net from client 2 SQL*Net roundtrips to/from client 0 sorts (memory) 0 sorts (disk) 5 rows processed ​结果证明，当执行的查询只需要软解析和逻辑读取数据块的时候，所消耗的资源是最少的！]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript时间格式化]]></title>
    <url>%2FJavaScript%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96.html</url>
    <content type="text"><![CDATA[有时候后台传送的时间格式是这样的：1471881600000，或者通过new Date( )生成的时间格式是这样的：Tue Aug 30 2016 16:32:38 GMT+0800 (中国标准时间)。JavaScript没有类似于java的SimpleDateFormat( )函数，这时候可以自己写一个函数代替：1234567891011121314151617181920212223//时间格式化Date.prototype.Format = function (fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, "d+": this.getDate(), "h+": this.getHours(), "m+": this.getMinutes(), "s+": this.getSeconds(), "q+": Math.floor((this.getMonth() + 3) / 3), "S": this.getMilliseconds() &#125;; if (/(y+)/.test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "") .substr(4 - RegExp.$1.length)); &#125; for (var k in o)&#123; if (new RegExp("(" + k + ")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); &#125; &#125; return fmt;&#125;调用方式：new Date( ).Format(&quot;yyyy-MM-dd&quot;);]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom4j解析和生成xml文件]]></title>
    <url>%2Fdom4j%E8%A7%A3%E6%9E%90%E5%92%8C%E7%94%9F%E6%88%90xml%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[解析xml大致步骤：1: 创建SAXReader；2: 使用SAXReader解析指定的xml文档信息，并返回对应Document对象。Document对象中就包含了该xml文中的所有信息以及结构了。3: 根据文档结构将xml描述的树状信息读取到 。现有emp.xml文件，内容如下：123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;list&gt; &lt;emp id="1"&gt; &lt;name&gt;提利昂·兰尼斯特&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;salary&gt;5000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="2"&gt; &lt;name&gt;卡丽熙&lt;/name&gt; &lt;age&gt;27&lt;/age&gt; &lt;gender&gt;女&lt;/gender&gt; &lt;salary&gt;6000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="3"&gt; &lt;name&gt;琼恩·雪诺&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;salary&gt;7000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="4"&gt; &lt;name&gt;布兰·斯塔克&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;salary&gt;8000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="5"&gt; &lt;name&gt;nightKing&lt;/name&gt; &lt;age&gt;26&lt;/age&gt; &lt;gender&gt;未知&lt;/gender&gt; &lt;salary&gt;9000&lt;/salary&gt; &lt;/emp&gt;&lt;/list&gt;新建一个emp实体类，用于接收解析数据：12345678910111213141516171819public class Emp &#123; private int id; private String name; private int age; private String gender; private int salary; public Emp()&#123; &#125; public Emp(int id,String name,int age,String gender,int salary)&#123; super(); this.id = id; this.name = name; this.age = age; this.gender = gender; this.salary = salary; &#125; //get,set略&#125;123456789101112131415161718192021222324252627282930313233343536373839public class ParseXmlDemo &#123; public static List getXml()&#123; try &#123; SAXReader reader=new SAXReader(); Document doc=reader.read(new File("emp.xml")); List&lt;Emp&gt; list=new ArrayList&lt;Emp&gt;(); /* * 解析第一步，获取根标签（根元素） * 这里获取的根标签就相当于是&lt;list&gt;...&lt;/list&gt; * 那对标签。 */ Element root=doc.getRootElement(); //获取名为"emp"的标签 List&lt;Element&gt; elementList=root.elements("emp"); //遍历每一个emp标签 for(Element empEle:elementList)&#123; //获取name String name=empEle.elementText("name"); int age=Integer.parseInt(empEle.elementText("age")); String gender=empEle.elementText("gender"); int salary=Integer.parseInt(empEle.elementText("salary")); //属性 Attribute attr=empEle.attribute("id"); int id=Integer.parseInt(attr.getValue()); Emp emp=new Emp(id,name,age,gender,salary); list.add(emp); &#125; return list; &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.toString()); &#125; return null;&#125; public static void main(String[] args) &#123; List list=ParseXmlDemo.getXml(); System.out.println(list.toString()); &#125;&#125;输出结果：123451,提利昂·兰尼斯特,25,男,5000, 2,卡丽熙,27,女,6000,3,琼恩雪诺,28,男,7000, 4,布兰斯塔克,22,男,8000, 5,nightKing,26,未知,9000生成xml大致步骤：1: 创建一个Document对象，表示一个空的xml文档；2: 向Document中添加根元素；3: 按照目标xml文档的结构顺序向根元素中添加子元素来组建该结构；4: 创建XMLWriter；5: 设置低级流；6: 使用XMLWriter将Document写出来生成 该文档 。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class WriteXmlDemo &#123; public static void main(String[] args) &#123; try &#123; List&lt;Emp&gt; list= new ArrayList&lt;Emp&gt;(); list.add(new Emp(1,"鸣人",25,"男",4000)); list.add(new Emp(2,"小樱",27,"女",6000)); list.add(new Emp(3,"佐助",28,"男",7000)); list.add(new Emp(4,"雏田",22,"女",8000)); list.add(new Emp(5,"卡卡西",26,"男",90001)); Document doc = DocumentHelper.createDocument(); //生成根元素 Element root = doc.addElement("list"); for(Emp emp : list)&#123; //根标签下添加子标签 Element empEle= root.addElement("emp"); //向emp标签中添加子标签name Element nameEle= empEle.addElement("name"); //标签赋值 nameEle.addText(emp.getName()); Element ageEle = empEle.addElement("age"); ageEle.addText(emp.getAge()+""); Element genderEle = empEle.addElement("gender"); genderEle.addText(emp.getGender()); Element salaryEle = empEle.addElement("salary"); salaryEle.addText(emp.getSalary()+""); //添加属性 empEle.addAttribute("id", emp.getId()+""); &#125; //org.dom4j.XMLWriter XMLWriter writer = new XMLWriter( OutputFormat.createPrettyPrint()); /* * 向文件myemp.xml中写出数据 */ FileOutputStream fos= new FileOutputStream("myemp.xml"); writer.setOutputStream(fos); writer.write(doc); writer.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;生成myemp.xml：12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;list&gt; &lt;emp id="1"&gt; &lt;name&gt;鸣人&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;salary&gt;4000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="2"&gt; &lt;name&gt;小樱&lt;/name&gt; &lt;age&gt;27&lt;/age&gt; &lt;gender&gt;女&lt;/gender&gt; &lt;salary&gt;6000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="3"&gt; &lt;name&gt;佐助&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;salary&gt;7000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="4"&gt; &lt;name&gt;雏田&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;gender&gt;女&lt;/gender&gt; &lt;salary&gt;8000&lt;/salary&gt; &lt;/emp&gt; &lt;emp id="5"&gt; &lt;name&gt;卡卡西&lt;/name&gt; &lt;age&gt;26&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;salary&gt;90001&lt;/salary&gt; &lt;/emp&gt;&lt;/list&gt;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java读取和修改ini文件]]></title>
    <url>%2FJava%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9ini%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[项目开发中，一般将系统级的配置放在ini配置文件里，项目启动时，通过java读取ini里的变量值，然后发送到页面上。如红色警戒的ra2.ini配置文件：12345678910111213141516171819202122232425262728[MultiPlayer]PreferredGameTypeID = 111111 PreferredScenarioIndex=0Locale=0StoreNick=yesPortBase=1255PortPool=9415PhoneIndex=-1WOLLimitResolution=noLastNickSlot=-1Handle=5b,4e,65,77,20,50,6c,61,79,65,72,5d,Color=2ColorEx=-1Side=AmericansSideEx=-1GameMode=2 [Options]GameSpeed=0Difficulty=0ScrollMethod=0ScrollRate=0AutoScroll=yesDetailLevel=2SidebarCameoText=yesUnitActionLines=yesShowHidden=yesToolTips=yes读取和修改方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public final class javaReadIniUtil &#123; /** * 从ini配置文档中读取变量的值 * @param file 配置文档的路径 * @param section 要获取的变量所在段名称 * @param variable 要获取的变量名称 * @param defaultValue 变量名称不存在时的默认值 * @return 变量的值 * @throws IOException 抛出文档操作可能出现的io异常 */ public static String getProfileString(String file, String section, String variable, String defaultValue) throws IOException &#123; String strLine, value = ""; BufferedReader bufferedReader = new BufferedReader(new FileReader(file)); boolean isInSection = false; try &#123; while ((strLine = bufferedReader.readLine()) != null) &#123; strLine = strLine.trim(); Pattern p; Matcher m; p = Pattern.compile("\\["+section+"\\]"); m = p.matcher((strLine)); if (m.matches()) &#123; p = Pattern.compile("\\["+section+"\\]"); m = p.matcher(strLine); if (m.matches()) &#123; isInSection = true; &#125; else &#123; isInSection = false; &#125; &#125; if (isInSection == true) &#123; strLine = strLine.trim(); String[] strArray = strLine.split("="); if (strArray.length == 1) &#123; value = strArray[0].trim(); if (value.equalsIgnoreCase(variable)) &#123; value = ""; return value; &#125; &#125; else if (strArray.length == 2) &#123; value = strArray[0].trim(); if (value.equalsIgnoreCase(variable)) &#123; value = strArray[1].trim(); return value; &#125; &#125; else if (strArray.length &gt; 2) &#123; value = strArray[0].trim(); if (value.equalsIgnoreCase(variable)) &#123; value = strLine .substring(strLine.indexOf("=") + 1).trim(); return value; &#125; &#125; &#125; &#125; &#125; finally &#123; bufferedReader.close(); &#125; return defaultValue; &#125; /** * 修改ini配置文档中变量的值 * @param file 配置文档的路径 * @param section 要修改的变量所在段名称 * @param variable 要修改的变量名称 * @param value 变量的新值 * @throws IOException 抛出文档操作可能出现的io异常 */ public static boolean setProfileString(String file, String section,String variable, String value)throws IOException&#123; String fileContent, allLine, strLine, newLine, remarkStr; String getValue; BufferedReader bufferedReader = new BufferedReader(new FileReader(file)); boolean isInSection = false; fileContent = ""; try &#123; while ((allLine = bufferedReader.readLine()) != null) &#123; allLine = allLine.trim(); strLine = allLine; Pattern p; Matcher m; p = Pattern.compile("\\["+section+"\\]"); m = p.matcher((strLine)); if (m.matches()) &#123; p = Pattern.compile("\\["+section+"\\]"); m = p.matcher(strLine); if (m.matches()) &#123; isInSection = true; &#125; else &#123; isInSection = false; &#125; &#125; if (isInSection == true) &#123; strLine = strLine.trim(); String[] strArray = strLine.split("="); getValue = strArray[0].trim(); if (getValue.equalsIgnoreCase(variable)) &#123; newLine = getValue + " = " + value + " "; fileContent += newLine + "\r\n"; while((allLine = bufferedReader.readLine())!= null)&#123; fileContent += allLine + "\r\n"; &#125; bufferedReader.close(); BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file, false)); bufferedWriter.write(fileContent); bufferedWriter.flush(); bufferedWriter.close(); return true; &#125; &#125; fileContent += allLine + "\r\n"; &#125; &#125; catch (IOException ex) &#123; throw ex; &#125; finally &#123; bufferedReader.close(); &#125; return false; &#125; &#125;测试程序：123456789101112// 修改ini值public static void main(String[] args) &#123; try &#123; javaReadIniUtil.setProfileString( "resource/ra2.ini", "MultiPlayer", "GameMode", "mr_bird")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;值已被改变：12345678910111213141516[MultiPlayer]PreferredGameTypeID = 111111PreferredScenarioIndex=0Locale=0StoreNick=yesPortBase=1255PortPool=9415PhoneIndex=-1WOLLimitResolution=noLastNickSlot=-1Handle=5b,4e,65,77,20,50,6c,61,79,65,72,5d,Color=2ColorEx=-1Side=AmericansSideEx=-1GameMode = mr_bird读取[MultiPlayer]的GameMode变量值123456789101112public static void main(String[] args) &#123; try &#123; System.out.println( readIniUtil.getProfileString( "resource/ra2.ini", "MultiPlayer", "GameMode", "default")); //mr_bird &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; ​]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java.math.BigDecimal类常用方法]]></title>
    <url>%2FJava-math-BigDecimal%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[在编程中，当我们需要得到精确的运算结果的时候，+，-，*，/ 已经不能满足我们的需求，比如：1234System.out.println(0.1+0.2); //0.30000000000000004System.out.println(0.3-0.2); //0.09999999999999998System.out.println(0.1*0.2); //0.020000000000000004System.out.println(1.2/3); //0.39999999999999997简单的运算结果却不符合我们的预期。Java提供了一个叫BigDecimal的类，该类支持任何精度的定点数，可以用它来精确计算货币值。java.math.BigDecimal类共有四个构造方法：1.BigDecimal(int) —-int类型转为BigDecimal类型2.BigDecimal(double) —-double类型转为BigDecimal类型3.BigDecimal(long) —-long类型转为BigDecimal类型4.BigDecimal(string) —-string类型转为BigDecimal类型实际使用中，一般使用BigDecimal(string)构造方法。因为将string类型转为BigDecimal的结果是可预知的。相反，如通过构造方法BigDecimal(0.1) 将0.1转为BigDecimal类型：1System.out.println(new BigDecimal(0.1)); //0.1000000000000000055511151...因为0.1并不能精确的表示为double而通过BigDecimal(string)我们可以得到预期的转换结果：1System.out.println(new BigDecimal("0.1")); //0.1常用方法：1.加法：123456BigDecimal add=new BigDecimal("0.1").add(new BigDecimal("0.2"));System.out.println(add); //0.3//保留两位有效数字BigDecimal add1=new BigDecimal("0.1") .add(new BigDecimal("0.22222222222"),new MathContext(2));System.out.println(add1); //0.322.减法：123456BigDecimal sub=new BigDecimal("0.3").subtract(new BigDecimal("0.1"));System.out.println(sub); //0.2//保留两位有效数字BigDecimal sub=new BigDecimal("0.3") .subtract(new BigDecimal("0.111111111"),new MathContext(2));System.out.println(sub); //0.193.乘法：123456BigDecimal mul=new BigDecimal("0.1").multiply(new BigDecimal("0.2"));System.out.println(mul); //0.02//保留两位有效数字BigDecimal mul1=new BigDecimal("0.1") .multiply(new BigDecimal("0.2222222222"),new MathContext(2));System.out.println(mul1); //0.0224.除法：12345678910BigDecimal div=new BigDecimal("1.2").divide(new BigDecimal("3"));System.out.println(div); //0.4//保留两位有效数字BigDecimal div1=new BigDecimal("1") .divide(new BigDecimal("3"),new MathContext(2));System.out.println(div1); //0.33//四舍五入，保留两位小数BigDecimal div2=new BigDecimal("2") .divide(new BigDecimal("3"), 2, RoundingMode.HALF_UP);System.out.println(div2); //0.675.比较大小：123456789//小于，返回-1int result=new BigDecimal("0.1").compareTo(new BigDecimal("0.2"));System.out.println(result); //-1 //等于，返回 0int result=new BigDecimal("0.2").compareTo(new BigDecimal("0.2"));System.out.println(result); //0//大于，返回 1int result=new BigDecimal("0.3").compareTo(new BigDecimal("0.2"));System.out.println(result); //1]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EasyUI等待加载动画 [转]]]></title>
    <url>%2FEasyUI%E7%AD%89%E5%BE%85%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB-%E8%BD%AC.html</url>
    <content type="text"><![CDATA[使用方法:1.开启:MaskUtil.mask();2.关闭:MaskUtil.unmask();3.MaskUtil.mask(‘其它提示文字…’);123456789101112131415161718192021222324252627282930var MaskUtil = (function()&#123; var $mask,$maskMsg; var defMsg = '正在处理，请稍待。。。'; function init()&#123; if(!$mask)&#123; $mask = $("&lt;div class=\"datagrid-mask mymask\"&gt;&lt;/div&gt;").appendTo("body"); &#125; if(!$maskMsg)&#123; $maskMsg = $("&lt;div class=\"datagrid-mask-msg mymask\"&gt;"+defMsg+"&lt;/div&gt;") .appendTo("body").css(&#123;'font-size':'12px'&#125;); &#125; $mask.css(&#123;width:"100%",height:$(document).height()&#125;); var scrollTop = $(document.body).scrollTop(); $maskMsg.css(&#123; left:( $(document.body).outerWidth(true) - 190 ) / 2 , top:( ($(window).height() - 45) / 2 ) + scrollTop &#125;); &#125; return &#123; mask:function(msg)&#123; init(); $mask.show(); $maskMsg.html(msg||defMsg).show(); &#125;, unmask:function()&#123; $mask.hide(); $maskMsg.hide(); &#125; &#125;&#125;());转自：AXE博客]]></content>
      <tags>
        <tag>EasyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿Windows界面的JFileChooser]]></title>
    <url>%2F%E4%BB%BFWindows%E7%95%8C%E9%9D%A2%E7%9A%84JFileChooser.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920try &#123; UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());&#125; catch (Exception e1) &#123; e1.printStackTrace();&#125;String out = new SimpleDateFormat("yyMMddhhmmss").format(new Date());JFileChooser fc = new JFileChooser();//设置默认文件名fc.setSelectedFile(new File("项目内容表" + out + ".xls"));fc.setDialogType(JFileChooser.FILES_ONLY);fc.setDialogTitle("选择保存路径");fc.setMultiSelectionEnabled(false);int result = fc.showSaveDialog(fc);if (result == JFileChooser.APPROVE_OPTION) &#123; //保存 //your code here&#125; else &#123; //取消 //your code here&#125;如图：更换图标：重写其父类JFrame：123JFrame jf=new JFrame();ImageIcon imgIcon = new ImageIcon(ProExportUtil.class.getResource("icon.png"));jf.setIconImage(imgIcon.getImage());将上面13行代码改为：1int result = fc.showSaveDialog(jf);效果如图所示：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onClick事件和onDblClick 事件并存的解决方法 [转]]]></title>
    <url>%2FonClick%E4%BA%8B%E4%BB%B6%E5%92%8ConDblClick-%E4%BA%8B%E4%BB%B6%E5%B9%B6%E5%AD%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-%E8%BD%AC.html</url>
    <content type="text"><![CDATA[最近项目中遇到了在同一DOM元素上需要添加 onclick 和 ondblclick 2个事件，如果按照正常的方式添加处理，结果发现只会执行onclick，而不会执行 ondblclick；这时我们需要对2个事件的处理函数稍作处理就可以实现2个事件并存了，代码如下：12345678910111213141516171819202122&lt;script type="text/javascript"&gt; var clickTimer = null; function _click()&#123; if(clickTimer) &#123; window.clearTimeout(clickTimer); clickTimer = null; &#125; clickTimer = window.setTimeout(function()&#123; // your click process code here alert("你单击了我"); &#125;, 300); &#125; function _dblclick()&#123; if(clickTimer) &#123; window.clearTimeout(clickTimer); clickTimer = null; &#125; // your click process code here alert("你双击了我"); &#125; &lt;/script&gt;处理思想就是：利用定时器延迟执行onclick事件，这样在双击过程中会取消中途触发的单击事件。转自山哥]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache POI导出Excel文件]]></title>
    <url>%2FApache-POI%E5%AF%BC%E5%87%BAExcel%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[Apache POI 是用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程式对Microsoft Office格式档案读和写的功能。Apache POI 中提供的几大部分的作用：1.HSSF － 提供读写Microsoft Excel XLS格式档案的功能。2.XSSF － 提供读写Microsoft Excel OOXML XLSX格式档案的功能。3.HWPF － 提供读写Microsoft Word DOC格式档案的功能。4.HSLF － 提供读写Microsoft PowerPoint格式档案的功能。5.HDGF － 提供读Microsoft Visio格式档案的功能。6.HPBF － 提供读Microsoft Publisher格式档案的功能。7.HSMF － 提供读Microsoft Outlook格式档案的功能。使用Apache POI导出Excel表格文件大致如下几个步骤：1.创建新的Excel工作薄：1HSSFWorkbook workbook = new HSSFWorkbook(); ​2.创建一个工作表，如“员工表”：1HSSFSheet sheet = workbook.createSheet("员工表"); ​3.创建行：1HSSFRow row = sheet.createRow(0); //0表示索引为0的位置，也就是左上角4.创建列（也就是每一行的单元格）:1HSSFCell cell = row.createCell((short) 0); ​5.创建文件流，输出Excel，输出后关闭流以下是具体实例：Excel工具类(ExcelUtil)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class ExcelUtil &#123; private HSSFWorkbook wb = null; private HSSFSheet sheet = null; /** * @param wb * @param sheet */ public ExcelUtil(HSSFWorkbook wb, HSSFSheet sheet) &#123; super(); this.wb = wb; this.sheet = sheet; &#125; public HSSFSheet getSheet() &#123; return sheet; &#125; public void setSheet(HSSFSheet sheet) &#123; this.sheet = sheet; &#125; public HSSFWorkbook getWb() &#123; return wb; &#125; public void setWb(HSSFWorkbook wb) &#123; this.wb = wb; &#125; /** * 创建通用EXCEL头部 * * @param headString 头部显示的字符 * @param colSum 该报表的列数 */ @SuppressWarnings("deprecation") public void createNormalHead(String headString, int colSum) &#123; // 设置第一行 HSSFRow row = sheet.createRow(0); HSSFCell cell = row.createCell(0); row.setHeight((short) 350); // 定义单元格为字符串类型 cell.setCellType(HSSFCell.ENCODING_UTF_16); // 设置Excel表格标题 cell.setCellValue(new HSSFRichTextString(headString)); // 指定合并区域 sheet.addMergedRegion(new Region(0,(short) 0,0,(short) colSum)); // 设置单元格样式 HSSFCellStyle cellStyle = wb.createCellStyle(); // 指定单元格居中对齐 cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER); cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER); // 指定单元格自动换行 cellStyle.setWrapText(true); // 设置单元格字体 HSSFFont font = wb.createFont(); font.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL); font.setFontName("微软雅黑"); font.setFontHeight((short) 250); cellStyle.setFont(font); cell.setCellStyle(cellStyle); &#125; /** * 创建单元格方法 * * @param wb HSSFWorkbook * @param row HSSFRow * @param col short型的列索引 * @param align 对齐方式 * @param val 列值 */ public void cteateCell(HSSFWorkbook wb, HSSFRow row, int col, String val) &#123; HSSFCell cell = row.createCell(col); cell.setCellType(HSSFCell.ENCODING_UTF_16); cell.setCellValue(new HSSFRichTextString(val)); HSSFCellStyle cellStyle = wb.createCellStyle(); cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER); cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER); HSSFFont font = wb.createFont(); font.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL); font.setFontName("微软雅黑"); cellStyle.setFont(font); cell.setCellStyle(cellStyle); &#125; /** * 输入EXCEL文件 * * @param fileName 文件名 */ public void outputExcel(String fileName) &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(new File(fileName)); wb.write(fos); fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;Excel表格文件生成类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class ExportExcelClient &#123; // 创建一个新的Excel工作簿 private static HSSFWorkbook wb = new HSSFWorkbook(); // 创建一个新的工作表 private static HSSFSheet sheet = wb.createSheet(); private static Session session = null; public static void main(String[] args) &#123; ExcelUtil exportExcel = new ExcelUtil(wb, sheet); session = SessionUtil.getSession(); // 查询列名 String column_names = "select COLUMN_NAME from USER_TAB_COLS where TABLE_NAME = 'SYS_OBJECT_TYPE'"; List&lt;String&gt; list = session.createSQLQuery(column_names).list(); // 列数 Integer column_nums = list.toArray().length; exportExcel.createNormalHead("查询结果表", column_nums - 1); // 1.设置Excel表表头 HSSFRow row = sheet.createRow(1); HSSFCellStyle cellStyle = wb.createCellStyle(); // 设置表头背景色 cellStyle.setFillForegroundColor(HSSFColor.LIGHT_GREEN.index); cellStyle.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND); // 设置表头字体 HSSFFont font = wb.createFont(); font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); font.setFontName("微软雅黑"); cellStyle.setFont(font); // 设置表头列名 for (int i = 0; i &lt; column_nums; i++) &#123; HSSFCell cell = row.createCell((short) i); cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue(list.toArray()[i].toString()); cell.setCellStyle(cellStyle); &#125; // 2.填值 // 统计总共有几行数据 String count = "select count(*) from SYS_OBJECT_TYPE"; Integer num = Integer.valueOf(session.createSQLQuery(count).uniqueResult().toString()); // 查询出表格内容 String sql = "select * from SYS_OBJECT_TYPE"; Query q = session.createSQLQuery(sql); @SuppressWarnings("unchecked") List&lt;Object&gt; data = q.list(); // 循环向Excel表格填充数据 // 每一行 for (int i = 2; i &lt; num; i++) &#123; HSSFRow row1 = sheet.createRow((short) i); // 每一列 for (int j = 0; j &lt; column_nums; j++) &#123; ortExcel.cteateCell(wb, row1, (short) j, ((Object[]) data.get(i))[j] == null ? "" :((Object[]) data.get(i))[j].toString()); // 设置列的宽度根据内容自适应 sheet.autoSizeColumn((short) j); &#125; &#125; String out = new SimpleDateFormat("yyMMddhhmmss").format(new Date()); // 3.输出xls exportExcel.outputExcel("d:\\查询结果" + out + ".xls"); session.close(); &#125;&#125;效果如下图所示：附录一：相关jar包链接:百度网盘 密码：wow5附录二：HSSFColor颜色对照表：]]></content>
      <tags>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传下载demo]]></title>
    <url>%2F%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BDdemo.html</url>
    <content type="text"><![CDATA[附件上传下载的基本过程主要包含两个步骤：1.通过IO流将附件上传/下载到对应的文件夹内；2.将附件对应的信息（经过处理后的附件名，格式，大小等）保存到数据库。下图是此次demo的效果图（默认用户id为1）：数据库附件表SYS_ANNEX：123456789101112 create table SYS_ANNEX ( ANNEX_ID VARCHAR2(20) not null, --附件id AREA_ID NUMBER(5), BUSI_TYPE_ID NUMBER(5), --业务类型id，这里我们默认为1 ANNEX_KEY VARCHAR2(20) not null, NAME VARCHAR2(100) not null, --附件名 USER_ID NUMBER(12) not null, --用户id，这里我们默认为1 CREATE_DATE DATE not null, --创建时间 STATE_ID NUMBER(5) not null, STATE_DATE DATE not null, constraint PK_SYS_ANNEX primary key (ANNEX_ID));Session工具类，用来创建查询：1234567891011121314public class SessionUtil &#123; private static SessionFactory sf; static&#123; Configuration conf=new Configuration(); conf.configure("hibernate.cfg.xml"); sf=conf.buildSessionFactory(); &#125; public static Session getSession()&#123; return sf.openSession(); &#125; public static SessionFactory getSf()&#123; return sf; &#125;&#125;上传模块servlet：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class UploadHandleServlet extends HttpServlet &#123; public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问， // 保证上传文件的安全 String savePath = this.getServletContext().getRealPath("/WEB-INF/upload"); // 上传时生成的临时文件保存目录 String tempPath = this.getServletContext().getRealPath("/WEB-INF/temp"); File tmpFile = new File(tempPath); if (!tmpFile.exists()) &#123; // 创建临时目录 tmpFile.mkdir(); &#125; // 消息提示 String message = ""; try &#123; // 使用Apache文件上传组件处理文件上传步骤： // 1、创建一个DiskFileItemFactory工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); // 设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个 // 临时文件存放到指定的临时目录当中。设置缓冲区的大小为100KB，如果不指定， // 那么缓冲区的大小默认是10KB factory.setSizeThreshold(1024 * 100); // 设置上传时生成的临时文件的保存目录 factory.setRepository(tmpFile); // 2、创建一个文件上传解析器 ServletFileUpload upload=new ServletFileUpload(factory); // 解决上传文件名的中文乱码 upload.setHeaderEncoding("UTF-8"); // 3、判断提交上来的数据是否是上传表单的数据 if (!ServletFileUpload.isMultipartContent(request)) &#123; // 按照传统方式获取数据 return; &#125; // 设置上传单个文件的大小的最大值，目前是设置为1024*1024*100字节， // 也就是100MB upload.setFileSizeMax(1024 * 1024 * 100); // 设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的 // 最大值的和，目前设置为1000MB upload.setSizeMax(1024 * 1024 * 1000); // 4、使用ServletFileUpload解析器解析上传数据，解析结果返回的 // 是一个List&lt;FileItem&gt;集合，每一个FileItem对应一个Form表单的 // 输入项 List&lt;FileItem&gt; list = upload.parseRequest(request); for (FileItem item : list) &#123; // 如果fileitem中封装的是普通输入项的数据 if (item.isFormField()) &#123; String name = item.getFieldName(); // 解决普通输入项的数据的中文乱码问题 String value = item.getString("UTF-8"); &#125; else &#123;// 如果fileitem中封装的是上传文件 // 得到上传的文件名称， String filename = item.getName(); System.out.println(filename); if (filename == null || filename.trim().equals("")) &#123; continue; &#125; // 注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的 // 文件名是带有路径的，如： c:\a\b\1.txt，而有些只是单纯的文件名， // 如：1.txt，处理获取到的上传文件的文件名的路径部分，只保留文件 // 名部分 filename = filename.substring(filename.lastIndexOf("\\") + 1); // 得到上传文件的扩展名 String fileExtName = filename.substring(filename.lastIndexOf(".") + 1); // 如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的 // 文件类型是否合法 System.out.println( "上传的文件的扩展名是：" + fileExtName); // 获取item中的上传文件的输入流 InputStream in = item.getInputStream(); // 得到文件保存的名称 String saveFilename = makeFileName(filename); // 得到文件的保存目录 String realSavePath = savePath; // 创建一个文件输出流 FileOutputStream out = new FileOutputStream(realSavePath+ "\\"+ saveFilename); // 创建一个缓冲区 byte buffer[] = new byte[1024]; // 判断输入流中的数据是否已经读完的标识 int len = 0; // 循环将输入流读入到缓冲区当中，(len=in.read(buffer))&gt;0就 // 表示in里面还有数据 while ((len = in.read(buffer)) &gt; 0) &#123; // 使用FileOutputStream输出流将缓冲区的数据写入到指定的 // 目录(savePath + "\\"+ filename)中 out.write(buffer, 0, len); &#125; // 关闭输入流 in.close(); // 关闭输出流 out.close(); // 删除处理文件上传时生成的临时文件 item.delete(); message = "文件上传成功！"; // 文件上传成功后，将对应的信息保存到数据库SYS_ANNEX表 Integer userId = Integer.valueOf(request.getParameter("userId")); Date date = new Date(System.currentTimeMillis()); String annexId = System.currentTimeMillis() + ""; String annexKey = userId + ""; Session session = SessionUtil.getSession(); String sql = "insert INTO SYS_ANNEX VALUES(ANNEX_SEQ.nextval,"; sql+="1,1,?,?,?,sysdate,1,sysdate)"; SQLQuery query = session.createSQLQuery(sql); query.setString(0, annexKey); query.setString(1, saveFilename); query.setInteger(2, userId); Transaction ts = session.beginTransaction(); try &#123; query.executeUpdate(); ts.commit(); System.out.println("插入成功"); &#125; catch (HibernateException e) &#123; e.printStackTrace(); ts.rollback(); System.out.println("插入失败"); &#125; finally &#123; session.close(); &#125; &#125; &#125; &#125; catch (FileUploadBase .FileSizeLimitExceededException e) &#123; e.printStackTrace(); request.setAttribute( "message", "单个文件超出最大值！"); return; &#125; catch (FileUploadBase.SizeLimitExceededException e) &#123; e.printStackTrace(); request.setAttribute( "message","上传文件的总大小超出限制的最大值！"); return; &#125; catch (Exception e) &#123; message = "文件上传失败！"; e.printStackTrace(); &#125; request.setAttribute("message", message); &#125; /** * @Method: makeFileName * @Description: 生成上传文件的文件名，文件名以：uuid+"_"+文件的原始名称 * @param filename文件的原始名称 * @return uuid+"_"+文件的原始名称 */ private String makeFileName(String filename) &#123; // 为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名 return UUID.randomUUID().toString() + "_" + filename; &#125; &#125;展示当前（用户id为1，业务类型id为1）的所有附件的servlet：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ListFileServlet extends HttpServlet &#123; public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Integer userId = Integer.valueOf(request.getParameter("userId")); Integer busiTypeId = Integer.valueOf(request.getParameter("busiTypeId")); // 获取上传文件的目录 String uploadFilePath = this.getServletContext() .getRealPath("/WEB-INF/upload"); // 存储要下载的文件名 Map&lt;String, String&gt; fileNameMap = new HashMap&lt;String, String&gt;(); // 递归遍历filepath目录下的所有文件和目录，将文件的文件名存储到map集合中 listfile(new File(uploadFilePath),fileNameMap,userId,busiTypeId); // File既可以代表一个文件也可以代表一个目录 Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = fileNameMap.entrySet().iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = it.next(); &#125; // 将Map集合发送到listfile.jsp页面进行显示 request.setAttribute("fileNameMap", fileNameMap); request.getRequestDispatcher("/listfile.jsp").forward(request, response); &#125; /** * @Method: listfile * @Description: 递归遍历指定目录下的所有文件 * @param file：即代表一个文件，也代表一个文件目录 * @param map：存储文件名的Map集合 */ public void listfile(File file, Map&lt;String, String&gt; map,Integer userId, Integer busiTypeId)&#123; Session session = SessionUtil.getSession(); String sql = "select name from SYS_ANNEX where user_id=?" sql += "and busi_type_id=?"; SQLQuery query = session.createSQLQuery(sql); query.setInteger(0, userId); query.setInteger(1, busiTypeId); List&lt;String&gt; list = query.list(); for (String fileName : list) &#123; /** * 处理文件名，上传后的文件是以uuid_文件名的形式去重新命 * 名的，去除文件名的uuid_部分file.getName().indexOf("_") * 检索字符串中第一次出现"_"字符的位置，如果文件名 * 类似于：9349249849-88343-8344_多啦A梦.avi那么 * file.getName().substring(file.getName().indexOf("_")+1) * 处理之后就可以得到多啦A梦.avi部分 */ String realName = fileName.substring(fileName.indexOf("_") + 1); // file.getName()得到的是文件的原始名称，这个名称是 // 唯一的，因此可以作为key，realName是处理过后的名称， // 有可能会重复 map.put(fileName, realName); &#125; session.close(); &#125; &#125;下载servlet：12345678910111213141516171819202122232425262728293031323334353637383940public class DownLoadServlet extends HttpServlet &#123; public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 得到要下载的文件名 String fileName = request.getParameter("filename"); // 上传的文件都是保存在/WEB-INF/upload目录下的子目录当中 String fileSaveRootPath = this.getServletContext() .getRealPath("/WEB-INF/upload"); // 通过文件名找出文件的所在目录 String path = fileSaveRootPath; // 得到要下载的文件 File file = new File(path + "\\" + fileName); // 如果文件不存在 if (!file.exists()) &#123; request.setAttribute("message", "您要下载的资源已被删除！"); return; &#125; // 处理文件名 String realname = fileName.substring(fileName.indexOf("_") + 1); // 设置响应头，控制浏览器下载该文件 response.setHeader("content-disposition", "attachment;filename=" + URLEncoder.encode(realname, "UTF-8")); // 读取要下载的文件，保存到文件输入流 FileInputStream in = new FileInputStream(path + "\\" + fileName); // 创建输出流 OutputStream out = response.getOutputStream(); // 创建缓冲区 byte buffer[] = new byte[1024]; int len = 0; // 循环将输入流中的内容读取到缓冲区当中 while ((len = in.read(buffer)) &gt; 0) &#123; // 输出缓冲区的内容到浏览器，实现文件下载 out.write(buffer, 0, len); &#125; // 关闭文件输入流 in.close(); // 关闭输出流 out.close(); &#125;&#125;删除servlet：123456789101112131415161718192021222324252627282930313233343536public class DeleteFileServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取文件名 String fileName = request.getParameter("fileName"); // 数据库删除记录 Session session=SessionUtil.getSession(); String sql="delete from SYS_ANNEX where name=?"; SQLQuery query=session.createSQLQuery(sql); query.setString(0,fileName); Transaction ts=session.beginTransaction(); try&#123; query.executeUpdate(); ts.commit(); &#125;catch(HibernateException e)&#123; e.printStackTrace(); ts.rollback(); return; &#125;finally&#123; session.close(); &#125; // 数据库成功删除记录后，再从硬盘里删除文件 //上传的文件都是保存在/WEB-INF/upload目录下的子目录当中 String fileSaveRootPath = this.getServletContext() .getRealPath("/WEB-INF/upload"); //通过文件名找出文件的所在目录 String path = fileSaveRootPath; //得到要删除的文件 File file = new File(path + "\\" + fileName); //删除文件 file.delete(); &#125;&#125;上传页面upload.jsp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="c_rt" uri="http://java.sun.com/jstl/core_rt" %&gt; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;style&gt; table&#123; margin:auto; &#125; &lt;/style&gt; &lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;script type="text/javascript" src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; //页面一加载调用onLoad()函数读取附件 onLoad(); $("#submit").click(function()&#123; //将form表单附件格式化 var formData = new FormData($("#form")[0]); var userId=$("#userId").val().trim(); var location="http://localhost:8080/file/servlet/"; location+="UploadHandleServlet?userId="+userId; $.ajax(&#123; //调用上传servlet url:location, type:"post", data:formData, async: false, cache: false, contentType: false, processData: false, success:function()&#123; //成功后清除上传附件模块内容 $("#file").empty(); AddMore(); //调用onLoad()函数，刷新 onLoad(); &#125; &#125;); &#125;); //onLoad()函数调用listfileServlet,读取当前用户下的所有附件 function onLoad()&#123; $.ajax(&#123; url:"http://localhost:8080/file/listfile", type:"post", //模拟用户id为1，业务类型id为1 data:&#123;"userId":1,"busiTypeId":1&#125;, success:function(fileNameMap)&#123; //将读取到的fileMap展示出来 $("#fileLoad").html(fileNameMap); &#125; &#125;); &#125;&#125;); &lt;/script&gt; &lt;script type="text/javascript"&gt; function AddMore()&#123; var more = document.getElementById("file"); var br = document.createElement("br"); var input = document.createElement("input"); var button = document.createElement("input"); input.type = "file"; input.name = "file"; input.id="file"; button.type = "button"; button.value = "删除"; more.appendChild(input); more.appendChild(button); more.appendChild(br); button.onclick = function()&#123; more.removeChild(br); more.removeChild(input); more.removeChild(button); &#125;;&#125; &lt;/script&gt; &lt;/head&gt; &lt;body &gt; &lt;form action="http://localhost:8080/file/servlet/UploadHandleServlet" enctype="multipart/form-data" method="post" id="form"&gt; &lt;table border="1" &gt; &lt;tr&gt; &lt;td&gt;用户ID:&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="userId" id="userId" value="1"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;附件:&lt;/td&gt; &lt;td id="file"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt; &lt;input type="button" value="增加附件" onclick="AddMore()"&gt; &lt;input type="button" value="提交" id="submit"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;附件下载:&lt;/td&gt; &lt;td id="fileLoad"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; AddMore(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;展示页面listfile.jsp，供ajax调用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="c_rt" uri="http://java.sun.com/jstl/core_rt" %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;style&gt; #method &#123; float:right; margin-right:2px; &#125;&lt;/style&gt;&lt;script type="text/javascript"&gt; $(function()&#123; //删除 $(".delete").click(function()&#123; var name=$(this).attr("name"); var location="http://localhost:8080/file/servlet/DeleteFileServlet"; $.ajax(&#123; url:location, type:"post", data:&#123;"fileName":name&#125;, success:function()&#123; onLoad(); &#125; &#125;); &#125;); function onLoad()&#123; $.ajax(&#123; url:"http://localhost:8080/file/listfile", type:"post", data:&#123;"userId":1,"busiTypeId":1&#125;, success:function(fileNameMap)&#123; $("#fileLoad").html(fileNameMap); &#125; &#125;); &#125;&#125;); &lt;/script&gt;&lt;head&gt; &lt;title&gt;下载文件页面，供ajax返回调用&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;!-- 遍历fileNameMap集合 --&gt;&lt;c_rt:forEach var="me" items="$&#123;fileNameMap&#125;"&gt; &lt;c_rt:url value="/servlet/DownLoadServlet" var="downurl"&gt; &lt;c_rt:param name="filename" value="$&#123;me.key&#125;"&gt;&lt;/c_rt:param&gt; &lt;/c_rt:url&gt; &lt;c_rt:url value="/servlet/DeleteFileServlet" var="deleteurl"&gt; &lt;c_rt:param name="filename" value="$&#123;me.key&#125;"&gt;&lt;/c_rt:param&gt; &lt;/c_rt:url&gt; $&#123;me.value&#125; &lt;span id="method"&gt; &lt;a href="$&#123;downurl&#125;" id="downLoad"&gt;下载&lt;/a&gt; &lt;a href="javascript:void(0)" class="delete" name="$&#123;me.key&#125;"&gt;删除&lt;/a&gt; &lt;/span&gt;&lt;br/&gt;&lt;/c_rt:forEach&gt;&lt;/body&gt;&lt;/html&gt;剩下的只需在web.xml中配置这几个servlet，以及配置hibernate.cfg.xml即可 。jar包：链接:百度网盘 密码：q75g]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle树查询]]></title>
    <url>%2FOracle%E6%A0%91%E6%9F%A5%E8%AF%A2.html</url>
    <content type="text"><![CDATA[oracle树查询的最重要的就是select…start with…connect by…prior语法了。依托于该语法，我们可以将一个表形结构的以树的顺序列出来。在下面列述了oracle中树型查询的常用查询方式以及经常使用的与树查询相关的oracle特性函数等，在这里只涉及到一张表中的树查询方式而不涉及多表中的关联等。1.准备测试表和测试数据：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162--菜单目录结构表create table tb_menu( id number(10) not null, --主键id title varchar2(50), --标题 parent number(10) --parent id) --父菜单insert into tb_menu(id, title, parent) values(1, '父菜单1',0);insert into tb_menu(id, title, parent) values(2, '父菜单2',0);insert into tb_menu(id, title, parent) values(3, '父菜单3',0);insert into tb_menu(id, title, parent) values(4, '父菜单4',0);insert into tb_menu(id, title, parent) values(5, '父菜单5',0);--一级菜单insert into tb_menu(id, title, parent) values(6, '一级菜单6',1);insert into tb_menu(id, title, parent) values(7, '一级菜单7',1);insert into tb_menu(id, title, parent) values(8, '一级菜单8',1);insert into tb_menu(id, title, parent) values(9, '一级菜单9',2);insert into tb_menu(id, title, parent) values(10, '一级菜单10',2);insert into tb_menu(id, title, parent) values(11, '一级菜单11',2);insert into tb_menu(id, title, parent) values(12, '一级菜单12',3);insert into tb_menu(id, title, parent) values(13, '一级菜单13',3);insert into tb_menu(id, title, parent) values(14, '一级菜单14',3);insert into tb_menu(id, title, parent) values(15, '一级菜单15',4);insert into tb_menu(id, title, parent) values(16, '一级菜单16',4);insert into tb_menu(id, title, parent) values(17, '一级菜单17',4);insert into tb_menu(id, title, parent) values(18, '一级菜单18',5);insert into tb_menu(id, title, parent) values(19, '一级菜单19',5);insert into tb_menu(id, title, parent) values(20, '一级菜单20',5);--二级菜单insert into tb_menu(id, title, parent) values(21, '二级菜单21',6);insert into tb_menu(id, title, parent) values(22, '二级菜单22',6);insert into tb_menu(id, title, parent) values(23, '二级菜单23',7);insert into tb_menu(id, title, parent) values(24, '二级菜单24',7);insert into tb_menu(id, title, parent) values(25, '二级菜单25',8);insert into tb_menu(id, title, parent) values(26, '二级菜单26',9);insert into tb_menu(id, title, parent) values(27, '二级菜单27',10);insert into tb_menu(id, title, parent) values(28, '二级菜单28',11);insert into tb_menu(id, title, parent) values(29, '二级菜单29',12);insert into tb_menu(id, title, parent) values(30, '二级菜单30',13);insert into tb_menu(id, title, parent) values(31, '二级菜单31',14);insert into tb_menu(id, title, parent) values(32, '二级菜单32',15);insert into tb_menu(id, title, parent) values(33, '二级菜单33',16);insert into tb_menu(id, title, parent) values(34, '二级菜单34',17);insert into tb_menu(id, title, parent) values(35, '二级菜单35',18);insert into tb_menu(id, title, parent) values(36, '二级菜单36',19);insert into tb_menu(id, title, parent) values(37, '二级菜单37',20);--三级菜单insert into tb_menu(id, title, parent) values(38, '三级菜单38',21);insert into tb_menu(id, title, parent) values(39, '三级菜单39',22);insert into tb_menu(id, title, parent) values(40, '三级菜单40',23);insert into tb_menu(id, title, parent) values(41, '三级菜单41',24);insert into tb_menu(id, title, parent) values(42, '三级菜单42',25);insert into tb_menu(id, title, parent) values(43, '三级菜单43',26);insert into tb_menu(id, title, parent) values(44, '三级菜单44',27);insert into tb_menu(id, title, parent) values(45, '三级菜单45',28);insert into tb_menu(id, title, parent) values(46, '三级菜单46',28);insert into tb_menu(id, title, parent) values(47, '三级菜单47',29);insert into tb_menu(id, title, parent) values(48, '三级菜单48',30);insert into tb_menu(id, title, parent) values(49, '三级菜单49',31);insert into tb_menu(id, title, parent) values(50, '三级菜单50',31);commit;parent字段存储的是上级id，如果是顶级父节点，该parent为0。2.树操作我们从最基本的操作，逐步列出树查询中常见的操作，所有查询出来的节点以家族中的辈份作比方。查找树中的所有顶级父节点假设这个树是个目录结构，那么第一个操作总是找出所有的顶级节点，再根据该节点找到其下属节点。123456789SQL&gt; select * from tb_menu m where m.parent=0; ID TITLE PARENT---------- -------------------------------------------------- ---------- 1 父菜单1 0 2 父菜单2 0 3 父菜单3 0 4 父菜单4 0 5 父菜单5 0查找一个节点的直属子节点如果查找的是直属子类节点，也是不用用到树型查询的。1234567SQL&gt; select * from tb_menu m where m.parent=1; ID TITLE PARENT---------- -------------------------------------------------- ---------- 6 一级菜单6 1 7 一级菜单7 1 8 一级菜单8 1查找一个节点所有直属子节点1234567891011121314151617181920SQL&gt; select * from tb_menu m start with m.id=1 connect by m.parent=prior m.id; ID TITLE PARENT---------- -------------------------------------------------- ---------- 1 父菜单1 0 6 一级菜单6 1 21 二级菜单21 6 38 三级菜单38 21 22 二级菜单22 6 39 三级菜单39 22 7 一级菜单7 1 23 二级菜单23 7 40 三级菜单40 23 24 二级菜单24 7 41 三级菜单41 24 8 一级菜单8 1 25 二级菜单25 8 42 三级菜单42 25 已选择14行。这个查找的是id为1的节点下的所有直属子类节点，包括子辈的和孙子辈的所有直属节点。查找一个节点的直属父节点如果查找的是节点的直属父节点，也是不用用到树型查询的。12345678910111213141516SQL&gt;SELECT c. ID, c.title, P . ID parent_id, P .title parent_titleFROM tb_menu c, tb_menu PWHERE c. PARENT = P . IDAND c. ID = 6; ID TITLE PARENT_ID PARENT_TITLE---------- --------------------- ---------- --------------------------- 6 一级菜单6 1 父菜单1查找一个节点所有直属父节点12345678SQL&gt; select * from tb_menu m start with m.id=38 connect by prior m.parent=m.id; ID TITLE PARENT---------- -------------------------------------------------- ---------- 38 三级菜单38 21 21 二级菜单21 6 6 一级菜单6 1 1 父菜单1 0这里查找的就是id为1的所有直属父节点，打个比方就是找到一个人的父亲、祖父等。但是值得注意的是这个查询出来的结果的顺序是先列出子类节点再列出父类节点，姑且认为是个倒序吧。上面列出两个树型查询方式，第3条语句和第5条语句，这两条语句之间的区别在于prior关键字的位置不同，所以决定了查询的方式不同。 当parent = prior id时，数据库会根据当前的id迭代出parent与该id相同的记录，所以查询的结果是迭代出了所有的子类记录；而prior parent = id时，数据库会跟据当前的parent来迭代出与当前的parent相同的id的记录，所以查询出来的结果就是所有的父类结果。以下是一系列针对树结构的更深层次的查询，这里的查询不一定是最优的查询方式，或许只是其中的一种实现而已。查询一个节点的兄弟节点12345678910111213141516171819202122--m.parent=m2.parent--&gt;同一个父亲SQL&gt; SELECT * FROM tb_menu MWHERE EXISTS ( SELECT * FROM tb_menu m2 WHERE M . PARENT = m2. PARENT AND m2. ID = 6 ); ID TITLE PARENT---------- -------------------------------------------------- ---------- 8 一级菜单8 1 7 一级菜单7 1 6 一级菜单6 1查询与一个节点同级的节点如果在表中设置了级别的字段，那么在做这类查询时会很轻松，同一级别的就是与那个节点同级的，在这里列出不使用该字段时的实现：12345678910111213141516171819202122232425262728293031323334353637SQL&gt; WITH tmp AS ( SELECT A .*, LEVEL leaf FROM tb_menu A START WITH A . PARENT = 0 CONNECT BY A . PARENT = PRIOR A . ID) SELECT *FROM tmpWHERE leaf = ( SELECT leaf FROM tmp WHERE ID = 50 ); ID TITLE PARENT LEAF---------- ----------------------------------------- ---------- ---------- 38 三级菜单38 21 4 39 三级菜单39 22 4 40 三级菜单40 23 4 41 三级菜单41 24 4 42 三级菜单42 25 4 43 三级菜单43 26 4 44 三级菜单44 27 4 45 三级菜单45 28 4 46 三级菜单46 28 4 47 三级菜单47 29 4 48 三级菜单48 30 4 49 三级菜单49 31 4 50 三级菜单50 31 4 已选择13行。这里使用两个技巧，一个是使用了level来标识每个节点在表中的级别，还有就是使用with语法模拟出了一张带有级别的临时表。查询一个节点父节点的兄弟节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455SQL&gt; WITH tmp AS ( SELECT tb_menu.*, LEVEL lev FROM tb_menu START WITH PARENT = 0 CONNECT BY PARENT = PRIOR ID) SELECT b.*FROM tmp b, ( SELECT * FROM tmp WHERE ID = 21 AND lev = 2 ) AWHERE b.lev = 1UNION ALL SELECT * FROM tmp WHERE PARENT = ( SELECT DISTINCT x. ID FROM tmp x, --祖父 tmp y, --父亲 ( SELECT * FROM tmp WHERE ID = 21 AND lev &gt; 2 ) z --儿子 WHERE y. ID = z. PARENT AND x. ID = y. PARENT ); ID TITLE PARENT LEV---------- ---------------------------------------- ---------- ---------- 6 一级菜单6 1 2 7 一级菜单7 1 2 8 一级菜单8 1 2这里查询分成以下几步。首先，将第7个一样，将全表都使用临时表加上级别；其次，根据级别来判断有几种类型，以上文中举的例子来说，有三种情况：（1）当前节点为顶级节点，即查询出来的lev值为1，那么它没有上级节点，不予考虑。（2）当前节点为2级节点，查询出来的lev值为2，那么就只要保证lev级别为1的就是其上级节点的兄弟节点。（3）其它情况就是3以及以上级别，那么就要选查询出来其上级的上级节点（祖父），再来判断祖父的下级节点都是属于该节点的上级节点的兄弟节点。最后，就是使用union将查询出来的结果进行结合起来，形成结果集。查询一个节点父节点的同级节点这个其实跟第7种情况是相同的。1234567891011121314151617181920SQL&gt; WITH tmp AS ( SELECT A .*, LEVEL leaf FROM tb_menu A START WITH A . PARENT = 0 CONNECT BY A . PARENT = PRIOR A . ID) SELECT *FROM tmpWHERE leaf = (SELECT leaf FROM tmp WHERE ID = 6) - 1; ID TITLE PARENT LEAF---------- ------------------------------------------- ---------- ---------- 1 父菜单1 0 1 2 父菜单2 0 1 3 父菜单3 0 1 4 父菜单4 0 1 5 父菜单5 0 1基本上，常见的查询在里面了，不常见的也有部分了。其中，查询的内容都是节点的基本信息，都是数据表中的基本字段，但是在树查询中还有些特殊需求，是对查询数据进行了处理的，常见的包括列出树路径等。补充一个概念，对于数据库来说，根节点并不一定是在数据库中设计的顶级节点，对于数据库来说，根节点就是start with开始的地方。下面列出的是一些与树相关的特殊需求。名称要列出名称全部路径这里常见的有两种情况，一种是从顶级列出，直到当前节点的名称（或者其它属性）；一种是从当前节点列出，直到顶级节点的名称（或其它属性）。举地址为例：国内的习惯是从省开始、到市、到县、到居委会的，而国外的习惯正好相反。 从顶部开始：1234567891011SQL&gt; SELECT SYS_CONNECT_BY_PATH (title, '/')FROM tb_menuWHERE ID = 50 START WITH PARENT = 0 CONNECT BY PARENT = PRIOR ID; SYS_CONNECT_BY_PATH(TITLE,'/')----------------------------------------------------/父菜单3/一级菜单14/二级菜单31/三级菜单50从当前节点开始：123456789101112SQL&gt; SELECT SYS_CONNECT_BY_PATH (title, '/')FROM tb_menu START WITH ID = 50 CONNECT BY PRIOR PARENT = ID; SYS_CONNECT_BY_PATH(TITLE,'/')------------------------------------------------------ /三级菜单50/三级菜单50/二级菜单31/三级菜单50/二级菜单31/一级菜单14/三级菜单50/二级菜单31/一级菜单14/父菜单3在这里我又不得不放个牢骚了。oracle只提供了一个sys_connect_by_path函数，却忘了字符串的连接的顺序。在上面的例子中，第一个sql是从根节点开始遍历，而第二个sql是直接找到当前节点，从效率上来说已经是千差万别，更关键的是第一个sql只能选择一个节点，而第二个sql却是遍历出了一颗树来。再次ps一下。sys_connect_by_path函数就是从start with开始的地方开始遍历，并记下其遍历到的节点，start with开始的地方被视为根节点，将遍历到的路径根据函数中的分隔符，组成一个新的字符串，这个功能还是很强大的。列出当前节点的根节点。在前面说过，根节点就是start with开始的地方。12345678910111213SQL&gt; SELECT CONNECT_BY_ROOT title, tb_menu.*FROM tb_menu START WITH ID = 50 CONNECT BY PRIOR PARENT = ID; CONNECT_BY_ROOTTITLE ID TITLE PARENT----------------------------------------------------------------三级菜单50 50 三级菜单50 31三级菜单50 31 二级菜单31 14三级菜单50 14 一级菜单14 3三级菜单50 3 父菜单3 0connect_by_root函数用来列的前面，记录的是当前节点的根节点的内容。列出当前节点是否为叶子这个比较常见，尤其在动态目录中，在查出的内容是否还有下级节点时，这个函数是很适用的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960SELECT CONNECT_BY_ISLEAF, tb_menu.*FROM tb_menu START WITH PARENT = 0 CONNECT BY PARENT = PRIOR ID; CONNECT_BY_ISLEAF ID TITLE PARENT----------------- ---------- --------------------------------------- ---------- 0 1 父菜单1 0 0 6 一级菜单6 1 0 21 二级菜单21 6 1 38 三级菜单38 21 0 22 二级菜单22 6 1 39 三级菜单39 22 0 7 一级菜单7 1 0 23 二级菜单23 7 1 40 三级菜单40 23 0 24 二级菜单24 7 1 41 三级菜单41 24 0 8 一级菜单8 1 0 25 二级菜单25 8 1 42 三级菜单42 25 0 2 父菜单2 0 0 9 一级菜单9 2 0 26 二级菜单26 9 1 43 三级菜单43 6 0 10 一级菜单10 2 0 27 二级菜单27 10 1 44 三级菜单44 27 0 11 一级菜单11 2 0 28 二级菜单28 11 1 45 三级菜单45 28 1 46 三级菜单46 28 0 3 父菜单3 0 0 12 一级菜单12 3 0 29 二级菜单29 12 1 47 三级菜单47 29 0 13 一级菜单13 3 0 30 二级菜单30 13 1 48 三级菜单48 30 0 14 一级菜单14 3 0 31 二级菜单31 14 1 49 三级菜单49 31 1 50 三级菜单50 31 0 4 父菜单4 0 0 15 一级菜单15 4 1 32 二级菜单32 15 0 16 一级菜单16 4 1 33 二级菜单33 16 0 17 一级菜单17 4 1 34 二级菜单34 17 0 5 父菜单5 0 0 18 一级菜单18 5 1 35 二级菜单35 18 0 19 一级菜单19 5 1 36 二级菜单36 19 0 20 一级菜单20 5 1 37 二级菜单37 20 已选择50行。]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle 11g</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JFinal快速搭建 Java web项目]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8JFinal%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-Java-web%E9%A1%B9%E7%9B%AE.html</url>
    <content type="text"><![CDATA[JFinal是一个基于Java的极速Web开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展、Restful，在拥有Java语言所有优势的同时再拥有Ruby、Python等动态语言的开发效率。1.在eclipse中新建Jfinal项目 导入jfinal-1.8-bin.jar 和 jfinal-2.2-bin-with-src.jar；2.新建JfinalConfig类，用来配置Jfinal：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class JfinalConfig extends JFinalConfig&#123; /* * 配置常量值 */ @Override public void configConstant(Constants arg0) &#123; //设置开发模式为true arg0.setDevMode(true); //设置编码格式 arg0.setEncoding("utf-8"); //设置视图类型 arg0.setViewType(ViewType.JSP); &#125; /* * 配置处理器 */ @Override public void configHandler(Handlers arg0) &#123; //配置项目contextPath,以便在jsp页面直接获取项目访问路径 arg0.add(new ContextPathHandler("basepath")); &#125; /* * 配置拦截器，项目里需要拦截器的话在这里配置 */ @Override public void configInterceptor(Interceptors arg0) &#123; // TODO Auto-generated method stub &#125; /* * 配置插件，通常用来配置对数据库的支持 */ @Override public void configPlugin(Plugins arg0) &#123; // TODO Auto-generated method stub &#125; /* * 配置路由，类似于struts的action */ @Override public void configRoute(Routes arg0) &#123; //访问路径为项目根路径时，调用JfinalController arg0.add("/", JfinalController.class); &#125; &#125;3.在web.xml中配置JfinalConfig，以此在启动Tomcat的时候初始化JfinalConfig这个入口：12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-ap.xsd" version="2.5"&gt; &lt;filter&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;filter-class&gt;com.jfinal.core.JFinalFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;configClass&lt;/param-name&gt; &lt;param-value&gt;com.vis.config.JfinalConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;jfinal&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;4.创建登陆页面 login.jsp 和主页 index.jsp：login.jsp：1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;login page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 跳转到JfinalController login方法 --&gt; &lt;form action="$&#123;basepath &#125;/login" id="body"&gt; &lt;p&gt;input userName:&lt;/p&gt; &lt;input type="text" name="userName" id="userName"/&gt; &lt;input type="submit" value="login"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;index.jsp：12345678910111213 &lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;my index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 获取userName --&gt; &lt;h3&gt;welcome back,$&#123;userName &#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;5.创建JfinalController，用来响应jsp页面的请求：12345678910111213public class JfinalController extends Controller&#123; //设置默认访问页面 public void index()&#123; this.render("login.jsp"); &#125; //访问路径为 basepath/login时调用此方法 public void login()&#123; String userName=this.getPara("userName"); this.setAttr("userName", userName); //取到userName后跳转到index.jsp this.render("index.jsp"); &#125;&#125;至此，一个简单的Java web项目搭建完了，将项目部署到Tomcat中，并启动，在浏览器中输入访问路径：localhost:8080/Jfinal/：]]></content>
      <tags>
        <tag>JFinal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom编辑器添加酷炫动画]]></title>
    <url>%2FAtom%E7%BC%96%E8%BE%91%E5%99%A8%E6%B7%BB%E5%8A%A0%E9%85%B7%E7%82%AB%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[由于没有安装完整依赖库或者那堵伟大的墙的原因，使得原本只是安装一个Package的操作变得不那么简单。这里介绍一种100%安装成功的方法：1.首先安装node.js：https://nodejs.org/en/。2.然后下载 activate-power-mode-master 并解压到 C:\Users\Administrator\.atom\packages目录下。3.使用CMD命令切换到activate-power-mode-master文件夹下，执行npm命令：123C:\Users\Administrator\.atom\packages\activate-power-mode-master&gt;npm install lodashC:\Users\Administrator\.atom\packages\activate-power-mode-master&gt;npm install lodash.randomC:\Users\Administrator\.atom\packages\activate-power-mode-master&gt;npm install lodash.throttle执行命令之后，打开Atom编辑器，Ctrl+Alt+O开启就可以看到酷炫的动画啦。如果想关闭震动效果的话，修改activate-power-mode-master/lib/activate-power-mode.coffee文件68行为：1if @getConfig "screenShake.disabled"附上一张效果图：]]></content>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Ajax向服务端传送form表单数据]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Ajax%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%A0%E9%80%81form%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[今天在做附件Demo的时候，发现form表单的submit按钮会自动刷新页面，但在很多情况下，页面的刷新会很大程度影响体验。于是想到用Ajax来代替submit向服务端发送数据，网络上的说法是通过JQuery的serialize()方法序列化表单，但实验之后发现该方法只能传递一般的参数，上传的文件并不能被序列化传递到服务端。继续查找资料发现可以使用formData方法来使用Ajax请求向服务端上传form表单附件：HTML代码：1234567891011121314151617181920212223&lt;form action="http://localhost:8080/file/servlet/UploadHandleServlet" enctype="multipart/form-data" method="post" id="form"&gt; &lt;table border="1" &gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type="text" name=userName/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;附件:&lt;/td&gt; &lt;td id="file"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt; &lt;input type="button" value="增加附件" onclick="AddMore()"&gt; &lt;input type="button" value="提交" id="submit"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;附件下载:&lt;/td&gt; &lt;td id="fileLoad"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;JS代码：123456789101112131415$("#submit").click(function()&#123; var formData = new FormData($("#form")[0]); $.ajax(&#123; url:"http://localhost:8080/file/servlet/UploadHandleServlet", type:"post", data:formData, async: false, cache: false, contentType: false, processData: false, success:function()&#123; // something to do... &#125; &#125;); &#125;);]]></content>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发基础]]></title>
    <url>%2FJava-Concurrent-Basis.html</url>
    <content type="text"><![CDATA[Thread 类的每一个实例都表示一个线程， 进程是操作系统级别的多任务，JVM 就是运行在一个进程中的。所以在Java 中我我们只考虑线程。进程有独立的内存，一个进程间的多个线程共享进程的内存进程中至少要有一个线程。线程状态New：当我们创建一个线程时，该线程并没有纳入线程调度，其处于一个new状态。Runnable：当调用线程的start方法后，该线程纳入线程调度的控制，其处于一个可运行状态，等待分配时间片段以并发运行。Running：当该线程被分配到了时间片段后其被CPU运行，这是该线程处于running状态。Blocked：当线程在运行过程中可能会出现阻塞现象，比如等待用户输入信息等。但阻塞状态不是百分百出现的，具体要看代码中是否有相关需求。Dead：当线程的任务全部运行完毕，或在运行过程中抛出了一个未捕获的异常，那么线程结束，等待GC回收创建线程线程有两种创建方式：方式1：定义一个类并继承Thread，然后重写run方法，在其中书写线程任务逻辑：12345678910111213141516171819Thread t1 = new MyThread1();Thread t2 = new MyThread2();t1.start();t2.start();class MyThread1 extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("are you ok?"); &#125; &#125;&#125;class MyThread2 extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("of course"); &#125; &#125;&#125;输出：123456789of courseof courseof courseof courseof courseare you ok?are you ok?are you ok?are you ok?启动线程要调用start方法，不能直接调用run方法。start方法会将当前线程纳入到线程调度中，使其具有并发运行的能力。start方法很快会执行完毕。当start方法执行完毕后，当前线程的run方法会很快的被执行起来（只要获取到了cpu时间片）。但不能理解为调用start方法时run方法就执行了！线程有几个不可控因素:cpu分配时间片给哪个线程我们说了不算。时间片长短也不可控。线程调度会尽可能均匀的将时间片分配给多个线程。第一种创建线程的方式存在两个不足：由于java是单继承的，这就导致我们若继承了Thread类就无法再继承其他类，这在写项目时会遇到很大问题；由于我们定义线程的同时重写run方法来定义线程要执行的任务，这就导致线程与任务有一个强耦合关系，线程的重用性变得非常局限。方式2：定义一个类并实现Runnable接口然后在创建线程的同时将任务指定。因为是实现Runnable接口，所以不影响其继承其他类：12345678910111213Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("are you ok?"); &#125;&#125;);t1.start();Thread t2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println("of course"); &#125;&#125;);t2.start();线程相关API获取当前线程：1Thread current = Thread.currentThread(); // Thread[main,5,main]获取当前线程ID：12Thread current = Thread.currentThread();System.out.println(current.getId()); // 1获取当前线程名字：12Thread current = Thread.currentThread();System.out.println(current.getName()); // main获取当前线程优先级：12Thread current = Thread.currentThread();System.out.println(current.getPriority()); // 5判断当前线程是否还活着：12Thread current = Thread.currentThread();System.out.println(current.isAlive()); // true判断当前线程是否为守护线程：12Thread current = Thread.currentThread();System.out.println(current.isDaemon()); // false判断当前线程是否被中断：12Thread current = Thread.currentThread();System.out.println(current.isInterrupted()); // false线程的优先级线程优先级分为10个等级，1最低，5默认，10最高。线程提供了3个常量：MIN_PRIORITY：1 对应最低优先级；MAX_PRIORITY： 10 对应最高优先级；NORM_PRIORITY：5 默认优先级。线程阻塞Thread提供了一个静态方法: sleep，该方法会阻塞运行当前方法的线程指定毫秒。当超时后，线程会自动回到Runnable状态，等待再次分配时间片运行：1234567System.out.println("程序开始了");try &#123; Thread.sleep(5000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;System.out.println("程序结束了");守护线程后台线程，又叫做守护线程，当一个进程中的所有前台线程都结束了，进程就会结束，无论进程中的其他后台线程是否还在运行，都要被强制中断：1234567891011121314151617181920212223242526Thread front = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 2; i++) &#123; System.out.println("前端线程运行中"); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("前台线程运行完毕");&#125;);Thread back = new Thread(() -&gt; &#123; while (true) &#123; System.out.println("前台线程结束，我就gg"); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);front.start();back.setDaemon(true);back.start();输出如下：123456前台线程结束，我就gg前端线程运行中前台线程结束，我就gg前端线程运行中前台线程结束，我就gg前台线程运行完毕yield该方法用于使当前线程主动让出当次CPU时间片回到Runnable状态，等待分配时间片。join允许当前线程在另一个线程上等待，直到另一个线程结束工作。通常是用来协调两个线程工作使用：1234567891011121314151617181920212223242526272829303132private static boolean isFinish = false;public static void main(String[] args) &#123; Thread download = new Thread(() -&gt; &#123; System.out.println("开始下载图片..."); for (int i = 1; i &lt;= 100; i++) &#123; System.out.println("down:" + i + "%"); try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("图片下载完毕!"); isFinish = true; &#125;); Thread show = new Thread(() -&gt; &#123; System.out.println("开始显示图片..."); try &#123; download.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (!isFinish) &#123; throw new RuntimeException("图片加载失败!"); &#125; System.out.println("图片显示完毕!"); &#125;); download.start(); show.start();&#125;synchroinzed多个线程并发读写同一个临界资源时候会发生“线程并发安全问题”常见的临界资源:多线程共享实例变量；多线程共享静态公共变量。若想解决线程安全问题，需要将异步的操作变为同步操作。 何为同步？那么我们来对比看一下什么是同步什么异步：所谓异步操作是指多线程并发的操作，相当于各干各的。所谓同步操作是指有先后顺序的操作，相当于你干完我再干。而java中有一个关键字名为：synchronized，该关键字是同步锁，用于将某段代码变为同步操作，从而解决线程并发安全问题。使用锁需要注意两个方面：选择合适的锁对象：使用synchroinzed需要对一个锁对象上锁以保证线程同步。那么这个锁对象应当注意多个需要同步的线程在访问该同步块时，看到的应该是同一个锁对象引用。否则达不到同步效果。 通常我们会使用this来作为锁对象。选择合适的锁范围：在使用同步块时，应当尽量在允许的情况下减少同步范围，以提高并发的执行效率。synchronized关键字有两个用法:修饰方法，这样的话，该方法就称为”同步方法”，多个线程就不能同时进入到方法内部去执行。可以避免由于线程切换不确定，导致的逻辑错误。synchronized块，可以将某段代码片段括起来，多个线程不能同时执行里面的代码。12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; final Table table = new Table(); Thread t0 = new Thread() &#123; public void run() &#123; while (true) &#123; int bean = table.getBean(); Thread.yield(); System.out.println(getName() + ":" + bean); &#125; &#125; &#125;; Thread t1 = new Thread() &#123; public void run() &#123; while (true) &#123; int bean = table.getBean(); Thread.yield(); System.out.println(getName() + ":" + bean); &#125; &#125; &#125;; t0.start(); t1.start();&#125;static class Table &#123; private int beans = 20; synchronized int getBean() &#123; if (beans == 0) &#123; throw new RuntimeException("没有豆子了!"); &#125; Thread.yield(); return beans--; &#125;&#125;如果不加synchronized关键字，可能beans为负数了，线程还在执行，成了死循环。synchronized块的例子：12345678910111213141516171819202122232425public static void main(String[] args) &#123; final Shop shop = new Shop(); Thread t1 = new Thread(shop::buy); Thread t2 = new Thread(shop::buy); t1.start(); t2.start();&#125;static class Shop &#123; void buy() &#123; try &#123; Thread t = Thread.currentThread(); System.out.println(t + "正在挑选衣服."); Thread.sleep(1000); synchronized (this) &#123; System.out.println(t + "正在试衣服."); Thread.sleep(1000); &#125; System.out.println(t + "结账离开."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;此时，“正在试衣服”这个代码块一次只能一个线程执行。wait&amp;notifyObject类中定义了两个方法wait()和notify()。它们也可以实现协调线程之间同步工作的方法。当一个线程调用了某个对象的wait方法时，这个线程就进入阻塞状态，直到这个对象的notify方法被调用，这个线程才会解除wait阻塞，继续向下执行代码。若多个线程在同一个对象上调用wait方法进入阻塞状态后，那么当该对象的notify方法被调用时，会随机解除一个线程的wait阻塞，这个不可控。若希望一次性将所有线程的wait阻塞解除，可以调用notifyAll方法。12345678910111213141516171819202122232425262728293031323334353637383940private static boolean isFinish;private static final Object obj = new Object();public static void main(String[] args) &#123; final Thread download = new Thread(() -&gt; &#123; System.out.println("down:开始下载图片..."); for (int i = 1; i &lt;= 100; i++) &#123; System.out.println("down:" + i + "%"); try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("down:图片下载完毕!"); isFinish = true; //通知 show线程开始工作 synchronized (obj) &#123; obj.notify(); &#125; &#125;); Thread show = new Thread(() -&gt; &#123; System.out.println("show:开始显示图片..."); synchronized (obj) &#123; try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (!isFinish) &#123; throw new RuntimeException("图片加载失败!"); &#125; System.out.println("show:图片显示完毕!"); &#125;); download.start(); show.start();&#125;线程池当我们的逻辑中出现了会频繁创建线程的情况时，就要考虑使用线程池来管理线程。这可以解决创建过多线程导致的系统威胁。线程池主要解决两个问题：控制线程数量；重用线程。12345678910111213141516171819//创建一个固定大小的线程池ExecutorService threadPool = Executors.newFixedThreadPool(3);//指派 5个任务for (int i = 0; i &lt; 5; i++) &#123; Runnable runn = () -&gt; &#123; Thread t = Thread.currentThread(); System.out.println(t + "正在运行任务!"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(t + "执行任务完毕"); &#125;; threadPool.execute(runn);&#125;//停止线程池threadPool.shutdown();12345678910Thread[pool-1-thread-2,5,main]正在运行任务!Thread[pool-1-thread-1,5,main]正在运行任务!Thread[pool-1-thread-3,5,main]正在运行任务!Thread[pool-1-thread-2,5,main]执行任务完毕Thread[pool-1-thread-3,5,main]执行任务完毕Thread[pool-1-thread-2,5,main]正在运行任务!Thread[pool-1-thread-1,5,main]执行任务完毕Thread[pool-1-thread-3,5,main]正在运行任务!Thread[pool-1-thread-3,5,main]执行任务完毕Thread[pool-1-thread-2,5,main]执行任务完毕此时同时只能有三个线程数量。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 经典试题集]]></title>
    <url>%2FOracle-%E7%BB%8F%E5%85%B8%E8%AF%95%E9%A2%98%E9%9B%86.html</url>
    <content type="text"><![CDATA[一份很好的Oracle SQL试题集🙌。准备工作：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465create table student( sno varchar2(10) primary key, sname varchar2(20), sage number(2), ssex varchar2(5));create table teacher( tno varchar2(10) primary key, tname varchar2(20));create table course( cno varchar2(10), cname varchar2(20), tno varchar2(20), constraint pk_course primary key (cno,tno));create table sc( sno varchar2(10), cno varchar2(10), score number(4,2), constraint pk_sc primary key (sno,cno));/*******初始化学生表的数据******/insert into student values ('s001','张三',23,'男');insert into student values ('s002','李四',23,'男');insert into student values ('s003','吴鹏',25,'男');insert into student values ('s004','琴沁',20,'女');insert into student values ('s005','王丽',20,'女');insert into student values ('s006','李波',21,'男');insert into student values ('s007','刘玉',21,'男');insert into student values ('s008','萧蓉',21,'女');insert into student values ('s009','陈萧晓',23,'女');insert into student values ('s010','陈美',22,'女');commit;/******************初始化教师表***********************/insert into teacher values ('t001', '刘阳');insert into teacher values ('t002', '谌燕');insert into teacher values ('t003', '胡明星');commit;/***************初始化课程表****************************/insert into course values ('c001','J2SE','t002');insert into course values ('c002','Java Web','t002');insert into course values ('c003','SSH','t001');insert into course values ('c004','Oracle','t001');insert into course values ('c005','SQL SERVER 2005','t003');insert into course values ('c006','C#','t003');insert into course values ('c007','JavaScript','t002');insert into course values ('c008','DIV+CSS','t001');insert into course values ('c009','PHP','t003');insert into course values ('c010','EJB3.0','t002');commit;/***************初始化成绩表***********************/insert into sc values ('s001','c001',78.9);insert into sc values ('s002','c001',80.9);insert into sc values ('s003','c001',81.9);insert into sc values ('s004','c001',60.9);insert into sc values ('s001','c002',82.9);insert into sc values ('s002','c002',72.9);insert into sc values ('s003','c002',81.9);insert into sc values ('s001','c003','59');commit;1、查询“c001”课程比“c002”课程成绩高的所有学生的成绩信息；12345678SQL&gt; select a.* from 2 (select * from sc a where a.cno = 'c001') a, 3 (select * from sc b where b.cno = 'c002') b 4 where a.sno=b.sno and a.score &gt; b.score;SNO CNO SCORE---------- ---------- ----------s002 c001 80.9或者：1234567SQL&gt; select * from sc a 2 where a.cno = 'c001' 3 and exists (select * from sc b where b.cno='c002' and a.score &gt; b.score and a.sno = b.sno);SNO CNO SCORE---------- ---------- ----------s002 c001 80.92、查询平均成绩大于60分的同学的学号和平均成绩；12345678SQL&gt; select sno,avg(score) from sc group by sno having avg(score) &gt; 60;SNO AVG(SCORE)---------- ----------s003 81.9s004 60.9s001 73.6s002 76.93、查询所有同学的学号、姓名、选课数、总成绩；1234567891011121314151617SQL&gt; SELECT a.sno, a.sNAME,sum(score),count(b.cno) 2 FROM student a, sc b 3 WHERE a.sno = b.sno(+) 4 group by a.sno,sname;SNO SNAME SUM(SCORE) COUNT(B.CNO)---------- -------------------- ---------- ------------s009 陈萧晓 0s005 王丽 0s001 张三 220.8 3s008 萧蓉 0s003 吴鹏 163.8 2s004 琴沁 60.9 1s007 刘玉 0s006 李波 0s010 陈美 0s002 李四 153.8 24、查询姓“刘”的老师的个数：12345SQL&gt; select count(1) from TEACHER where TNAME LIKE '刘%'; COUNT(1)---------- 1]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle basis]]></title>
    <url>%2FOracle-basis.html</url>
    <content type="text"><![CDATA[Oracle数据类型NUMBERNUMBER表示数字类型，经常被定义成NUMBER（P，S）形式，其中：P表示数字的总位数；S表示小数点后面的位数。如：Sal NUMBER(6,2)：表示Sal列中的数据，整数位最大为4位，小数位最大位数是2位，也就是最大取值：9999.99。P不写为*号的时候代表默认38。CHARCHAR表示固定长度的字符类型，经常被定义成CHAR（N）形式， N表示占用的字节数，N的最大取值是2000。例如在表Emp中的Ename列的定义如下：Ename CHAR(20)：表示Ename列中最多可存储20个字节的字符串，并且占用的空间是固定的20个字节。VARCHAR2VARCHAR2表示变长的字符类型，定义格式是VARCHAR2（N）， N表示最多可占用的字节数，最大长度是4000字节。例如在表Emp中的JOB列的定义如下： JOB VARCHAR2(100)：表示JOB列中最多可存储长度为100个字节的字符串。根据其中保存的数据长度，占用的空间是变化的，最大占用空间为100个字节。CHAR和VARCHAR2的区别CHAR和VARCHAR2类型CHAR和VARCHAR2类型都是用来表示字符串数据类型，用来在表中存放字符串信息， 比如姓名、职业、地址等。CHAR存放定长字符，如果数据存不满定长长度，则补齐空格；VARCHAR2存放变长字符，实际数据有多少长度则占用多少。如保存字符串’HELLOWORLD’，共10个英文字母：CHAR(100)： 10个字母，补齐90个空格，实际占用100个字节。VARCHAR2(100) ：10个字母，实际占用10个字节。CHAR类型浪费空间换取查询时间的缩短，VARCHAR2节省空间查询时间较CHAR类型要长。字符串按照自然顺序排序。CHAR和VARCHAR2的存储编码字符串在数据库中存储的默认单位是字节，也可显式指定为字符。如：CHAR(10)，等价于 CHAR(10 BYTE)。如果指定单位为字符：CHAR(10 CHAR)，20个字节。VARCHAR2(10)， 等价于VARCHAR2（10 BYTE）。指定单位为字符：VARCHAR2(10 CHAR)，20个字节。CHAR和VARCHAR2的最大长度CHAR类型的最大取值为2000字节，也就是定义为CHAR（2000）。其中最多保存2000个英文字符，1000个汉字（GBK）。VARCHAR2最大取值为4000字节，也就是VARCHAR2（4000），最多保存4000个英文字符，2000个汉字（GBK）。CHAR如果不指定长度，默认为1个字节， VARCHAR2必须指定长度。DATEDATE用于定义日期时间的数据，长度是7个字节，默认格式是：DD-MON-RR， 例如：“11-APR-71”。如果是中文环境，是“11-4月-71”这种形式。例如在表Emp中的Hiredate列的定义如下：Hiredate DATE：表示Hiredate列中存放的是日期数据。LONG和CLOB类型LONG类型可以认为是VARCHAR2的加长版，用来存储变长字符串，最多达2GB的字符串数据，但是LONG类型有诸多限制，所以不建议使用：每个表只能有一个LONG类型列；不能作为主键；不能建立索引；不能出现在查询条件中等CLOB用来存储定长或变长字符串，最多达4GB的字符串数据，ORACLE建议开发中使用CLOB替代LONG类型。SQL分类SQL（Structured Query Language）是结构化查询语言的缩写。可分为：数据定义语言（DDL Data Definition Language）：用于建立，修改和删除数据库对象。包含：CREATE：创建表或其他对象的结构。ALTER: 修改表或其他对象的结构。DROP：删除表或其他对象的结构。TRUNCATE：删除表数据，保留表结构。CREATE语句创建表格：12345678910111213141516171819202122SQL&gt; create table employee ( 2 id NUMBER(10) not null, 3 name VARCHAR2(20), 4 gender CHAR(1), 5 birth DATE, 6 salary NUMBER(6,2), 7 job VARCHAR2(30), 8 deptno NUMBER(2) 9 );表已创建。SQL&gt; desc employee; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- ID NOT NULL NUMBER(10) NAME VARCHAR2(20) GENDER CHAR(1) BIRTH DATE SALARY NUMBER(6,2) JOB VARCHAR2(30) DEPTNO NUMBER(2)修改表名：123SQL&gt; RENAME employee TO employee1;表已重命名。增加列：在建表之后，要给表增加列可以使用ALTER TABLE的ADD子句实现。如在employee1表最后面增加一列：123456789101112131415SQL&gt; ALTER TABLE employee1 ADD(hiredate DATE DEFAULT SYSDATE);表已更改。SQL&gt; desc employee1 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- ID NOT NULL NUMBER(10) NAME VARCHAR2(20) GENDER CHAR(1) BIRTH DATE SALARY NUMBER(6,2) JOB VARCHAR2(30) DEPTNO NUMBER(2) HIREDATE DATE删除列：删除employee1表中的hiredate列：123SQL&gt; ALTER TABLE employee1 DROP(hiredate);表已更改。删除所有表数据，保留结构：123SQL&gt; truncate TABLE employee1;表被截断。TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同：二者均删除表中的全部行。但TRUNCATE TABLE比DELETE速度快，且使用的系统和事务日志资源少。DELETE语句每次删除一行，并在事务日志中为所删除的每行记录一项。修改列：建表之后，可以改变表中列的数据类型、长度和默认值，注意这种修改仅对以后插入的数据有效，另外如果表中已经有数据的情况下，把长度由大改小，有可能不成功，比如原来的类型是VARCHAR2(100)，其中已经存放了100个字节长度的数据，如果要改为VARCHAR2(80)，则不会修改成功。修改表employee1的列job，并增加默认值的设置：123SQL&gt; ALTER TABLE employee1 MODIFY(job VARCHAR2(40) DEFAULT 'manager');表已更改。删除表：1234567SQL&gt; drop table employee1;表已删除。SQL&gt; desc employee1;ERROR:ORA-04043: 对象 employee1 不存在数据操纵语言（DML Data Manipulation Language）：用于改变数据表中的数据，和事务相关，执行完后需要通过事务控制语句提交后才真正的将改变应用到数据库中。包括：INSERT：将数据插入到数据表中。UPDATE：更新数据表中已存在的数据。DELETE：删除数据表中的数据。事务控制语言（TCL Transaction Control Language）：用来维护数据一致性的语句。包括：COMMIT：提交，确认已经进行的数据改变。ROLLBACK：回滚，取消已经进行的数据改变。SAVEPOINT：保存点，使当前的事务可以回退到指定的保存点，便于取消部分改变。数据查询语言（DQL Data Query Language）：用来查询需要的数据。SELECT语句。数据控制语言（DCL Data Control Language）：用于执行权限的授予与回收工作。包括：GRANT：授予，用于给用户或角色授予权限。REVOKE：用于收回用户或角色的权限。CREATE USER：创建用户。SQL基础查询FROM子句SELECT用于指定要查询的列，FROM指定要从哪个表中查询。如果要查询所有列，可以在SELECT后面使用*号，如果只查询特定的列，可以直接在SELECT后面指定列名，列名之间用逗号隔开。列的别名当我们查询的内容不是一个单纯的列，可能是一个函数，或者表达式，那么在结果集中该字段对应的字段名就是这个函数或者表达式。这样不够清晰，为此我们可以单独指定别名，这样在结果集中该字段的名字就是这个别名。若想显示自己想要的内容，使用双引号。其中”AS”可以省略。123456789101112131415SQL&gt; SELECT ename,sal*12 as "年薪",job from emp;ENAME 年薪 JOB---------- ---------- ---------SMITH 9600 CLERKALLEN 19200 SALESMANWARD 15000 SALESMANJONES 35700 MANAGERMARTIN 15000 SALESMANBLAKE 34200 MANAGERCLARK 29400 MANAGERSCOTT 36000 ANALYSTKING 60000 PRESIDENTTURNER 18000 SALESMANADAMS 13200 CLERKAND,OR与和或。AND优先级高于OR，可以用括号提高优先级。123456789101112131415161718SQL&gt; select ename,sal,job from emp where sal &gt; 1000 or job = 'CLERK';ENAME SAL JOB---------- ---------- ---------SMITH 800 CLERKALLEN 1600 SALESMANWARD 1250 SALESMANJONES 2975 MANAGERMARTIN 1250 SALESMANBLAKE 2850 MANAGERCLARK 2450 MANAGERSCOTT 3000 ANALYSTKING 5000 PRESIDENTTURNER 1500 SALESMANADAMS 1100 CLERKJAMES 950 CLERKFORD 3000 ANALYSTMILLER 1300 CLERKLIKE用于模糊查询，支持两个通配符，%：表示0到多个字符，_表示一个字符。1234567SQL&gt; select ename,sal,job from emp where ename like '_L%';ENAME SAL JOB---------- ---------- ---------ALLEN 1600 SALESMANBLAKE 2850 MANAGERCLARK 2450 MANAGERIN,NOT IN在WHERE子句中可以用比较操作符IN(list)来取出符合列表范围中的数据。其中的参数list表示值列表，当列或表达式匹配于列表中的任何一个值时，条件为TRUE，该条记录则被显示出来。IN也可以理解为一个范围比较操作符，只不过这个范围是一个指定的值列表，NOT IN(list)取出不符合此列表中的数据记录。123456789101112SQL&gt; select ename,sal,job from emp where job in('CLERK','SALESMAN');ENAME SAL JOB---------- ---------- ---------SMITH 800 CLERKALLEN 1600 SALESMANWARD 1250 SALESMANMARTIN 1250 SALESMANTURNER 1500 SALESMANADAMS 1100 CLERKJAMES 950 CLERKMILLER 1300 CLERKBETWEEN AND1234567891011SQL&gt; select ename,sal,job from emp where sal between 1500 and 3000;ENAME SAL JOB---------- ---------- ---------ALLEN 1600 SALESMANJONES 2975 MANAGERBLAKE 2850 MANAGERCLARK 2450 MANAGERSCOTT 3000 ANALYSTTURNER 1500 SALESMANFORD 3000 ANALYSTANY,ALL当我们需要判断内容&gt;，&gt;=，&lt;，&lt;=一个列表中的多个值时，需要结合ANY或ALL来使用。ANY(LIST)：大于列表中其中之一即可，即大于最小的；ALL(LIST)：大于列表中所有，即大于最大的。列表中的内容通常不是固定值，而是一个查询结果集，所以常在子查询中，与IN道理一样。如查询谁的薪水比FORD高？如果有多个同名，比任何一个叫FORD的人高就行：12345SQL&gt; select ename from emp where sal &gt; any(select sal from emp where ename = 'FORD');ENAME----------KING查询条件中使用表达式和函数当查询需要对选出的字段进行进一步计算，可以在数字列上使用算术表达式(+、-、*、/)。表达式符合四则运算的默认优先级，如果要改变优先级可以使用括号。算术运算主要是针对数字类型的数据，对日期类型的数据可以做加减操作，表示在一个日期值上加或减一个天数。查询条件中不能使用聚合函数！查询条件中使用算数表达式，查询年薪大于5w元的员工记录：12345SQL&gt; select ename,sal,job from emp where sal*12 &gt; 50000;ENAME SAL JOB---------- ---------- ---------KING 5000 PRESIDENTORDER BY使用ORDER BY字句：用于对结果即按照指定的字段的值升序或者降序进行排序。ASC：升序，默认也是ASC；DESC：降序。查看工资排名：123456789101112131415161718SQL&gt; select ename,sal,job from emp order by sal;ENAME SAL JOB---------- ---------- ---------SMITH 800 CLERKJAMES 950 CLERKADAMS 1100 CLERKWARD 1250 SALESMANMARTIN 1250 SALESMANMILLER 1300 CLERKTURNER 1500 SALESMANALLEN 1600 SALESMANCLARK 2450 MANAGERBLAKE 2850 MANAGERJONES 2975 MANAGERSCOTT 3000 ANALYSTFORD 3000 ANALYSTKING 5000 PRESIDENT若排序的字段中有NULL值，NULL被视为最大值。当多个字段进行排序时， 每个字段可以分别指定升降序，并且排序顺序按照第一个字段优先排序，只有第一个字段值相同时才按照第二个字段排序，以此类推。12345678910111213141516171819SQL&gt; select ename,sal,job,deptno from emp 2 order by deptno desc,sal desc;ENAME SAL JOB DEPTNO---------- ---------- --------- ----------BLAKE 2850 MANAGER 30ALLEN 1600 SALESMAN 30TURNER 1500 SALESMAN 30WARD 1250 SALESMAN 30MARTIN 1250 SALESMAN 30JAMES 950 CLERK 30FORD 3000 ANALYST 20SCOTT 3000 ANALYST 20JONES 2975 MANAGER 20ADAMS 1100 CLERK 20SMITH 800 CLERK 20KING 5000 PRESIDENT 10CLARK 2450 MANAGER 10MILLER 1300 CLERK 10聚合函数（分组函数，组函数）查询时需要做一些数据统计，比如：查询职员表中各部门职员的平均薪水，各部门的员工人数。当需要统计的数据并不能在职员表里直观列出，而是需要根据现有的数据计算得到结果，这种功能可以使用聚合函数来实现，即：将表的全部数据划分为几组数据，每组数据统计出一个结果。因为是多行数据参与运算返回一行结果，也称作分组函数、多行函数、集合函数。用到的关键字：GOURP BY 按什么分组。HAVING 进一步限制分组结果。聚合函数是忽略NULL值的。1、MAX和MIN用来取得列或表达式的最大、最小值，可以用来统计任何数据类型，包括数字、字符和日期。计算最早和最晚的入职时间，参数是日期：12345SQL&gt; select max(hiredate),min(hiredate) from emp;MAX(HIREDATE) MIN(HIREDATE)-------------- --------------23-5月 -87 17-12月-802、AVG和SUMAVG和SUM函数用来统计列或表达式的平均值和和值，这两个函数只能操作数字类型，并忽略NULL值。统计所有员工的总工资和平均工资：12345SQL&gt; select avg(sal) avg_sal,sum(sal) sum_sal from emp; AVG_SAL SUM_SAL---------- ----------2073.21429 290253、COUNTCOUNT函数用来计算表中的记录条数，同样忽略NULL值。例如获取职员表中一共有多少名职员记录：12345SQL&gt; select count(1) from emp; COUNT(1)---------- 14分组1、GROUP BY子句其是为聚合函数服务的，可以在统计数据时细化分组。他允许将某个字段值一样的记录看成一组，然后进行统计。而不是将整张表所有记录看成一组，那么每组可以出一个统计结果。查看每个部门的最高工资，最低工资：12345678SQL&gt; select deptno "部门", max(sal) "最高工资",min(sal) "最低工资" 2 from emp group by deptno; 部门 最高工资 最低工资---------- ---------- ---------- 30 2850 950 20 3000 800 10 5000 1300SQL语法要求：除了聚合函数，其他不在GROUP BY子句中的列名，不能出现在SELECT语句后面。GROUP BY进行分组的字段应在整张表中有重复数据，否则分组毛有意义GROUP BY子句后面允许指定多个字段，那么是按照这些字段值的组合相同的记录看作一组。查看每个部门每种职位的平均工资以及工资总和：1234567891011121314SQL&gt; select deptno,job,avg(sal),sum(sal) 2 from emp group by deptno,job; DEPTNO JOB AVG(SAL) SUM(SAL)---------- --------- ---------- ---------- 20 CLERK 950 1900 30 SALESMAN 1400 5600 20 MANAGER 2975 2975 30 CLERK 950 950 10 PRESIDENT 5000 5000 30 MANAGER 2850 2850 10 CLERK 1300 1300 10 MANAGER 2450 2450 20 ANALYST 3000 60002、HAVING字句HAVING 也是用于添加过滤条件的，它的过滤实际是在统计结果之后进行的，所以HAVING是为统计结果进行过滤使用的，其不能独立出现，必须跟在GROUP BY子句后面。查看平均工资大于2000的部门：1234567SQL&gt; select deptno,avg(sal) from emp 2 group by deptno having avg(sal) &gt; 2000; DEPTNO AVG(SAL)---------- ---------- 20 2175 10 2916.66667HAVING子句解决了WHERE子句后面不能跟聚合函数的问题：123456SQL&gt; select deptno,avg(sal) from emp where avg(sal) &gt; 2000 2 group by deptno;select deptno,avg(sal) from emp where avg(sal) &gt; 2000 *第 1 行出现错误:ORA-00934: 此处不允许使用分组函数该语句会报错，原因在于我们的过滤条件是平均工资高于2000，而WHERE的过滤时机在于：第一次从表中查询数据时进行过滤，只有满足WHERE条件的记录才会被查询出来。而判断平均工资高于2000，首先平均工资统计是建立在数据查询出来的基础上的，所以这时WHERE已经完成了过滤。改使用HVING 子句就可解决。查询语句的执行顺序当一条查询语句中包含所有的子句，执行顺序依下列子句次序：FROM 子句：执行顺序为从后往前、从右到左。数据量较少的表尽量放在后面。WHERE子句：执行顺序为自下而上、从右到左。将能过滤掉最大数量记录的条件写在WHERE 子句的最右。GROUP BY：执行顺序从左往右分组，最好在GROUP BY前使用WHERE将不需要的记录在GROUP BY之前过滤掉。HAVING 子句：消耗资源。尽量避免使用，HAVING 会在检索出所有记录之后才对结果集进行过滤，需要排序等操作。SELECT子句：少用*号，尽量取字段名称。ORACLE 在解析的过程中，通过查询数据字典将*号依次转换成所有的列名，消耗时间。ORDER BY子句：执行顺序为从左到右排序，消耗资源。SQL关联查询关联查询当从多张表查询数据时，我们会建立关联关系然后在张表中进行查询工作，重点就是如何指定这些表中数据的对应关系(关联关系)，N张表查询时至少要有N-1个连接条件。查询每个员工的名字，工资，以及部门名称和所在地：1234567891011121314151617181920SQL&gt; select e.ename,e.deptno,d.dname,d.loc 2 from emp e join dept d 3 on(d.deptno = e.deptno);ENAME DEPTNO DNAME LOC---------- ---------- -------------- -------------CLARK 10 ACCOUNTING NEW YORKKING 10 ACCOUNTING NEW YORKMILLER 10 ACCOUNTING NEW YORKJONES 20 RESEARCH DALLASFORD 20 RESEARCH DALLASADAMS 20 RESEARCH DALLASSMITH 20 RESEARCH DALLASSCOTT 20 RESEARCH DALLASWARD 30 SALES CHICAGOTURNER 30 SALES CHICAGOALLEN 30 SALES CHICAGOJAMES 30 SALES CHICAGOBLAKE 30 SALES CHICAGOMARTIN 30 SALES CHICAGO或者：123SQL&gt; select e.ename,e.deptno,d.dname,d.loc 2 from emp e,dept d 3 where e.deptno = d.deptno;内连接内连接只返回两个关联表中所有满足连接条件的记录。外连接内连接返回两个表中所有满足连接条件的数据记录，在有些情况下，需要返回那些不满足连接条件的记录，需要使用外连接，即不仅返回满足连接条件的记录，还将返回不满足连接条件的记录。将员工SOCTT的部门号改为50：12SQL&gt; update emp set deptno = 50 2 where ename = 'SCOTT';执行下面语句：123456789101112131415161718192021SQL&gt; select e.ename,d.dname 2 from emp e join dept d 3 on(e.deptno = d.deptno);ENAME DNAME---------- --------------CLARK ACCOUNTINGKING ACCOUNTINGMILLER ACCOUNTINGJONES RESEARCHFORD RESEARCHADAMS RESEARCHSMITH RESEARCHWARD SALESTURNER SALESALLEN SALESJAMES SALESBLAKE SALESMARTIN SALES已选择13行。会发现SCOTT员工没有被查询出来，原因是其不满足连接条件。外连接允许我们在关联查询的时候，以一张表作为驱动表(数据要显示全)。该表的数据全部会体现再结果集中，但是来自关联表中的字段由于不满足连接条件没有对应的记录，所以全部取NULL。外连接主要解决的问题就是显示再关联查询中不满足连接条件的记录。外连接分为：左外连接，右外连接，全外连接。使用左外连接查询员工信息：12345678910111213141516171819202122SQL&gt; select e.ename,d.dname 2 from emp e left outer join dept d 3 on(e.deptno = d.deptno);ENAME DNAME---------- --------------MILLER ACCOUNTINGKING ACCOUNTINGCLARK ACCOUNTINGFORD RESEARCHADAMS RESEARCHJONES RESEARCHSMITH RESEARCHJAMES SALESTURNER SALESBLAKE SALESMARTIN SALESWARD SALESALLEN SALESSCOTT已选择14行。可以看出，虽然SCOTT不满足连接条件，但也出现在查询结果中了。自连接当前表的一条记录对应当前表的多条记录，自连接的设计是为了解决同类型数据间又存在上下级关系的树状结构的保存与关联。查看员工的名字以及他领导的名字：12345678910111213141516171819SQL&gt; select e.ename "员工",m.ename "领导" 2 from emp e,emp m 3 where e.mgr = m.empno;员工 领导---------- ----------FORD JONESSCOTT JONESTURNER BLAKEALLEN BLAKEWARD BLAKEJAMES BLAKEMARTIN BLAKEMILLER CLARKADAMS SCOTTBLAKE KINGJONES KINGCLARK KINGSMITH FORD若想将没有领导的人也列出来，可以将代码改为：12345678910111213141516171819202122SQL&gt; select e.ename "员工",m.ename "领导" 2 from emp e,emp m 3 where e.mgr = m.empno(+);员工 领导---------- ----------FORD JONESSCOTT JONESJAMES BLAKETURNER BLAKEMARTIN BLAKEWARD BLAKEALLEN BLAKEMILLER CLARKADAMS SCOTTCLARK KINGBLAKE KINGJONES KINGSMITH FORDKING已选择14行。等同于：12345678910111213141516171819202122SQL&gt; select e.ename "员工",m.ename "领导" 2 from emp e left join emp m 3 on(e.mgr = m.empno);员工 领导---------- ----------FORD JONESSCOTT JONESJAMES BLAKETURNER BLAKEMARTIN BLAKEWARD BLAKEALLEN BLAKEMILLER CLARKADAMS SCOTTCLARK KINGBLAKE KINGJONES KINGSMITH FORDKING已选择14行。子查询子查询通常是将其查询出来的结果集提供给其他SQL语句使用，通常嵌套在实际要运行的SQL语句之中。1、子查询在WHERE子句中。在WHERE查询条件中的限制条件不是一个确定的值，而是来自于另外一个查询的结果。比如查看工资比CLARK高的员工信息：1234567891011SQL&gt; select ename,job,sal from emp 2 where sal &gt; (select sal from emp 3 where ename = 'CLARK');ENAME JOB SAL---------- --------- ----------JONES MANAGER 2975BLAKE MANAGER 2850SCOTT ANALYST 3000KING PRESIDENT 5000FORD ANALYST 3000根据返回结果的不同，子查询可分为单行单列子查询、多行单列子查询及多行多列子查询。如果子查询返回多行，主查询中要使用多行比较操作符，包括IN、ALL、ANY。其中ALL和ANY不能单独使用，需要配合单行比较操作符&gt;、&gt;=、&lt;、&lt;= 一起使用。例如查询出部门中有SALESMAN但职位不是SALESMAN的员工的信息：12345678910SQL&gt; select ename,job,sal from emp 2 where deptno in 3 (select deptno from emp 4 where job = 'SALESMAN') 5 and job &lt;&gt; 'SALESMAN';ENAME JOB SAL---------- --------- ----------JAMES CLERK 950BLAKE MANAGER 2850由于子句select deptno from emp where job = &#39;SALESMAN&#39;查询结果为多行单列：123456789SQL&gt; select deptno from emp 2 where job = 'SALESMAN'; DEPTNO---------- 30 30 30 30所以不能用=，而用IN。查看所有比SALESMAN和CLERK职位工资都要高的员工信息：12345678910111213SQL&gt; select ename,job,sal from emp 2 where sal &gt; all( 3 select sal from emp 4 where job in('SALESMAN','CLERK'));ENAME JOB SAL---------- --------- ----------CLARK MANAGER 2450BLAKE MANAGER 2850JONES MANAGER 2975SCOTT ANALYST 3000FORD ANALYST 3000KING PRESIDENT 5000EXISTS关键字:用在过滤条件中，该关键字后面跟一个子查询只要子查询能查询至少一条数据，EXISTS就返回TRUE。例如列出那些有员工的部门信息：123456789SQL&gt; select d.deptno,d.dname from dept d 2 where exists(select 1 from 3 emp e where e.deptno = d.deptno); DEPTNO DNAME---------- -------------- 10 ACCOUNTING 20 RESEARCH 30 SALES2、子查询在HAVING部分子查询不仅可以出现在WHERE子句中，还可以出现在HAVING部分。例如查询列出最低薪水高于30号部门的最低薪水的部门信息：123456789SQL&gt; select deptno,min(sal) from emp 2 group by deptno having min(sal) &gt; 3 (select min(sal) from emp 4 where deptno = 30); DEPTNO MIN(SAL)---------- ---------- 50 3000 10 13003、子查询在FROM部分在查询语句中，FROM子句用来指定要查询的表。如果要在一个子查询的结果中继续查询，则子查询出现在FROM 子句中，这个子查询也称作行内视图或者匿名视图。这时，把子查询当作视图对待，但视图没有名字，只能在当前的SQL语句中有效。查询出薪水比本部门平均薪水高的员工信息：12345678910111213SQL&gt; select e.ename,e.job,e.sal from emp e, 2 (select deptno,avg(sal) avg_sal from emp group by deptno) d 3 where e.deptno = d.deptno 4 and e.sal &gt; d.avg_sal 5 order by e.deptno;ENAME JOB SAL---------- --------- ----------KING PRESIDENT 5000JONES MANAGER 2975FORD ANALYST 3000ALLEN SALESMAN 1600BLAKE MANAGER 28504、子查询在SELECT部分把子查询放在SELECT子句部分，可以认为是外连接的另一种表现形式，使用更灵活：123456789101112131415161718192021SQL&gt; select e.ename,e.job,e.sal, 2 (select d.deptno from dept d 3 where d.deptno = e.deptno) deptno 4 from emp e;ENAME JOB SAL DEPTNO---------- --------- ---------- ----------SMITH CLERK 800 20ALLEN SALESMAN 1600 30WARD SALESMAN 1250 30JONES MANAGER 2975 20MARTIN SALESMAN 1250 30BLAKE MANAGER 2850 30CLARK MANAGER 2450 10SCOTT ANALYST 3000KING PRESIDENT 5000 10TURNER SALESMAN 1500 30ADAMS CLERK 1100 20JAMES CLERK 950 30FORD ANALYST 3000 20MILLER CLERK 1300 10可以看出，即使不满足where条件的SCOTT也被列出来了，所以，相当于外连接。5、DDL中使用子查询：创建表可以将一个查询的结果集创建为一张表。创建一个10号部门员工信息表 ：1234567891011121314SQL&gt; create table emp_10 2 as 3 select * from emp 4 where deptno = 10;表已创建。SQL&gt; select * from emp_10; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- ---------- --------- ---------- -------------- ---------- ---------- ---------- 7782 CLARK MANAGER 7839 09-6月 -81 2450 10 7839 KING PRESIDENT 17-11月-81 5000 10 7934 MILLER CLERK 7782 23-1月 -82 1300 10分页查询分页是将查询的结果集分批显示目的视为了解决时间，性能，资源消耗，和用户需求。当查询结果集条目数非常多时。通常会使用分页。分页在标准SQL中没有定义，所以不同的数据库管理系统对于分页的语句也是不一样的。ROWNUM：ROWNUM被称作伪列，用于返回标识行数据顺序的数字。该关键字不是所有数据库都有的。ROWNUM在SELECT被当作一个字段去使用，他不是表中真实的字段，当我们从表中查询出一条数据后，该字段就会为这一条记录编一个行号，从1开始，自动递增。ROWNUM默认值为1。在使用ROWNUM对结果集进行编号时不要使用ROWNUM做&gt;1以上的数字的判断，否则该结果集将得不到任何记录。除非ROWNUM从1开始(包含1)。例如：1234567891011121314151617 ROWNUM ENAME JOB---------- ---------- --------- 1 SMITH CLERK 2 ALLEN SALESMAN 3 WARD SALESMAN 4 JONES MANAGER 5 MARTIN SALESMAN 6 BLAKE MANAGER 7 CLARK MANAGER 8 SCOTT ANALYST 9 KING PRESIDENT 10 TURNER SALESMAN 11 ADAMS CLERK 12 JAMES CLERK 13 FORD ANALYST 14 MILLER CLERKROWNUM只能从1计数，不能从结果集中直接截取。下面的查询语句将没有结果：1234SQL&gt; select rownum,ename,job from emp 2 where rownum between 6 and 10;未选定行注意区分下面语句，此处ROWNUM可以不从1开始，因为他已经生成一张表了：1234567891011SQL&gt; select * from 2 (select rownum rn,ename,job from emp) 3 where rn between 6 and 10; RN ENAME JOB---------- ---------- --------- 6 BLAKE MANAGER 7 CLARK MANAGER 8 SCOTT ANALYST 9 KING PRESIDENT 10 TURNER SALESMAN按照工资从高到低排序后，取6到10名：123456789101112SQL&gt; select * from 2 (select rownum rn,ename,job,sal from emp 3 order by sal desc) t 4 where t.rn between 6 and 10; RN ENAME JOB SAL---------- ---------- --------- ---------- 9 KING PRESIDENT 5000 8 SCOTT ANALYST 3000 6 BLAKE MANAGER 2850 7 CLARK MANAGER 2450 10 TURNER SALESMAN 1500上面的写法是先编号后排序的，所以上面这种写法得出的序号是不对的。而应该先排序再编号，再根据编号取范围（嵌套两层，先排序，排序结果再编号）：123456789101112SQL&gt; select * from 2 (select rownum rn,ename,job,sal from 3 (select * from emp order by sal desc)) t 4 where t.rn between 6 and 10; RN ENAME JOB SAL---------- ---------- --------- ---------- 6 CLARK MANAGER 2450 7 ALLEN SALESMAN 1600 8 TURNER SALESMAN 1500 9 MILLER CLERK 1300 10 WARD SALESMAN 1250排序函数可以根据指定的字段进行分组，再根据指定的字段排序后生成一个组内编号。1、ROW_NUMBER：生成组内连续且唯一的数字查看公司每个部门的工资排名，按照部门分组，按照工资降序排列生成编号：123456789101112131415161718192021SQL&gt; select ename,deptno,sal, 2 row_number() over( 3 partition by deptno 4 order by sal desc) rank from emp;ENAME DEPTNO SAL RANK---------- ---------- ---------- ----------KING 10 5000 1CLARK 10 2450 2MILLER 10 1300 3FORD 20 3000 1JONES 20 2975 2ADAMS 20 1100 3SMITH 20 800 4BLAKE 30 2850 1ALLEN 30 1600 2TURNER 30 1500 3WARD 30 1250 4MARTIN 30 1250 5JAMES 30 950 6SCOTT 50 3000 12、RANK函数：生成不连续不唯一的数字排序字段相同的记录，得到的数字一样后续内容会根据重复的行数自动跳号。比如：123456789101112131415161718192021SQL&gt; select ename,deptno,sal, 2 rank() over( 3 partition by deptno 4 order by sal desc) rank from emp;ENAME DEPTNO SAL RANK---------- ---------- ---------- ----------KING 10 5000 1CLARK 10 2450 2MILLER 10 1300 3FORD 20 3000 1JONES 20 2975 2ADAMS 20 1100 3SMITH 20 800 4BLAKE 30 2850 1ALLEN 30 1600 2TURNER 30 1500 3WARD 30 1250 4MARTIN 30 1250 4JAMES 30 950 6SCOTT 50 3000 13、DENSE_RANK()：函数生成连续但不唯一的数字：123456789101112131415161718192021SQL&gt; select ename,deptno,sal, 2 dense_rank() over( 3 partition by deptno 4 order by sal desc) rank from emp;ENAME DEPTNO SAL RANK---------- ---------- ---------- ----------KING 10 5000 1CLARK 10 2450 2MILLER 10 1300 3FORD 20 3000 1JONES 20 2975 2ADAMS 20 1100 3SMITH 20 800 4BLAKE 30 2850 1ALLEN 30 1600 2TURNER 30 1500 3WARD 30 1250 4MARTIN 30 1250 4JAMES 30 950 5SCOTT 50 3000 1高级分组函数集合操作1、UNION和UNION ALL用来获取两个或两个以上结果集的并集（结果集的列必须一一对应）：UNION操作符会自动去掉合并后的重复记录。UNION ALL返回两个结果集中的所有行，包括重复的行。UNION操作符对查询结果排序，UNION ALL不排序。合并职位是’MANAGER’的员工和薪水大于2500的员工集合，查看两种方式的结果差别：UNION：1234567891011121314SQL&gt; select ename,job,sal from emp 2 where job = 'MANAGER' 3 UNION 4 select ename,job,sal from emp 5 where sal &gt; 2500;ENAME JOB SAL---------- --------- ----------BLAKE MANAGER 2850CLARK MANAGER 2450FORD ANALYST 3000JONES MANAGER 2975KING PRESIDENT 5000SCOTT ANALYST 3000UNION ALL：12345678910111213141516SQL&gt; select ename,job,sal from emp 2 where job = 'MANAGER' 3 UNION ALL 4 select ename,job,sal from emp 5 where sal &gt; 2500;ENAME JOB SAL---------- --------- ----------JONES MANAGER 2975BLAKE MANAGER 2850CLARK MANAGER 2450JONES MANAGER 2975BLAKE MANAGER 2850SCOTT ANALYST 3000KING PRESIDENT 5000FORD ANALYST 30002、INTERSECT（[ˌɪntəˈsekt]，相交）INTERSECT函数获得两个结果集的交集，只有同时存在于两个结果集中的数据，才被显示输出。使用INTERSECT操作符后的结果集会以第一列的数据作升序排列。12345678910SQL&gt; select ename,job,sal from emp 2 where job = 'MANAGER' 3 INTERSECT 4 select ename,job,sal from emp 5 where sal &gt; 2500;ENAME JOB SAL---------- --------- ----------BLAKE MANAGER 2850JONES MANAGER 29753、MINUS（英[ˈmaɪnəs]，减去）MINUS函数获取两个结果集的差集。只有在第一个结果集中存在，在第二个结果集中不存在的数据，才能够被显示出来。也就是结果集一减去结果集二的结果。123456789SQL&gt; select ename,job,sal from emp 2 where job = 'MANAGER' 3 MINUS 4 select ename,job,sal from emp 5 where sal &gt; 2500;ENAME JOB SAL---------- --------- ----------CLARK MANAGER 2450视图视图(VIEW)也被称作虚表，即虚拟的表，是一组数据的逻辑表示，其本质是对应于一条SELECT语句，结果集被赋予一个名字，即视图名字。视图本身并不包含任何数据，它只包含映射到基表的一个查询语句，当基表数据发生变化，视图数据也随之变化。作用：1、重用子查询。SELECT语句中的FROM子句中，我们常会使用一个子查询，然后将结果当作表再进行查询工作，若很多SELECT语句中都要用到该子查询，就可以将这个子查询定义为一个试图进行重用，这样也可以简化SQL语句的复杂度。2、限制数据访问，可以隐藏真实的表中字段信息，表的名字，字段的名字，这样可以避免访问敏感信息等。根据视图所对应的子查询种类分为几种类型：SELECT语句是基于单表建立的，且不包含任何函数运算、表达式或分组函数，叫做简单视图，此时视图是基表的子集；SELECT语句同样是基于单表，但包含了单行函数、表达式、分组函数或GROUP BY子句，叫做复杂视图；SELECT语句是基于多个表的，叫做连接视图。创建一个简单视图V_EMP_10，来显示部门10中的员工的编码、姓名和薪水：12345678910111213SQL&gt; create view v_emp_10 2 as 3 select empno,ename,sal 4 from emp where deptno = 10;视图已创建。SQL&gt; desc v_emp_10; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- EMPNO NOT NULL NUMBER(4) ENAME VARCHAR2(10) SAL NUMBER(7,2)修改视图由于视图自身没有结构，完全取决于对应的查询语句，所以修改视图就是替换对应的查询语句。1234567891011121314SQL&gt; create or replace view v_emp_10 2 as 3 select empno,ename name,sal salary,deptno 4 from emp where deptno = 20;视图已创建。SQL&gt; desc v_emp_10; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- EMPNO NOT NULL NUMBER(4) NAME VARCHAR2(10) SALARY NUMBER(7,2) DEPTNO NUMBER(2) NUMBER(2)对视图进行DML操作就是对视图数据来源的基表进行操作。只能对简单试图进行DML操作，复杂视图不允许DML操作，即视图定义中包含了函数、表达式、分组语句、DISTINCT关键字或ROWNUM伪列，不允许执行DML操作。由于视图只能看到emp表中的三个字段，所以就算向视图中所有字段插入值，那么实际插入emp表中时，除了这几个字段外，其他视图看不见的字段全部插入字段默认值NULL。123456789 SQL&gt; insert into v_emp_10 values(7935,'KangKang',4500,20);已创建 1 行。SQL&gt; select * from emp where ename = 'KangKang'; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- ---------- --------- ---------- -------------- ---------- ---------- ---------- 7935 KangKang 4500 20下面这条语句，通过视图插入到EMP表中，但是因为部门号是10，而不是视图中的20，所以视图看不见，无法再对这个对象进行修改，这就对基表数据产生了污染，修改视图数据同样可能存在将视图数据修改后，导致视图无法再查看到它们。12345678910111213SQL&gt; insert into v_emp_10 values(7936,'Jane',4000,10);已创建 1 行。SQL&gt; select * from v_emp_10; EMPNO NAME SALARY DEPTNO---------- ---------- ---------- ---------- 7935 KangKang 4500 20 7369 SMITH 800 20 7566 JONES 2975 20 7876 ADAMS 1100 20 7902 FORD 3000 20创建具有CHECK OPTION约束的视图可以为视图添加CHECK OPTION选项，这样对视图进行DML操作时，视图会检查操作完毕后对该记录是否可见，可见不允许操作。12345678910111213SQL&gt; create or replace view v_emp_10 2 as 3 select empno,ename name,sal salary,deptno 4 from emp where deptno = 20 5 with check option;视图已创建。SQL&gt; insert into v_emp_10 values(7937,'Maria',3000,10);insert into v_emp_10 values(7937,'Maria',3000,10) *第 1 行出现错误:ORA-01402: 视图 WITH CHECK OPTION where 子句违规创建具有READ ONLY约束的视图当视图被设置为READ ONLY后，不允许对该视图进行DML操作，其为只读的。12345678910111213SQL&gt; create or replace view v_emp_10 2 as 3 select empno,ename name,sal salary,deptno 4 from emp where deptno = 20 5 with read only;视图已创建。SQL&gt; insert into v_emp_10 values(7937,'Maria',3000,20);insert into v_emp_10 values(7937,'Maria',3000,20)*第 1 行出现错误:ORA-42399: 无法对只读视图执行 DML 操作复杂视图对应的SELECT语句中含有函数，表达式，分组，连接查询。创建一个显示每个部门薪水情况的视图：1234567891011121314151617181920SQL&gt; create view v_emp_sal 2 as 3 select d.deptno,d.dname, 4 avg(e.sal) avg_sal, 5 sum(e.sal) sum_sal, 6 max(e.sal) max_sal, 7 min(e.sal) min_sal 8 from emp e,dept d 9 where e.deptno = d.deptno 10 group by d.deptno,d.dname;视图已创建。SQL&gt; select * from v_emp_sal; DEPTNO DNAME AVG_SAL SUM_SAL MAX_SAL MIN_SAL---------- -------------- ---------- ---------- ---------- ---------- 10 ACCOUNTING 3187.5 12750 5000 1300 20 RESEARCH 2475 12375 4500 800 30 SALES 1566.66667 9400 2850 950复杂视图不能进行DML操作。当不再需要视图的定义，可以使用DROP VIEW语句删除视图：123SQL&gt; drop view v_emp_10;视图已删除。序列序列是一个数据库对象作用是根据指定的规则生成一组数字，每次返回一个数字。常用于为表中的主键提供值。主键：通常每张表的第一个字段就是主键，主键字段的值要求在整张表中不能为空，且值不能重复。目的是用于唯一标识每一个记录。创建一个序列，起始数据是100，步进是1：12345SQL&gt; create sequence emp_seq 2 start with 100 3 increment by 1;序列已创建。序列有两个伪列NEXTVAL：使序列生成一个数字，第一次使用时，返回的是START WITH指定的值。需要注意，序列不可逆，一旦获取下一个数字后，就不能得到上一个数字了。CURRVAL：获取序列最后一次生成的数字，可以调用多次，不会造成序列生成下一个数字。CURRVAL必须要在序列创建完毕后，至少调用过一侧NEXTVAL输出生成一个数字后才可以使用。测试让序列生成一个数字：1234567891011SQL&gt; select emp_seq.nextval from dual; NEXTVAL---------- 100SQL&gt; select emp_seq.nextval from dual; NEXTVAL---------- 101每运行一次，数字增加10。获取序列最后生成的数字：12345SQL&gt; select emp_seq.currval from dual; CURRVAL---------- 101删除序列的语法如下：123SQL&gt; drop sequence emp_seq;序列已删除。索引索引也是数据库对象，用来提高检索效率，排序效率有效的使用会带来很好的效果。数据库管理系统自行维护索引的算法，我们只需要指定何时为某表的某字段添加即可。为emp表的ENAME字段添加索引：123SQL&gt; create index idx_emp_ename on emp(ename);索引已创建。复合索引也叫多列索引，是基于多个列的索引。如果经常在ORDER BY子句中使用job和sal作为排序依据，可以建立复合索引：123SQL&gt; create index idx_emp_jobsal on emp(job,sal);索引已创建。当做下面的查询时，会自动应用索引idx_emp_jobsal：12SQL&gt; select empno,ename,job,sal from emp 2 order by job,sal;删除索引：123SQL&gt; drop index idx_emp_jobsal;索引已删除。合理使用索引提升查询效率：为经常出现在WHERE子句中的列创建索引。为经常出现在ORDER BY、DISTINCT后面的字段建立索引。如果建立的复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致。为经常作为表的连接条件的列上创建索引。不要在经常做DML操作的表上建立索引。不要在小表上建立索引。限制表上的索引数目，索引并不是越多越好。删除很少被使用的、不合理的索引。约束约束的类型：非空约束(Not Null)，简称NN。唯一性约束(Unique)，简称UK。主键约束(Primary Key)，简称PK。外键约束(Foreign Key)，简称FK。检查约束(Check)，简称CK。非空约束建表时添加非空约束：123456789101112131415SQL&gt; create table employees( 2 eid number(6), 3 name varchar2(30) not null, 4 salary number(7,2), 5 hiredate date constraint employees_hiredate_nn not null);表已创建。SQL&gt; desc employees; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- EID NUMBER(6) NAME NOT NULL VARCHAR2(30) SALARY NUMBER(7,2) HIREDATE NOT NULL DATE取消非空约束：1234567891011 SQL&gt; alter table employees modify(hiredate date null);表已更改。SQL&gt; desc employees; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- EID NUMBER(6) NAME NOT NULL DATE SALARY NUMBER(7,2) HIREDATE DATE唯一性约束唯一性(Unique)约束条件用于保证字段或者字段的组合不出现重复值。当给表的某个列定义了唯一约束条件，该列的值不允许重复，但允许是NULL值。建表的时候添加唯一性约束：123456789SQL&gt; create table employees1( 2 eid number(6) unique, 3 name varchar2(30), 4 email varchar(50), 5 salary number(7,2), 6 hiredate date, 7 constraint employees1_email_uk unique(email));表已创建。主键约束主键(Primary Key)约束条件从功能上看相当于非空（NOT NULL）且唯一（UNIQUE）的组合。主键字段可以是单字段或多字段组合，即：在主键约束下的单字段或者多字段组合上不允许有空值，也不允许有重复值。主键可以用来在表中唯一的确定一行数据。一个表上只允许建立一个主键，而其它约束条件则没有明确的个数限制。主键选取的原则：主键应是对系统无意义的数据。永远也不要更新主键，让主键除了唯一标识一行之外，再无其他的用途。主键不应包含动态变化的数据，如时间戳。主键应自动生成，不要人为干预，以免使它带有除了唯一标识一行以外的意义。主键尽量建立在单列上。建表的时候添加主键约束：1234567891011121314151617SQL&gt; create table employees2( 2 eid number(6) primary key, 3 name varchar(30), 4 email varchar2(30), 5 salary number(7,2), 6 hiredate date);表已创建。SQL&gt; desc employees2; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- EID NOT NULL NUMBER(6) NAME VARCHAR2(30) EMAIL VARCHAR2(30) SALARY NUMBER(7,2) HIREDATE DATE建表后添加主键，首先创建一张没有主键的表：12345678 SQL&gt; create table employees3( 2 eid number(6), 3 name varchar2(30), 4 email varchar2(50), 5 salary number(7,2), 6 hiredate date);表已创建。再添加主键：1234SQL&gt; alter table employees3 2 add constraint emplpoyees3_eid_pk primary key(eid);表已更改。外键约束外键约束条件定义在两个表的字段或一个表的两个字段上，用于保证相关两个字段的关系。比如emp表的deptno列参照dept表的deptno列，则dept称作主表或父表，emp表称作从表或子表。12345678910111213SQL&gt; create table employees4( 2 eid number(6), 3 name varchar2(30), 4 salary number(7,2), 5 deptno number(4));表已创建。SQL&gt; alter table employees4 2 add constraint employees4_deptno_fk 3 foreign key(deptno) references dept(deptno);表已更改。检查约束检查(Check)约束条件用来强制在字段上的每个值都要满足Check中定义的条件。当定义了Check约束的列新增或修改数据时，数据必须符合Check约束中定义的条件。员工的薪水必须大于2000元，增加检查约束：12345SQL&gt; alter table employees4 2 add constraint employees4_salary_check 3 check (salary &gt; 2000);表已更改。]]></content>
      <tags>
        <tag>DataBase</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet Jsp note]]></title>
    <url>%2FServlet-Jsp-note.html</url>
    <content type="text"><![CDATA[什么是Servletsun(oracle)公司制订的一种用来扩展web服务器功能的组件规范。使用Myeclipse创建一个web project，编写一个简单的servlet：src→com.postar.servlet（package）→HiServlet：12345678910public class HiServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; res.setContentType("text/html"); PrintWriter pw = res.getWriter(); pw.write("&lt;h1 style='color:#6db33f'&gt;hello world&lt;/h1&gt;"); pw.close(); &#125;&#125;配置文件WebRoot→WEB-INF→web.xml下添加：12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;hi&lt;/servlet-name&gt; &lt;servlet-class&gt;com.postar.servlet.HiServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hi&lt;/servlet-name&gt; &lt;url-pattern&gt;/hi&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;启动Tomcat，在浏览器中输入：http://localhost:8088/servlet/hi 得到页面：程序执行的过程：Servlet运行的原理原理图（执行过程）：具体过程描述：1.浏览器依据ip,port建立与容器之间的连接。2.浏览器将请求数据打包(包含了请求资源路径)。3.向容器（符合一定规范，提供组件的运行环境的一个程序。）发请求数据包。4.容器解析请求数据包。5.将解析的结果封装到request对象上，同时，容器还要创建一个response对象。6.容器依据请求资源路径找到servlet的配置(web.xml)。7.8.然后创建该servlet对象，调用servlet对象的service方法(会将request对象,response对象作为参数)。在service方法里面，可以通过request对象获得请求数据并进行相应的处理，然后，处理结果只需要写到response对象上。9.容器从response对象上获取处理结果，然后打包。10.发送给浏览器。11.浏览器从响应数据包中取出处理结果，生成相应的页面。get请求和post请求最常用的两种方式get和post。get/post请求的区别：get请求如果需要向服务器传递少量数据用get。get请求使用URL传值，即数据会附着在URL上传递给服务器，如：只能传递较少的数据post请求如果需要提交表单，或者传递大量的数据用post。post请求使用请求数据包的实体内容来传值。可以传递大量数据。post请求隐私性更好，但是安全级别和get完全相等，不能说它更安全。通过F12都能查看到所有数据。解决get，psot请求中文乱码服务端Servlet代码：1234567891011121314151617181920212223242526272829303132333435public class RegistServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; // 解决post请求乱码 req.setCharacterEncoding("utf-8"); // 使用request接收请求数据 // 通过框体的name属性值来接收数据 String code = req.getParameter("code"); // 解决get请求乱码 // code = new String(code.getBytes("iso8859-1"), "utf-8"); String pwd = req.getParameter("pwd"); String sex = req.getParameter("sex"); // 值是个数组的时候使用request.getParameterValues() String[] favorites = req.getParameterValues("favorites"); System.out.println(code); System.out.println(pwd); System.out.println(sex); for(String f : favorites) &#123; System.out.println(f); &#125; //向浏览器输出一些提示信息 res.setContentType("text/html;charset=utf-8;"); PrintWriter w = res.getWriter(); if("admin".equals(code)) &#123; w.println("&lt;h1&gt;此账号已存在.&lt;/h1&gt;"); &#125; else &#123; w.println("&lt;h1&gt;注册成功.&lt;/h1&gt;"); &#125; w.close(); &#125;&#125;客户端html代码：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="gbk" /&gt; &lt;title&gt;注册用户&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1.想要给服务器提交数据，需要使用表单。 2.传数据时，需要给框设置name属性，该属性将作为传递的数据的名字，服务端 需要通过此名字来获取数据。 3.表单传递的数据就是框体的value属性值。 3.1对于文本框、密码框，它的value属性值就是我们在框内输入的内容，因此不必额外设置； 3.2对于单选、复选、下拉选，需要明确设置value属性的值。 4.表单上需要通过action属性设置提交的路径，写出URI即可，不需要写出完整的URL。 通过method属性声明请求的类型。 --&gt; &lt;form action="/servlet/register" method="post"&gt; &lt;h1&gt;注册用户&lt;/h1&gt; &lt;p&gt;账号:&lt;input type="text" name="code" /&gt;&lt;/p&gt; &lt;p&gt;密码:&lt;input type="password" name="pwd" /&gt;&lt;/p&gt; &lt;p&gt;性别: &lt;input type="radio" name="sex" value="M" /&gt;男 &lt;input type="radio" name="sex" value="F" /&gt;女 &lt;/p&gt; &lt;p&gt; 兴趣: &lt;input type="checkbox" name="favorites" value="basketball" /&gt; 篮球 &lt;input type="checkbox" name="favorites" value="football" /&gt; 足球 &lt;input type="checkbox" name="favorites" value="pingpang" /&gt; 乒乓 &lt;input type="checkbox" name="favorites" value="running" /&gt; 跑步 &lt;/p&gt; &lt;p&gt; &lt;!-- submit是专门用于提交表单的按钮 --&gt; &lt;input type="submit" value="注册" /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;配置xml：12345678&lt;servlet&gt; &lt;servlet-name&gt;regist&lt;/servlet-name&gt; &lt;servlet-class&gt;com.postar.servlet.RegistServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;regist&lt;/servlet-name&gt; &lt;url-pattern&gt;/register&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;重定向服务器向浏览器发送一个302状态码及一个Location消息头（该消息头的值是一个地址，称之为重定向地址），浏览器收到后会立即向重定向地址发请求。如何重定向？1response.sendRedirect(String url);特点：重定向地址可以是任意的地址。重定向之后，浏览器地址栏的地址会变。转发一个web组件（servlet/jsp）将未完成的处理通过容器转交给另外一个web组件继续完成。常见的情况是：一个servlet获得数据之后（比如，通过调用dao），将这些数据转发给一个jsp，由这个jsp来展现这些数据（比如，以表格的方式来展现）。转发的原理图：转发的过程：1.先绑订数据到request对象：12// 变量名name，值objrequest.setAttribute(String name,Object obj);2.获得转发器：12// uri：转发的目的地，比如一个jsp文件。RequestDispatcher rd = request.getRequestDispatcher(String uri);3.转发：1rd.forward(request,response);转发的特点：转发之后，浏览器地址栏的地址不变。转发的目的地必须是同一个应用内部的某个地址。转发所涉及的各个web组件会共享同一个request对象和response对象。转发和重定向的区别转发所涉及的各个web组件会共享同一个request对象和response对象，而重定向不行。说明：当请求到达容器，容器会创建request对象和response对象，当响应发送完毕，容器会立即删除request对象和response对象。即request对象和response对象的生存时间是一次请求与响应期间。转发之后，浏览器地址栏的地址不变，重定向会变。转发的地址必须是同一个应用内部某个地址，而重定向没有这个限制。转发是一件事情未做完，调用另外一个组件继续做；而重定向是一件事情已经做完，再调用一个组件做另外一件事情。Servlet的生命周期Servlet容器如何创建Servlet对象、如何为Servlet对象分配、准备资源、如何调用对应的方法来处理请求以及如何销毁Servlet对象的整个过程即Servlet的生命周期。阶段一：实例化，容器调用servlet的构造器，创建一个servlet对象。容器在默认情况下，对于某个类型的servlet,只会创建一个实例。阶段二：初始化，容器在创建好servlet对象之后，会立即调用该对象的init方法。一般情况下，我们不用写init方法，因为GenericServlet已经提供了init方法的实现（将容器传递过来的ServletConfig对象保存来下，并且，提供了getServletConfig方法来获得ServletConfig对象）。阶段三：就绪，容器收到请求之后，调用servlet对象的service方法来处理请求。阶段四：销毁，容器依据自身的算法删除servlet对象，被删除的servlet对象会被垃圾回收机制回收。容器在删除servlet对象之前会调用该对象的destroy方法（只会执行一次）。可以override destroy方法来实现自已的处理逻辑。例子：123456789101112131415161718192021222324252627282930313233public class LifeServlet extends HttpServlet&#123; // 1.Tomcat会自动调用默认构造器创建Servlet public LifeServlet()&#123; System.out.println("创建LifeServlet"); &#125; // 2.Tomcat会自动为当前的Servlet创建一个ServletConfig，用来给它预置一些数据； // 3.Tomcat会自动调用init方法，来为此Servlet初始化一些数据； // 注意，ServletConfig中预置的数据，可以在init时使用，也可以在service时使用。 @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println("初始化Servlet"); &#125; // 4.当请求传入时，Tomcat会自动调用该方法来处理本次请求。 @Override protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; System.out.println("调用service()"); res.setContentType("text/html"); PrintWriter w = res.getWriter(); w.println("&lt;h1&gt;LifeServlet&lt;/h1&gt;"); w.close(); &#125; // 5.Tomcat在关闭前，会自动调用该方法来销毁该Servlet。通常是将此Servlet所依赖的数据释放（=null）。 @Override public void destroy() &#123; // TODO Auto-generated method stub super.destroy(); &#125;&#125;生命周期相关的几个接口与类：ServletContextServlet上下文，WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用，是一个全局的环境变量。该应用中的任何组件，在任何时候都可以访问到该对象，所以Servlet上下文具有唯一性。在一个web项目中写两个相同的Servlet：123456789101112131415161718192021222324252627public class FirstServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; //1.统计Servlet访问次数：获取ServletContext，它是Servlet公用的 //数据对象，在Tomcat启动时被Tomcat自动创建，在Tomcat关闭时被Tomcat自动销毁。 //它是单例的对象，一个项目内只有一份。 ServletContext ctx = getServletContext(); //尝试从此对象中读取count变量 Object count = ctx.getAttribute("count"); //判断变量是否存在 if(count == null) &#123; //变量不存在，本次访问是第1次， //初始化此变量并存入ServletContext。 ctx.setAttribute("count", 1); &#125; else &#123; //变量存在，本次访问不是第1次， //将变量+1，再次存入ServletContext。 ctx.setAttribute("count", new Integer(count.toString())+1); &#125; //2.将统计结果输出到浏览器上 res.setContentType("text/html;charset=utf-8;"); PrintWriter w = res.getWriter(); w.println("&lt;h1&gt;总流量是："+ctx.getAttribute("count")+"&lt;/h1&gt;"); w.close(); &#125;&#125;SecondServlet内容和FirstServlet一致。配置略。访问http://localhost:8080/servlet/first：访问http://localhost:8080/servlet/second：可见它们获取到的是同一个ServletContext，换句话说ServletContext只有一份。JSPJSP（Java Server Page）是Sun公司制定的一种服务器端动态页面技术的组件规范，以“.jsp”为后缀的文件中既包含HTML静态标记用于表现页面，也包含特殊的代码，用于生成动态内容。JSP作为简化Servlet开发的一种技术，实质上最终依然要转变为Servlet才可能运行，只不过这个转变过程由Servlet容器来完成。统一处理异常将系统异常将给容器来处理，在web.xml中配置异常处理页面：1234&lt;error-page&gt; &lt;exception-type&gt;javax.servlet.ServletException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt;&lt;/error-page&gt;过滤器Filter编写过滤器遵循下列步骤：1.编写一个实现了Filter接口的类。2.实现Filter接口的三个方法，过滤逻辑在doFilter方法中实现。3.在Web程序中注册过滤器。4.把过滤器和Web应用一起打包部署。当有多个过滤器的时候，过滤的先后按照xml文件中mapping的先后顺序执行，具体过程如下图所示：上图展示了多个过滤器的执行流程，过滤器1的doFilter的code1 →过滤器2的doFilter的code1 →service()方法→过滤器2的doFilter的code2 →过滤器1的doFilter的code2 →返回给客户端。在这个动作的传递过程中一定要写chain.doFilter()。模拟一个登录的例子：123456789101112131415161718192021222324252627282930313233343536373839public class LoginFilter implements Filter&#123; private String[] paths; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; String uri = req.getRequestURI(); for(String path : paths)&#123; if(uri.contains(path))&#123; chain.doFilter(req, res); return; &#125; &#125; //判断session中是否存在登录数据 HttpSession session = req.getSession(); //模拟一个叫admin的账号 String admin = (String) session.getAttribute("admin"); if(admin == null) &#123; //没有登录，强制跳转到登录页 res.sendRedirect(req.getContextPath() + "/login/toLogin.do"); &#125; else &#123; //已登录，继续执行 chain.doFilter(req, res); &#125; &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; String excludePath = filterConfig.getInitParameter("excludePath"); paths = excludePath.split(","); &#125;&#125;在web.xml中配置Filter：12345678910111213&lt;filter&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.postar.servlet.LoginFilter&lt;/filter-class&gt; &lt;!-- 设置要排除过滤的路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;excludePath&lt;/param-name&gt; &lt;param-value&gt;login/toLogin,login/login,login/createImage&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;loginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt;源码地址 https://git.coding.net/laizhipeng/Servlet.git]]></content>
      <tags>
        <tag>servlet&amp;jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java OOP2]]></title>
    <url>%2FJava-OOP2.html</url>
    <content type="text"><![CDATA[文章已加密，请输入密码 😛： 密码错误 😭 No content to display! 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]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java OOP1]]></title>
    <url>%2FJava%20OOP1.html</url>
    <content type="text"><![CDATA[文章已加密，请输入密码 😛： 密码错误 😭 No content to display! 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]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
